/*
 * This file was automatically generated by EvoSuite
 * Fri Jul 06 21:23:37 GMT 2018
 */

package weka.classifiers.functions.supportVector;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Locale;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.mock.java.util.MockRandom;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;
import weka.attributeSelection.PrincipalComponents;
import weka.classifiers.bayes.BayesNet;
import weka.classifiers.functions.SMOreg;
import weka.classifiers.functions.supportVector.RegSMO;
import weka.classifiers.meta.Vote;
import weka.core.Attribute;
import weka.core.BinarySparseInstance;
import weka.core.Capabilities;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.SparseInstance;
import weka.core.TechnicalInformation;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class RegSMO_ESTest extends RegSMO_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      try { 
        regSMO0.wrapUp();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegOptimizer", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      regSMO0.epsilonTipText();
      regSMO0.setEpsilon(3234.54641);
      assertEquals(3234.54641, regSMO0.getEpsilon(), 0.01);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      regSMO0.getOptions();
      String string0 = regSMO0.getRevision();
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("8034", string0);
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      RegSMO regSMO0 = new RegSMO();
      try { 
        regSMO0.buildClassifier((Instances) null);
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // SVM not initialized in optimizer. Use RegOptimizer.setSVMReg()
         //
         verifyException("weka.classifiers.functions.supportVector.RegOptimizer", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      String string0 = regSMO0.getRevision();
      assertEquals("8034", string0);
      
      boolean boolean0 = regSMO0.findOptimalPointOnLine((-2271), (-2271), (-2271), (-2271), 0, (-2271), 0, 0, (-2271), (-2271), (-2271));
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      FileSystemHandling.shouldAllThrowIOExceptions();
      RegSMO regSMO0 = new RegSMO();
      try { 
        regSMO0.takeStep((-2146558982), 2223, 2223, (-2146558982), 2223);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      regSMO0.getRevision();
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-2271), 2918.4153096451, (-2271), (-2271), 0, (-2271), 0, 0, (-2271), 2918.4153096451, 2918.4153096451);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      regSMO0.globalInfo();
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(1354, 1354, (-1265.19711559), (-1265.19711559), (-278), 1354, (-1265.19711559), 1354, 1.0E-12, 1354, 1354);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-100), (-100), (-100), 4348.642600043034, (-100), 0.1, 3778.8132731879027, 3778.8132731879027, 0.1, 3778.8132731879027, 1.0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      System.setCurrentTimeMillis((-1847L));
      RegSMO regSMO0 = new RegSMO();
      // Undeclared exception!
      try { 
        regSMO0.secondChoiceHeuristic(0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2146115695, 1110.6548574, 2146115695, 1085.3015698137456, 2146115695, 2146115695, 1085.3015698137456, 1110.6548574, 1085.3015698137456, 1085.3015698137456, 1085.3015698137456);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      regSMO0.globalInfo();
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(1354, (-1.2294723456323196), 590.1809987174, 590.1809987174, (-278), 1354, 590.1809987174, 1354, 1.0E-12, 1354, (-1.2294723456323196));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      regSMO0.globalInfo();
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2146115695, 1110.6548574, 2146115695, 1085.3015698137456, 2146115695, 2146115695, 1085.3015698137456, 1110.6548574, 99.0, 1085.3015698137456, 1085.3015698137456);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      regSMO0.getTechnicalInformation();
      int int0 = 1;
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(1, 0.0, 0.0, (-3592L), (-1073741824), 1.0, (-2186.0), (-2.0), (-2.0), 1.0, (-3592L));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      String string0 = regSMO0.globalInfo();
      assertNotNull(string0);
      assertEquals("Implementation of SMO for support vector regression as described in :\n\nA.J. Smola, B. Schoelkopf (1998). A tutorial on support vector regression.", string0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2146115695, 1110.6548574, 2146115695, 1085.3015698137456, 2146115695, 3.79172E-7, 1085.3015698137456, 1110.6548574, 99.0, 1085.3015698137456, 1085.3015698137456);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      double double0 = regSMO0.getScore();
      assertEquals(0.0, double0, 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      String[] stringArray0 = Locale.getISOLanguages();
      assertNotNull(stringArray0);
      
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = 0.0;
      doubleArray0[3] = 0.0;
      doubleArray0[7] = 0.0;
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      doubleArray0[8] = 0.0;
      doubleArray0[7] = 0.0;
      doubleArray0[2] = 0.0;
      regSMO0.setEpsilonParameter(2.813781829271803E-7);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(2.813781829271803E-7, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(22, 2.813781829271803E-7, 2.813781829271803E-7, 22, 22, 0.0, 0.0, 0.0, 0.0, 22, 96.0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      double double0 = regSMO0.getScore();
      assertEquals(0.0, double0, 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      double[] doubleArray0 = new double[8];
      regSMO0.m_alpha = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      TechnicalInformation technicalInformation0 = regSMO0.getTechnicalInformation();
      assertNotNull(technicalInformation0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(TechnicalInformation.Type.MISC, technicalInformation0.getType());
      assertFalse(technicalInformation0.hasAdditional());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      doubleArray0[5] = 0.0;
      regSMO0.setEpsilonParameter(3.4);
      assertEquals(3.4, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      System.setCurrentTimeMillis((byte)48);
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((byte) (-120), 3709.8895945753166, 3709.8895945753166, 42.799, 3668, 0.0, (-1.0), 0.0, 2.0, 3.4, 2.0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -120
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      regSMO0.m_classIndex = (-749);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      String string0 = regSMO0.getRevision();
      assertNotNull(string0);
      assertEquals("8034", string0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) (-749);
      doubleArray0[0] = (double) (-749);
      doubleArray0[2] = (double) (-749);
      doubleArray0[3] = (double) (-749);
      regSMO0.m_nCacheHits = (-749);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-749), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      doubleArray0[4] = (-749.0);
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(10000, (-749.0), 2282.4431435866, (-749.0), 10000, 0.0, (-749.0), (-2674.688429925353), 2282.4431435866, 345.39, (-3621.8797781611));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.createFolder((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      System.setCurrentTimeMillis((-3592L));
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(1, 0.0, 0.0, (-1523.0), (-1073741824), 1.0, (-2186.0), (-2.0), (-2.0), 1.0, 1831.67);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-2123), 40.76071072394753, (-2123), 1050.748421147, 108, 40.76071072394753, 0.01, 1050.748421147, 1050.748421147, 1050.748421147, (-2123));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      double double0 = regSMO0.m_eps;
      assertEquals(1.0E-12, double0, 0.01);
      
      String string0 = regSMO0.globalInfo();
      assertNotNull(string0);
      assertEquals("Implementation of SMO for support vector regression as described in :\n\nA.J. Smola, B. Schoelkopf (1998). A tutorial on support vector regression.", string0);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(1365, 1.0E-12, 590.1809987174, 9.2233720359324385E18, 10000, 4131.94, 73, 1365, 1.0E-12, 1.0E-12, 1365);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      String[] stringArray0 = regSMO0.getOptions();
      assertNotNull(stringArray0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      regSMO0.setOptions(stringArray0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      int int0 = SMOreg.FILTER_NONE;
      assertEquals(2, int0);
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      String string0 = regSMO0.globalInfo();
      assertNotNull(string0);
      assertEquals("Implementation of SMO for support vector regression as described in :\n\nA.J. Smola, B. Schoelkopf (1998). A tutorial on support vector regression.", string0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2146115695, 1110.6548574, 2146115695, 1085.3015698137456, 2146115695, 3.79172E-7, 3.79172E-7, 1085.3015698137456, 99.0, 1085.3015698137456, 1085.3015698137456);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      double[] doubleArray0 = new double[7];
      Random.setNextRandom((-2144324520));
      int int0 = 81;
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      regSMO0.m_nEvals = 81;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(81, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-2144324520), 0.0, (-1139.308941113), 2.0, (-2144324520), Double.POSITIVE_INFINITY, (-1677.1119), 0.0, (-2144324520), 1.7976931348623157E308, 15.0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      String string0 = regSMO0.getRevision();
      assertNotNull(string0);
      assertEquals("8034", string0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      int int0 = 68;
      String string1 = regSMO0.toString();
      assertNotNull(string1);
      assertFalse(string1.equals((Object)string0));
      assertEquals("SMOreg\n\nSupport vectors:\n +       0     \n\n\n\nNumber of kernel evaluations: 0", string1);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      String string2 = regSMO0.globalInfo();
      assertNotNull(string2);
      assertFalse(string2.equals((Object)string1));
      assertFalse(string2.equals((Object)string0));
      assertEquals("Implementation of SMO for support vector regression as described in :\n\nA.J. Smola, B. Schoelkopf (1998). A tutorial on support vector regression.", string2);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      int int1 = (-2147483647);
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-2147483647), 68, (-684.8970707), 1.7976931348623157E308, 68, 398.779894, 68, 1.7976931348623157E308, 2734.0993229670325, 1.7976931348623157E308, (-2147483647));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      SMOreg sMOreg0 = regSMO0.m_SVM;
      assertNull(sMOreg0);
      
      byte byte0 = (byte)104;
      regSMO0.setEpsilon(410.6);
      assertEquals(410.6, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      
      boolean boolean0 = FileSystemHandling.appendDataToFile((EvoSuiteFile) null, (byte[]) null);
      assertFalse(boolean0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-1), 146.799, 3791.72, (-582.124211), 1, (-582.124211), 0, 3791.72, 0.2819262067282644, 3791.72, 0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      String[] stringArray0 = new String[0];
      regSMO0.setOptions(stringArray0);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      double double0 = regSMO0.getEpsilon();
      assertEquals(1.0E-12, double0, 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      String[] stringArray1 = regSMO0.getOptions();
      assertNotSame(stringArray1, stringArray0);
      assertNotNull(stringArray1);
      assertFalse(stringArray1.equals((Object)stringArray0));
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(73, 590.1809987174, 4131.94, 73, 73, 1.7976931348623157E308, 4131.94, 590.1809987174, 1.0E-12, 563.735135, 1.0E-12);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      String[] stringArray0 = new String[0];
      regSMO0.setOptions(stringArray0);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      double double0 = regSMO0.getEpsilon();
      assertEquals(1.0E-12, double0, 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      int int0 = Integer.MAX_VALUE;
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(Integer.MAX_VALUE, 73, 1.0E-12, 4131.94, 73, (-3111402.950995709), 1364.9999998635, 4131.94, (-123.4), Integer.MAX_VALUE, 1.963E-8);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      int int0 = 3014;
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(3014, 0.0, 3264.6, 142.6964, 3014, (-2880.0), 0.0, 3791.72, (byte) (-26), 1568.8525, (-2880.0));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(151, 2276.0, 2276.0, 151, 151, 1129.283, 542.326476018552, 151, 151, 542.326476018552, 542.326476018552);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      int int0 = 2488;
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2488, (-1457.5108051), 635.559622881963, 635.559622881963, 2488, 2.0E-10, (-1457.5108051), 534.11040044, 106.0, 1.04E-8, 2488);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = 0.1;
      regSMO0.m_alpha = doubleArray0;
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      int int0 = regSMO0.secondChoiceHeuristic(43);
      assertEquals(0, int0);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      SMOreg sMOreg0 = regSMO0.m_SVM;
      assertNull(sMOreg0);
      
      double[] doubleArray0 = new double[18];
      doubleArray0[1] = (double) 1;
      regSMO0.m_alphaStar = null;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      double[] doubleArray1 = new double[2];
      assertFalse(doubleArray1.equals((Object)doubleArray0));
      
      doubleArray1[0] = (double) 1;
      regSMO0.m_alphaStar = doubleArray1;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      String string0 = regSMO0.seedTipText();
      assertNotNull(string0);
      assertEquals("Seed for random number generator.", string0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      regSMO0.m_alpha = doubleArray1;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      int int0 = regSMO0.secondChoiceHeuristic(1);
      assertEquals((-1), int0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      try { 
        regSMO0.examineExample(0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      double double0 = regSMO0.getScore();
      assertEquals(0.0, double0, 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      double[] doubleArray0 = new double[8];
      regSMO0.m_alpha2Star = 0.0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      String string0 = regSMO0.getRevision();
      assertNotNull(string0);
      assertEquals("8034", string0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      FileSystemHandling fileSystemHandling1 = new FileSystemHandling();
      assertNotNull(fileSystemHandling1);
      assertFalse(fileSystemHandling1.equals((Object)fileSystemHandling0));
      
      int int0 = regSMO0.secondChoiceHeuristic(5081);
      assertEquals((-1), int0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      regSMO0.setEpsilonParameter(0.0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.0, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      regSMO0.m_target = regSMO0.m_alpha;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.0, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      regSMO0.optimize();
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) (-1);
      doubleArray0[2] = (double) (-1);
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      regSMO0.m_sparseWeights = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      String string0 = regSMO0.getRevision();
      assertNotNull(string0);
      assertEquals("8034", string0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      String string1 = regSMO0.globalInfo();
      assertNotNull(string1);
      assertFalse(string1.equals((Object)string0));
      assertEquals("Implementation of SMO for support vector regression as described in :\n\nA.J. Smola, B. Schoelkopf (1998). A tutorial on support vector regression.", string1);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      regSMO0.setEpsilon((-1553.3766));
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1553.3766), regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-2144324520), (-1677.1119), 1.963E-8, Double.POSITIVE_INFINITY, 81, 1.963E-8, 1.963E-8, 1.7976931348623157E308, 1.963E-8, 2011.748258, Double.POSITIVE_INFINITY);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -2144324520
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      double[] doubleArray0 = new double[21];
      regSMO0.m_b = (-3612.2);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      doubleArray0[5] = 0.0;
      doubleArray0[6] = 0.0;
      regSMO0.m_alphaStar = doubleArray0;
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      regSMO0.m_sparseWeights = doubleArray0;
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      String string0 = regSMO0.getRevision();
      assertNotNull(string0);
      assertEquals("8034", string0);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      String string1 = regSMO0.globalInfo();
      assertNotNull(string1);
      assertFalse(string1.equals((Object)string0));
      assertEquals("Implementation of SMO for support vector regression as described in :\n\nA.J. Smola, B. Schoelkopf (1998). A tutorial on support vector regression.", string1);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      Random.setNextRandom((-2144324520));
      int int0 = 82;
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-2144324520), (-1022.21240429), 1433.2775095862085, 2345.3498535953427, 82, (-3612.2), 1654.9219149240678, 499.06028509, (-885.715832837926), 1654.9219149240678, 0.0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      regSMO0.m_b = 192.6406309;
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2491, 2491, 3322.61083696, 2491, 2146623494, (-1.0), 3322.61083696, 2146623494, (-2.0), 2491, (-2.0));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      SMOreg sMOreg0 = new SMOreg();
      assertNotNull(sMOreg0);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      
      double[] doubleArray0 = new double[6];
      String string0 = sMOreg0.globalInfo();
      assertNotNull(string0);
      assertEquals("SMOreg implements the support vector machine for regression. The parameters can be learned using various algorithms. The algorithm is selected by setting the RegOptimizer. The most popular algorithm (RegSMOImproved) is due to Shevade, Keerthi et al and this is the default RegOptimizer.\n\nFor more information see:\n\nS.K. Shevade, S.S. Keerthi, C. Bhattacharyya, K.R.K. Murthy: Improvements to the SMO Algorithm for SVM Regression. In: IEEE Transactions on Neural Networks, 1999.\n\nA.J. Smola, B. Schoelkopf (1998). A tutorial on support vector regression.", string0);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      
      doubleArray0[0] = 0.0;
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      Capabilities capabilities0 = sMOreg0.getCapabilities();
      assertNotNull(capabilities0);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals(1, capabilities0.getMinimumNumberInstances());
      assertTrue(capabilities0.hasDependencies());
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      sMOreg0.setRegOptimizer(regSMO0);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(1, 1, 3778.290758651436, (byte)104, 0, 0, 3778.290758651436, 3778.290758651436, 2, 434.62875443359235, (byte)104);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      
      SMOreg sMOreg0 = new SMOreg();
      assertNotNull(sMOreg0);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertFalse(sMOreg0.getDebug());
      
      double[] doubleArray0 = new double[6];
      String string0 = sMOreg0.regOptimizerTipText();
      assertNotNull(string0);
      assertEquals("The learning algorithm.", string0);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertFalse(sMOreg0.getDebug());
      
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      
      regSMO0.setEpsilon(1178.662778287815);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1178.662778287815, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      
      sMOreg0.setRegOptimizer(regSMO0);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1178.662778287815, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertFalse(sMOreg0.getDebug());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(1, 1, 3778.29075865, (byte)104, 0, 1178.662778287815, 3778.29075865, 3778.29075865, 2, 2, (byte)104);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      double[] doubleArray0 = new double[5];
      regSMO0.m_alphaStar = null;
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      regSMO0.m_alpha = doubleArray0;
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      regSMO0.m_alphaStar = doubleArray0;
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      regSMO0.m_target = regSMO0.m_alpha;
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      regSMO0.optimize();
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      String string0 = regSMO0.epsilonTipText();
      assertNotNull(string0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", string0);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      String string1 = regSMO0.toString();
      assertNotNull(string1);
      assertFalse(string1.equals((Object)string0));
      assertEquals("SMOreg\n\nSupport vectors:\n +       0     \n\n\n\nNumber of kernel evaluations: 0", string1);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      Enumeration enumeration0 = regSMO0.listOptions();
      assertNotNull(enumeration0);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      System.setCurrentTimeMillis(42L);
      regSMO0.setSeed(54);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(54, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(1, 1597.9681, 1.04E-8, 45.0, 91, 45.0, 3510, (-840.1544305), 0.0, 54, 489.1749);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 91
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      SMOreg sMOreg0 = new SMOreg();
      assertNotNull(sMOreg0);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertFalse(sMOreg0.getDebug());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      
      regSMO0.setSMOReg(sMOreg0);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertFalse(sMOreg0.getDebug());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      
      double[] doubleArray0 = new double[6];
      doubleArray0[0] = (double) 2;
      doubleArray0[0] = (double) 2;
      String string0 = sMOreg0.globalInfo();
      assertNotNull(string0);
      assertEquals("SMOreg implements the support vector machine for regression. The parameters can be learned using various algorithms. The algorithm is selected by setting the RegOptimizer. The most popular algorithm (RegSMOImproved) is due to Shevade, Keerthi et al and this is the default RegOptimizer.\n\nFor more information see:\n\nS.K. Shevade, S.S. Keerthi, C. Bhattacharyya, K.R.K. Murthy: Improvements to the SMO Algorithm for SVM Regression. In: IEEE Transactions on Neural Networks, 1999.\n\nA.J. Smola, B. Schoelkopf (1998). A tutorial on support vector regression.", string0);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertFalse(sMOreg0.getDebug());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      
      doubleArray0[0] = 0.0;
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      Capabilities capabilities0 = sMOreg0.getCapabilities();
      assertNotNull(capabilities0);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertFalse(sMOreg0.getDebug());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals(1, capabilities0.getMinimumNumberInstances());
      assertTrue(capabilities0.hasDependencies());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(1, 14.740761753375175, 0, 2, 1971, (-5211), 0.1, (-1236.7678092527), 2.0, 1653.1948010764, 14.740761753375175);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1971
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      SMOreg sMOreg0 = new SMOreg();
      assertNotNull(sMOreg0);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      
      double[] doubleArray0 = new double[6];
      String string0 = sMOreg0.globalInfo();
      assertNotNull(string0);
      assertEquals("SMOreg implements the support vector machine for regression. The parameters can be learned using various algorithms. The algorithm is selected by setting the RegOptimizer. The most popular algorithm (RegSMOImproved) is due to Shevade, Keerthi et al and this is the default RegOptimizer.\n\nFor more information see:\n\nS.K. Shevade, S.S. Keerthi, C. Bhattacharyya, K.R.K. Murthy: Improvements to the SMO Algorithm for SVM Regression. In: IEEE Transactions on Neural Networks, 1999.\n\nA.J. Smola, B. Schoelkopf (1998). A tutorial on support vector regression.", string0);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      
      doubleArray0[0] = 0.0;
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      Capabilities capabilities0 = sMOreg0.getCapabilities();
      assertNotNull(capabilities0);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals(1, capabilities0.getMinimumNumberInstances());
      assertTrue(capabilities0.hasDependencies());
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      
      sMOreg0.setRegOptimizer(regSMO0);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(1, 1, 3778.290758651436, (byte) (-98), 0, 0, 3778.290758651436, 3778.290758651436, 2, 434.62875443359235, (byte) (-98));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      SMOreg sMOreg0 = new SMOreg();
      assertNotNull(sMOreg0);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      
      sMOreg0.setRegOptimizer(regSMO0);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      
      regSMO0.setSMOReg(sMOreg0);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (double) (-1);
      doubleArray0[0] = (double) 1;
      doubleArray0[3] = (double) 0;
      doubleArray0[4] = 0.0;
      String string0 = sMOreg0.kernelTipText();
      assertNotNull(string0);
      assertEquals("The kernel to use.", string0);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      boolean boolean0 = FileSystemHandling.createFolder((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      byte[] byteArray0 = new byte[5];
      String string1 = regSMO0.getRevision();
      assertNotNull(string1);
      assertFalse(string1.equals((Object)string0));
      assertEquals("8034", string1);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      boolean boolean1 = regSMO0.findOptimalPointOnLine(0, 0.0, 2191.4399714975216, 0.0, 450, (-484.2), (-4331), (byte)0, 0.0, 0.0, 1.7976931348623157E308);
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      SMOreg sMOreg0 = new SMOreg();
      assertNotNull(sMOreg0);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertFalse(sMOreg0.getDebug());
      
      regSMO0.setSMOReg(sMOreg0);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertFalse(sMOreg0.getDebug());
      
      double[] doubleArray0 = new double[6];
      doubleArray0[0] = (double) (-1);
      doubleArray0[3] = (double) 0;
      doubleArray0[0] = 0.0;
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      sMOreg0.setDebug(true);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertTrue(sMOreg0.getDebug());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      
      byte[] byteArray0 = new byte[5];
      regSMO0.setEpsilon(1346.118363989696);
      assertEquals(1346.118363989696, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      boolean boolean0 = FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      assertFalse(boolean0);
      assertArrayEquals(new byte[] {(byte)0, (byte)0, (byte)0, (byte)0, (byte)0}, byteArray0);
      
      regSMO0.m_alpha1 = 5.5;
      assertEquals(1346.118363989696, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(43, 3791.72, 1, 1346.118363989696, 0, 3798.0786550559665, 3798.0786550559665, (byte)104, 42.799, 410.6, 2);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 43
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "");
      assertFalse(boolean0);
      
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      double double0 = regSMO0.getEpsilon();
      assertEquals(1.0E-12, double0, 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      double[] doubleArray0 = new double[7];
      doubleArray0[0] = (-651.079364649584);
      doubleArray0[1] = 1.0E-12;
      doubleArray0[2] = 1.0E-12;
      doubleArray0[3] = (-651.079364649584);
      doubleArray0[4] = 1.0E-12;
      doubleArray0[5] = (-651.079364649584);
      doubleArray0[6] = (-651.079364649584);
      regSMO0.m_alphaStar = doubleArray0;
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      regSMO0.setEpsilon((-651.079364649584));
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-651.079364649584), regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(53, 5.5, 1.4254007763926965E-8, 927.031667631, 53, (-1163.283), 1.0E-12, 2718.78922715052, (-651.079364649584), 6.7, (-518.3021452));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      boolean boolean0 = FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "h");
      assertFalse(boolean0);
      
      RegSMO regSMO1 = new RegSMO();
      assertNotNull(regSMO1);
      assertFalse(regSMO1.equals((Object)regSMO0));
      assertEquals(0.001, regSMO1.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO1.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO1.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO1.epsilonTipText());
      assertFalse(regSMO1.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO1.seedTipText());
      assertEquals(1, regSMO1.getSeed());
      assertEquals((-1), regSMO1.getCacheHits());
      assertEquals(1.0E-12, regSMO1.getEpsilon(), 0.01);
      
      byte byte0 = (byte)104;
      byte[] byteArray0 = new byte[5];
      byteArray0[0] = (byte) (-34);
      byteArray0[4] = (byte)104;
      byteArray0[4] = (byte) (-100);
      byteArray0[3] = (byte) (-1);
      byteArray0[4] = (byte)0;
      boolean boolean1 = FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
      assertArrayEquals(new byte[] {(byte) (-34), (byte)0, (byte)0, (byte) (-1), (byte)0}, byteArray0);
      
      TechnicalInformation technicalInformation0 = regSMO1.getTechnicalInformation();
      assertNotSame(regSMO1, regSMO0);
      assertNotNull(technicalInformation0);
      assertFalse(regSMO1.equals((Object)regSMO0));
      assertEquals(0.001, regSMO1.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO1.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO1.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO1.epsilonTipText());
      assertFalse(regSMO1.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO1.seedTipText());
      assertEquals(1, regSMO1.getSeed());
      assertEquals((-1), regSMO1.getCacheHits());
      assertEquals(1.0E-12, regSMO1.getEpsilon(), 0.01);
      assertEquals(TechnicalInformation.Type.MISC, technicalInformation0.getType());
      assertFalse(technicalInformation0.hasAdditional());
      
      // Undeclared exception!
      try { 
        regSMO1.findOptimalPointOnLine((byte) (-101), (-1.0), 1000.0, 101.84615070956971, 40, 475.064476999999, (byte) (-101), 5.5, (-1.0), 1.0E-12, 1550.915620366388);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      String[] stringArray0 = new String[0];
      regSMO0.setOptions(stringArray0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      double double0 = regSMO0.getEpsilon();
      assertEquals(1.0E-12, double0, 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      double double1 = 4131.94;
      int int0 = Integer.MAX_VALUE;
      MockRandom mockRandom0 = new MockRandom(0L);
      assertNotNull(mockRandom0);
      
      regSMO0.m_random = (java.util.Random) mockRandom0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      double double2 = (-3111402.950995709);
      double double3 = 15.568179495593663;
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(Integer.MAX_VALUE, 73, 4131.94, 4131.94, 73, (-3111402.950995709), 1364.9999998635, 4131.94, (-123.4), Integer.MAX_VALUE, 15.568179495593663);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      SMOreg sMOreg0 = new SMOreg();
      assertNotNull(sMOreg0);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      
      regSMO0.setSMOReg(sMOreg0);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      
      double[] doubleArray0 = new double[6];
      doubleArray0[0] = (double) (-1);
      doubleArray0[0] = (double) 1;
      doubleArray0[3] = (double) 0;
      doubleArray0[0] = 0.0;
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      regSMO0.setEpsilon((-1985.472715531));
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1985.472715531), regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      byte[] byteArray0 = new byte[6];
      byteArray0[1] = (byte) (-34);
      byteArray0[2] = (byte)104;
      byteArray0[3] = (byte) (-34);
      byteArray0[4] = (byte)104;
      byteArray0[5] = (byte)104;
      boolean boolean1 = FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
      assertArrayEquals(new byte[] {(byte)0, (byte) (-34), (byte)104, (byte) (-34), (byte)104, (byte)104}, byteArray0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, (-937.0936211699426), 1.0E-10, (byte)104, 0, (byte) (-34), (byte)104, 0.0, (byte)104, 1.0E-12, (-599.65558171));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      double[] doubleArray0 = new double[8];
      regSMO0.m_alpha = doubleArray0;
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      TechnicalInformation technicalInformation0 = regSMO0.getTechnicalInformation();
      assertNotNull(technicalInformation0);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(technicalInformation0.hasAdditional());
      assertEquals(TechnicalInformation.Type.MISC, technicalInformation0.getType());
      
      doubleArray0[5] = 0.0;
      regSMO0.m_target = regSMO0.m_alpha;
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      try { 
        regSMO0.optimize();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test49()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      regSMO0.m_classIndex = (-100);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      SMOreg sMOreg0 = new SMOreg();
      assertNotNull(sMOreg0);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      
      double[] doubleArray0 = new double[6];
      doubleArray0[0] = (double) (-100);
      doubleArray0[4] = (double) 0;
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      regSMO0.m_alpha = regSMO0.m_alphaStar;
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      sMOreg0.setC(1331.0);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(1331.0, sMOreg0.getC(), 0.01);
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      
      regSMO0.setEpsilon(1351.0632047343167);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1351.0632047343167, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      boolean boolean0 = regSMO0.findOptimalPointOnLine(4, 1331.0, 1, (-100.0), 4, 1331.0, 0, 1, (-100), 1, 4);
      assertFalse(boolean0);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1351.0632047343167, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      BayesNet bayesNet0 = new BayesNet();
      assertNotNull(bayesNet0);
      assertFalse(bayesNet0.getDebug());
      assertEquals(2, bayesNet0.graphType());
      assertEquals("When ADTree (the data structure for increasing speed on counts, not to be confused with the classifier under the same name) is used learning time goes down typically. However, because ADTrees are memory intensive, memory problems may occur. Switching this option off makes the structure learning algorithms slower, and run with less memory. By default, ADTrees are used.", bayesNet0.useADTreeTipText());
      assertFalse(bayesNet0.getUseADTree());
      assertEquals("If set to true, classifier may output additional info to the console.", bayesNet0.debugTipText());
      assertEquals("Set the name of a file in BIF XML format. A Bayes network learned from data can be compared with the Bayes network represented by the BIF file. Statistics calculated are o.a. the number of missing and extra arcs.", bayesNet0.BIFFileTipText());
      assertEquals("Select Estimator algorithm for finding the conditional probability tables of the Bayes Network.", bayesNet0.estimatorTipText());
      assertEquals("Bayes Network learning using various search algorithms and quality measures.\nBase class for a Bayes Network classifier. Provides datastructures (network structure, conditional probability distributions, etc.) and facilities common to Bayes Network learning algorithms like K2 and B.\n\nFor more information see:\n\nhttp://www.cs.waikato.ac.nz/~remco/weka.pdf", bayesNet0.globalInfo());
      assertEquals("Select method used for searching network structures.", bayesNet0.searchAlgorithmTipText());
      
      try { 
        regSMO0.examineExample(1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test50()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      int int0 = 2482;
      regSMO0.m_nInstances = 2482;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      regSMO0.setEpsilonParameter(2482);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(2482.0, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      try { 
        regSMO0.optimize();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test51()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      int int0 = regSMO0.takeStep((-2422), (-2422), 1.0E-5, (-2422), 1.0E-5);
      assertEquals(0, int0);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      SMOreg sMOreg0 = new SMOreg();
      assertNotNull(sMOreg0);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      
      double[] doubleArray0 = new double[6];
      String string0 = sMOreg0.regOptimizerTipText();
      assertNotNull(string0);
      assertEquals("The learning algorithm.", string0);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      
      doubleArray0[0] = (double) (-2422);
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      regSMO0.setEpsilon(1178.662778287815);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1178.662778287815, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      sMOreg0.setRegOptimizer(regSMO0);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1178.662778287815, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(1, 1, 3778.290758651436, (byte)104, 0, 1178.662778287815, 3778.290758651436, 3778.290758651436, 2, 434.62875443359235, (byte)104);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test52()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      double[] doubleArray0 = new double[3];
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      double[] doubleArray1 = new double[5];
      assertFalse(doubleArray1.equals((Object)doubleArray0));
      
      doubleArray1[0] = 1.0E-12;
      doubleArray0[2] = (-2811.5289234401);
      doubleArray1[2] = (-2811.5289234401);
      doubleArray1[3] = (-2811.5289234401);
      doubleArray1[4] = 1.0E-12;
      regSMO0.m_alphaStar = doubleArray1;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      regSMO0.m_target = doubleArray1;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      try { 
        regSMO0.optimize();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test53()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertNotNull(regSMO0);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      
      double[] doubleArray0 = new double[4];
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      double[] doubleArray1 = new double[5];
      assertFalse(doubleArray1.equals((Object)doubleArray0));
      
      doubleArray1[0] = 1.0E-12;
      doubleArray0[2] = (-2811.5289234401);
      doubleArray1[2] = (-1624.65881438686);
      doubleArray1[3] = (-2811.5289234401);
      doubleArray1[4] = 1.0E-12;
      regSMO0.m_alpha = doubleArray1;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      
      regSMO0.m_target = regSMO0.m_alphaStar;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      
      try { 
        regSMO0.optimize();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }
}
