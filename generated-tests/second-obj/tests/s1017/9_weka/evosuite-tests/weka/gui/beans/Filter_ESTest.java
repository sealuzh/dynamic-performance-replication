/*
 * This file was automatically generated by EvoSuite
 * Sat Jul 07 04:49:23 GMT 2018
 */

package weka.gui.beans;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.MockitoExtension.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.AWTEventMulticaster;
import java.awt.Button;
import java.awt.DefaultFocusTraversalPolicy;
import java.awt.GraphicsConfiguration;
import java.awt.HeadlessException;
import java.awt.event.ContainerListener;
import java.awt.event.HierarchyBoundsListener;
import java.awt.event.InputMethodListener;
import java.awt.event.KeyListener;
import java.awt.event.MouseMotionListener;
import java.beans.EventSetDescriptor;
import java.beans.beancontext.BeanContextServicesSupport;
import java.io.IOException;
import java.text.AttributedCharacterIterator;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Vector;
import javax.accessibility.AccessibleContext;
import javax.swing.InputVerifier;
import javax.swing.MenuSelectionManager;
import javax.swing.table.DefaultTableModel;
import javax.swing.text.DefaultCaret;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.time.chrono.MockMinguoDate;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;
import weka.classifiers.meta.FilteredClassifier;
import weka.core.AbstractInstance;
import weka.core.AllJavadoc;
import weka.core.Attribute;
import weka.core.BinarySparseInstance;
import weka.core.Capabilities;
import weka.core.ChebyshevDistance;
import weka.core.CheckGOE;
import weka.core.EuclideanDistance;
import weka.core.GlobalInfoJavadoc;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.ListOptions;
import weka.core.NormalizableDistance;
import weka.core.OptionHandlerJavadoc;
import weka.core.TechnicalInformationHandlerJavadoc;
import weka.core.TestInstances;
import weka.core.converters.SerializedInstancesLoader;
import weka.core.converters.TextDirectoryLoader;
import weka.core.neighboursearch.CoverTree;
import weka.core.neighboursearch.LinearNNSearch;
import weka.core.tokenizers.AlphabeticTokenizer;
import weka.filters.AllFilter;
import weka.filters.MultiFilter;
import weka.filters.supervised.attribute.AttributeSelection;
import weka.filters.supervised.attribute.NominalToBinary;
import weka.filters.supervised.instance.SpreadSubsample;
import weka.filters.supervised.instance.StratifiedRemoveFolds;
import weka.filters.unsupervised.attribute.Add;
import weka.gui.Logger;
import weka.gui.SysErrLog;
import weka.gui.beans.Appender;
import weka.gui.beans.Associator;
import weka.gui.beans.AttributeSummarizer;
import weka.gui.beans.BeanVisual;
import weka.gui.beans.ClassAssigner;
import weka.gui.beans.ClassValuePicker;
import weka.gui.beans.ClassifierPerformanceEvaluator;
import weka.gui.beans.Clusterer;
import weka.gui.beans.ClustererPerformanceEvaluator;
import weka.gui.beans.ConfigurationListener;
import weka.gui.beans.CostBenefitAnalysis;
import weka.gui.beans.CrossValidationFoldMaker;
import weka.gui.beans.DataSetEvent;
import weka.gui.beans.DataVisualizer;
import weka.gui.beans.Filter;
import weka.gui.beans.FlowByExpression;
import weka.gui.beans.GraphViewer;
import weka.gui.beans.IncrementalClassifierEvaluator;
import weka.gui.beans.InstanceEvent;
import weka.gui.beans.InstanceStreamToBatchMaker;
import weka.gui.beans.KnowledgeFlowApp;
import weka.gui.beans.Loader;
import weka.gui.beans.ModelPerformanceChart;
import weka.gui.beans.PredictionAppender;
import weka.gui.beans.Saver;
import weka.gui.beans.ScatterPlotMatrix;
import weka.gui.beans.SerializedModelSaver;
import weka.gui.beans.Sorter;
import weka.gui.beans.StripChart;
import weka.gui.beans.SubstringLabeler;
import weka.gui.beans.TestSetEvent;
import weka.gui.beans.TextViewer;
import weka.gui.beans.TrainTestSplitMaker;
import weka.gui.beans.TrainingSetEvent;
import weka.gui.beans.TrainingSetMaker;
import weka.gui.explorer.ClassifierErrorsPlotInstances;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class Filter_ESTest extends Filter_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Filter filter0 = new Filter();
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      filter0.addConfigurationListener(configurationListener0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Filter filter0 = new Filter();
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      filter0.removeTestSetListener(trainTestSplitMaker0);
      filter0.getWrappedAlgorithm();
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      Random.setNextRandom(2538);
      Filter filter0 = new Filter();
      MultiFilter multiFilter0 = new MultiFilter();
      filter0.setFilter(multiFilter0);
      assertEquals("MultiFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Filter filter0 = new Filter();
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, (byte[]) null);
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      ClassifierErrorsPlotInstances classifierErrorsPlotInstances0 = new ClassifierErrorsPlotInstances();
      classifierErrorsPlotInstances0.getInstances();
      SpreadSubsample spreadSubsample0 = new SpreadSubsample();
      filter0.setWrappedAlgorithm(spreadSubsample0);
      assertEquals("SpreadSubsample", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.useDefaultVisual();
      filter0.connectionNotification("c4)6G$'9jz(", "c4)6G$'9jz(");
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Filter filter0 = new Filter();
      FlowByExpression flowByExpression0 = new FlowByExpression();
      flowByExpression0.getConnectedFormat();
      flowByExpression0.addNotify();
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(filter0, (Instances) null);
      filter0.acceptTrainingSet(trainingSetEvent0);
      filter0.useDefaultVisual();
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Filter filter0 = new Filter();
      ClustererPerformanceEvaluator clustererPerformanceEvaluator0 = new ClustererPerformanceEvaluator();
      ClassValuePicker classValuePicker0 = new ClassValuePicker();
      classValuePicker0.getStructure();
      DataSetEvent dataSetEvent0 = new DataSetEvent(clustererPerformanceEvaluator0, (Instances) null);
      filter0.acceptDataSet(dataSetEvent0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.disconnectionNotification("/c):a,VjR2IUGl<!Yg", "/c):a,VjR2IUGl<!Yg");
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Filter filter0 = new Filter();
      ClassAssigner classAssigner0 = new ClassAssigner();
      BeanVisual beanVisual0 = classAssigner0.m_visual;
      filter0.setVisual(beanVisual0);
      boolean boolean0 = filter0.eventGeneratable(":/t,|-9Q=");
      assertEquals("ClassAssigner", filter0.getCustomName());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Filter filter0 = new Filter();
      // Undeclared exception!
      try { 
        filter0.performRequest("");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         //  not supported (Filter)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Filter filter0 = new Filter();
      FlowByExpression flowByExpression0 = new FlowByExpression();
      filter0.getCustomName();
      MockMinguoDate mockMinguoDate0 = new MockMinguoDate();
      // Undeclared exception!
      try { 
        filter0.connectionAllowed((EventSetDescriptor) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Filter filter0 = new Filter();
      BeanVisual beanVisual0 = filter0.getVisual();
      assertEquals("AllFilter", beanVisual0.getText());
      assertEquals("weka/gui/beans/icons/DefaultFilter.gif", beanVisual0.getIconPath());
      assertEquals("weka/gui/beans/icons/DefaultFilter_animated.gif", beanVisual0.getAnimatedIconPath());
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Filter filter0 = new Filter();
      FlowByExpression flowByExpression0 = new FlowByExpression();
      DefaultCaret defaultCaret0 = new DefaultCaret();
      AWTEventMulticaster.remove((MouseMotionListener) defaultCaret0, (MouseMotionListener) defaultCaret0);
      filter0.addMouseMotionListener((MouseMotionListener) null);
      filter0.getComponentListeners();
      filter0.eventGeneratable("7");
      filter0.isBusy();
      filter0.eventGeneratable("SrV3k]SSaEVtD");
      filter0.eventGeneratable("SrV3k]SSaEVtD");
      filter0.performRequest("Stop");
      // Undeclared exception!
      try { 
        filter0.acceptTestSet((TestSetEvent) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Filter filter0 = new Filter();
      Sorter sorter0 = new Sorter();
      sorter0.emitBufferedInstances();
      filter0.removeTestSetListener(sorter0);
      PredictionAppender predictionAppender0 = new PredictionAppender();
      InstanceEvent instanceEvent0 = predictionAppender0.m_instanceEvent;
      filter0.notifyInstanceListeners((InstanceEvent) null);
      filter0.isBusy();
      Appender appender0 = new Appender();
      filter0.removeTrainingSetListener(appender0);
      ClassAssigner classAssigner0 = new ClassAssigner();
      Instances instances0 = predictionAppender0.m_format;
      TestSetEvent testSetEvent0 = new TestSetEvent(sorter0, (Instances) null);
      filter0.acceptTestSet(testSetEvent0);
      EuclideanDistance euclideanDistance0 = new EuclideanDistance();
      DataSetEvent dataSetEvent0 = new DataSetEvent(euclideanDistance0, (Instances) null);
      filter0.acceptDataSet(dataSetEvent0);
      filter0.connectionNotification("\nSet of instances created from scratch:\n", sorter0);
      StripChart stripChart0 = null;
      try {
        stripChart0 = new StripChart();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.gui.beans.StripChart", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      System.setCurrentTimeMillis(829L);
      Filter filter0 = new Filter();
      String string0 = filter0.globalInfo();
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", string0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      Filter filter0 = new Filter();
      FileSystemHandling.createFolder((EvoSuiteFile) null);
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      filter0.isRequestFocusEnabled();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      filter0.getInputMethodListeners();
      filter0.eventGeneratable("configuration");
      TextViewer textViewer0 = new TextViewer();
      SerializedModelSaver serializedModelSaver0 = new SerializedModelSaver();
      Button button0 = null;
      try {
        button0 = new Button();
        fail("Expecting exception: HeadlessException");
      
      } catch(HeadlessException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.awt.GraphicsEnvironment", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      Filter filter0 = new Filter();
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      filter0.removeConfigurationListener(configurationListener0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      Filter filter0 = new Filter();
      FlowByExpression flowByExpression0 = new FlowByExpression();
      flowByExpression0.getConnectedFormat();
      TestSetEvent testSetEvent0 = new TestSetEvent(filter0, (Instances) null, (-2274), (-1994091956));
      testSetEvent0.m_testSet = null;
      filter0.acceptTestSet(testSetEvent0);
      flowByExpression0.addNotify();
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(filter0, (Instances) null);
      trainingSetEvent0.m_maxRunNumber = (-2274);
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      System.setCurrentTimeMillis(829L);
      Filter filter0 = new Filter();
      String string0 = KnowledgeFlowApp.USERCOMPONENTS_XML_EXTENSION;
      filter0.getWrappedAlgorithm();
      ChebyshevDistance chebyshevDistance0 = new ChebyshevDistance();
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getStructure();
      TestSetEvent testSetEvent0 = new TestSetEvent(chebyshevDistance0, instances0);
      filter0.acceptTestSet(testSetEvent0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      Filter filter0 = new Filter();
      HierarchyBoundsListener hierarchyBoundsListener0 = mock(HierarchyBoundsListener.class, new ViolatedAssumptionAnswer());
      filter0.getWidth();
      OptionHandlerJavadoc optionHandlerJavadoc0 = new OptionHandlerJavadoc();
      filter0.connectionNotification("Nkf;gMoc", optionHandlerJavadoc0);
      filter0.removeAll();
      PredictionAppender predictionAppender0 = new PredictionAppender();
      FlowByExpression flowByExpression0 = new FlowByExpression();
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      InstanceStreamToBatchMaker instanceStreamToBatchMaker0 = new InstanceStreamToBatchMaker();
      ClassAssigner classAssigner0 = new ClassAssigner();
      DataSetEvent dataSetEvent0 = new DataSetEvent(textDirectoryLoader0, instances0);
      FlowByExpression flowByExpression1 = new FlowByExpression();
      filter0.acceptDataSet(dataSetEvent0);
      filter0.setFilter(nominalToBinary0);
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      
      Add add0 = new Add();
      assertNotNull(add0);
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("unnamed", add0.getAttributeName());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      
      ContainerListener[] containerListenerArray0 = filter0.getContainerListeners();
      assertNotNull(containerListenerArray0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      
      FlowByExpression flowByExpression0 = new FlowByExpression();
      assertNotNull(flowByExpression0);
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertEquals("", flowByExpression0.getExpressionString());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertFalse(flowByExpression0.isBusy());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertEquals("", flowByExpression0.getFalseStepName());
      
      boolean boolean0 = filter0.isBusy();
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(boolean0);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      
      Clusterer clusterer0 = new Clusterer();
      assertNotNull(clusterer0);
      assertTrue(clusterer0.getFocusTraversalKeysEnabled());
      assertFalse(clusterer0.hasIncomingBatchInstances());
      assertEquals("EM", clusterer0.getCustomName());
      assertFalse(clusterer0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Simple EM (expectation maximisation) class.\n\nEM assigns a probability distribution to each instance which indicates the probability of it belonging to each of the clusters</font><br><br> EM can decide how many clusters to create by cross validation, or you may specify apriori how many clusters to generate.<br><br>The cross validation performed to determine the number of clusters is done in the following steps:<br>1. the number of clusters is set to 1<br>2. the training set is split randomly into 10 folds.<br>3. EM is performed 10 times using the 10 folds the usual CV way.<br>4. the loglikelihood is averaged over all 10 results.<br>5.<br>if loglikelihood has increased the number of clusters is increased by 1 and the program continues at step 2.<br><br><br>The number of folds is fixed to 10, as long as the number of instances in the training set is not smaller 10.<br>If this is the case the number of folds is set equal to the number of instances.<br></html>", clusterer0.globalInfo());
      assertFalse(clusterer0.isBusy());
      assertFalse(clusterer0.isFocusTraversalPolicyProvider());
      assertFalse(clusterer0.getIgnoreRepaint());
      assertFalse(clusterer0.isFocusCycleRoot());
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(add0, instances0, (-1721), 1561);
      assertNotNull(trainingSetEvent0);
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("unnamed", add0.getAttributeName());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals((-1721), trainingSetEvent0.getSetNumber());
      assertEquals(1561, trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("unnamed", add0.getAttributeName());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals((-1721), trainingSetEvent0.getSetNumber());
      assertEquals(1561, trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      
      filter0.removeInstanceListener(flowByExpression0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertEquals("", flowByExpression0.getExpressionString());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertFalse(flowByExpression0.isBusy());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertEquals("", flowByExpression0.getFalseStepName());
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      
      DataVisualizer dataVisualizer0 = new DataVisualizer();
      assertNotNull(dataVisualizer0);
      assertTrue(dataVisualizer0.getFocusTraversalKeysEnabled());
      assertFalse(dataVisualizer0.isFocusTraversalPolicyProvider());
      assertFalse(dataVisualizer0.isFocusCycleRoot());
      assertEquals("", dataVisualizer0.getOffscreenXAxis());
      assertEquals("", dataVisualizer0.getOffscreenAdditionalOpts());
      assertEquals("", dataVisualizer0.getOffscreenYAxis());
      assertFalse(dataVisualizer0.isFocusTraversalPolicySet());
      assertEquals("500", dataVisualizer0.getOffscreenWidth());
      assertEquals("Visualize incoming data/training/test sets in a 2D scatter plot.", dataVisualizer0.globalInfo());
      assertEquals("DataVisualizer", dataVisualizer0.getCustomName());
      assertEquals("Weka Chart Renderer", dataVisualizer0.getOffscreenRendererName());
      assertFalse(dataVisualizer0.isBusy());
      assertFalse(dataVisualizer0.getIgnoreRepaint());
      assertEquals("400", dataVisualizer0.getOffscreenHeight());
      
      filter0.addTestSetListener(dataVisualizer0);
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertTrue(dataVisualizer0.getFocusTraversalKeysEnabled());
      assertFalse(dataVisualizer0.isFocusTraversalPolicyProvider());
      assertFalse(dataVisualizer0.isFocusCycleRoot());
      assertEquals("", dataVisualizer0.getOffscreenXAxis());
      assertEquals("", dataVisualizer0.getOffscreenAdditionalOpts());
      assertEquals("", dataVisualizer0.getOffscreenYAxis());
      assertFalse(dataVisualizer0.isFocusTraversalPolicySet());
      assertEquals("500", dataVisualizer0.getOffscreenWidth());
      assertEquals("Visualize incoming data/training/test sets in a 2D scatter plot.", dataVisualizer0.globalInfo());
      assertEquals("DataVisualizer", dataVisualizer0.getCustomName());
      assertEquals("Weka Chart Renderer", dataVisualizer0.getOffscreenRendererName());
      assertFalse(dataVisualizer0.isBusy());
      assertFalse(dataVisualizer0.getIgnoreRepaint());
      assertEquals("400", dataVisualizer0.getOffscreenHeight());
      
      boolean boolean0 = filter0.eventGeneratable("/*");
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(boolean0);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      
      TestSetEvent testSetEvent0 = new TestSetEvent(dataVisualizer0, instances0);
      assertNotNull(testSetEvent0);
      assertTrue(dataVisualizer0.getFocusTraversalKeysEnabled());
      assertFalse(dataVisualizer0.isFocusTraversalPolicyProvider());
      assertFalse(dataVisualizer0.isFocusCycleRoot());
      assertEquals("", dataVisualizer0.getOffscreenXAxis());
      assertEquals("", dataVisualizer0.getOffscreenAdditionalOpts());
      assertEquals("", dataVisualizer0.getOffscreenYAxis());
      assertFalse(dataVisualizer0.isFocusTraversalPolicySet());
      assertEquals("500", dataVisualizer0.getOffscreenWidth());
      assertEquals("Visualize incoming data/training/test sets in a 2D scatter plot.", dataVisualizer0.globalInfo());
      assertEquals("DataVisualizer", dataVisualizer0.getCustomName());
      assertEquals("Weka Chart Renderer", dataVisualizer0.getOffscreenRendererName());
      assertFalse(dataVisualizer0.isBusy());
      assertFalse(dataVisualizer0.getIgnoreRepaint());
      assertEquals("400", dataVisualizer0.getOffscreenHeight());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertTrue(testSetEvent0.isStructureOnly());
      assertEquals(0, testSetEvent0.getSetNumber());
      assertEquals(1, testSetEvent0.getRunNumber());
      assertEquals(0, testSetEvent0.getMaxSetNumber());
      
      filter0.acceptTestSet(testSetEvent0);
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertTrue(dataVisualizer0.getFocusTraversalKeysEnabled());
      assertFalse(dataVisualizer0.isFocusTraversalPolicyProvider());
      assertFalse(dataVisualizer0.isFocusCycleRoot());
      assertEquals("", dataVisualizer0.getOffscreenXAxis());
      assertEquals("", dataVisualizer0.getOffscreenAdditionalOpts());
      assertEquals("", dataVisualizer0.getOffscreenYAxis());
      assertFalse(dataVisualizer0.isFocusTraversalPolicySet());
      assertEquals("500", dataVisualizer0.getOffscreenWidth());
      assertEquals("Visualize incoming data/training/test sets in a 2D scatter plot.", dataVisualizer0.globalInfo());
      assertEquals("DataVisualizer", dataVisualizer0.getCustomName());
      assertEquals("Weka Chart Renderer", dataVisualizer0.getOffscreenRendererName());
      assertFalse(dataVisualizer0.isBusy());
      assertFalse(dataVisualizer0.getIgnoreRepaint());
      assertEquals("400", dataVisualizer0.getOffscreenHeight());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertTrue(testSetEvent0.isStructureOnly());
      assertEquals(0, testSetEvent0.getSetNumber());
      assertEquals(1, testSetEvent0.getRunNumber());
      assertEquals(0, testSetEvent0.getMaxSetNumber());
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      PredictionAppender predictionAppender0 = new PredictionAppender();
      assertNotNull(predictionAppender0);
      assertFalse(predictionAppender0.isFocusCycleRoot());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      assertFalse(predictionAppender0.isBusy());
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      
      Vector vector0 = predictionAppender0.m_trainingSetListeners;
      assertNotNull(vector0);
      assertEquals(10, vector0.capacity());
      assertEquals("[]", vector0.toString());
      assertTrue(vector0.isEmpty());
      assertEquals(0, vector0.size());
      
      DefaultTableModel defaultTableModel0 = new DefaultTableModel(vector0, 10000);
      assertNotNull(defaultTableModel0);
      assertFalse(predictionAppender0.isFocusCycleRoot());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      assertFalse(predictionAppender0.isBusy());
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      assertEquals(10, vector0.capacity());
      assertEquals("[]", vector0.toString());
      assertTrue(vector0.isEmpty());
      assertEquals(0, vector0.size());
      
      filter0.connectionNotification("n4|)6G$'9jw(", defaultTableModel0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(predictionAppender0.isFocusCycleRoot());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      assertFalse(predictionAppender0.isBusy());
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      assertEquals(10, vector0.capacity());
      assertEquals("[]", vector0.toString());
      assertTrue(vector0.isEmpty());
      assertEquals(0, vector0.size());
      
      Sorter sorter0 = new Sorter();
      assertNotNull(sorter0);
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertEquals("", sorter0.getTempDirectory());
      
      filter0.removeDataSourceListener(sorter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertEquals("", sorter0.getTempDirectory());
      
      filter0.stop();
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      
      Enumeration enumeration0 = filter0.enumerateRequests();
      assertNotNull(enumeration0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      
      TrainingSetMaker trainingSetMaker0 = new TrainingSetMaker();
      assertNotNull(trainingSetMaker0);
      assertFalse(trainingSetMaker0.isFocusTraversalPolicySet());
      assertFalse(trainingSetMaker0.isBusy());
      assertFalse(trainingSetMaker0.isFocusCycleRoot());
      assertEquals("TrainingSetMaker", trainingSetMaker0.getCustomName());
      assertTrue(trainingSetMaker0.getFocusTraversalKeysEnabled());
      assertFalse(trainingSetMaker0.getIgnoreRepaint());
      assertEquals("Designate an incoming data set as a training set.", trainingSetMaker0.globalInfo());
      assertFalse(trainingSetMaker0.isFocusTraversalPolicyProvider());
      
      Instances instances0 = appender0.m_completeHeader;
      assertNull(instances0);
      
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      assertNotNull(trainTestSplitMaker0);
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      
      DataSetEvent dataSetEvent0 = new DataSetEvent(trainTestSplitMaker0, (Instances) null);
      assertNotNull(dataSetEvent0);
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertFalse(dataSetEvent0.isStructureOnly());
      
      trainTestSplitMaker0.revalidate();
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      
      filter0.connectionNotification("type of algorithmP(Associator)", dataSetEvent0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertFalse(dataSetEvent0.isStructureOnly());
      
      boolean boolean0 = filter0.eventGeneratable("type of algorithmP(Associator)");
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(boolean0);
      
      DataSetEvent dataSetEvent1 = new DataSetEvent(trainTestSplitMaker0, (Instances) null);
      assertFalse(dataSetEvent1.equals((Object)dataSetEvent0));
      assertNotNull(dataSetEvent1);
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertFalse(dataSetEvent1.isStructureOnly());
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      
      EuclideanDistance euclideanDistance0 = new EuclideanDistance();
      assertNotNull(euclideanDistance0);
      assertEquals("", euclideanDistance0.toString());
      assertFalse(euclideanDistance0.getDontNormalize());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", euclideanDistance0.attributeIndicesTipText());
      assertEquals("Set attribute selection mode. If false, only selected attributes in the range will be used in the distance calculation; if true, only non-selected attributes will be used for the calculation.", euclideanDistance0.invertSelectionTipText());
      assertFalse(euclideanDistance0.rangesSet());
      assertEquals("Whether if the normalization of attributes should be turned off for distance calculation (Default: false i.e. attribute values are normalized). ", euclideanDistance0.dontNormalizeTipText());
      assertEquals(1, NormalizableDistance.R_MAX);
      assertEquals(2, NormalizableDistance.R_WIDTH);
      assertEquals(0, NormalizableDistance.R_MIN);
      
      SerializedInstancesLoader serializedInstancesLoader0 = new SerializedInstancesLoader();
      assertNotNull(serializedInstancesLoader0);
      assertEquals("Use relative rather than absolute paths", serializedInstancesLoader0.useRelativePathTipText());
      assertEquals("Binary serialized instances", serializedInstancesLoader0.getFileDescription());
      assertEquals(".bsi", serializedInstancesLoader0.getFileExtension());
      assertEquals("Reads a source that contains serialized Instances.", serializedInstancesLoader0.globalInfo());
      assertFalse(serializedInstancesLoader0.getUseRelativePath());
      
      try { 
        serializedInstancesLoader0.getNextInstance((Instances) null);
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // No source has been specified
         //
         verifyException("weka.core.converters.SerializedInstancesLoader", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      filter0.useDefaultVisual();
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      AlphabeticTokenizer alphabeticTokenizer0 = new AlphabeticTokenizer();
      assertNotNull(alphabeticTokenizer0);
      assertEquals("Alphabetic string tokenizer, tokens are to be formed only from contiguous alphabetic sequences.", alphabeticTokenizer0.globalInfo());
      
      IncrementalClassifierEvaluator incrementalClassifierEvaluator0 = new IncrementalClassifierEvaluator();
      assertNotNull(incrementalClassifierEvaluator0);
      assertFalse(incrementalClassifierEvaluator0.getOutputPerClassInfoRetrievalStats());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals("For charting only, specify a sliding window size over which to compute performance stats. <= 0 means eval on whole stream", incrementalClassifierEvaluator0.chartingEvalWindowSizeTipText());
      assertEquals("Evaluate the performance of incrementally trained classifiers.", incrementalClassifierEvaluator0.globalInfo());
      assertFalse(incrementalClassifierEvaluator0.getIgnoreRepaint());
      assertEquals("IncrementalClassifierEvaluator", incrementalClassifierEvaluator0.getCustomName());
      assertFalse(incrementalClassifierEvaluator0.isBusy());
      assertFalse(incrementalClassifierEvaluator0.isFocusCycleRoot());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicySet());
      assertEquals("How often to report progress to the status bar.", incrementalClassifierEvaluator0.statusFrequencyTipText());
      assertEquals("Output per-class info retrieval stats. If set to true, predictions get stored so that stats such as AUC can be computed. Note: this consumes some memory.", incrementalClassifierEvaluator0.outputPerClassInfoRetrievalStatsTipText());
      assertEquals(100, incrementalClassifierEvaluator0.getStatusFrequency());
      assertEquals(0, incrementalClassifierEvaluator0.getChartingEvalWindowSize());
      assertTrue(incrementalClassifierEvaluator0.getFocusTraversalKeysEnabled());
      
      PredictionAppender predictionAppender0 = new PredictionAppender();
      assertNotNull(predictionAppender0);
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertFalse(predictionAppender0.isBusy());
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      assertFalse(predictionAppender0.isFocusCycleRoot());
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      
      Associator associator0 = new Associator();
      assertNotNull(associator0);
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertFalse(associator0.isFocusCycleRoot());
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      assertFalse(associator0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      assertFalse(associator0.isBusy());
      assertEquals("Apriori", associator0.getCustomName());
      assertTrue(associator0.getFocusTraversalKeysEnabled());
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      assertNotNull(trainTestSplitMaker0);
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      
      InputMethodListener[] inputMethodListenerArray0 = filter0.getInputMethodListeners();
      assertNotNull(inputMethodListenerArray0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      AttributedCharacterIterator.Attribute attributedCharacterIterator_Attribute0 = AttributedCharacterIterator.Attribute.LANGUAGE;
      assertNotNull(attributedCharacterIterator_Attribute0);
      
      Sorter.InstanceHolder sorter_InstanceHolder0 = new Sorter.InstanceHolder();
      assertNotNull(sorter_InstanceHolder0);
      
      Instance instance0 = sorter_InstanceHolder0.m_instance;
      assertNull(instance0);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isBusy());
      
      InputVerifier inputVerifier0 = substringLabeler0.getInputVerifier();
      assertNull(inputVerifier0);
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isBusy());
      
      SubstringLabeler substringLabeler1 = new SubstringLabeler();
      assertFalse(substringLabeler1.equals((Object)substringLabeler0));
      assertNotNull(substringLabeler1);
      assertTrue(substringLabeler1.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler1.getConsumeNonMatching());
      assertEquals("", substringLabeler1.getMatchDetails());
      assertFalse(substringLabeler1.isFocusTraversalPolicySet());
      assertEquals("SubstringLabeler", substringLabeler1.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler1.globalInfo());
      assertFalse(substringLabeler1.getNominalBinary());
      assertEquals("Match", substringLabeler1.getMatchAttributeName());
      assertFalse(substringLabeler1.getIgnoreRepaint());
      assertFalse(substringLabeler1.isBusy());
      assertFalse(substringLabeler1.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler1.isFocusCycleRoot());
      
      SubstringLabeler substringLabeler2 = new SubstringLabeler();
      assertFalse(substringLabeler2.equals((Object)substringLabeler0));
      assertFalse(substringLabeler2.equals((Object)substringLabeler1));
      assertNotNull(substringLabeler2);
      assertFalse(substringLabeler2.getNominalBinary());
      assertFalse(substringLabeler2.getConsumeNonMatching());
      assertFalse(substringLabeler2.getIgnoreRepaint());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler2.globalInfo());
      assertTrue(substringLabeler2.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler2.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler2.getCustomName());
      assertEquals("Match", substringLabeler2.getMatchAttributeName());
      assertFalse(substringLabeler2.isFocusTraversalPolicySet());
      assertFalse(substringLabeler2.isBusy());
      assertFalse(substringLabeler2.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler2.isFocusCycleRoot());
      
      StratifiedRemoveFolds stratifiedRemoveFolds0 = new StratifiedRemoveFolds();
      assertNotNull(stratifiedRemoveFolds0);
      assertEquals(0L, stratifiedRemoveFolds0.getSeed());
      assertFalse(stratifiedRemoveFolds0.getInvertSelection());
      assertEquals(1, stratifiedRemoveFolds0.getFold());
      assertTrue(stratifiedRemoveFolds0.isNewBatch());
      assertFalse(stratifiedRemoveFolds0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("The fold which is selected.", stratifiedRemoveFolds0.foldTipText());
      assertEquals("Whether to invert the selection.", stratifiedRemoveFolds0.invertSelectionTipText());
      assertEquals("the random number seed for shuffling the dataset. If seed is negative, shuffling will not be performed.", stratifiedRemoveFolds0.seedTipText());
      assertEquals("This filter takes a dataset and outputs a specified fold for cross validation. If you do not want the folds to be stratified use the unsupervised version.", stratifiedRemoveFolds0.globalInfo());
      assertFalse(stratifiedRemoveFolds0.isFirstBatchDone());
      assertFalse(stratifiedRemoveFolds0.isOutputFormatDefined());
      assertEquals("The number of folds to split the dataset into.", stratifiedRemoveFolds0.numFoldsTipText());
      assertEquals(10, stratifiedRemoveFolds0.getNumFolds());
      
      filter0.connectionNotification("instance", stratifiedRemoveFolds0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals(0L, stratifiedRemoveFolds0.getSeed());
      assertFalse(stratifiedRemoveFolds0.getInvertSelection());
      assertEquals(1, stratifiedRemoveFolds0.getFold());
      assertTrue(stratifiedRemoveFolds0.isNewBatch());
      assertFalse(stratifiedRemoveFolds0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("The fold which is selected.", stratifiedRemoveFolds0.foldTipText());
      assertEquals("Whether to invert the selection.", stratifiedRemoveFolds0.invertSelectionTipText());
      assertEquals("the random number seed for shuffling the dataset. If seed is negative, shuffling will not be performed.", stratifiedRemoveFolds0.seedTipText());
      assertEquals("This filter takes a dataset and outputs a specified fold for cross validation. If you do not want the folds to be stratified use the unsupervised version.", stratifiedRemoveFolds0.globalInfo());
      assertFalse(stratifiedRemoveFolds0.isFirstBatchDone());
      assertFalse(stratifiedRemoveFolds0.isOutputFormatDefined());
      assertEquals("The number of folds to split the dataset into.", stratifiedRemoveFolds0.numFoldsTipText());
      assertEquals(10, stratifiedRemoveFolds0.getNumFolds());
      
      filter0.notifyInstanceListeners(instanceEvent0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      
      filter0.useDefaultVisual();
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      
      AlphabeticTokenizer alphabeticTokenizer0 = new AlphabeticTokenizer();
      assertNotNull(alphabeticTokenizer0);
      assertEquals("Alphabetic string tokenizer, tokens are to be formed only from contiguous alphabetic sequences.", alphabeticTokenizer0.globalInfo());
      
      IncrementalClassifierEvaluator incrementalClassifierEvaluator0 = new IncrementalClassifierEvaluator();
      assertNotNull(incrementalClassifierEvaluator0);
      assertFalse(incrementalClassifierEvaluator0.isBusy());
      assertTrue(incrementalClassifierEvaluator0.getFocusTraversalKeysEnabled());
      assertEquals("IncrementalClassifierEvaluator", incrementalClassifierEvaluator0.getCustomName());
      assertFalse(incrementalClassifierEvaluator0.getIgnoreRepaint());
      assertEquals("Evaluate the performance of incrementally trained classifiers.", incrementalClassifierEvaluator0.globalInfo());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicySet());
      assertEquals(0, incrementalClassifierEvaluator0.getChartingEvalWindowSize());
      assertEquals(100, incrementalClassifierEvaluator0.getStatusFrequency());
      assertEquals("Output per-class info retrieval stats. If set to true, predictions get stored so that stats such as AUC can be computed. Note: this consumes some memory.", incrementalClassifierEvaluator0.outputPerClassInfoRetrievalStatsTipText());
      assertEquals("For charting only, specify a sliding window size over which to compute performance stats. <= 0 means eval on whole stream", incrementalClassifierEvaluator0.chartingEvalWindowSizeTipText());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicyProvider());
      assertFalse(incrementalClassifierEvaluator0.getOutputPerClassInfoRetrievalStats());
      assertFalse(incrementalClassifierEvaluator0.isFocusCycleRoot());
      assertEquals("How often to report progress to the status bar.", incrementalClassifierEvaluator0.statusFrequencyTipText());
      
      PredictionAppender predictionAppender0 = new PredictionAppender();
      assertNotNull(predictionAppender0);
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      assertFalse(predictionAppender0.isBusy());
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertFalse(predictionAppender0.isFocusCycleRoot());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      
      Associator associator0 = new Associator();
      assertNotNull(associator0);
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      assertFalse(associator0.isBusy());
      assertFalse(associator0.getIgnoreRepaint());
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      assertTrue(associator0.getFocusTraversalKeysEnabled());
      assertEquals("Apriori", associator0.getCustomName());
      assertFalse(associator0.isFocusCycleRoot());
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      assertNotNull(trainTestSplitMaker0);
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      
      InputMethodListener[] inputMethodListenerArray0 = filter0.getInputMethodListeners();
      assertNotNull(inputMethodListenerArray0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      
      AttributedCharacterIterator.Attribute attributedCharacterIterator_Attribute0 = AttributedCharacterIterator.Attribute.LANGUAGE;
      assertNotNull(attributedCharacterIterator_Attribute0);
      
      Sorter.InstanceHolder sorter_InstanceHolder0 = new Sorter.InstanceHolder();
      assertNotNull(sorter_InstanceHolder0);
      
      Instance instance0 = sorter_InstanceHolder0.m_instance;
      assertNull(instance0);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      
      SubstringLabeler substringLabeler1 = new SubstringLabeler();
      assertFalse(substringLabeler1.equals((Object)substringLabeler0));
      assertNotNull(substringLabeler1);
      assertFalse(substringLabeler1.getIgnoreRepaint());
      assertFalse(substringLabeler1.isBusy());
      assertEquals("SubstringLabeler", substringLabeler1.getCustomName());
      assertFalse(substringLabeler1.isFocusTraversalPolicyProvider());
      assertEquals("", substringLabeler1.getMatchDetails());
      assertFalse(substringLabeler1.getNominalBinary());
      assertFalse(substringLabeler1.isFocusTraversalPolicySet());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler1.globalInfo());
      assertTrue(substringLabeler1.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler1.isFocusCycleRoot());
      assertEquals("Match", substringLabeler1.getMatchAttributeName());
      assertFalse(substringLabeler1.getConsumeNonMatching());
      
      InputVerifier inputVerifier0 = substringLabeler1.getInputVerifier();
      assertFalse(substringLabeler1.equals((Object)substringLabeler0));
      assertNull(inputVerifier0);
      assertNotSame(substringLabeler1, substringLabeler0);
      assertFalse(substringLabeler1.getIgnoreRepaint());
      assertFalse(substringLabeler1.isBusy());
      assertEquals("SubstringLabeler", substringLabeler1.getCustomName());
      assertFalse(substringLabeler1.isFocusTraversalPolicyProvider());
      assertEquals("", substringLabeler1.getMatchDetails());
      assertFalse(substringLabeler1.getNominalBinary());
      assertFalse(substringLabeler1.isFocusTraversalPolicySet());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler1.globalInfo());
      assertTrue(substringLabeler1.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler1.isFocusCycleRoot());
      assertEquals("Match", substringLabeler1.getMatchAttributeName());
      assertFalse(substringLabeler1.getConsumeNonMatching());
      
      SubstringLabeler substringLabeler2 = new SubstringLabeler();
      assertFalse(substringLabeler2.equals((Object)substringLabeler0));
      assertFalse(substringLabeler2.equals((Object)substringLabeler1));
      assertNotNull(substringLabeler2);
      assertEquals("", substringLabeler2.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler2.getCustomName());
      assertFalse(substringLabeler2.isBusy());
      assertFalse(substringLabeler2.getNominalBinary());
      assertFalse(substringLabeler2.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler2.getConsumeNonMatching());
      assertEquals("Match", substringLabeler2.getMatchAttributeName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler2.globalInfo());
      assertFalse(substringLabeler2.isFocusCycleRoot());
      assertTrue(substringLabeler2.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler2.getIgnoreRepaint());
      assertFalse(substringLabeler2.isFocusTraversalPolicySet());
      
      SubstringLabeler substringLabeler3 = new SubstringLabeler();
      assertFalse(substringLabeler3.equals((Object)substringLabeler1));
      assertFalse(substringLabeler3.equals((Object)substringLabeler0));
      assertFalse(substringLabeler3.equals((Object)substringLabeler2));
      assertNotNull(substringLabeler3);
      assertEquals("Match", substringLabeler3.getMatchAttributeName());
      assertFalse(substringLabeler3.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler3.isFocusCycleRoot());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler3.globalInfo());
      assertFalse(substringLabeler3.getIgnoreRepaint());
      assertTrue(substringLabeler3.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler3.getMatchDetails());
      assertFalse(substringLabeler3.isFocusTraversalPolicySet());
      assertFalse(substringLabeler3.getNominalBinary());
      assertFalse(substringLabeler3.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler3.getCustomName());
      assertFalse(substringLabeler3.isBusy());
      
      StratifiedRemoveFolds stratifiedRemoveFolds0 = new StratifiedRemoveFolds();
      assertNotNull(stratifiedRemoveFolds0);
      assertEquals(1, stratifiedRemoveFolds0.getFold());
      assertFalse(stratifiedRemoveFolds0.isFirstBatchDone());
      assertEquals("Whether to invert the selection.", stratifiedRemoveFolds0.invertSelectionTipText());
      assertEquals("This filter takes a dataset and outputs a specified fold for cross validation. If you do not want the folds to be stratified use the unsupervised version.", stratifiedRemoveFolds0.globalInfo());
      assertEquals("the random number seed for shuffling the dataset. If seed is negative, shuffling will not be performed.", stratifiedRemoveFolds0.seedTipText());
      assertFalse(stratifiedRemoveFolds0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals(0L, stratifiedRemoveFolds0.getSeed());
      assertTrue(stratifiedRemoveFolds0.isNewBatch());
      assertFalse(stratifiedRemoveFolds0.isOutputFormatDefined());
      assertEquals("The number of folds to split the dataset into.", stratifiedRemoveFolds0.numFoldsTipText());
      assertFalse(stratifiedRemoveFolds0.getInvertSelection());
      assertEquals("The fold which is selected.", stratifiedRemoveFolds0.foldTipText());
      assertEquals(10, stratifiedRemoveFolds0.getNumFolds());
      
      filter0.connectionNotification("weka/gui/GenericObjectEditor.props", substringLabeler3);
      assertFalse(substringLabeler3.equals((Object)substringLabeler1));
      assertFalse(substringLabeler3.equals((Object)substringLabeler0));
      assertFalse(substringLabeler3.equals((Object)substringLabeler2));
      assertNotSame(substringLabeler3, substringLabeler1);
      assertNotSame(substringLabeler3, substringLabeler0);
      assertNotSame(substringLabeler3, substringLabeler2);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler3.getMatchAttributeName());
      assertFalse(substringLabeler3.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler3.isFocusCycleRoot());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler3.globalInfo());
      assertFalse(substringLabeler3.getIgnoreRepaint());
      assertTrue(substringLabeler3.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler3.getMatchDetails());
      assertFalse(substringLabeler3.isFocusTraversalPolicySet());
      assertFalse(substringLabeler3.getNominalBinary());
      assertFalse(substringLabeler3.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler3.getCustomName());
      assertFalse(substringLabeler3.isBusy());
      
      filter0.notifyInstanceListeners(instanceEvent0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      filter0.addTestSetListener(substringLabeler0);
      assertFalse(substringLabeler0.equals((Object)substringLabeler1));
      assertFalse(substringLabeler0.equals((Object)substringLabeler3));
      assertFalse(substringLabeler0.equals((Object)substringLabeler2));
      assertNotSame(substringLabeler0, substringLabeler1);
      assertNotSame(substringLabeler0, substringLabeler3);
      assertNotSame(substringLabeler0, substringLabeler2);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      
      filter0.connectionNotification("weka/gui/GenericObjectEditor.props", predictionAppender0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      assertFalse(predictionAppender0.isBusy());
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertFalse(predictionAppender0.isFocusCycleRoot());
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      
      byte[] byteArray0 = new byte[6];
      byteArray0[2] = (byte)0;
      AttributeSummarizer attributeSummarizer0 = new AttributeSummarizer();
      assertNotNull(attributeSummarizer0);
      assertFalse(attributeSummarizer0.isFocusTraversalPolicyProvider());
      assertEquals("Attribute summary", attributeSummarizer0.getPerspectiveTitle());
      assertEquals("400", attributeSummarizer0.getOffscreenHeight());
      assertEquals("", attributeSummarizer0.getOffscreenXAxis());
      assertTrue(attributeSummarizer0.acceptsInstances());
      assertEquals(100, attributeSummarizer0.getMaxPlots());
      assertEquals(4, attributeSummarizer0.getGridWidth());
      assertTrue(attributeSummarizer0.getFocusTraversalKeysEnabled());
      assertEquals("Plot summary bar charts for incoming data/training/test sets.", attributeSummarizer0.globalInfo());
      assertEquals("AttributeSummarizer", attributeSummarizer0.getCustomName());
      assertFalse(attributeSummarizer0.isFocusCycleRoot());
      assertEquals("", attributeSummarizer0.getOffscreenAdditionalOpts());
      assertEquals("Weka Chart Renderer", attributeSummarizer0.getOffscreenRendererName());
      assertEquals("", attributeSummarizer0.getOffscreenYAxis());
      assertEquals("500", attributeSummarizer0.getOffscreenWidth());
      assertEquals("Matrix of attribute summary histograms", attributeSummarizer0.getPerspectiveTipText());
      assertFalse(attributeSummarizer0.isBusy());
      assertEquals((-1), attributeSummarizer0.getColoringIndex());
      assertFalse(attributeSummarizer0.getIgnoreRepaint());
      assertFalse(attributeSummarizer0.isFocusTraversalPolicySet());
      
      filter0.removeDataSourceListener(attributeSummarizer0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(attributeSummarizer0.isFocusTraversalPolicyProvider());
      assertEquals("Attribute summary", attributeSummarizer0.getPerspectiveTitle());
      assertEquals("400", attributeSummarizer0.getOffscreenHeight());
      assertEquals("", attributeSummarizer0.getOffscreenXAxis());
      assertTrue(attributeSummarizer0.acceptsInstances());
      assertEquals(100, attributeSummarizer0.getMaxPlots());
      assertEquals(4, attributeSummarizer0.getGridWidth());
      assertTrue(attributeSummarizer0.getFocusTraversalKeysEnabled());
      assertEquals("Plot summary bar charts for incoming data/training/test sets.", attributeSummarizer0.globalInfo());
      assertEquals("AttributeSummarizer", attributeSummarizer0.getCustomName());
      assertFalse(attributeSummarizer0.isFocusCycleRoot());
      assertEquals("", attributeSummarizer0.getOffscreenAdditionalOpts());
      assertEquals("Weka Chart Renderer", attributeSummarizer0.getOffscreenRendererName());
      assertEquals("", attributeSummarizer0.getOffscreenYAxis());
      assertEquals("500", attributeSummarizer0.getOffscreenWidth());
      assertEquals("Matrix of attribute summary histograms", attributeSummarizer0.getPerspectiveTipText());
      assertFalse(attributeSummarizer0.isBusy());
      assertEquals((-1), attributeSummarizer0.getColoringIndex());
      assertFalse(attributeSummarizer0.getIgnoreRepaint());
      assertFalse(attributeSummarizer0.isFocusTraversalPolicySet());
      
      byteArray0[4] = (byte) (-123);
      byteArray0[5] = (byte)2;
      boolean boolean0 = FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      assertArrayEquals(new byte[] {(byte)0, (byte)0, (byte)0, (byte)0, (byte) (-123), (byte)2}, byteArray0);
      assertFalse(boolean0);
      
      CoverTree coverTree0 = new CoverTree();
      assertNotNull(coverTree0);
      assertEquals(0.0, coverTree0.measureNumLeaves(), 0.01);
      assertEquals("Whether to calculate performance statistics for the NN search or not", coverTree0.measurePerformanceTipText());
      assertEquals(0.0, coverTree0.measureTreeSize(), 0.01);
      assertFalse(coverTree0.getMeasurePerformance());
      assertEquals(0.0, coverTree0.measureMaxDepth(), 0.01);
      assertEquals("The distance function to use for finding neighbours (default: weka.core.EuclideanDistance). ", coverTree0.distanceFunctionTipText());
      assertEquals("The base for the expansion constant.", coverTree0.baseTipText());
      assertEquals(1.3, coverTree0.getBase(), 0.01);
      
      boolean boolean1 = FileSystemHandling.createFolder((EvoSuiteFile) null);
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      
      AttributeSummarizer attributeSummarizer1 = new AttributeSummarizer();
      assertFalse(attributeSummarizer1.equals((Object)attributeSummarizer0));
      assertNotNull(attributeSummarizer1);
      assertFalse(attributeSummarizer1.isFocusTraversalPolicySet());
      assertEquals("Weka Chart Renderer", attributeSummarizer1.getOffscreenRendererName());
      assertEquals("Plot summary bar charts for incoming data/training/test sets.", attributeSummarizer1.globalInfo());
      assertFalse(attributeSummarizer1.isBusy());
      assertEquals("Matrix of attribute summary histograms", attributeSummarizer1.getPerspectiveTipText());
      assertTrue(attributeSummarizer1.acceptsInstances());
      assertEquals(100, attributeSummarizer1.getMaxPlots());
      assertEquals("AttributeSummarizer", attributeSummarizer1.getCustomName());
      assertEquals("", attributeSummarizer1.getOffscreenAdditionalOpts());
      assertFalse(attributeSummarizer1.isFocusCycleRoot());
      assertEquals("", attributeSummarizer1.getOffscreenXAxis());
      assertFalse(attributeSummarizer1.isFocusTraversalPolicyProvider());
      assertEquals((-1), attributeSummarizer1.getColoringIndex());
      assertEquals(4, attributeSummarizer1.getGridWidth());
      assertTrue(attributeSummarizer1.getFocusTraversalKeysEnabled());
      assertEquals("Attribute summary", attributeSummarizer1.getPerspectiveTitle());
      assertFalse(attributeSummarizer1.getIgnoreRepaint());
      assertEquals("500", attributeSummarizer1.getOffscreenWidth());
      assertEquals("", attributeSummarizer1.getOffscreenYAxis());
      assertEquals("400", attributeSummarizer1.getOffscreenHeight());
      
      ClassifierPerformanceEvaluator classifierPerformanceEvaluator0 = new ClassifierPerformanceEvaluator();
      assertNotNull(classifierPerformanceEvaluator0);
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicyProvider());
      assertFalse(classifierPerformanceEvaluator0.isFocusCycleRoot());
      assertEquals("Set the number of evaluation tasks to run in parallel.", classifierPerformanceEvaluator0.executionSlotsTipText());
      assertTrue(classifierPerformanceEvaluator0.getFocusTraversalKeysEnabled());
      assertFalse(classifierPerformanceEvaluator0.getIgnoreRepaint());
      assertEquals(2, classifierPerformanceEvaluator0.getExecutionSlots());
      assertEquals("Evaluate the performance of batch trained classifiers.", classifierPerformanceEvaluator0.globalInfo());
      assertEquals("ClassifierPerformanceEvaluator", classifierPerformanceEvaluator0.getCustomName());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicySet());
      
      filter0.connectionNotification("iL-dh?-ic1^Q", classifierPerformanceEvaluator0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicyProvider());
      assertFalse(classifierPerformanceEvaluator0.isFocusCycleRoot());
      assertEquals("Set the number of evaluation tasks to run in parallel.", classifierPerformanceEvaluator0.executionSlotsTipText());
      assertTrue(classifierPerformanceEvaluator0.getFocusTraversalKeysEnabled());
      assertFalse(classifierPerformanceEvaluator0.getIgnoreRepaint());
      assertEquals(2, classifierPerformanceEvaluator0.getExecutionSlots());
      assertEquals("Evaluate the performance of batch trained classifiers.", classifierPerformanceEvaluator0.globalInfo());
      assertEquals("ClassifierPerformanceEvaluator", classifierPerformanceEvaluator0.getCustomName());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicySet());
      
      boolean boolean2 = appender0.m_busy;
      assertTrue(boolean2 == boolean1);
      assertTrue(boolean2 == boolean0);
      assertFalse(boolean2);
      
      boolean boolean3 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "iL-dh?-ic1^Q");
      assertTrue(boolean3 == boolean0);
      assertTrue(boolean3 == boolean2);
      assertTrue(boolean3 == boolean1);
      assertFalse(boolean3);
      
      CrossValidationFoldMaker crossValidationFoldMaker0 = new CrossValidationFoldMaker();
      assertNotNull(crossValidationFoldMaker0);
      assertEquals(1, crossValidationFoldMaker0.getSeed());
      assertEquals("Split an incoming data set into cross validation folds. Separate train and test sets are produced for each of the k folds.", crossValidationFoldMaker0.globalInfo());
      assertFalse(crossValidationFoldMaker0.getPreserveOrder());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicyProvider());
      assertEquals("The number of train and test splits to produce", crossValidationFoldMaker0.foldsTipText());
      assertFalse(crossValidationFoldMaker0.isBusy());
      assertEquals("CrossValidationFoldMaker", crossValidationFoldMaker0.getCustomName());
      assertEquals("The randomization seed", crossValidationFoldMaker0.seedTipText());
      assertTrue(crossValidationFoldMaker0.getFocusTraversalKeysEnabled());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicySet());
      assertEquals(10, crossValidationFoldMaker0.getFolds());
      assertFalse(crossValidationFoldMaker0.isFocusCycleRoot());
      assertFalse(crossValidationFoldMaker0.getIgnoreRepaint());
      
      filter0.stop();
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      try { 
        filter0.getMousePosition(false);
        fail("Expecting exception: HeadlessException");
      
      } catch(HeadlessException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.awt.Container", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      
      Add add0 = new Add();
      assertNotNull(add0);
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      
      filter0.setFilter(add0);
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      
      CoverTree coverTree0 = new CoverTree();
      assertNotNull(coverTree0);
      assertEquals("The distance function to use for finding neighbours (default: weka.core.EuclideanDistance). ", coverTree0.distanceFunctionTipText());
      assertFalse(coverTree0.getMeasurePerformance());
      assertEquals(0.0, coverTree0.measureTreeSize(), 0.01);
      assertEquals(0.0, coverTree0.measureNumLeaves(), 0.01);
      assertEquals(0.0, coverTree0.measureMaxDepth(), 0.01);
      assertEquals(1.3, coverTree0.getBase(), 0.01);
      assertEquals("Whether to calculate performance statistics for the NN search or not", coverTree0.measurePerformanceTipText());
      assertEquals("The base for the expansion constant.", coverTree0.baseTipText());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      
      String string0 = "''";
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      ModelPerformanceChart modelPerformanceChart0 = new ModelPerformanceChart();
      assertNotNull(modelPerformanceChart0);
      assertEquals("", modelPerformanceChart0.getOffscreenYAxis());
      assertFalse(modelPerformanceChart0.isFocusTraversalPolicyProvider());
      assertFalse(modelPerformanceChart0.isBusy());
      assertEquals("400", modelPerformanceChart0.getOffscreenHeight());
      assertEquals("Visualize performance charts (such as ROC).", modelPerformanceChart0.globalInfo());
      assertFalse(modelPerformanceChart0.isFocusTraversalPolicySet());
      assertFalse(modelPerformanceChart0.getIgnoreRepaint());
      assertEquals("", modelPerformanceChart0.getOffscreenXAxis());
      assertEquals("", modelPerformanceChart0.getOffscreenAdditionalOpts());
      assertEquals("Weka Chart Renderer", modelPerformanceChart0.getOffscreenRendererName());
      assertFalse(modelPerformanceChart0.isFocusCycleRoot());
      assertEquals("ModelPerformanceChart", modelPerformanceChart0.getCustomName());
      assertTrue(modelPerformanceChart0.getFocusTraversalKeysEnabled());
      assertEquals("500", modelPerformanceChart0.getOffscreenWidth());
      
      // Undeclared exception!
      try { 
        filter0.setWrappedAlgorithm(modelPerformanceChart0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // class weka.gui.beans.ModelPerformanceChart : incorrect type of algorithm (Filter)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      
      CoverTree coverTree0 = new CoverTree();
      assertNotNull(coverTree0);
      assertFalse(coverTree0.getMeasurePerformance());
      assertEquals("The base for the expansion constant.", coverTree0.baseTipText());
      assertEquals(1.3, coverTree0.getBase(), 0.01);
      assertEquals(0.0, coverTree0.measureNumLeaves(), 0.01);
      assertEquals(0.0, coverTree0.measureMaxDepth(), 0.01);
      assertEquals("Whether to calculate performance statistics for the NN search or not", coverTree0.measurePerformanceTipText());
      assertEquals(0.0, coverTree0.measureTreeSize(), 0.01);
      assertEquals("The distance function to use for finding neighbours (default: weka.core.EuclideanDistance). ", coverTree0.distanceFunctionTipText());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      
      appender0.setToolTipText("''");
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      
      AttributeSummarizer attributeSummarizer0 = new AttributeSummarizer();
      assertNotNull(attributeSummarizer0);
      assertEquals("Attribute summary", attributeSummarizer0.getPerspectiveTitle());
      assertFalse(attributeSummarizer0.isFocusTraversalPolicyProvider());
      assertEquals(4, attributeSummarizer0.getGridWidth());
      assertEquals("400", attributeSummarizer0.getOffscreenHeight());
      assertFalse(attributeSummarizer0.isBusy());
      assertEquals((-1), attributeSummarizer0.getColoringIndex());
      assertFalse(attributeSummarizer0.getIgnoreRepaint());
      assertEquals("500", attributeSummarizer0.getOffscreenWidth());
      assertFalse(attributeSummarizer0.isFocusCycleRoot());
      assertFalse(attributeSummarizer0.isFocusTraversalPolicySet());
      assertEquals("", attributeSummarizer0.getOffscreenAdditionalOpts());
      assertEquals("Matrix of attribute summary histograms", attributeSummarizer0.getPerspectiveTipText());
      assertEquals("Weka Chart Renderer", attributeSummarizer0.getOffscreenRendererName());
      assertEquals("", attributeSummarizer0.getOffscreenYAxis());
      assertTrue(attributeSummarizer0.acceptsInstances());
      assertTrue(attributeSummarizer0.getFocusTraversalKeysEnabled());
      assertEquals("", attributeSummarizer0.getOffscreenXAxis());
      assertEquals("Plot summary bar charts for incoming data/training/test sets.", attributeSummarizer0.globalInfo());
      assertEquals("AttributeSummarizer", attributeSummarizer0.getCustomName());
      assertEquals(100, attributeSummarizer0.getMaxPlots());
      
      ClassifierPerformanceEvaluator classifierPerformanceEvaluator0 = new ClassifierPerformanceEvaluator();
      assertNotNull(classifierPerformanceEvaluator0);
      assertFalse(classifierPerformanceEvaluator0.getIgnoreRepaint());
      assertFalse(classifierPerformanceEvaluator0.isFocusCycleRoot());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals("Set the number of evaluation tasks to run in parallel.", classifierPerformanceEvaluator0.executionSlotsTipText());
      assertEquals("ClassifierPerformanceEvaluator", classifierPerformanceEvaluator0.getCustomName());
      assertEquals(2, classifierPerformanceEvaluator0.getExecutionSlots());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicySet());
      assertEquals("Evaluate the performance of batch trained classifiers.", classifierPerformanceEvaluator0.globalInfo());
      assertTrue(classifierPerformanceEvaluator0.getFocusTraversalKeysEnabled());
      
      filter0.connectionNotification("iL-dh?-ic1^Q", classifierPerformanceEvaluator0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(classifierPerformanceEvaluator0.getIgnoreRepaint());
      assertFalse(classifierPerformanceEvaluator0.isFocusCycleRoot());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals("Set the number of evaluation tasks to run in parallel.", classifierPerformanceEvaluator0.executionSlotsTipText());
      assertEquals("ClassifierPerformanceEvaluator", classifierPerformanceEvaluator0.getCustomName());
      assertEquals(2, classifierPerformanceEvaluator0.getExecutionSlots());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicySet());
      assertEquals("Evaluate the performance of batch trained classifiers.", classifierPerformanceEvaluator0.globalInfo());
      assertTrue(classifierPerformanceEvaluator0.getFocusTraversalKeysEnabled());
      
      filter0.useDefaultVisual();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      
      boolean boolean0 = FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "    Node ");
      assertFalse(boolean0);
      
      boolean boolean1 = filter0.eventGeneratable("iL-dh?-ic1^Q");
      assertTrue(boolean1 == boolean0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(boolean1);
      
      CrossValidationFoldMaker crossValidationFoldMaker0 = new CrossValidationFoldMaker();
      assertNotNull(crossValidationFoldMaker0);
      assertFalse(crossValidationFoldMaker0.isBusy());
      assertTrue(crossValidationFoldMaker0.getFocusTraversalKeysEnabled());
      assertFalse(crossValidationFoldMaker0.isFocusCycleRoot());
      assertEquals("CrossValidationFoldMaker", crossValidationFoldMaker0.getCustomName());
      assertEquals(1, crossValidationFoldMaker0.getSeed());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicyProvider());
      assertEquals(10, crossValidationFoldMaker0.getFolds());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicySet());
      assertEquals("The randomization seed", crossValidationFoldMaker0.seedTipText());
      assertFalse(crossValidationFoldMaker0.getIgnoreRepaint());
      assertEquals("Split an incoming data set into cross validation folds. Separate train and test sets are produced for each of the k folds.", crossValidationFoldMaker0.globalInfo());
      assertEquals("The number of train and test splits to produce", crossValidationFoldMaker0.foldsTipText());
      assertFalse(crossValidationFoldMaker0.getPreserveOrder());
      
      Saver saver0 = new Saver();
      assertNotNull(saver0);
      assertFalse(saver0.getIgnoreRepaint());
      assertTrue(saver0.getFocusTraversalKeysEnabled());
      assertTrue(saver0.getRelationNameForFilename());
      assertFalse(saver0.isFocusTraversalPolicySet());
      assertFalse(saver0.isFocusCycleRoot());
      assertFalse(saver0.isFocusTraversalPolicyProvider());
      assertFalse(saver0.isBusy());
      assertEquals("ArffSaver", saver0.getCustomName());
      assertEquals("<html><font color=blue>Writes to a destination that is in arff (attribute relation file format) format</font><br><br> The data can be compressed with gzip in order to save space.<br></html>", saver0.globalInfo());
      
      Appender appender1 = new Appender();
      assertFalse(appender1.equals((Object)appender0));
      assertNotNull(appender1);
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.isFocusCycleRoot());
      assertEquals("Appender", appender1.getCustomName());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      
      AttributeSummarizer attributeSummarizer1 = new AttributeSummarizer();
      assertFalse(attributeSummarizer1.equals((Object)attributeSummarizer0));
      assertNotNull(attributeSummarizer1);
      assertFalse(attributeSummarizer1.isFocusCycleRoot());
      assertEquals("Weka Chart Renderer", attributeSummarizer1.getOffscreenRendererName());
      assertTrue(attributeSummarizer1.acceptsInstances());
      assertEquals("", attributeSummarizer1.getOffscreenXAxis());
      assertEquals("", attributeSummarizer1.getOffscreenAdditionalOpts());
      assertTrue(attributeSummarizer1.getFocusTraversalKeysEnabled());
      assertEquals(100, attributeSummarizer1.getMaxPlots());
      assertEquals("Plot summary bar charts for incoming data/training/test sets.", attributeSummarizer1.globalInfo());
      assertEquals("AttributeSummarizer", attributeSummarizer1.getCustomName());
      assertEquals("400", attributeSummarizer1.getOffscreenHeight());
      assertEquals(4, attributeSummarizer1.getGridWidth());
      assertFalse(attributeSummarizer1.isFocusTraversalPolicyProvider());
      assertEquals("Attribute summary", attributeSummarizer1.getPerspectiveTitle());
      assertEquals("Matrix of attribute summary histograms", attributeSummarizer1.getPerspectiveTipText());
      assertEquals("", attributeSummarizer1.getOffscreenYAxis());
      assertEquals("500", attributeSummarizer1.getOffscreenWidth());
      assertFalse(attributeSummarizer1.isFocusTraversalPolicySet());
      assertEquals((-1), attributeSummarizer1.getColoringIndex());
      assertFalse(attributeSummarizer1.isBusy());
      assertFalse(attributeSummarizer1.getIgnoreRepaint());
      
      filter0.addDataSourceListener(appender1);
      assertFalse(appender1.equals((Object)appender0));
      assertNotSame(appender1, appender0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.isFocusCycleRoot());
      assertEquals("Appender", appender1.getCustomName());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      
      DefaultCaret defaultCaret0 = new DefaultCaret();
      assertNotNull(defaultCaret0);
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.y);
      assertEquals(0, defaultCaret0.width);
      
      DefaultCaret defaultCaret1 = new DefaultCaret();
      assertFalse(defaultCaret1.equals((Object)defaultCaret0));
      assertNotNull(defaultCaret1);
      assertEquals(0.0, defaultCaret1.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret1.getY(), 0.01);
      assertTrue(defaultCaret1.isEmpty());
      assertEquals(0.0, defaultCaret1.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret1.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret1.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret1.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret1.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret1.getX(), 0.01);
      assertEquals(0.0, defaultCaret1.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret1.getCenterY(), 0.01);
      assertEquals(0, defaultCaret1.height);
      assertEquals(0, defaultCaret1.x);
      assertEquals(0, defaultCaret1.width);
      assertEquals(0, defaultCaret1.y);
      
      MouseMotionListener mouseMotionListener0 = AWTEventMulticaster.add((MouseMotionListener) defaultCaret1, (MouseMotionListener) defaultCaret1);
      assertFalse(defaultCaret1.equals((Object)defaultCaret0));
      assertNotNull(mouseMotionListener0);
      assertNotSame(defaultCaret1, defaultCaret0);
      assertEquals(0.0, defaultCaret1.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret1.getY(), 0.01);
      assertTrue(defaultCaret1.isEmpty());
      assertEquals(0.0, defaultCaret1.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret1.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret1.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret1.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret1.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret1.getX(), 0.01);
      assertEquals(0.0, defaultCaret1.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret1.getCenterY(), 0.01);
      assertEquals(0, defaultCaret1.height);
      assertEquals(0, defaultCaret1.x);
      assertEquals(0, defaultCaret1.width);
      assertEquals(0, defaultCaret1.y);
      
      MouseMotionListener mouseMotionListener1 = AWTEventMulticaster.add((MouseMotionListener) defaultCaret1, (MouseMotionListener) defaultCaret1);
      assertFalse(defaultCaret1.equals((Object)defaultCaret0));
      assertFalse(mouseMotionListener1.equals((Object)mouseMotionListener0));
      assertNotNull(mouseMotionListener1);
      assertNotSame(defaultCaret1, defaultCaret0);
      assertNotSame(mouseMotionListener1, mouseMotionListener0);
      assertEquals(0.0, defaultCaret1.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret1.getY(), 0.01);
      assertTrue(defaultCaret1.isEmpty());
      assertEquals(0.0, defaultCaret1.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret1.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret1.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret1.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret1.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret1.getX(), 0.01);
      assertEquals(0.0, defaultCaret1.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret1.getCenterY(), 0.01);
      assertEquals(0, defaultCaret1.height);
      assertEquals(0, defaultCaret1.x);
      assertEquals(0, defaultCaret1.width);
      assertEquals(0, defaultCaret1.y);
      
      LinearNNSearch linearNNSearch0 = new LinearNNSearch();
      assertNotNull(linearNNSearch0);
      assertFalse(linearNNSearch0.getMeasurePerformance());
      assertEquals("Class implementing the brute force search algorithm for nearest neighbour search.", linearNNSearch0.globalInfo());
      assertEquals("Whether to skip identical instances (with distance 0 to the target)", linearNNSearch0.skipIdenticalTipText());
      assertEquals("Whether to calculate performance statistics for the NN search or not", linearNNSearch0.measurePerformanceTipText());
      assertFalse(linearNNSearch0.getSkipIdentical());
      assertEquals("The distance function to use for finding neighbours (default: weka.core.EuclideanDistance). ", linearNNSearch0.distanceFunctionTipText());
      
      filter0.setCustomName("''");
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("''", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      
      Instances instances0 = appender0.m_completeHeader;
      assertNull(instances0);
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      
      IncrementalClassifierEvaluator incrementalClassifierEvaluator0 = new IncrementalClassifierEvaluator();
      assertNotNull(incrementalClassifierEvaluator0);
      assertEquals("How often to report progress to the status bar.", incrementalClassifierEvaluator0.statusFrequencyTipText());
      assertEquals(100, incrementalClassifierEvaluator0.getStatusFrequency());
      assertFalse(incrementalClassifierEvaluator0.isFocusCycleRoot());
      assertEquals("Output per-class info retrieval stats. If set to true, predictions get stored so that stats such as AUC can be computed. Note: this consumes some memory.", incrementalClassifierEvaluator0.outputPerClassInfoRetrievalStatsTipText());
      assertEquals("For charting only, specify a sliding window size over which to compute performance stats. <= 0 means eval on whole stream", incrementalClassifierEvaluator0.chartingEvalWindowSizeTipText());
      assertEquals("IncrementalClassifierEvaluator", incrementalClassifierEvaluator0.getCustomName());
      assertFalse(incrementalClassifierEvaluator0.isBusy());
      assertEquals("Evaluate the performance of incrementally trained classifiers.", incrementalClassifierEvaluator0.globalInfo());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicySet());
      assertFalse(incrementalClassifierEvaluator0.getIgnoreRepaint());
      assertTrue(incrementalClassifierEvaluator0.getFocusTraversalKeysEnabled());
      assertFalse(incrementalClassifierEvaluator0.getOutputPerClassInfoRetrievalStats());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals(0, incrementalClassifierEvaluator0.getChartingEvalWindowSize());
      
      PredictionAppender predictionAppender0 = new PredictionAppender();
      assertNotNull(predictionAppender0);
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertFalse(predictionAppender0.isBusy());
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      assertFalse(predictionAppender0.isFocusCycleRoot());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      
      int int0 = appender0.getDebugGraphicsOptions();
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      assertEquals(0, int0);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      
      FlowByExpression flowByExpression0 = new FlowByExpression();
      assertNotNull(flowByExpression0);
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertEquals("", flowByExpression0.getExpressionString());
      assertFalse(flowByExpression0.isBusy());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      
      TechnicalInformationHandlerJavadoc technicalInformationHandlerJavadoc0 = new TechnicalInformationHandlerJavadoc();
      assertNotNull(technicalInformationHandlerJavadoc0);
      assertTrue(technicalInformationHandlerJavadoc0.getProlog());
      assertTrue(technicalInformationHandlerJavadoc0.getUseStars());
      assertFalse(technicalInformationHandlerJavadoc0.getSilent());
      assertEquals("weka.core.Javadoc", technicalInformationHandlerJavadoc0.getClassname());
      assertEquals("", technicalInformationHandlerJavadoc0.getDir());
      
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/mnt/gaiagpfs/users/homedirs/apanichella/Evosuite_performance/Dataset/gordon_script_sum/projects/9_weka");
      boolean boolean0 = FileSystemHandling.appendLineToFile(evoSuiteFile0, "^=rG&;{$=v/");
      assertFalse(boolean0);
      
      Appender appender1 = new Appender();
      assertFalse(appender1.equals((Object)appender0));
      assertNotNull(appender1);
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isBusy());
      
      ClassAssigner classAssigner0 = new ClassAssigner();
      assertNotNull(classAssigner0);
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertFalse(classAssigner0.isBusy());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertEquals("last", classAssigner0.getClassColumn());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      
      GraphicsConfiguration graphicsConfiguration0 = filter0.getGraphicsConfiguration();
      assertNull(graphicsConfiguration0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      
      Loader loader0 = new Loader();
      assertNotNull(loader0);
      assertTrue(loader0.getFocusTraversalKeysEnabled());
      assertEquals("ArffLoader", loader0.getCustomName());
      assertFalse(loader0.isFocusTraversalPolicySet());
      assertFalse(loader0.isFocusCycleRoot());
      assertFalse(loader0.isBusy());
      assertEquals("<html><font color=blue>Reads a source that is in arff (attribute relation file format) format</font> <br></html>", loader0.globalInfo());
      assertFalse(loader0.isFocusTraversalPolicyProvider());
      assertFalse(loader0.getIgnoreRepaint());
      
      DataSetEvent dataSetEvent0 = new DataSetEvent(appender0, instances0);
      assertFalse(appender0.equals((Object)appender1));
      assertNotNull(dataSetEvent0);
      assertTrue(dataSetEvent0.isStructureOnly());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      
      AttributeSummarizer attributeSummarizer0 = new AttributeSummarizer();
      assertNotNull(attributeSummarizer0);
      assertEquals("AttributeSummarizer", attributeSummarizer0.getCustomName());
      assertFalse(attributeSummarizer0.getIgnoreRepaint());
      assertTrue(attributeSummarizer0.acceptsInstances());
      assertEquals("500", attributeSummarizer0.getOffscreenWidth());
      assertEquals("Weka Chart Renderer", attributeSummarizer0.getOffscreenRendererName());
      assertEquals("", attributeSummarizer0.getOffscreenXAxis());
      assertFalse(attributeSummarizer0.isFocusCycleRoot());
      assertEquals("Plot summary bar charts for incoming data/training/test sets.", attributeSummarizer0.globalInfo());
      assertEquals(4, attributeSummarizer0.getGridWidth());
      assertTrue(attributeSummarizer0.getFocusTraversalKeysEnabled());
      assertEquals(100, attributeSummarizer0.getMaxPlots());
      assertEquals("", attributeSummarizer0.getOffscreenYAxis());
      assertEquals("", attributeSummarizer0.getOffscreenAdditionalOpts());
      assertEquals("400", attributeSummarizer0.getOffscreenHeight());
      assertFalse(attributeSummarizer0.isFocusTraversalPolicyProvider());
      assertFalse(attributeSummarizer0.isFocusTraversalPolicySet());
      assertEquals((-1), attributeSummarizer0.getColoringIndex());
      assertFalse(attributeSummarizer0.isBusy());
      assertEquals("Matrix of attribute summary histograms", attributeSummarizer0.getPerspectiveTipText());
      assertEquals("Attribute summary", attributeSummarizer0.getPerspectiveTitle());
      
      filter0.addDataSourceListener(classAssigner0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertFalse(classAssigner0.isBusy());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertEquals("last", classAssigner0.getClassColumn());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      
      DefaultCaret defaultCaret0 = new DefaultCaret();
      assertNotNull(defaultCaret0);
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0, defaultCaret0.y);
      assertEquals(0, defaultCaret0.width);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.height);
      
      MouseMotionListener mouseMotionListener0 = AWTEventMulticaster.add((MouseMotionListener) defaultCaret0, (MouseMotionListener) defaultCaret0);
      assertNotNull(mouseMotionListener0);
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0, defaultCaret0.y);
      assertEquals(0, defaultCaret0.width);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.height);
      
      EuclideanDistance euclideanDistance0 = new EuclideanDistance();
      assertNotNull(euclideanDistance0);
      assertEquals("Set attribute selection mode. If false, only selected attributes in the range will be used in the distance calculation; if true, only non-selected attributes will be used for the calculation.", euclideanDistance0.invertSelectionTipText());
      assertFalse(euclideanDistance0.rangesSet());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", euclideanDistance0.attributeIndicesTipText());
      assertEquals("Whether if the normalization of attributes should be turned off for distance calculation (Default: false i.e. attribute values are normalized). ", euclideanDistance0.dontNormalizeTipText());
      assertEquals("", euclideanDistance0.toString());
      assertFalse(euclideanDistance0.getDontNormalize());
      assertEquals(2, NormalizableDistance.R_WIDTH);
      assertEquals(0, NormalizableDistance.R_MIN);
      assertEquals(1, NormalizableDistance.R_MAX);
      
      Clusterer clusterer0 = new Clusterer();
      assertNotNull(clusterer0);
      assertTrue(clusterer0.getFocusTraversalKeysEnabled());
      assertFalse(clusterer0.hasIncomingBatchInstances());
      assertFalse(clusterer0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Simple EM (expectation maximisation) class.\n\nEM assigns a probability distribution to each instance which indicates the probability of it belonging to each of the clusters</font><br><br> EM can decide how many clusters to create by cross validation, or you may specify apriori how many clusters to generate.<br><br>The cross validation performed to determine the number of clusters is done in the following steps:<br>1. the number of clusters is set to 1<br>2. the training set is split randomly into 10 folds.<br>3. EM is performed 10 times using the 10 folds the usual CV way.<br>4. the loglikelihood is averaged over all 10 results.<br>5.<br>if loglikelihood has increased the number of clusters is increased by 1 and the program continues at step 2.<br><br><br>The number of folds is fixed to 10, as long as the number of instances in the training set is not smaller 10.<br>If this is the case the number of folds is set equal to the number of instances.<br></html>", clusterer0.globalInfo());
      assertFalse(clusterer0.getIgnoreRepaint());
      assertFalse(clusterer0.isBusy());
      assertFalse(clusterer0.isFocusTraversalPolicyProvider());
      assertEquals("EM", clusterer0.getCustomName());
      assertFalse(clusterer0.isFocusCycleRoot());
      
      DefaultFocusTraversalPolicy defaultFocusTraversalPolicy0 = new DefaultFocusTraversalPolicy();
      assertNotNull(defaultFocusTraversalPolicy0);
      assertTrue(defaultFocusTraversalPolicy0.getImplicitDownCycleTraversal());
      
      Instances instances1 = textDirectoryLoader0.getStructure();
      assertNotNull(instances1);
      assertSame(instances1, instances0);
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals(0, instances1.numClasses());
      assertEquals(1, instances1.classIndex());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances1.relationName());
      assertTrue(instances1.checkForStringAttributes());
      assertEquals(0, instances1.size());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      assertEquals(0, instances1.numInstances());
      
      DataSetEvent dataSetEvent1 = new DataSetEvent(defaultFocusTraversalPolicy0, instances1);
      assertFalse(dataSetEvent1.equals((Object)dataSetEvent0));
      assertNotNull(dataSetEvent1);
      assertTrue(defaultFocusTraversalPolicy0.getImplicitDownCycleTraversal());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals(0, instances1.numClasses());
      assertEquals(1, instances1.classIndex());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances1.relationName());
      assertTrue(instances1.checkForStringAttributes());
      assertEquals(0, instances1.size());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      assertEquals(0, instances1.numInstances());
      assertTrue(dataSetEvent1.isStructureOnly());
      
      filter0.acceptDataSet(dataSetEvent1);
      assertFalse(dataSetEvent1.equals((Object)dataSetEvent0));
      assertSame(instances1, instances0);
      assertNotSame(dataSetEvent1, dataSetEvent0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(defaultFocusTraversalPolicy0.getImplicitDownCycleTraversal());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals(0, instances1.numClasses());
      assertEquals(1, instances1.classIndex());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances1.relationName());
      assertTrue(instances1.checkForStringAttributes());
      assertEquals(0, instances1.size());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      assertEquals(0, instances1.numInstances());
      assertTrue(dataSetEvent1.isStructureOnly());
      
      CrossValidationFoldMaker crossValidationFoldMaker0 = new CrossValidationFoldMaker();
      assertNotNull(crossValidationFoldMaker0);
      assertFalse(crossValidationFoldMaker0.getPreserveOrder());
      assertEquals(1, crossValidationFoldMaker0.getSeed());
      assertEquals("Split an incoming data set into cross validation folds. Separate train and test sets are produced for each of the k folds.", crossValidationFoldMaker0.globalInfo());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicyProvider());
      assertFalse(crossValidationFoldMaker0.isBusy());
      assertTrue(crossValidationFoldMaker0.getFocusTraversalKeysEnabled());
      assertFalse(crossValidationFoldMaker0.isFocusCycleRoot());
      assertEquals("The randomization seed", crossValidationFoldMaker0.seedTipText());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicySet());
      assertEquals("The number of train and test splits to produce", crossValidationFoldMaker0.foldsTipText());
      assertEquals("CrossValidationFoldMaker", crossValidationFoldMaker0.getCustomName());
      assertEquals(10, crossValidationFoldMaker0.getFolds());
      assertFalse(crossValidationFoldMaker0.getIgnoreRepaint());
      
      filter0.connectionNotification("<!-- technical-plaintext-end -->", flowByExpression0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertEquals("", flowByExpression0.getExpressionString());
      assertFalse(flowByExpression0.isBusy());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      
      StripChart stripChart0 = null;
      try {
        stripChart0 = new StripChart();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.gui.beans.StripChart", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      HierarchyBoundsListener hierarchyBoundsListener0 = mock(HierarchyBoundsListener.class, new ViolatedAssumptionAnswer());
      filter0.useDefaultVisual();
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      Add add0 = new Add();
      assertNotNull(add0);
      assertFalse(add0.isFirstBatchDone());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      
      Capabilities capabilities0 = add0.getCapabilities();
      assertNotNull(capabilities0);
      assertFalse(add0.isFirstBatchDone());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals(0, capabilities0.getMinimumNumberInstances());
      assertFalse(capabilities0.hasDependencies());
      
      filter0.setFilter(add0);
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      
      CoverTree coverTree0 = new CoverTree();
      assertNotNull(coverTree0);
      assertEquals("The distance function to use for finding neighbours (default: weka.core.EuclideanDistance). ", coverTree0.distanceFunctionTipText());
      assertEquals(0.0, coverTree0.measureNumLeaves(), 0.01);
      assertEquals(0.0, coverTree0.measureTreeSize(), 0.01);
      assertFalse(coverTree0.getMeasurePerformance());
      assertEquals(0.0, coverTree0.measureMaxDepth(), 0.01);
      assertEquals("The base for the expansion constant.", coverTree0.baseTipText());
      assertEquals("Whether to calculate performance statistics for the NN search or not", coverTree0.measurePerformanceTipText());
      assertEquals(1.3, coverTree0.getBase(), 0.01);
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      
      appender0.setToolTipText("''");
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "''");
      assertFalse(boolean0);
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      instanceEvent0.setStatus(1);
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      InstanceEvent instanceEvent1 = appender0.m_ie;
      assertNotNull(instanceEvent1);
      assertSame(instanceEvent1, instanceEvent0);
      assertEquals(1, instanceEvent1.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      boolean boolean1 = filter0.eventGeneratable("''");
      assertTrue(boolean1 == boolean0);
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(boolean1);
      
      FilteredClassifier filteredClassifier0 = new FilteredClassifier();
      assertNotNull(filteredClassifier0);
      assertEquals("Class for running an arbitrary classifier on data that has been passed through an arbitrary filter. Like the classifier, the structure of the filter is based exclusively on the training data and test instances will be processed by the filter without changing their structure.", filteredClassifier0.globalInfo());
      assertFalse(filteredClassifier0.getDebug());
      assertEquals("If set to true, classifier may output additional info to the console.", filteredClassifier0.debugTipText());
      assertEquals("The base classifier to be used.", filteredClassifier0.classifierTipText());
      assertEquals(1, filteredClassifier0.graphType());
      assertEquals("The filter to be used.", filteredClassifier0.filterTipText());
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(1, instances0.classIndex());
      
      ScatterPlotMatrix scatterPlotMatrix0 = new ScatterPlotMatrix();
      assertNotNull(scatterPlotMatrix0);
      assertEquals("DataVisualizer", scatterPlotMatrix0.getCustomName());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicyProvider());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTitle());
      assertEquals("400", scatterPlotMatrix0.getOffscreenHeight());
      assertEquals("", scatterPlotMatrix0.getOffscreenYAxis());
      assertTrue(scatterPlotMatrix0.getFocusTraversalKeysEnabled());
      assertEquals("500", scatterPlotMatrix0.getOffscreenWidth());
      assertFalse(scatterPlotMatrix0.getIgnoreRepaint());
      assertFalse(scatterPlotMatrix0.isBusy());
      assertEquals("Weka Chart Renderer", scatterPlotMatrix0.getOffscreenRendererName());
      assertEquals("Visualize incoming data/training/test sets in a scatter plot matrix.", scatterPlotMatrix0.globalInfo());
      assertTrue(scatterPlotMatrix0.acceptsInstances());
      assertFalse(scatterPlotMatrix0.isFocusCycleRoot());
      assertEquals("", scatterPlotMatrix0.getOffscreenXAxis());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicySet());
      assertEquals("", scatterPlotMatrix0.getOffscreenAdditionalOpts());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTipText());
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      
      filter0.removeAll();
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      
      Instances instances0 = appender0.m_completeHeader;
      assertNull(instances0);
      
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      assertNotNull(trainTestSplitMaker0);
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      
      InputVerifier inputVerifier0 = trainTestSplitMaker0.getInputVerifier();
      assertNull(inputVerifier0);
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      
      trainTestSplitMaker0.revalidate();
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      
      boolean boolean0 = appender0.m_busy;
      assertFalse(boolean0);
      
      CrossValidationFoldMaker crossValidationFoldMaker0 = new CrossValidationFoldMaker();
      assertNotNull(crossValidationFoldMaker0);
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicyProvider());
      assertEquals("Split an incoming data set into cross validation folds. Separate train and test sets are produced for each of the k folds.", crossValidationFoldMaker0.globalInfo());
      assertEquals(1, crossValidationFoldMaker0.getSeed());
      assertFalse(crossValidationFoldMaker0.isFocusCycleRoot());
      assertEquals("The randomization seed", crossValidationFoldMaker0.seedTipText());
      assertTrue(crossValidationFoldMaker0.getFocusTraversalKeysEnabled());
      assertFalse(crossValidationFoldMaker0.getIgnoreRepaint());
      assertEquals("CrossValidationFoldMaker", crossValidationFoldMaker0.getCustomName());
      assertEquals("The number of train and test splits to produce", crossValidationFoldMaker0.foldsTipText());
      assertFalse(crossValidationFoldMaker0.isBusy());
      assertFalse(crossValidationFoldMaker0.getPreserveOrder());
      assertEquals(10, crossValidationFoldMaker0.getFolds());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicySet());
      
      int int0 = appender0.getY();
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals(0, int0);
      
      LinearNNSearch linearNNSearch0 = new LinearNNSearch();
      assertNotNull(linearNNSearch0);
      assertEquals("Whether to skip identical instances (with distance 0 to the target)", linearNNSearch0.skipIdenticalTipText());
      assertEquals("The distance function to use for finding neighbours (default: weka.core.EuclideanDistance). ", linearNNSearch0.distanceFunctionTipText());
      assertEquals("Whether to calculate performance statistics for the NN search or not", linearNNSearch0.measurePerformanceTipText());
      assertEquals("Class implementing the brute force search algorithm for nearest neighbour search.", linearNNSearch0.globalInfo());
      assertFalse(linearNNSearch0.getMeasurePerformance());
      assertFalse(linearNNSearch0.getSkipIdentical());
      
      SysErrLog sysErrLog0 = new SysErrLog();
      assertNotNull(sysErrLog0);
      
      filter0.setLog(sysErrLog0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      
      Instances instances1 = appender0.m_completeHeader;
      assertNull(instances1);
      
      boolean boolean1 = FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "state");
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
      
      InstanceEvent instanceEvent0 = new InstanceEvent(appender0, (Instances) null);
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      InstanceStreamToBatchMaker instanceStreamToBatchMaker0 = new InstanceStreamToBatchMaker();
      assertNotNull(instanceStreamToBatchMaker0);
      assertFalse(instanceStreamToBatchMaker0.isBusy());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicySet());
      assertTrue(instanceStreamToBatchMaker0.getFocusTraversalKeysEnabled());
      assertFalse(instanceStreamToBatchMaker0.getIgnoreRepaint());
      assertEquals("InstanceStreamToBatchMaker", instanceStreamToBatchMaker0.getCustomName());
      assertFalse(instanceStreamToBatchMaker0.isFocusCycleRoot());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicyProvider());
      
      BeanVisual beanVisual0 = instanceStreamToBatchMaker0.getVisual();
      assertNotNull(beanVisual0);
      assertFalse(instanceStreamToBatchMaker0.isBusy());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicySet());
      assertTrue(instanceStreamToBatchMaker0.getFocusTraversalKeysEnabled());
      assertFalse(instanceStreamToBatchMaker0.getIgnoreRepaint());
      assertEquals("InstanceStreamToBatchMaker", instanceStreamToBatchMaker0.getCustomName());
      assertFalse(instanceStreamToBatchMaker0.isFocusCycleRoot());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicyProvider());
      assertTrue(beanVisual0.getFocusTraversalKeysEnabled());
      assertEquals("weka/gui/beans/icons/InstanceStreamToBatchMaker_animated.gif", beanVisual0.getAnimatedIconPath());
      assertEquals("weka/gui/beans/icons/InstanceStreamToBatchMaker.gif", beanVisual0.getIconPath());
      assertFalse(beanVisual0.getIgnoreRepaint());
      assertFalse(beanVisual0.isFocusTraversalPolicySet());
      assertFalse(beanVisual0.isFocusTraversalPolicyProvider());
      assertFalse(beanVisual0.isFocusCycleRoot());
      assertEquals("InstanceStreamToBatchMaker", beanVisual0.getText());
      assertEquals(2, BeanVisual.EAST_CONNECTOR);
      assertEquals(3, BeanVisual.WEST_CONNECTOR);
      assertEquals(1, BeanVisual.SOUTH_CONNECTOR);
      assertEquals(0, BeanVisual.NORTH_CONNECTOR);
      
      AllJavadoc allJavadoc0 = null;
      try {
        allJavadoc0 = new AllJavadoc();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      
      Add add0 = new Add();
      assertNotNull(add0);
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      filter0.setFilter(add0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      assertEquals("Appender", appender0.getCustomName());
      
      IncrementalClassifierEvaluator incrementalClassifierEvaluator0 = new IncrementalClassifierEvaluator();
      assertNotNull(incrementalClassifierEvaluator0);
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicyProvider());
      assertFalse(incrementalClassifierEvaluator0.getOutputPerClassInfoRetrievalStats());
      assertFalse(incrementalClassifierEvaluator0.getIgnoreRepaint());
      assertEquals("For charting only, specify a sliding window size over which to compute performance stats. <= 0 means eval on whole stream", incrementalClassifierEvaluator0.chartingEvalWindowSizeTipText());
      assertEquals("IncrementalClassifierEvaluator", incrementalClassifierEvaluator0.getCustomName());
      assertEquals("Evaluate the performance of incrementally trained classifiers.", incrementalClassifierEvaluator0.globalInfo());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicySet());
      assertFalse(incrementalClassifierEvaluator0.isBusy());
      assertEquals("How often to report progress to the status bar.", incrementalClassifierEvaluator0.statusFrequencyTipText());
      assertEquals(0, incrementalClassifierEvaluator0.getChartingEvalWindowSize());
      assertFalse(incrementalClassifierEvaluator0.isFocusCycleRoot());
      assertEquals(100, incrementalClassifierEvaluator0.getStatusFrequency());
      assertEquals("Output per-class info retrieval stats. If set to true, predictions get stored so that stats such as AUC can be computed. Note: this consumes some memory.", incrementalClassifierEvaluator0.outputPerClassInfoRetrievalStatsTipText());
      assertTrue(incrementalClassifierEvaluator0.getFocusTraversalKeysEnabled());
      
      Appender appender1 = new Appender();
      assertFalse(appender1.equals((Object)appender0));
      assertNotNull(appender1);
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isBusy());
      
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      add0.setAttributeName("E,BoTM^O8");
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("E,BoTM^O8", add0.getAttributeName());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      
      Associator associator0 = new Associator();
      assertNotNull(associator0);
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      assertEquals("Apriori", associator0.getCustomName());
      assertTrue(associator0.getFocusTraversalKeysEnabled());
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertFalse(associator0.getIgnoreRepaint());
      assertFalse(associator0.isBusy());
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      assertFalse(associator0.isFocusCycleRoot());
      
      InstanceEvent instanceEvent0 = appender1.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      assertNotNull(trainTestSplitMaker0);
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertEquals(1, trainTestSplitMaker0.getSeed());
      
      Filter filter1 = new Filter();
      assertFalse(filter1.equals((Object)filter0));
      assertNotNull(filter1);
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertEquals("AllFilter", filter1.getCustomName());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertFalse(filter1.isBusy());
      assertFalse(filter1.getIgnoreRepaint());
      
      InputMethodListener[] inputMethodListenerArray0 = filter1.getInputMethodListeners();
      assertFalse(filter1.equals((Object)filter0));
      assertNotNull(inputMethodListenerArray0);
      assertNotSame(filter1, filter0);
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertEquals("AllFilter", filter1.getCustomName());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertFalse(filter1.isBusy());
      assertFalse(filter1.getIgnoreRepaint());
      
      AttributedCharacterIterator.Attribute attributedCharacterIterator_Attribute0 = AttributedCharacterIterator.Attribute.LANGUAGE;
      assertNotNull(attributedCharacterIterator_Attribute0);
      
      instanceEvent0.setStatus(2);
      assertFalse(appender1.equals((Object)appender0));
      assertNotSame(appender1, appender0);
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isBusy());
      assertEquals(2, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      filter0.removeTestSetListener(filter0);
      assertFalse(filter0.equals((Object)filter1));
      assertNotSame(filter0, filter1);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      
      Sorter.InstanceHolder sorter_InstanceHolder0 = new Sorter.InstanceHolder();
      assertNotNull(sorter_InstanceHolder0);
      
      double[] doubleArray0 = new double[10];
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(0);
      assertNotNull(binarySparseInstance0);
      assertEquals(0, binarySparseInstance0.numValues());
      assertEquals(0, binarySparseInstance0.numAttributes());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      instanceEvent0.setInstance(binarySparseInstance0);
      assertFalse(appender1.equals((Object)appender0));
      assertNotSame(appender1, appender0);
      assertEquals(0, binarySparseInstance0.numValues());
      assertEquals(0, binarySparseInstance0.numAttributes());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isBusy());
      assertEquals(2, instanceEvent0.getStatus());
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      Sorter.InstanceHolder sorter_InstanceHolder1 = new Sorter.InstanceHolder();
      assertFalse(sorter_InstanceHolder1.equals((Object)sorter_InstanceHolder0));
      assertNotNull(sorter_InstanceHolder1);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertEquals("", substringLabeler0.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      
      DataSetEvent dataSetEvent0 = new DataSetEvent(sorter_InstanceHolder0, (Instances) null);
      assertFalse(sorter_InstanceHolder0.equals((Object)sorter_InstanceHolder1));
      assertNotNull(dataSetEvent0);
      assertFalse(dataSetEvent0.isStructureOnly());
      
      AttributeSelection attributeSelection0 = new AttributeSelection();
      assertNotNull(attributeSelection0);
      assertEquals("Determines how attributes/attribute subsets are evaluated.", attributeSelection0.evaluatorTipText());
      assertFalse(attributeSelection0.isOutputFormatDefined());
      assertFalse(attributeSelection0.isFirstBatchDone());
      assertEquals("A supervised attribute filter that can be used to select attributes. It is very flexible and allows various search and evaluation methods to be combined.", attributeSelection0.globalInfo());
      assertTrue(attributeSelection0.isNewBatch());
      assertFalse(attributeSelection0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Determines the search method.", attributeSelection0.searchTipText());
      
      filter1.notifyInstanceListeners(instanceEvent0);
      assertFalse(appender1.equals((Object)appender0));
      assertFalse(filter1.equals((Object)filter0));
      assertNotSame(appender1, appender0);
      assertNotSame(filter1, filter0);
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isBusy());
      assertEquals(2, instanceEvent0.getStatus());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertEquals("AllFilter", filter1.getCustomName());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertFalse(filter1.isBusy());
      assertFalse(filter1.getIgnoreRepaint());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      FileSystemHandling fileSystemHandling1 = new FileSystemHandling();
      assertFalse(fileSystemHandling1.equals((Object)fileSystemHandling0));
      assertNotNull(fileSystemHandling1);
      
      Enumeration enumeration0 = filter0.enumerateRequests();
      assertFalse(filter0.equals((Object)filter1));
      assertNotNull(enumeration0);
      assertNotSame(filter0, filter1);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.equals((Object)filter1));
      assertFalse(appender1.equals((Object)appender0));
      assertNotSame(filter0, filter1);
      assertNotSame(appender1, appender0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isBusy());
      assertEquals(2, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      Appender appender2 = new Appender();
      assertFalse(appender2.equals((Object)appender0));
      assertFalse(appender2.equals((Object)appender1));
      assertNotNull(appender2);
      assertFalse(appender2.isFocusTraversalPolicyProvider());
      assertFalse(appender2.isBusy());
      assertFalse(appender2.isFocusCycleRoot());
      assertEquals("Appender", appender2.getCustomName());
      assertTrue(appender2.getFocusTraversalKeysEnabled());
      assertFalse(appender2.getIgnoreRepaint());
      assertFalse(appender2.isFocusTraversalPolicySet());
      
      StripChart stripChart0 = null;
      try {
        stripChart0 = new StripChart();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.gui.beans.StripChart", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      
      filter0.acceptTrainingSet((TrainingSetEvent) null);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      
      filter0.firePropertyChange("$", (short)218, (short) (-1042));
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      
      filter0.useDefaultVisual();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      
      CrossValidationFoldMaker crossValidationFoldMaker0 = new CrossValidationFoldMaker();
      assertNotNull(crossValidationFoldMaker0);
      assertFalse(crossValidationFoldMaker0.isBusy());
      assertEquals("CrossValidationFoldMaker", crossValidationFoldMaker0.getCustomName());
      assertEquals("The number of train and test splits to produce", crossValidationFoldMaker0.foldsTipText());
      assertEquals(1, crossValidationFoldMaker0.getSeed());
      assertEquals("Split an incoming data set into cross validation folds. Separate train and test sets are produced for each of the k folds.", crossValidationFoldMaker0.globalInfo());
      assertEquals("The randomization seed", crossValidationFoldMaker0.seedTipText());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicyProvider());
      assertFalse(crossValidationFoldMaker0.isFocusCycleRoot());
      assertTrue(crossValidationFoldMaker0.getFocusTraversalKeysEnabled());
      assertEquals(10, crossValidationFoldMaker0.getFolds());
      assertFalse(crossValidationFoldMaker0.getPreserveOrder());
      assertFalse(crossValidationFoldMaker0.getIgnoreRepaint());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicySet());
      
      byte[] byteArray0 = new byte[0];
      boolean boolean0 = FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      assertArrayEquals(new byte[] {}, byteArray0);
      assertFalse(boolean0);
      
      filter0.removeTestSetListener(crossValidationFoldMaker0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(crossValidationFoldMaker0.isBusy());
      assertEquals("CrossValidationFoldMaker", crossValidationFoldMaker0.getCustomName());
      assertEquals("The number of train and test splits to produce", crossValidationFoldMaker0.foldsTipText());
      assertEquals(1, crossValidationFoldMaker0.getSeed());
      assertEquals("Split an incoming data set into cross validation folds. Separate train and test sets are produced for each of the k folds.", crossValidationFoldMaker0.globalInfo());
      assertEquals("The randomization seed", crossValidationFoldMaker0.seedTipText());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicyProvider());
      assertFalse(crossValidationFoldMaker0.isFocusCycleRoot());
      assertTrue(crossValidationFoldMaker0.getFocusTraversalKeysEnabled());
      assertEquals(10, crossValidationFoldMaker0.getFolds());
      assertFalse(crossValidationFoldMaker0.getPreserveOrder());
      assertFalse(crossValidationFoldMaker0.getIgnoreRepaint());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicySet());
      
      filter0.addTestSetListener(crossValidationFoldMaker0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(crossValidationFoldMaker0.isBusy());
      assertEquals("CrossValidationFoldMaker", crossValidationFoldMaker0.getCustomName());
      assertEquals("The number of train and test splits to produce", crossValidationFoldMaker0.foldsTipText());
      assertEquals(1, crossValidationFoldMaker0.getSeed());
      assertEquals("Split an incoming data set into cross validation folds. Separate train and test sets are produced for each of the k folds.", crossValidationFoldMaker0.globalInfo());
      assertEquals("The randomization seed", crossValidationFoldMaker0.seedTipText());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicyProvider());
      assertFalse(crossValidationFoldMaker0.isFocusCycleRoot());
      assertTrue(crossValidationFoldMaker0.getFocusTraversalKeysEnabled());
      assertEquals(10, crossValidationFoldMaker0.getFolds());
      assertFalse(crossValidationFoldMaker0.getPreserveOrder());
      assertFalse(crossValidationFoldMaker0.getIgnoreRepaint());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicySet());
      
      filter0.acceptTrainingSet((TrainingSetEvent) null);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      
      Add add0 = new Add();
      assertNotNull(add0);
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      
      Capabilities capabilities0 = add0.getCapabilities();
      assertNotNull(capabilities0);
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals(0, capabilities0.getMinimumNumberInstances());
      assertFalse(capabilities0.hasDependencies());
      
      filter0.setFilter(add0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Add", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      
      FlowByExpression flowByExpression0 = new FlowByExpression();
      assertNotNull(flowByExpression0);
      assertFalse(flowByExpression0.getIgnoreRepaint());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertEquals("", flowByExpression0.getExpressionString());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertFalse(flowByExpression0.isBusy());
      
      int int0 = filter0.getX();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Add", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertEquals(0, int0);
      
      CrossValidationFoldMaker crossValidationFoldMaker0 = new CrossValidationFoldMaker();
      assertNotNull(crossValidationFoldMaker0);
      assertEquals("Split an incoming data set into cross validation folds. Separate train and test sets are produced for each of the k folds.", crossValidationFoldMaker0.globalInfo());
      assertEquals(1, crossValidationFoldMaker0.getSeed());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicyProvider());
      assertFalse(crossValidationFoldMaker0.isBusy());
      assertEquals("CrossValidationFoldMaker", crossValidationFoldMaker0.getCustomName());
      assertFalse(crossValidationFoldMaker0.getPreserveOrder());
      assertEquals("The number of train and test splits to produce", crossValidationFoldMaker0.foldsTipText());
      assertFalse(crossValidationFoldMaker0.getIgnoreRepaint());
      assertEquals(10, crossValidationFoldMaker0.getFolds());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicySet());
      assertFalse(crossValidationFoldMaker0.isFocusCycleRoot());
      assertEquals("The randomization seed", crossValidationFoldMaker0.seedTipText());
      assertTrue(crossValidationFoldMaker0.getFocusTraversalKeysEnabled());
      
      GlobalInfoJavadoc globalInfoJavadoc0 = new GlobalInfoJavadoc();
      assertNotNull(globalInfoJavadoc0);
      assertEquals("", globalInfoJavadoc0.getDir());
      assertTrue(globalInfoJavadoc0.getUseStars());
      assertFalse(globalInfoJavadoc0.getSilent());
      assertEquals("weka.core.Javadoc", globalInfoJavadoc0.getClassname());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      
      Instances instances0 = new Instances("<!-- globalinfo-end -->", arrayList0, 0);
      assertNotNull(instances0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numInstances());
      assertEquals("<!-- globalinfo-end -->", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      
      DataSetEvent dataSetEvent0 = new DataSetEvent(globalInfoJavadoc0, instances0);
      assertNotNull(dataSetEvent0);
      assertEquals("", globalInfoJavadoc0.getDir());
      assertTrue(globalInfoJavadoc0.getUseStars());
      assertFalse(globalInfoJavadoc0.getSilent());
      assertEquals("weka.core.Javadoc", globalInfoJavadoc0.getClassname());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numInstances());
      assertEquals("<!-- globalinfo-end -->", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertTrue(dataSetEvent0.isStructureOnly());
      
      AttributeSummarizer attributeSummarizer0 = new AttributeSummarizer();
      assertNotNull(attributeSummarizer0);
      assertFalse(attributeSummarizer0.isFocusTraversalPolicyProvider());
      assertEquals("Attribute summary", attributeSummarizer0.getPerspectiveTitle());
      assertEquals(4, attributeSummarizer0.getGridWidth());
      assertTrue(attributeSummarizer0.getFocusTraversalKeysEnabled());
      assertTrue(attributeSummarizer0.acceptsInstances());
      assertEquals(100, attributeSummarizer0.getMaxPlots());
      assertEquals("", attributeSummarizer0.getOffscreenAdditionalOpts());
      assertFalse(attributeSummarizer0.isFocusCycleRoot());
      assertEquals("", attributeSummarizer0.getOffscreenXAxis());
      assertEquals("Plot summary bar charts for incoming data/training/test sets.", attributeSummarizer0.globalInfo());
      assertFalse(attributeSummarizer0.isBusy());
      assertFalse(attributeSummarizer0.isFocusTraversalPolicySet());
      assertEquals("Weka Chart Renderer", attributeSummarizer0.getOffscreenRendererName());
      assertEquals("AttributeSummarizer", attributeSummarizer0.getCustomName());
      assertEquals("Matrix of attribute summary histograms", attributeSummarizer0.getPerspectiveTipText());
      assertEquals("500", attributeSummarizer0.getOffscreenWidth());
      assertEquals((-1), attributeSummarizer0.getColoringIndex());
      assertEquals("", attributeSummarizer0.getOffscreenYAxis());
      assertFalse(attributeSummarizer0.getIgnoreRepaint());
      assertEquals("400", attributeSummarizer0.getOffscreenHeight());
      
      filter0.addDataSourceListener(attributeSummarizer0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Add", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(attributeSummarizer0.isFocusTraversalPolicyProvider());
      assertEquals("Attribute summary", attributeSummarizer0.getPerspectiveTitle());
      assertEquals(4, attributeSummarizer0.getGridWidth());
      assertTrue(attributeSummarizer0.getFocusTraversalKeysEnabled());
      assertTrue(attributeSummarizer0.acceptsInstances());
      assertEquals(100, attributeSummarizer0.getMaxPlots());
      assertEquals("", attributeSummarizer0.getOffscreenAdditionalOpts());
      assertFalse(attributeSummarizer0.isFocusCycleRoot());
      assertEquals("", attributeSummarizer0.getOffscreenXAxis());
      assertEquals("Plot summary bar charts for incoming data/training/test sets.", attributeSummarizer0.globalInfo());
      assertFalse(attributeSummarizer0.isBusy());
      assertFalse(attributeSummarizer0.isFocusTraversalPolicySet());
      assertEquals("Weka Chart Renderer", attributeSummarizer0.getOffscreenRendererName());
      assertEquals("AttributeSummarizer", attributeSummarizer0.getCustomName());
      assertEquals("Matrix of attribute summary histograms", attributeSummarizer0.getPerspectiveTipText());
      assertEquals("500", attributeSummarizer0.getOffscreenWidth());
      assertEquals((-1), attributeSummarizer0.getColoringIndex());
      assertEquals("", attributeSummarizer0.getOffscreenYAxis());
      assertFalse(attributeSummarizer0.getIgnoreRepaint());
      assertEquals("400", attributeSummarizer0.getOffscreenHeight());
      
      ClassValuePicker classValuePicker0 = new ClassValuePicker();
      assertNotNull(classValuePicker0);
      assertFalse(classValuePicker0.isBusy());
      assertFalse(classValuePicker0.isFocusCycleRoot());
      assertFalse(classValuePicker0.isFocusTraversalPolicyProvider());
      assertEquals("Designate which class value is to be considered the \"positive\" class value (useful for ROC style curves).", classValuePicker0.globalInfo());
      assertFalse(classValuePicker0.getIgnoreRepaint());
      assertNull(classValuePicker0.getClassValue());
      assertFalse(classValuePicker0.isFocusTraversalPolicySet());
      assertEquals("ClassValuePicker", classValuePicker0.getCustomName());
      assertTrue(classValuePicker0.getFocusTraversalKeysEnabled());
      
      classValuePicker0.setFocusTraversalKeysEnabled(false);
      assertFalse(classValuePicker0.getFocusTraversalKeysEnabled());
      assertFalse(classValuePicker0.isBusy());
      assertFalse(classValuePicker0.isFocusCycleRoot());
      assertFalse(classValuePicker0.isFocusTraversalPolicyProvider());
      assertEquals("Designate which class value is to be considered the \"positive\" class value (useful for ROC style curves).", classValuePicker0.globalInfo());
      assertFalse(classValuePicker0.getIgnoreRepaint());
      assertNull(classValuePicker0.getClassValue());
      assertFalse(classValuePicker0.isFocusTraversalPolicySet());
      assertEquals("ClassValuePicker", classValuePicker0.getCustomName());
      
      Logger logger0 = classValuePicker0.m_logger;
      assertNull(logger0);
      
      DefaultCaret defaultCaret0 = new DefaultCaret();
      assertNotNull(defaultCaret0);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.width);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.y);
      
      DefaultCaret defaultCaret1 = new DefaultCaret();
      assertFalse(defaultCaret1.equals((Object)defaultCaret0));
      assertNotNull(defaultCaret1);
      assertTrue(defaultCaret1.isEmpty());
      assertEquals(0.0, defaultCaret1.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret1.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret1.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret1.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret1.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret1.getX(), 0.01);
      assertEquals(0.0, defaultCaret1.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret1.getY(), 0.01);
      assertEquals(0.0, defaultCaret1.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret1.getWidth(), 0.01);
      assertEquals(0, defaultCaret1.y);
      assertEquals(0, defaultCaret1.height);
      assertEquals(0, defaultCaret1.x);
      assertEquals(0, defaultCaret1.width);
      
      MockMinguoDate mockMinguoDate0 = new MockMinguoDate();
      assertNotNull(mockMinguoDate0);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      
      Instances instances1 = textDirectoryLoader0.getDataSet();
      assertTrue(instances1.equals((Object)instances0));
      assertNotNull(instances1);
      assertNotSame(instances1, instances0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals(0, instances1.numClasses());
      assertEquals(1, instances1.classIndex());
      assertTrue(instances1.checkForStringAttributes());
      assertEquals(0, instances1.size());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      assertEquals(0, instances1.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances1.relationName());
      
      textDirectoryLoader0.reset();
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      
      InstanceEvent instanceEvent0 = new InstanceEvent(mockMinguoDate0, instances1);
      assertTrue(instances1.equals((Object)instances0));
      assertNotNull(instanceEvent0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals(0, instances1.numClasses());
      assertEquals(1, instances1.classIndex());
      assertTrue(instances1.checkForStringAttributes());
      assertEquals(0, instances1.size());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      assertEquals(0, instances1.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances1.relationName());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      filter0.acceptInstance(instanceEvent0);
      assertTrue(instances1.equals((Object)instances0));
      assertNotSame(instances1, instances0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Add", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals(0, instances1.numClasses());
      assertEquals(1, instances1.classIndex());
      assertTrue(instances1.checkForStringAttributes());
      assertEquals(0, instances1.size());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      assertEquals(0, instances1.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances1.relationName());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      KeyListener[] keyListenerArray0 = filter0.getKeyListeners();
      assertNotNull(keyListenerArray0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Add", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      
      boolean boolean0 = filter0.isPaintingForPrint();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Add", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(boolean0);
      
      Add add1 = new Add();
      assertFalse(add1.equals((Object)add0));
      assertNotNull(add1);
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add1.getDateFormat());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add1.globalInfo());
      assertFalse(add1.isOutputFormatDefined());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add1.nominalLabelsTipText());
      assertEquals("Set the new attribute's name.", add1.attributeNameTipText());
      assertEquals("unnamed", add1.getAttributeName());
      assertFalse(add1.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Defines the type of the attribute to generate.", add1.attributeTypeTipText());
      assertTrue(add1.isNewBatch());
      assertEquals("last", add1.getAttributeIndex());
      assertFalse(add1.isFirstBatchDone());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add1.attributeIndexTipText());
      assertEquals("The format of the date values (see ISO-8601).", add1.dateFormatTipText());
      
      filter0.setLog((Logger) null);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Add", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      
      GraphViewer graphViewer0 = new GraphViewer();
      assertNotNull(graphViewer0);
      assertTrue(graphViewer0.getFocusTraversalKeysEnabled());
      assertFalse(graphViewer0.isFocusTraversalPolicySet());
      assertFalse(graphViewer0.isFocusCycleRoot());
      assertEquals("Graphically visualize trees or graphs produced by classifiers/clusterers.", graphViewer0.globalInfo());
      assertFalse(graphViewer0.isFocusTraversalPolicyProvider());
      assertFalse(graphViewer0.getIgnoreRepaint());
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(graphViewer0, instances0);
      assertTrue(instances0.equals((Object)instances1));
      assertNotNull(trainingSetEvent0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numInstances());
      assertEquals("<!-- globalinfo-end -->", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertTrue(graphViewer0.getFocusTraversalKeysEnabled());
      assertFalse(graphViewer0.isFocusTraversalPolicySet());
      assertFalse(graphViewer0.isFocusCycleRoot());
      assertEquals("Graphically visualize trees or graphs produced by classifiers/clusterers.", graphViewer0.globalInfo());
      assertFalse(graphViewer0.isFocusTraversalPolicyProvider());
      assertFalse(graphViewer0.getIgnoreRepaint());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertTrue(instances0.equals((Object)instances1));
      assertNotSame(instances0, instances1);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Add", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numInstances());
      assertEquals("<!-- globalinfo-end -->", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertTrue(graphViewer0.getFocusTraversalKeysEnabled());
      assertFalse(graphViewer0.isFocusTraversalPolicySet());
      assertFalse(graphViewer0.isFocusCycleRoot());
      assertEquals("Graphically visualize trees or graphs produced by classifiers/clusterers.", graphViewer0.globalInfo());
      assertFalse(graphViewer0.isFocusTraversalPolicyProvider());
      assertFalse(graphViewer0.getIgnoreRepaint());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      
      Associator associator0 = new Associator();
      assertNotNull(associator0);
      assertFalse(associator0.getIgnoreRepaint());
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      assertFalse(associator0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertTrue(associator0.getFocusTraversalKeysEnabled());
      assertFalse(associator0.isBusy());
      assertEquals("Apriori", associator0.getCustomName());
      
      associator0.grabFocus();
      assertFalse(associator0.getIgnoreRepaint());
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      assertFalse(associator0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertTrue(associator0.getFocusTraversalKeysEnabled());
      assertFalse(associator0.isBusy());
      assertEquals("Apriori", associator0.getCustomName());
      
      filter0.addDataSourceListener(associator0);
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(associator0.getIgnoreRepaint());
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      assertFalse(associator0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertTrue(associator0.getFocusTraversalKeysEnabled());
      assertFalse(associator0.isBusy());
      assertEquals("Apriori", associator0.getCustomName());
      
      filter0.useDefaultVisual();
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      
      int int0 = filter0.getHeight();
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals(0, int0);
      
      Filter filter1 = new Filter();
      assertFalse(filter1.equals((Object)filter0));
      assertNotNull(filter1);
      assertFalse(filter1.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isBusy());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter1.getCustomName());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      
      filter0.addInstanceListener(filter1);
      assertFalse(filter0.equals((Object)filter1));
      assertFalse(filter1.equals((Object)filter0));
      assertNotSame(filter0, filter1);
      assertNotSame(filter1, filter0);
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter1.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isBusy());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter1.getCustomName());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      
      InstanceEvent instanceEvent0 = substringLabeler0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      instanceEvent0.setStructure((Instances) null);
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      filter0.notifyInstanceListeners(instanceEvent0);
      assertFalse(filter0.equals((Object)filter1));
      assertNotSame(filter0, filter1);
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      
      filter0.useDefaultVisual();
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      
      Add add0 = new Add();
      assertNotNull(add0);
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("unnamed", add0.getAttributeName());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      
      filter0.setFilter(add0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("Add", filter0.getCustomName());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("unnamed", add0.getAttributeName());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      
      CoverTree coverTree0 = new CoverTree();
      assertNotNull(coverTree0);
      assertEquals("The distance function to use for finding neighbours (default: weka.core.EuclideanDistance). ", coverTree0.distanceFunctionTipText());
      assertEquals("Whether to calculate performance statistics for the NN search or not", coverTree0.measurePerformanceTipText());
      assertEquals(1.3, coverTree0.getBase(), 0.01);
      assertFalse(coverTree0.getMeasurePerformance());
      assertEquals("The base for the expansion constant.", coverTree0.baseTipText());
      assertEquals(0.0, coverTree0.measureMaxDepth(), 0.01);
      assertEquals(0.0, coverTree0.measureTreeSize(), 0.01);
      assertEquals(0.0, coverTree0.measureNumLeaves(), 0.01);
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      
      boolean boolean0 = filter0.eventGeneratable("W");
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(boolean0);
      
      BeanContextServicesSupport beanContextServicesSupport0 = new BeanContextServicesSupport();
      assertNotNull(beanContextServicesSupport0);
      assertTrue(beanContextServicesSupport0.isEmpty());
      assertEquals(0, beanContextServicesSupport0.size());
      assertFalse(beanContextServicesSupport0.isDelegated());
      assertFalse(beanContextServicesSupport0.isDesignTime());
      assertFalse(beanContextServicesSupport0.isSerializing());
      
      ScatterPlotMatrix scatterPlotMatrix0 = new ScatterPlotMatrix();
      assertNotNull(scatterPlotMatrix0);
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicyProvider());
      assertEquals("DataVisualizer", scatterPlotMatrix0.getCustomName());
      assertEquals("400", scatterPlotMatrix0.getOffscreenHeight());
      assertEquals("", scatterPlotMatrix0.getOffscreenXAxis());
      assertTrue(scatterPlotMatrix0.getFocusTraversalKeysEnabled());
      assertEquals("", scatterPlotMatrix0.getOffscreenAdditionalOpts());
      assertFalse(scatterPlotMatrix0.isFocusCycleRoot());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTitle());
      assertEquals("Weka Chart Renderer", scatterPlotMatrix0.getOffscreenRendererName());
      assertFalse(scatterPlotMatrix0.isBusy());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTipText());
      assertFalse(scatterPlotMatrix0.getIgnoreRepaint());
      assertEquals("", scatterPlotMatrix0.getOffscreenYAxis());
      assertEquals("Visualize incoming data/training/test sets in a scatter plot matrix.", scatterPlotMatrix0.globalInfo());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicySet());
      assertEquals("500", scatterPlotMatrix0.getOffscreenWidth());
      assertTrue(scatterPlotMatrix0.acceptsInstances());
      
      filter0.addTrainingSetListener(scatterPlotMatrix0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicyProvider());
      assertEquals("DataVisualizer", scatterPlotMatrix0.getCustomName());
      assertEquals("400", scatterPlotMatrix0.getOffscreenHeight());
      assertEquals("", scatterPlotMatrix0.getOffscreenXAxis());
      assertTrue(scatterPlotMatrix0.getFocusTraversalKeysEnabled());
      assertEquals("", scatterPlotMatrix0.getOffscreenAdditionalOpts());
      assertFalse(scatterPlotMatrix0.isFocusCycleRoot());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTitle());
      assertEquals("Weka Chart Renderer", scatterPlotMatrix0.getOffscreenRendererName());
      assertFalse(scatterPlotMatrix0.isBusy());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTipText());
      assertFalse(scatterPlotMatrix0.getIgnoreRepaint());
      assertEquals("", scatterPlotMatrix0.getOffscreenYAxis());
      assertEquals("Visualize incoming data/training/test sets in a scatter plot matrix.", scatterPlotMatrix0.globalInfo());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicySet());
      assertEquals("500", scatterPlotMatrix0.getOffscreenWidth());
      assertTrue(scatterPlotMatrix0.acceptsInstances());
      
      DefaultCaret defaultCaret0 = new DefaultCaret();
      assertNotNull(defaultCaret0);
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0, defaultCaret0.width);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.y);
      
      DefaultCaret defaultCaret1 = new DefaultCaret();
      assertFalse(defaultCaret1.equals((Object)defaultCaret0));
      assertNotNull(defaultCaret1);
      assertEquals(0.0, defaultCaret1.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret1.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret1.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret1.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret1.getY(), 0.01);
      assertEquals(0.0, defaultCaret1.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret1.getX(), 0.01);
      assertEquals(0.0, defaultCaret1.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret1.getCenterY(), 0.01);
      assertTrue(defaultCaret1.isEmpty());
      assertEquals(0.0, defaultCaret1.getWidth(), 0.01);
      assertEquals(0, defaultCaret1.y);
      assertEquals(0, defaultCaret1.width);
      assertEquals(0, defaultCaret1.x);
      assertEquals(0, defaultCaret1.height);
      
      LinearNNSearch linearNNSearch0 = new LinearNNSearch();
      assertNotNull(linearNNSearch0);
      assertEquals("Whether to calculate performance statistics for the NN search or not", linearNNSearch0.measurePerformanceTipText());
      assertEquals("Whether to skip identical instances (with distance 0 to the target)", linearNNSearch0.skipIdenticalTipText());
      assertFalse(linearNNSearch0.getMeasurePerformance());
      assertEquals("The distance function to use for finding neighbours (default: weka.core.EuclideanDistance). ", linearNNSearch0.distanceFunctionTipText());
      assertEquals("Class implementing the brute force search algorithm for nearest neighbour search.", linearNNSearch0.globalInfo());
      assertFalse(linearNNSearch0.getSkipIdentical());
      
      MockMinguoDate mockMinguoDate0 = new MockMinguoDate();
      assertNotNull(mockMinguoDate0);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      
      InstanceEvent instanceEvent0 = new InstanceEvent(beanContextServicesSupport0, instances0);
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertTrue(beanContextServicesSupport0.isEmpty());
      assertEquals(0, beanContextServicesSupport0.size());
      assertFalse(beanContextServicesSupport0.isDelegated());
      assertFalse(beanContextServicesSupport0.isDesignTime());
      assertFalse(beanContextServicesSupport0.isSerializing());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("Add", filter0.getCustomName());
      assertTrue(beanContextServicesSupport0.isEmpty());
      assertEquals(0, beanContextServicesSupport0.size());
      assertFalse(beanContextServicesSupport0.isDelegated());
      assertFalse(beanContextServicesSupport0.isDesignTime());
      assertFalse(beanContextServicesSupport0.isSerializing());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      boolean boolean1 = filter0.isPaintingForPrint();
      assertTrue(boolean1 == boolean0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(boolean1);
      
      boolean boolean2 = filter0.connectionAllowed("@data");
      assertFalse(boolean2 == boolean0);
      assertFalse(boolean2 == boolean1);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("Add", filter0.getCustomName());
      assertTrue(boolean2);
      
      filter0.removeTestSetListener(appender0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      
      CoverTree coverTree0 = new CoverTree();
      assertNotNull(coverTree0);
      assertEquals(0.0, coverTree0.measureMaxDepth(), 0.01);
      assertEquals(0.0, coverTree0.measureTreeSize(), 0.01);
      assertEquals(0.0, coverTree0.measureNumLeaves(), 0.01);
      assertEquals("The base for the expansion constant.", coverTree0.baseTipText());
      assertEquals("Whether to calculate performance statistics for the NN search or not", coverTree0.measurePerformanceTipText());
      assertEquals(1.3, coverTree0.getBase(), 0.01);
      assertEquals("The distance function to use for finding neighbours (default: weka.core.EuclideanDistance). ", coverTree0.distanceFunctionTipText());
      assertFalse(coverTree0.getMeasurePerformance());
      
      boolean boolean0 = FileSystemHandling.createFolder((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      MenuSelectionManager menuSelectionManager0 = MenuSelectionManager.defaultManager();
      assertNotNull(menuSelectionManager0);
      
      filter0.connectionNotification("dataSet", appender0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      
      Appender appender1 = new Appender();
      assertFalse(appender1.equals((Object)appender0));
      assertNotNull(appender1);
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isBusy());
      
      CheckGOE checkGOE0 = new CheckGOE();
      assertNotNull(checkGOE0);
      assertFalse(checkGOE0.getSuccess());
      assertFalse(checkGOE0.getDebug());
      assertFalse(checkGOE0.getSilent());
      
      AttributeSummarizer attributeSummarizer0 = new AttributeSummarizer();
      assertNotNull(attributeSummarizer0);
      assertEquals("AttributeSummarizer", attributeSummarizer0.getCustomName());
      assertFalse(attributeSummarizer0.getIgnoreRepaint());
      assertEquals("Plot summary bar charts for incoming data/training/test sets.", attributeSummarizer0.globalInfo());
      assertEquals("500", attributeSummarizer0.getOffscreenWidth());
      assertTrue(attributeSummarizer0.getFocusTraversalKeysEnabled());
      assertFalse(attributeSummarizer0.isBusy());
      assertFalse(attributeSummarizer0.isFocusTraversalPolicySet());
      assertEquals("", attributeSummarizer0.getOffscreenAdditionalOpts());
      assertFalse(attributeSummarizer0.isFocusCycleRoot());
      assertEquals("Matrix of attribute summary histograms", attributeSummarizer0.getPerspectiveTipText());
      assertEquals("", attributeSummarizer0.getOffscreenXAxis());
      assertFalse(attributeSummarizer0.isFocusTraversalPolicyProvider());
      assertTrue(attributeSummarizer0.acceptsInstances());
      assertEquals("400", attributeSummarizer0.getOffscreenHeight());
      assertEquals(100, attributeSummarizer0.getMaxPlots());
      assertEquals(4, attributeSummarizer0.getGridWidth());
      assertEquals("Attribute summary", attributeSummarizer0.getPerspectiveTitle());
      assertEquals((-1), attributeSummarizer0.getColoringIndex());
      assertEquals("Weka Chart Renderer", attributeSummarizer0.getOffscreenRendererName());
      assertEquals("", attributeSummarizer0.getOffscreenYAxis());
      
      boolean boolean1 = filter0.connectionAllowed("seeming");
      assertFalse(boolean1 == boolean0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(boolean1);
      
      AllFilter allFilter0 = (AllFilter)filter0.getWrappedAlgorithm();
      assertNotNull(allFilter0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("An instance filter that passes all instances through unmodified. Primarily for testing purposes.", allFilter0.globalInfo());
      assertFalse(allFilter0.isFirstBatchDone());
      assertFalse(allFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(allFilter0.isNewBatch());
      assertFalse(allFilter0.isOutputFormatDefined());
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      
      filter0.useDefaultVisual();
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      
      Add add0 = new Add();
      assertNotNull(add0);
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertFalse(add0.isOutputFormatDefined());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      
      filter0.setFilter(add0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", filter0.getCustomName());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertFalse(add0.isOutputFormatDefined());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      instanceEvent0.setStatus(1);
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      BeanContextServicesSupport beanContextServicesSupport0 = new BeanContextServicesSupport();
      assertNotNull(beanContextServicesSupport0);
      assertEquals(0, beanContextServicesSupport0.size());
      assertFalse(beanContextServicesSupport0.isDesignTime());
      assertFalse(beanContextServicesSupport0.isDelegated());
      assertFalse(beanContextServicesSupport0.isSerializing());
      assertTrue(beanContextServicesSupport0.isEmpty());
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(1, instances0.classIndex());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numClasses());
      
      FlowByExpression flowByExpression0 = new FlowByExpression();
      assertNotNull(flowByExpression0);
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertFalse(flowByExpression0.isBusy());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertEquals("", flowByExpression0.getExpressionString());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      
      InstanceEvent instanceEvent1 = new InstanceEvent(instances0, instances0);
      assertFalse(instanceEvent1.equals((Object)instanceEvent0));
      assertNotNull(instanceEvent1);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(1, instances0.classIndex());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(0, instanceEvent1.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      filter0.acceptInstance(instanceEvent1);
      assertFalse(instanceEvent1.equals((Object)instanceEvent0));
      assertNotSame(instanceEvent1, instanceEvent0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(1, instances0.classIndex());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(0, instanceEvent1.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      KeyListener[] keyListenerArray0 = filter0.getKeyListeners();
      assertNotNull(keyListenerArray0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", filter0.getCustomName());
      
      HierarchyBoundsListener[] hierarchyBoundsListenerArray0 = appender0.getHierarchyBoundsListeners();
      assertNotNull(hierarchyBoundsListenerArray0);
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      
      instances0.deleteStringAttributes();
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0, instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.numAttributes());
      
      boolean boolean0 = filter0.isPaintingForPrint();
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(boolean0);
      
      boolean boolean1 = filter0.connectionAllowed("@relation");
      assertFalse(boolean1 == boolean0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", filter0.getCustomName());
      assertTrue(boolean1);
      
      Sorter sorter0 = new Sorter();
      assertNotNull(sorter0);
      assertEquals("Sorter", sorter0.getCustomName());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isBusy());
      assertEquals("10000", sorter0.getBufferSize());
      assertNull(sorter0.getSortDetails());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isFocusCycleRoot());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.getIgnoreRepaint());
      
      Clusterer clusterer0 = new Clusterer();
      assertNotNull(clusterer0);
      assertFalse(clusterer0.isBusy());
      assertFalse(clusterer0.isFocusTraversalPolicyProvider());
      assertFalse(clusterer0.isFocusTraversalPolicySet());
      assertFalse(clusterer0.getIgnoreRepaint());
      assertFalse(clusterer0.isFocusCycleRoot());
      assertTrue(clusterer0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Simple EM (expectation maximisation) class.\n\nEM assigns a probability distribution to each instance which indicates the probability of it belonging to each of the clusters</font><br><br> EM can decide how many clusters to create by cross validation, or you may specify apriori how many clusters to generate.<br><br>The cross validation performed to determine the number of clusters is done in the following steps:<br>1. the number of clusters is set to 1<br>2. the training set is split randomly into 10 folds.<br>3. EM is performed 10 times using the 10 folds the usual CV way.<br>4. the loglikelihood is averaged over all 10 results.<br>5.<br>if loglikelihood has increased the number of clusters is increased by 1 and the program continues at step 2.<br><br><br>The number of folds is fixed to 10, as long as the number of instances in the training set is not smaller 10.<br>If this is the case the number of folds is set equal to the number of instances.<br></html>", clusterer0.globalInfo());
      assertEquals("EM", clusterer0.getCustomName());
      assertFalse(clusterer0.hasIncomingBatchInstances());
      
      AttributeSelection attributeSelection0 = new AttributeSelection();
      assertNotNull(attributeSelection0);
      assertEquals("Determines how attributes/attribute subsets are evaluated.", attributeSelection0.evaluatorTipText());
      assertTrue(attributeSelection0.isNewBatch());
      assertFalse(attributeSelection0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Determines the search method.", attributeSelection0.searchTipText());
      assertEquals("A supervised attribute filter that can be used to select attributes. It is very flexible and allows various search and evaluation methods to be combined.", attributeSelection0.globalInfo());
      assertFalse(attributeSelection0.isOutputFormatDefined());
      assertFalse(attributeSelection0.isFirstBatchDone());
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      SubstringLabeler substringLabeler1 = new SubstringLabeler();
      assertFalse(substringLabeler1.equals((Object)substringLabeler0));
      assertNotNull(substringLabeler1);
      assertTrue(substringLabeler1.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler1.getNominalBinary());
      assertFalse(substringLabeler1.getConsumeNonMatching());
      assertEquals("", substringLabeler1.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler1.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler1.globalInfo());
      assertFalse(substringLabeler1.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler1.getMatchAttributeName());
      assertFalse(substringLabeler1.isFocusTraversalPolicySet());
      assertFalse(substringLabeler1.getIgnoreRepaint());
      assertFalse(substringLabeler1.isFocusCycleRoot());
      assertFalse(substringLabeler1.isBusy());
      
      filter0.notifyInstanceListeners(instanceEvent0);
      assertFalse(instanceEvent0.equals((Object)instanceEvent1));
      assertNotSame(instanceEvent0, instanceEvent1);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      Appender appender1 = new Appender();
      assertFalse(appender1.equals((Object)appender0));
      assertNotNull(appender1);
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isBusy());
      assertEquals("Appender", appender1.getCustomName());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicySet());
      
      ScatterPlotMatrix scatterPlotMatrix0 = new ScatterPlotMatrix();
      assertNotNull(scatterPlotMatrix0);
      assertEquals("", scatterPlotMatrix0.getOffscreenXAxis());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicyProvider());
      assertEquals("400", scatterPlotMatrix0.getOffscreenHeight());
      assertTrue(scatterPlotMatrix0.acceptsInstances());
      assertEquals("Visualize incoming data/training/test sets in a scatter plot matrix.", scatterPlotMatrix0.globalInfo());
      assertEquals("Weka Chart Renderer", scatterPlotMatrix0.getOffscreenRendererName());
      assertEquals("DataVisualizer", scatterPlotMatrix0.getCustomName());
      assertTrue(scatterPlotMatrix0.getFocusTraversalKeysEnabled());
      assertFalse(scatterPlotMatrix0.isFocusCycleRoot());
      assertEquals("", scatterPlotMatrix0.getOffscreenAdditionalOpts());
      assertEquals("", scatterPlotMatrix0.getOffscreenYAxis());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicySet());
      assertFalse(scatterPlotMatrix0.isBusy());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTitle());
      assertEquals("500", scatterPlotMatrix0.getOffscreenWidth());
      assertFalse(scatterPlotMatrix0.getIgnoreRepaint());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTipText());
      
      filter0.addTestSetListener(scatterPlotMatrix0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", filter0.getCustomName());
      assertEquals("", scatterPlotMatrix0.getOffscreenXAxis());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicyProvider());
      assertEquals("400", scatterPlotMatrix0.getOffscreenHeight());
      assertTrue(scatterPlotMatrix0.acceptsInstances());
      assertEquals("Visualize incoming data/training/test sets in a scatter plot matrix.", scatterPlotMatrix0.globalInfo());
      assertEquals("Weka Chart Renderer", scatterPlotMatrix0.getOffscreenRendererName());
      assertEquals("DataVisualizer", scatterPlotMatrix0.getCustomName());
      assertTrue(scatterPlotMatrix0.getFocusTraversalKeysEnabled());
      assertFalse(scatterPlotMatrix0.isFocusCycleRoot());
      assertEquals("", scatterPlotMatrix0.getOffscreenAdditionalOpts());
      assertEquals("", scatterPlotMatrix0.getOffscreenYAxis());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicySet());
      assertFalse(scatterPlotMatrix0.isBusy());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTitle());
      assertEquals("500", scatterPlotMatrix0.getOffscreenWidth());
      assertFalse(scatterPlotMatrix0.getIgnoreRepaint());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTipText());
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(appender0.equals((Object)appender1));
      assertFalse(instanceEvent0.equals((Object)instanceEvent1));
      assertNotSame(appender0, appender1);
      assertNotSame(instanceEvent0, instanceEvent1);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      
      IncrementalClassifierEvaluator incrementalClassifierEvaluator0 = new IncrementalClassifierEvaluator();
      assertNotNull(incrementalClassifierEvaluator0);
      assertFalse(incrementalClassifierEvaluator0.isBusy());
      assertTrue(incrementalClassifierEvaluator0.getFocusTraversalKeysEnabled());
      assertEquals("Evaluate the performance of incrementally trained classifiers.", incrementalClassifierEvaluator0.globalInfo());
      assertFalse(incrementalClassifierEvaluator0.getIgnoreRepaint());
      assertEquals("How often to report progress to the status bar.", incrementalClassifierEvaluator0.statusFrequencyTipText());
      assertEquals(100, incrementalClassifierEvaluator0.getStatusFrequency());
      assertEquals("Output per-class info retrieval stats. If set to true, predictions get stored so that stats such as AUC can be computed. Note: this consumes some memory.", incrementalClassifierEvaluator0.outputPerClassInfoRetrievalStatsTipText());
      assertFalse(incrementalClassifierEvaluator0.isFocusCycleRoot());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicySet());
      assertEquals(0, incrementalClassifierEvaluator0.getChartingEvalWindowSize());
      assertFalse(incrementalClassifierEvaluator0.getOutputPerClassInfoRetrievalStats());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals("For charting only, specify a sliding window size over which to compute performance stats. <= 0 means eval on whole stream", incrementalClassifierEvaluator0.chartingEvalWindowSizeTipText());
      assertEquals("IncrementalClassifierEvaluator", incrementalClassifierEvaluator0.getCustomName());
      
      PredictionAppender predictionAppender0 = new PredictionAppender();
      assertNotNull(predictionAppender0);
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      assertFalse(predictionAppender0.isFocusCycleRoot());
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertFalse(predictionAppender0.isBusy());
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.getIgnoreRepaint());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      
      int int0 = appender0.getDebugGraphicsOptions();
      assertFalse(appender0.getIgnoreRepaint());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertEquals(0, int0);
      
      CoverTree coverTree0 = new CoverTree();
      assertNotNull(coverTree0);
      assertEquals("The distance function to use for finding neighbours (default: weka.core.EuclideanDistance). ", coverTree0.distanceFunctionTipText());
      assertEquals("The base for the expansion constant.", coverTree0.baseTipText());
      assertEquals(0.0, coverTree0.measureMaxDepth(), 0.01);
      assertEquals(0.0, coverTree0.measureTreeSize(), 0.01);
      assertEquals(0.0, coverTree0.measureNumLeaves(), 0.01);
      assertEquals("Whether to calculate performance statistics for the NN search or not", coverTree0.measurePerformanceTipText());
      assertEquals(1.3, coverTree0.getBase(), 0.01);
      assertFalse(coverTree0.getMeasurePerformance());
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertEquals("", substringLabeler0.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      
      FlowByExpression flowByExpression0 = new FlowByExpression();
      assertNotNull(flowByExpression0);
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertFalse(flowByExpression0.isBusy());
      assertEquals("", flowByExpression0.getExpressionString());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numClasses());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      
      TechnicalInformationHandlerJavadoc technicalInformationHandlerJavadoc0 = new TechnicalInformationHandlerJavadoc();
      assertNotNull(technicalInformationHandlerJavadoc0);
      assertFalse(technicalInformationHandlerJavadoc0.getSilent());
      assertEquals("weka.core.Javadoc", technicalInformationHandlerJavadoc0.getClassname());
      assertTrue(technicalInformationHandlerJavadoc0.getProlog());
      assertEquals("", technicalInformationHandlerJavadoc0.getDir());
      assertTrue(technicalInformationHandlerJavadoc0.getUseStars());
      
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/mnt/gaiagpfs/users/homedirs/apanichella/Evosuite_performance/Dataset/gordon_script_sum/projects/9_weka");
      boolean boolean0 = FileSystemHandling.appendLineToFile(evoSuiteFile0, "^=rG&;{$=v/");
      assertFalse(boolean0);
      
      Appender appender1 = new Appender();
      assertFalse(appender1.equals((Object)appender0));
      assertNotNull(appender1);
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusCycleRoot());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      
      ClassAssigner classAssigner0 = new ClassAssigner();
      assertNotNull(classAssigner0);
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertFalse(classAssigner0.isBusy());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertEquals("last", classAssigner0.getClassColumn());
      
      GraphicsConfiguration graphicsConfiguration0 = filter0.getGraphicsConfiguration();
      assertNull(graphicsConfiguration0);
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      
      System.setCurrentTimeMillis(0);
      filter0.setCustomName("testSet");
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("testSet", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      
      boolean boolean1 = filter0.connectionAllowed(".arff");
      assertFalse(boolean1 == boolean0);
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("testSet", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertTrue(boolean1);
      
      AllFilter allFilter0 = (AllFilter)filter0.getWrappedAlgorithm();
      assertNotNull(allFilter0);
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("testSet", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(allFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(allFilter0.isNewBatch());
      assertEquals("An instance filter that passes all instances through unmodified. Primarily for testing purposes.", allFilter0.globalInfo());
      assertFalse(allFilter0.isOutputFormatDefined());
      assertFalse(allFilter0.isFirstBatchDone());
      
      StratifiedRemoveFolds stratifiedRemoveFolds0 = new StratifiedRemoveFolds();
      assertNotNull(stratifiedRemoveFolds0);
      assertFalse(stratifiedRemoveFolds0.isFirstBatchDone());
      assertEquals(1, stratifiedRemoveFolds0.getFold());
      assertEquals("The fold which is selected.", stratifiedRemoveFolds0.foldTipText());
      assertFalse(stratifiedRemoveFolds0.getInvertSelection());
      assertEquals(10, stratifiedRemoveFolds0.getNumFolds());
      assertFalse(stratifiedRemoveFolds0.isOutputFormatDefined());
      assertEquals("The number of folds to split the dataset into.", stratifiedRemoveFolds0.numFoldsTipText());
      assertEquals("the random number seed for shuffling the dataset. If seed is negative, shuffling will not be performed.", stratifiedRemoveFolds0.seedTipText());
      assertEquals(0L, stratifiedRemoveFolds0.getSeed());
      assertEquals("Whether to invert the selection.", stratifiedRemoveFolds0.invertSelectionTipText());
      assertEquals("This filter takes a dataset and outputs a specified fold for cross validation. If you do not want the folds to be stratified use the unsupervised version.", stratifiedRemoveFolds0.globalInfo());
      assertTrue(stratifiedRemoveFolds0.isNewBatch());
      assertFalse(stratifiedRemoveFolds0.mayRemoveInstanceAfterFirstBatchDone());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      filter0.connectionNotification("istical", evoSuiteFile0);
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("testSet", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      
      SubstringLabeler substringLabeler1 = new SubstringLabeler();
      assertFalse(substringLabeler1.equals((Object)substringLabeler0));
      assertNotNull(substringLabeler1);
      assertFalse(substringLabeler1.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler1.getMatchAttributeName());
      assertFalse(substringLabeler1.isFocusTraversalPolicySet());
      assertFalse(substringLabeler1.getIgnoreRepaint());
      assertFalse(substringLabeler1.isBusy());
      assertFalse(substringLabeler1.isFocusCycleRoot());
      assertTrue(substringLabeler1.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler1.getNominalBinary());
      assertFalse(substringLabeler1.getConsumeNonMatching());
      assertEquals("", substringLabeler1.getMatchDetails());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler1.globalInfo());
      assertEquals("SubstringLabeler", substringLabeler1.getCustomName());
      
      InstanceEvent instanceEvent0 = substringLabeler0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      filter0.notifyInstanceListeners(instanceEvent0);
      assertFalse(substringLabeler0.equals((Object)substringLabeler1));
      assertNotSame(substringLabeler0, substringLabeler1);
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("testSet", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      boolean boolean2 = filter0.eventGeneratable("<!-- technical-plaintext-end -->");
      assertFalse(boolean2 == boolean1);
      assertTrue(boolean2 == boolean0);
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("testSet", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(boolean2);
      
      filter0.addTrainingSetListener(flowByExpression0);
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("testSet", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertFalse(flowByExpression0.isBusy());
      assertEquals("", flowByExpression0.getExpressionString());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      
      SerializedModelSaver serializedModelSaver0 = new SerializedModelSaver();
      assertNotNull(serializedModelSaver0);
      assertEquals("SerializedModelSaver", serializedModelSaver0.getCustomName());
      assertFalse(serializedModelSaver0.isFocusTraversalPolicyProvider());
      assertFalse(serializedModelSaver0.getIncludeRelationName());
      assertFalse(serializedModelSaver0.getUseRelativePath());
      assertFalse(serializedModelSaver0.isFocusCycleRoot());
      assertEquals("Save trained models to serialized object files.", serializedModelSaver0.globalInfo());
      assertFalse(serializedModelSaver0.isBusy());
      assertTrue(serializedModelSaver0.getFocusTraversalKeysEnabled());
      assertEquals("", serializedModelSaver0.getPrefix());
      assertFalse(serializedModelSaver0.getIgnoreRepaint());
      assertFalse(serializedModelSaver0.isFocusTraversalPolicySet());
      assertEquals(2, SerializedModelSaver.XSTREAM);
      assertEquals(1, SerializedModelSaver.KOMLV);
      assertEquals(0, SerializedModelSaver.BINARY);
      
      SerializedModelSaver serializedModelSaver1 = new SerializedModelSaver();
      assertFalse(serializedModelSaver1.equals((Object)serializedModelSaver0));
      assertNotNull(serializedModelSaver1);
      assertFalse(serializedModelSaver1.getIgnoreRepaint());
      assertEquals("Save trained models to serialized object files.", serializedModelSaver1.globalInfo());
      assertFalse(serializedModelSaver1.isFocusTraversalPolicyProvider());
      assertFalse(serializedModelSaver1.isFocusCycleRoot());
      assertFalse(serializedModelSaver1.getIncludeRelationName());
      assertFalse(serializedModelSaver1.getUseRelativePath());
      assertFalse(serializedModelSaver1.isBusy());
      assertFalse(serializedModelSaver1.isFocusTraversalPolicySet());
      assertEquals("", serializedModelSaver1.getPrefix());
      assertTrue(serializedModelSaver1.getFocusTraversalKeysEnabled());
      assertEquals("SerializedModelSaver", serializedModelSaver1.getCustomName());
      assertEquals(2, SerializedModelSaver.XSTREAM);
      assertEquals(1, SerializedModelSaver.KOMLV);
      assertEquals(0, SerializedModelSaver.BINARY);
      
      Logger logger0 = serializedModelSaver0.m_logger;
      assertNull(logger0);
      
      filter0.setLog((Logger) null);
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("testSet", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      
      StratifiedRemoveFolds stratifiedRemoveFolds1 = new StratifiedRemoveFolds();
      assertFalse(stratifiedRemoveFolds1.equals((Object)stratifiedRemoveFolds0));
      assertNotNull(stratifiedRemoveFolds1);
      assertFalse(stratifiedRemoveFolds1.getInvertSelection());
      assertEquals(0L, stratifiedRemoveFolds1.getSeed());
      assertFalse(stratifiedRemoveFolds1.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals(10, stratifiedRemoveFolds1.getNumFolds());
      assertEquals("The number of folds to split the dataset into.", stratifiedRemoveFolds1.numFoldsTipText());
      assertFalse(stratifiedRemoveFolds1.isOutputFormatDefined());
      assertFalse(stratifiedRemoveFolds1.isFirstBatchDone());
      assertEquals("the random number seed for shuffling the dataset. If seed is negative, shuffling will not be performed.", stratifiedRemoveFolds1.seedTipText());
      assertTrue(stratifiedRemoveFolds1.isNewBatch());
      assertEquals("The fold which is selected.", stratifiedRemoveFolds1.foldTipText());
      assertEquals("Whether to invert the selection.", stratifiedRemoveFolds1.invertSelectionTipText());
      assertEquals(1, stratifiedRemoveFolds1.getFold());
      assertEquals("This filter takes a dataset and outputs a specified fold for cross validation. If you do not want the folds to be stratified use the unsupervised version.", stratifiedRemoveFolds1.globalInfo());
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(stratifiedRemoveFolds1, instances0, (-18), 1, 17, 214);
      assertFalse(stratifiedRemoveFolds1.equals((Object)stratifiedRemoveFolds0));
      assertNotNull(trainingSetEvent0);
      assertFalse(stratifiedRemoveFolds1.getInvertSelection());
      assertEquals(0L, stratifiedRemoveFolds1.getSeed());
      assertFalse(stratifiedRemoveFolds1.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals(10, stratifiedRemoveFolds1.getNumFolds());
      assertEquals("The number of folds to split the dataset into.", stratifiedRemoveFolds1.numFoldsTipText());
      assertFalse(stratifiedRemoveFolds1.isOutputFormatDefined());
      assertFalse(stratifiedRemoveFolds1.isFirstBatchDone());
      assertEquals("the random number seed for shuffling the dataset. If seed is negative, shuffling will not be performed.", stratifiedRemoveFolds1.seedTipText());
      assertTrue(stratifiedRemoveFolds1.isNewBatch());
      assertEquals("The fold which is selected.", stratifiedRemoveFolds1.foldTipText());
      assertEquals("Whether to invert the selection.", stratifiedRemoveFolds1.invertSelectionTipText());
      assertEquals(1, stratifiedRemoveFolds1.getFold());
      assertEquals("This filter takes a dataset and outputs a specified fold for cross validation. If you do not want the folds to be stratified use the unsupervised version.", stratifiedRemoveFolds1.globalInfo());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals(214, trainingSetEvent0.getMaxSetNumber());
      assertEquals((-18), trainingSetEvent0.getRunNumber());
      assertEquals(17, trainingSetEvent0.getSetNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numClasses());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertFalse(stratifiedRemoveFolds1.equals((Object)stratifiedRemoveFolds0));
      assertNotSame(stratifiedRemoveFolds1, stratifiedRemoveFolds0);
      assertFalse(stratifiedRemoveFolds1.getInvertSelection());
      assertEquals(0L, stratifiedRemoveFolds1.getSeed());
      assertFalse(stratifiedRemoveFolds1.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals(10, stratifiedRemoveFolds1.getNumFolds());
      assertEquals("The number of folds to split the dataset into.", stratifiedRemoveFolds1.numFoldsTipText());
      assertFalse(stratifiedRemoveFolds1.isOutputFormatDefined());
      assertFalse(stratifiedRemoveFolds1.isFirstBatchDone());
      assertEquals("the random number seed for shuffling the dataset. If seed is negative, shuffling will not be performed.", stratifiedRemoveFolds1.seedTipText());
      assertTrue(stratifiedRemoveFolds1.isNewBatch());
      assertEquals("The fold which is selected.", stratifiedRemoveFolds1.foldTipText());
      assertEquals("Whether to invert the selection.", stratifiedRemoveFolds1.invertSelectionTipText());
      assertEquals(1, stratifiedRemoveFolds1.getFold());
      assertEquals("This filter takes a dataset and outputs a specified fold for cross validation. If you do not want the folds to be stratified use the unsupervised version.", stratifiedRemoveFolds1.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("testSet", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals(214, trainingSetEvent0.getMaxSetNumber());
      assertEquals((-18), trainingSetEvent0.getRunNumber());
      assertEquals(17, trainingSetEvent0.getSetNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numClasses());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      
      Add add0 = new Add();
      assertNotNull(add0);
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      
      filter0.setFilter(add0);
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      
      IncrementalClassifierEvaluator incrementalClassifierEvaluator0 = new IncrementalClassifierEvaluator();
      assertNotNull(incrementalClassifierEvaluator0);
      assertEquals(100, incrementalClassifierEvaluator0.getStatusFrequency());
      assertEquals("How often to report progress to the status bar.", incrementalClassifierEvaluator0.statusFrequencyTipText());
      assertFalse(incrementalClassifierEvaluator0.isFocusCycleRoot());
      assertEquals(0, incrementalClassifierEvaluator0.getChartingEvalWindowSize());
      assertFalse(incrementalClassifierEvaluator0.getIgnoreRepaint());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicySet());
      assertEquals("Output per-class info retrieval stats. If set to true, predictions get stored so that stats such as AUC can be computed. Note: this consumes some memory.", incrementalClassifierEvaluator0.outputPerClassInfoRetrievalStatsTipText());
      assertTrue(incrementalClassifierEvaluator0.getFocusTraversalKeysEnabled());
      assertFalse(incrementalClassifierEvaluator0.isBusy());
      assertEquals("Evaluate the performance of incrementally trained classifiers.", incrementalClassifierEvaluator0.globalInfo());
      assertEquals("For charting only, specify a sliding window size over which to compute performance stats. <= 0 means eval on whole stream", incrementalClassifierEvaluator0.chartingEvalWindowSizeTipText());
      assertEquals("IncrementalClassifierEvaluator", incrementalClassifierEvaluator0.getCustomName());
      assertFalse(incrementalClassifierEvaluator0.getOutputPerClassInfoRetrievalStats());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicyProvider());
      
      PredictionAppender predictionAppender0 = new PredictionAppender();
      assertNotNull(predictionAppender0);
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      assertFalse(predictionAppender0.isBusy());
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertFalse(predictionAppender0.isFocusCycleRoot());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      
      Appender appender1 = new Appender();
      assertFalse(appender1.equals((Object)appender0));
      assertNotNull(appender1);
      assertFalse(appender1.isBusy());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertEquals("Appender", appender1.getCustomName());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      
      add0.setAttributeName("E,BoTM^O8");
      assertEquals("E,BoTM^O8", add0.getAttributeName());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      
      Associator associator0 = new Associator();
      assertNotNull(associator0);
      assertFalse(associator0.isBusy());
      assertFalse(associator0.isFocusCycleRoot());
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      assertEquals("Apriori", associator0.getCustomName());
      assertTrue(associator0.getFocusTraversalKeysEnabled());
      assertFalse(associator0.getIgnoreRepaint());
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      
      InstanceEvent instanceEvent0 = appender1.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      assertNotNull(trainTestSplitMaker0);
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      
      Filter filter1 = new Filter();
      assertFalse(filter1.equals((Object)filter0));
      assertNotNull(filter1);
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isBusy());
      
      InputMethodListener[] inputMethodListenerArray0 = filter1.getInputMethodListeners();
      assertFalse(filter1.equals((Object)filter0));
      assertNotNull(inputMethodListenerArray0);
      assertNotSame(filter1, filter0);
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isBusy());
      
      AttributedCharacterIterator.Attribute attributedCharacterIterator_Attribute0 = AttributedCharacterIterator.Attribute.LANGUAGE;
      assertNotNull(attributedCharacterIterator_Attribute0);
      
      instanceEvent0.setStatus(10000);
      assertFalse(appender1.equals((Object)appender0));
      assertNotSame(appender1, appender0);
      assertFalse(appender1.isBusy());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertEquals("Appender", appender1.getCustomName());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals(10000, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      filter0.removeTestSetListener(filter0);
      assertFalse(filter0.equals((Object)filter1));
      assertNotSame(filter0, filter1);
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      
      Sorter.InstanceHolder sorter_InstanceHolder0 = new Sorter.InstanceHolder();
      assertNotNull(sorter_InstanceHolder0);
      
      double[] doubleArray0 = new double[10];
      doubleArray0[0] = (double) 0;
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(0);
      assertNotNull(binarySparseInstance0);
      assertEquals(0, binarySparseInstance0.numValues());
      assertEquals(0, binarySparseInstance0.numAttributes());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      instanceEvent0.setInstance(binarySparseInstance0);
      assertFalse(appender1.equals((Object)appender0));
      assertNotSame(appender1, appender0);
      assertEquals(0, binarySparseInstance0.numValues());
      assertEquals(0, binarySparseInstance0.numAttributes());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertFalse(appender1.isBusy());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertEquals("Appender", appender1.getCustomName());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals(10000, instanceEvent0.getStatus());
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      Sorter.InstanceHolder sorter_InstanceHolder1 = new Sorter.InstanceHolder();
      assertFalse(sorter_InstanceHolder1.equals((Object)sorter_InstanceHolder0));
      assertNotNull(sorter_InstanceHolder1);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.isBusy());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      
      DataSetEvent dataSetEvent0 = new DataSetEvent(sorter_InstanceHolder0, (Instances) null);
      assertFalse(sorter_InstanceHolder0.equals((Object)sorter_InstanceHolder1));
      assertNotNull(dataSetEvent0);
      assertFalse(dataSetEvent0.isStructureOnly());
      
      AttributeSelection attributeSelection0 = new AttributeSelection();
      assertNotNull(attributeSelection0);
      assertFalse(attributeSelection0.isOutputFormatDefined());
      assertEquals("Determines the search method.", attributeSelection0.searchTipText());
      assertEquals("A supervised attribute filter that can be used to select attributes. It is very flexible and allows various search and evaluation methods to be combined.", attributeSelection0.globalInfo());
      assertTrue(attributeSelection0.isNewBatch());
      assertFalse(attributeSelection0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(attributeSelection0.isFirstBatchDone());
      assertEquals("Determines how attributes/attribute subsets are evaluated.", attributeSelection0.evaluatorTipText());
      
      filter1.notifyInstanceListeners(instanceEvent0);
      assertFalse(appender1.equals((Object)appender0));
      assertFalse(filter1.equals((Object)filter0));
      assertNotSame(appender1, appender0);
      assertNotSame(filter1, filter0);
      assertFalse(appender1.isBusy());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertEquals("Appender", appender1.getCustomName());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals(10000, instanceEvent0.getStatus());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isBusy());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.equals((Object)filter1));
      assertFalse(appender1.equals((Object)appender0));
      assertNotSame(filter0, filter1);
      assertNotSame(appender1, appender0);
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertEquals("Appender", appender1.getCustomName());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals(10000, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      Appender appender2 = new Appender();
      assertFalse(appender2.equals((Object)appender1));
      assertFalse(appender2.equals((Object)appender0));
      assertNotNull(appender2);
      assertFalse(appender2.isFocusTraversalPolicySet());
      assertEquals("Appender", appender2.getCustomName());
      assertTrue(appender2.getFocusTraversalKeysEnabled());
      assertFalse(appender2.isBusy());
      assertFalse(appender2.getIgnoreRepaint());
      assertFalse(appender2.isFocusCycleRoot());
      assertFalse(appender2.isFocusTraversalPolicyProvider());
      
      StripChart stripChart0 = null;
      try {
        stripChart0 = new StripChart();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.gui.beans.StripChart", e);
      }
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      
      Add add0 = new Add();
      assertNotNull(add0);
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertFalse(add0.isOutputFormatDefined());
      
      Capabilities capabilities0 = add0.getCapabilities();
      assertNotNull(capabilities0);
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertFalse(capabilities0.hasDependencies());
      assertEquals(0, capabilities0.getMinimumNumberInstances());
      
      filter0.setFilter(add0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertFalse(add0.isOutputFormatDefined());
      
      CoverTree coverTree0 = new CoverTree();
      assertNotNull(coverTree0);
      assertEquals("The distance function to use for finding neighbours (default: weka.core.EuclideanDistance). ", coverTree0.distanceFunctionTipText());
      assertEquals("The base for the expansion constant.", coverTree0.baseTipText());
      assertEquals("Whether to calculate performance statistics for the NN search or not", coverTree0.measurePerformanceTipText());
      assertEquals(0.0, coverTree0.measureNumLeaves(), 0.01);
      assertEquals(1.3, coverTree0.getBase(), 0.01);
      assertEquals(0.0, coverTree0.measureMaxDepth(), 0.01);
      assertFalse(coverTree0.getMeasurePerformance());
      assertEquals(0.0, coverTree0.measureTreeSize(), 0.01);
      
      ClassifierPerformanceEvaluator classifierPerformanceEvaluator0 = new ClassifierPerformanceEvaluator();
      assertNotNull(classifierPerformanceEvaluator0);
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicyProvider());
      assertFalse(classifierPerformanceEvaluator0.isFocusCycleRoot());
      assertEquals("Set the number of evaluation tasks to run in parallel.", classifierPerformanceEvaluator0.executionSlotsTipText());
      assertEquals("Evaluate the performance of batch trained classifiers.", classifierPerformanceEvaluator0.globalInfo());
      assertTrue(classifierPerformanceEvaluator0.getFocusTraversalKeysEnabled());
      assertEquals(2, classifierPerformanceEvaluator0.getExecutionSlots());
      assertFalse(classifierPerformanceEvaluator0.getIgnoreRepaint());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicySet());
      assertEquals("ClassifierPerformanceEvaluator", classifierPerformanceEvaluator0.getCustomName());
      
      filter0.connectionNotification("dataSet", appender0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      
      byte[] byteArray0 = new byte[1];
      appender0.firePropertyChange("dataSet", 0.15, (double) (byte) (-35));
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      
      byteArray0[0] = (byte) (-35);
      AttributedCharacterIterator.Attribute attributedCharacterIterator_Attribute0 = AttributedCharacterIterator.Attribute.INPUT_METHOD_SEGMENT;
      assertNotNull(attributedCharacterIterator_Attribute0);
      
      Sorter.InstanceHolder sorter_InstanceHolder0 = new Sorter.InstanceHolder();
      assertNotNull(sorter_InstanceHolder0);
      
      Instance instance0 = sorter_InstanceHolder0.m_instance;
      assertNull(instance0);
      
      boolean boolean0 = filter0.eventGeneratable("dataSet");
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(boolean0);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      
      SubstringLabeler substringLabeler1 = new SubstringLabeler();
      assertFalse(substringLabeler1.equals((Object)substringLabeler0));
      assertNotNull(substringLabeler1);
      assertFalse(substringLabeler1.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler1.getCustomName());
      assertTrue(substringLabeler1.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler1.getMatchDetails());
      assertFalse(substringLabeler1.getNominalBinary());
      assertEquals("Match", substringLabeler1.getMatchAttributeName());
      assertFalse(substringLabeler1.isFocusTraversalPolicySet());
      assertFalse(substringLabeler1.isFocusCycleRoot());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler1.globalInfo());
      assertFalse(substringLabeler1.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler1.getIgnoreRepaint());
      assertFalse(substringLabeler1.isBusy());
      
      InputVerifier inputVerifier0 = filter0.getInputVerifier();
      assertNull(inputVerifier0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      
      BeanContextServicesSupport beanContextServicesSupport0 = new BeanContextServicesSupport();
      assertNotNull(beanContextServicesSupport0);
      assertEquals(0, beanContextServicesSupport0.size());
      assertFalse(beanContextServicesSupport0.isDesignTime());
      assertFalse(beanContextServicesSupport0.isSerializing());
      assertFalse(beanContextServicesSupport0.isDelegated());
      assertTrue(beanContextServicesSupport0.isEmpty());
      
      BeanContextServicesSupport beanContextServicesSupport1 = new BeanContextServicesSupport(beanContextServicesSupport0);
      assertFalse(beanContextServicesSupport1.equals((Object)beanContextServicesSupport0));
      assertNotNull(beanContextServicesSupport1);
      assertEquals(0, beanContextServicesSupport0.size());
      assertFalse(beanContextServicesSupport0.isDesignTime());
      assertFalse(beanContextServicesSupport0.isSerializing());
      assertFalse(beanContextServicesSupport0.isDelegated());
      assertTrue(beanContextServicesSupport0.isEmpty());
      assertFalse(beanContextServicesSupport1.isDesignTime());
      assertEquals(0, beanContextServicesSupport1.size());
      assertTrue(beanContextServicesSupport1.isDelegated());
      assertTrue(beanContextServicesSupport1.isEmpty());
      assertFalse(beanContextServicesSupport1.isSerializing());
      
      filter0.removeVetoableChangeListener(beanContextServicesSupport0);
      assertFalse(beanContextServicesSupport0.equals((Object)beanContextServicesSupport1));
      assertNotSame(beanContextServicesSupport0, beanContextServicesSupport1);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertEquals(0, beanContextServicesSupport0.size());
      assertFalse(beanContextServicesSupport0.isDesignTime());
      assertFalse(beanContextServicesSupport0.isSerializing());
      assertFalse(beanContextServicesSupport0.isDelegated());
      assertTrue(beanContextServicesSupport0.isEmpty());
      
      SubstringLabeler substringLabeler2 = new SubstringLabeler();
      assertFalse(substringLabeler2.equals((Object)substringLabeler0));
      assertFalse(substringLabeler2.equals((Object)substringLabeler1));
      assertNotNull(substringLabeler2);
      assertFalse(substringLabeler2.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler2.isBusy());
      assertEquals("SubstringLabeler", substringLabeler2.getCustomName());
      assertEquals("", substringLabeler2.getMatchDetails());
      assertFalse(substringLabeler2.getNominalBinary());
      assertFalse(substringLabeler2.getIgnoreRepaint());
      assertFalse(substringLabeler2.isFocusTraversalPolicySet());
      assertTrue(substringLabeler2.getFocusTraversalKeysEnabled());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler2.globalInfo());
      assertFalse(substringLabeler2.isFocusCycleRoot());
      assertFalse(substringLabeler2.getConsumeNonMatching());
      assertEquals("Match", substringLabeler2.getMatchAttributeName());
      
      StratifiedRemoveFolds stratifiedRemoveFolds0 = new StratifiedRemoveFolds();
      assertNotNull(stratifiedRemoveFolds0);
      assertTrue(stratifiedRemoveFolds0.isNewBatch());
      assertEquals("the random number seed for shuffling the dataset. If seed is negative, shuffling will not be performed.", stratifiedRemoveFolds0.seedTipText());
      assertEquals("This filter takes a dataset and outputs a specified fold for cross validation. If you do not want the folds to be stratified use the unsupervised version.", stratifiedRemoveFolds0.globalInfo());
      assertEquals("The fold which is selected.", stratifiedRemoveFolds0.foldTipText());
      assertEquals(1, stratifiedRemoveFolds0.getFold());
      assertEquals(10, stratifiedRemoveFolds0.getNumFolds());
      assertFalse(stratifiedRemoveFolds0.isFirstBatchDone());
      assertFalse(stratifiedRemoveFolds0.getInvertSelection());
      assertEquals(0L, stratifiedRemoveFolds0.getSeed());
      assertFalse(stratifiedRemoveFolds0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("The number of folds to split the dataset into.", stratifiedRemoveFolds0.numFoldsTipText());
      assertFalse(stratifiedRemoveFolds0.isOutputFormatDefined());
      assertEquals("Whether to invert the selection.", stratifiedRemoveFolds0.invertSelectionTipText());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      filter0.connectionNotification("instance", substringLabeler1);
      assertFalse(substringLabeler1.equals((Object)substringLabeler0));
      assertFalse(substringLabeler1.equals((Object)substringLabeler2));
      assertNotSame(substringLabeler1, substringLabeler0);
      assertNotSame(substringLabeler1, substringLabeler2);
      assertFalse(substringLabeler1.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler1.getCustomName());
      assertTrue(substringLabeler1.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler1.getMatchDetails());
      assertFalse(substringLabeler1.getNominalBinary());
      assertEquals("Match", substringLabeler1.getMatchAttributeName());
      assertFalse(substringLabeler1.isFocusTraversalPolicySet());
      assertFalse(substringLabeler1.isFocusCycleRoot());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler1.globalInfo());
      assertFalse(substringLabeler1.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler1.getIgnoreRepaint());
      assertFalse(substringLabeler1.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      
      boolean boolean1 = filter0.isBusy();
      assertTrue(boolean1 == boolean0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(boolean1);
      
      filter0.stop();
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      Add add0 = new Add();
      assertNotNull(add0);
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertFalse(add0.isFirstBatchDone());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      
      filter0.setFilter(add0);
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertFalse(add0.isFirstBatchDone());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      
      IncrementalClassifierEvaluator incrementalClassifierEvaluator0 = new IncrementalClassifierEvaluator();
      assertNotNull(incrementalClassifierEvaluator0);
      assertTrue(incrementalClassifierEvaluator0.getFocusTraversalKeysEnabled());
      assertFalse(incrementalClassifierEvaluator0.isBusy());
      assertEquals("IncrementalClassifierEvaluator", incrementalClassifierEvaluator0.getCustomName());
      assertEquals("Evaluate the performance of incrementally trained classifiers.", incrementalClassifierEvaluator0.globalInfo());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicySet());
      assertFalse(incrementalClassifierEvaluator0.getIgnoreRepaint());
      assertEquals(0, incrementalClassifierEvaluator0.getChartingEvalWindowSize());
      assertEquals(100, incrementalClassifierEvaluator0.getStatusFrequency());
      assertEquals("Output per-class info retrieval stats. If set to true, predictions get stored so that stats such as AUC can be computed. Note: this consumes some memory.", incrementalClassifierEvaluator0.outputPerClassInfoRetrievalStatsTipText());
      assertEquals("For charting only, specify a sliding window size over which to compute performance stats. <= 0 means eval on whole stream", incrementalClassifierEvaluator0.chartingEvalWindowSizeTipText());
      assertFalse(incrementalClassifierEvaluator0.getOutputPerClassInfoRetrievalStats());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicyProvider());
      assertFalse(incrementalClassifierEvaluator0.isFocusCycleRoot());
      assertEquals("How often to report progress to the status bar.", incrementalClassifierEvaluator0.statusFrequencyTipText());
      
      PredictionAppender predictionAppender0 = new PredictionAppender();
      assertNotNull(predictionAppender0);
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertFalse(predictionAppender0.isBusy());
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      assertFalse(predictionAppender0.isFocusCycleRoot());
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      
      Associator associator0 = new Associator();
      assertNotNull(associator0);
      assertFalse(associator0.getIgnoreRepaint());
      assertTrue(associator0.getFocusTraversalKeysEnabled());
      assertFalse(associator0.isBusy());
      assertEquals("Apriori", associator0.getCustomName());
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      assertFalse(associator0.isFocusCycleRoot());
      
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      assertNotNull(trainTestSplitMaker0);
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      
      Filter filter1 = new Filter();
      assertFalse(filter1.equals((Object)filter0));
      assertNotNull(filter1);
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter1.getCustomName());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      
      InputMethodListener[] inputMethodListenerArray0 = filter1.getInputMethodListeners();
      assertFalse(filter1.equals((Object)filter0));
      assertNotNull(inputMethodListenerArray0);
      assertNotSame(filter1, filter0);
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter1.getCustomName());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      
      AttributedCharacterIterator.Attribute attributedCharacterIterator_Attribute0 = AttributedCharacterIterator.Attribute.LANGUAGE;
      assertNotNull(attributedCharacterIterator_Attribute0);
      
      filter0.removeTestSetListener(filter0);
      assertFalse(filter0.equals((Object)filter1));
      assertNotSame(filter0, filter1);
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      Sorter.InstanceHolder sorter_InstanceHolder0 = new Sorter.InstanceHolder();
      assertNotNull(sorter_InstanceHolder0);
      
      Sorter.InstanceHolder sorter_InstanceHolder1 = new Sorter.InstanceHolder();
      assertFalse(sorter_InstanceHolder1.equals((Object)sorter_InstanceHolder0));
      assertNotNull(sorter_InstanceHolder1);
      
      Instance instance0 = sorter_InstanceHolder0.m_instance;
      assertNull(instance0);
      
      ListOptions listOptions0 = new ListOptions();
      assertNotNull(listOptions0);
      assertEquals("weka.core.ListOptions", listOptions0.getClassname());
      
      String string0 = listOptions0.generate();
      assertNotNull(string0);
      assertEquals("weka.core.ListOptions", listOptions0.getClassname());
      assertEquals("-W <classname>\n\tThe class to load.\n", string0);
      
      filter0.connectionNotification("instance", listOptions0);
      assertFalse(filter0.equals((Object)filter1));
      assertNotSame(filter0, filter1);
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("weka.core.ListOptions", listOptions0.getClassname());
      
      DataSetEvent dataSetEvent0 = new DataSetEvent(sorter_InstanceHolder0, (Instances) null);
      assertFalse(sorter_InstanceHolder0.equals((Object)sorter_InstanceHolder1));
      assertNotNull(dataSetEvent0);
      assertFalse(dataSetEvent0.isStructureOnly());
      
      AttributeSelection attributeSelection0 = new AttributeSelection();
      assertNotNull(attributeSelection0);
      assertFalse(attributeSelection0.isOutputFormatDefined());
      assertEquals("Determines the search method.", attributeSelection0.searchTipText());
      assertFalse(attributeSelection0.isFirstBatchDone());
      assertEquals("Determines how attributes/attribute subsets are evaluated.", attributeSelection0.evaluatorTipText());
      assertEquals("A supervised attribute filter that can be used to select attributes. It is very flexible and allows various search and evaluation methods to be combined.", attributeSelection0.globalInfo());
      assertTrue(attributeSelection0.isNewBatch());
      assertFalse(attributeSelection0.mayRemoveInstanceAfterFirstBatchDone());
      
      Capabilities capabilities0 = attributeSelection0.getCapabilities();
      assertNotNull(capabilities0);
      assertFalse(attributeSelection0.isOutputFormatDefined());
      assertEquals("Determines the search method.", attributeSelection0.searchTipText());
      assertFalse(attributeSelection0.isFirstBatchDone());
      assertEquals("Determines how attributes/attribute subsets are evaluated.", attributeSelection0.evaluatorTipText());
      assertEquals("A supervised attribute filter that can be used to select attributes. It is very flexible and allows various search and evaluation methods to be combined.", attributeSelection0.globalInfo());
      assertTrue(attributeSelection0.isNewBatch());
      assertFalse(attributeSelection0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(capabilities0.hasDependencies());
      assertEquals(0, capabilities0.getMinimumNumberInstances());
      
      filter0.connectionNotification("| tNmHy7)|]J&", attributeSelection0);
      assertFalse(filter0.equals((Object)filter1));
      assertNotSame(filter0, filter1);
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(attributeSelection0.isOutputFormatDefined());
      assertEquals("Determines the search method.", attributeSelection0.searchTipText());
      assertFalse(attributeSelection0.isFirstBatchDone());
      assertEquals("Determines how attributes/attribute subsets are evaluated.", attributeSelection0.evaluatorTipText());
      assertEquals("A supervised attribute filter that can be used to select attributes. It is very flexible and allows various search and evaluation methods to be combined.", attributeSelection0.globalInfo());
      assertTrue(attributeSelection0.isNewBatch());
      assertFalse(attributeSelection0.mayRemoveInstanceAfterFirstBatchDone());
      
      TestSetEvent testSetEvent0 = new TestSetEvent(attributedCharacterIterator_Attribute0, (Instances) null);
      assertNotNull(testSetEvent0);
      assertEquals(1, testSetEvent0.getRunNumber());
      assertEquals(0, testSetEvent0.getSetNumber());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertEquals(0, testSetEvent0.getMaxSetNumber());
      assertFalse(testSetEvent0.isStructureOnly());
      
      filter1.acceptTestSet(testSetEvent0);
      assertFalse(filter1.equals((Object)filter0));
      assertNotSame(filter1, filter0);
      assertEquals(1, testSetEvent0.getRunNumber());
      assertEquals(0, testSetEvent0.getSetNumber());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertEquals(0, testSetEvent0.getMaxSetNumber());
      assertFalse(testSetEvent0.isStructureOnly());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter1.getCustomName());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      
      filter1.removeInstanceListener(filter0);
      assertFalse(filter0.equals((Object)filter1));
      assertFalse(filter1.equals((Object)filter0));
      assertNotSame(filter0, filter1);
      assertNotSame(filter1, filter0);
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter1.getCustomName());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      
      boolean boolean0 = FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "laj~O#D9F8");
      assertFalse(boolean0);
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      
      Add add0 = new Add();
      assertNotNull(add0);
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("unnamed", add0.getAttributeName());
      
      Capabilities capabilities0 = add0.getCapabilities();
      assertNotNull(capabilities0);
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertFalse(capabilities0.hasDependencies());
      assertEquals(0, capabilities0.getMinimumNumberInstances());
      
      filter0.setFilter(add0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("unnamed", add0.getAttributeName());
      
      CoverTree coverTree0 = new CoverTree();
      assertNotNull(coverTree0);
      assertEquals(1.3, coverTree0.getBase(), 0.01);
      assertEquals("The base for the expansion constant.", coverTree0.baseTipText());
      assertEquals(0.0, coverTree0.measureTreeSize(), 0.01);
      assertFalse(coverTree0.getMeasurePerformance());
      assertEquals(0.0, coverTree0.measureMaxDepth(), 0.01);
      assertEquals("Whether to calculate performance statistics for the NN search or not", coverTree0.measurePerformanceTipText());
      assertEquals(0.0, coverTree0.measureNumLeaves(), 0.01);
      assertEquals("The distance function to use for finding neighbours (default: weka.core.EuclideanDistance). ", coverTree0.distanceFunctionTipText());
      
      ClassifierPerformanceEvaluator classifierPerformanceEvaluator0 = new ClassifierPerformanceEvaluator();
      assertNotNull(classifierPerformanceEvaluator0);
      assertFalse(classifierPerformanceEvaluator0.isFocusCycleRoot());
      assertEquals(2, classifierPerformanceEvaluator0.getExecutionSlots());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicySet());
      assertEquals("ClassifierPerformanceEvaluator", classifierPerformanceEvaluator0.getCustomName());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals("Set the number of evaluation tasks to run in parallel.", classifierPerformanceEvaluator0.executionSlotsTipText());
      assertEquals("Evaluate the performance of batch trained classifiers.", classifierPerformanceEvaluator0.globalInfo());
      assertFalse(classifierPerformanceEvaluator0.getIgnoreRepaint());
      assertTrue(classifierPerformanceEvaluator0.getFocusTraversalKeysEnabled());
      
      Clusterer clusterer0 = new Clusterer();
      assertNotNull(clusterer0);
      assertTrue(clusterer0.getFocusTraversalKeysEnabled());
      assertFalse(clusterer0.getIgnoreRepaint());
      assertFalse(clusterer0.isBusy());
      assertFalse(clusterer0.isFocusCycleRoot());
      assertFalse(clusterer0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Simple EM (expectation maximisation) class.\n\nEM assigns a probability distribution to each instance which indicates the probability of it belonging to each of the clusters</font><br><br> EM can decide how many clusters to create by cross validation, or you may specify apriori how many clusters to generate.<br><br>The cross validation performed to determine the number of clusters is done in the following steps:<br>1. the number of clusters is set to 1<br>2. the training set is split randomly into 10 folds.<br>3. EM is performed 10 times using the 10 folds the usual CV way.<br>4. the loglikelihood is averaged over all 10 results.<br>5.<br>if loglikelihood has increased the number of clusters is increased by 1 and the program continues at step 2.<br><br><br>The number of folds is fixed to 10, as long as the number of instances in the training set is not smaller 10.<br>If this is the case the number of folds is set equal to the number of instances.<br></html>", clusterer0.globalInfo());
      assertFalse(clusterer0.isFocusTraversalPolicyProvider());
      assertEquals("EM", clusterer0.getCustomName());
      assertFalse(clusterer0.hasIncomingBatchInstances());
      
      filter0.connectionNotification("weka/core/Capabilities.props", clusterer0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(clusterer0.getFocusTraversalKeysEnabled());
      assertFalse(clusterer0.getIgnoreRepaint());
      assertFalse(clusterer0.isBusy());
      assertFalse(clusterer0.isFocusCycleRoot());
      assertFalse(clusterer0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Simple EM (expectation maximisation) class.\n\nEM assigns a probability distribution to each instance which indicates the probability of it belonging to each of the clusters</font><br><br> EM can decide how many clusters to create by cross validation, or you may specify apriori how many clusters to generate.<br><br>The cross validation performed to determine the number of clusters is done in the following steps:<br>1. the number of clusters is set to 1<br>2. the training set is split randomly into 10 folds.<br>3. EM is performed 10 times using the 10 folds the usual CV way.<br>4. the loglikelihood is averaged over all 10 results.<br>5.<br>if loglikelihood has increased the number of clusters is increased by 1 and the program continues at step 2.<br><br><br>The number of folds is fixed to 10, as long as the number of instances in the training set is not smaller 10.<br>If this is the case the number of folds is set equal to the number of instances.<br></html>", clusterer0.globalInfo());
      assertFalse(clusterer0.isFocusTraversalPolicyProvider());
      assertEquals("EM", clusterer0.getCustomName());
      assertFalse(clusterer0.hasIncomingBatchInstances());
      
      appender0.firePropertyChange("datat", (-45.0), 0.15);
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      
      AttributedCharacterIterator.Attribute attributedCharacterIterator_Attribute0 = AttributedCharacterIterator.Attribute.INPUT_METHOD_SEGMENT;
      assertNotNull(attributedCharacterIterator_Attribute0);
      
      Sorter.InstanceHolder sorter_InstanceHolder0 = new Sorter.InstanceHolder();
      assertNotNull(sorter_InstanceHolder0);
      
      Instance instance0 = sorter_InstanceHolder0.m_instance;
      assertNull(instance0);
      
      boolean boolean1 = filter0.eventGeneratable("weka/core/Capabilities.props");
      assertFalse(boolean1 == boolean0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(boolean1);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      
      SubstringLabeler substringLabeler1 = new SubstringLabeler();
      assertFalse(substringLabeler1.equals((Object)substringLabeler0));
      assertNotNull(substringLabeler1);
      assertFalse(substringLabeler1.getIgnoreRepaint());
      assertFalse(substringLabeler1.isBusy());
      assertEquals("SubstringLabeler", substringLabeler1.getCustomName());
      assertTrue(substringLabeler1.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler1.getMatchDetails());
      assertFalse(substringLabeler1.getNominalBinary());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler1.globalInfo());
      assertFalse(substringLabeler1.isFocusTraversalPolicySet());
      assertEquals("Match", substringLabeler1.getMatchAttributeName());
      assertFalse(substringLabeler1.getConsumeNonMatching());
      assertFalse(substringLabeler1.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler1.isFocusCycleRoot());
      
      InputVerifier inputVerifier0 = filter0.getInputVerifier();
      assertNull(inputVerifier0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      
      BeanContextServicesSupport beanContextServicesSupport0 = new BeanContextServicesSupport();
      assertNotNull(beanContextServicesSupport0);
      assertFalse(beanContextServicesSupport0.isDelegated());
      assertEquals(0, beanContextServicesSupport0.size());
      assertFalse(beanContextServicesSupport0.isSerializing());
      assertTrue(beanContextServicesSupport0.isEmpty());
      assertFalse(beanContextServicesSupport0.isDesignTime());
      
      SubstringLabeler substringLabeler2 = new SubstringLabeler();
      assertFalse(substringLabeler2.equals((Object)substringLabeler1));
      assertFalse(substringLabeler2.equals((Object)substringLabeler0));
      assertNotNull(substringLabeler2);
      assertFalse(substringLabeler2.getIgnoreRepaint());
      assertEquals("SubstringLabeler", substringLabeler2.getCustomName());
      assertFalse(substringLabeler2.isBusy());
      assertFalse(substringLabeler2.getNominalBinary());
      assertFalse(substringLabeler2.isFocusTraversalPolicySet());
      assertTrue(substringLabeler2.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler2.getMatchDetails());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler2.globalInfo());
      assertFalse(substringLabeler2.getConsumeNonMatching());
      assertFalse(substringLabeler2.isFocusCycleRoot());
      assertEquals("Match", substringLabeler2.getMatchAttributeName());
      assertFalse(substringLabeler2.isFocusTraversalPolicyProvider());
      
      InputVerifier inputVerifier1 = substringLabeler2.getInputVerifier();
      assertFalse(substringLabeler2.equals((Object)substringLabeler1));
      assertFalse(substringLabeler2.equals((Object)substringLabeler0));
      assertNull(inputVerifier1);
      assertNotSame(substringLabeler2, substringLabeler1);
      assertNotSame(substringLabeler2, substringLabeler0);
      assertFalse(substringLabeler2.getIgnoreRepaint());
      assertEquals("SubstringLabeler", substringLabeler2.getCustomName());
      assertFalse(substringLabeler2.isBusy());
      assertFalse(substringLabeler2.getNominalBinary());
      assertFalse(substringLabeler2.isFocusTraversalPolicySet());
      assertTrue(substringLabeler2.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler2.getMatchDetails());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler2.globalInfo());
      assertFalse(substringLabeler2.getConsumeNonMatching());
      assertFalse(substringLabeler2.isFocusCycleRoot());
      assertEquals("Match", substringLabeler2.getMatchAttributeName());
      assertFalse(substringLabeler2.isFocusTraversalPolicyProvider());
      
      BeanContextServicesSupport beanContextServicesSupport1 = new BeanContextServicesSupport();
      assertFalse(beanContextServicesSupport1.equals((Object)beanContextServicesSupport0));
      assertNotNull(beanContextServicesSupport1);
      assertFalse(beanContextServicesSupport1.isSerializing());
      assertTrue(beanContextServicesSupport1.isEmpty());
      assertFalse(beanContextServicesSupport1.isDesignTime());
      assertFalse(beanContextServicesSupport1.isDelegated());
      assertEquals(0, beanContextServicesSupport1.size());
      
      BeanContextServicesSupport beanContextServicesSupport2 = new BeanContextServicesSupport(beanContextServicesSupport1);
      assertFalse(beanContextServicesSupport1.equals((Object)beanContextServicesSupport0));
      assertFalse(beanContextServicesSupport2.equals((Object)beanContextServicesSupport1));
      assertFalse(beanContextServicesSupport2.equals((Object)beanContextServicesSupport0));
      assertNotNull(beanContextServicesSupport2);
      assertFalse(beanContextServicesSupport1.isSerializing());
      assertTrue(beanContextServicesSupport1.isEmpty());
      assertFalse(beanContextServicesSupport1.isDesignTime());
      assertFalse(beanContextServicesSupport1.isDelegated());
      assertEquals(0, beanContextServicesSupport1.size());
      assertTrue(beanContextServicesSupport2.isDelegated());
      assertFalse(beanContextServicesSupport2.isDesignTime());
      assertEquals(0, beanContextServicesSupport2.size());
      assertTrue(beanContextServicesSupport2.isEmpty());
      assertFalse(beanContextServicesSupport2.isSerializing());
      
      filter0.removeVetoableChangeListener(beanContextServicesSupport2);
      assertFalse(beanContextServicesSupport1.equals((Object)beanContextServicesSupport0));
      assertFalse(beanContextServicesSupport1.equals((Object)beanContextServicesSupport2));
      assertFalse(beanContextServicesSupport2.equals((Object)beanContextServicesSupport1));
      assertFalse(beanContextServicesSupport2.equals((Object)beanContextServicesSupport0));
      assertNotSame(beanContextServicesSupport1, beanContextServicesSupport0);
      assertNotSame(beanContextServicesSupport1, beanContextServicesSupport2);
      assertNotSame(beanContextServicesSupport2, beanContextServicesSupport1);
      assertNotSame(beanContextServicesSupport2, beanContextServicesSupport0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(beanContextServicesSupport1.isSerializing());
      assertTrue(beanContextServicesSupport1.isEmpty());
      assertFalse(beanContextServicesSupport1.isDesignTime());
      assertFalse(beanContextServicesSupport1.isDelegated());
      assertEquals(0, beanContextServicesSupport1.size());
      assertTrue(beanContextServicesSupport2.isDelegated());
      assertFalse(beanContextServicesSupport2.isDesignTime());
      assertEquals(0, beanContextServicesSupport2.size());
      assertTrue(beanContextServicesSupport2.isEmpty());
      assertFalse(beanContextServicesSupport2.isSerializing());
      
      SubstringLabeler substringLabeler3 = new SubstringLabeler();
      assertFalse(substringLabeler3.equals((Object)substringLabeler0));
      assertFalse(substringLabeler3.equals((Object)substringLabeler1));
      assertFalse(substringLabeler3.equals((Object)substringLabeler2));
      assertNotNull(substringLabeler3);
      assertTrue(substringLabeler3.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler3.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler3.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler3.globalInfo());
      assertFalse(substringLabeler3.getIgnoreRepaint());
      assertFalse(substringLabeler3.isFocusTraversalPolicySet());
      assertFalse(substringLabeler3.getNominalBinary());
      assertFalse(substringLabeler3.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler3.getMatchAttributeName());
      assertFalse(substringLabeler3.isBusy());
      assertFalse(substringLabeler3.getConsumeNonMatching());
      assertFalse(substringLabeler3.isFocusCycleRoot());
      
      StratifiedRemoveFolds stratifiedRemoveFolds0 = new StratifiedRemoveFolds();
      assertNotNull(stratifiedRemoveFolds0);
      assertEquals(1, stratifiedRemoveFolds0.getFold());
      assertFalse(stratifiedRemoveFolds0.isFirstBatchDone());
      assertEquals("Whether to invert the selection.", stratifiedRemoveFolds0.invertSelectionTipText());
      assertEquals("the random number seed for shuffling the dataset. If seed is negative, shuffling will not be performed.", stratifiedRemoveFolds0.seedTipText());
      assertEquals("This filter takes a dataset and outputs a specified fold for cross validation. If you do not want the folds to be stratified use the unsupervised version.", stratifiedRemoveFolds0.globalInfo());
      assertEquals(0L, stratifiedRemoveFolds0.getSeed());
      assertTrue(stratifiedRemoveFolds0.isNewBatch());
      assertFalse(stratifiedRemoveFolds0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(stratifiedRemoveFolds0.isOutputFormatDefined());
      assertFalse(stratifiedRemoveFolds0.getInvertSelection());
      assertEquals("The number of folds to split the dataset into.", stratifiedRemoveFolds0.numFoldsTipText());
      assertEquals(10, stratifiedRemoveFolds0.getNumFolds());
      assertEquals("The fold which is selected.", stratifiedRemoveFolds0.foldTipText());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      Filter filter1 = new Filter();
      assertFalse(filter1.equals((Object)filter0));
      assertNotNull(filter1);
      assertFalse(filter1.isBusy());
      assertFalse(filter1.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      
      ClustererPerformanceEvaluator clustererPerformanceEvaluator0 = new ClustererPerformanceEvaluator();
      assertNotNull(clustererPerformanceEvaluator0);
      assertTrue(clustererPerformanceEvaluator0.getFocusTraversalKeysEnabled());
      assertEquals("ClustererPerformanceEvaluator", clustererPerformanceEvaluator0.getCustomName());
      assertFalse(clustererPerformanceEvaluator0.isFocusTraversalPolicySet());
      assertFalse(clustererPerformanceEvaluator0.getIgnoreRepaint());
      assertEquals("Evaluate the performance of batch trained clusterers.", clustererPerformanceEvaluator0.globalInfo());
      assertFalse(clustererPerformanceEvaluator0.isFocusTraversalPolicyProvider());
      assertFalse(clustererPerformanceEvaluator0.isFocusCycleRoot());
      assertFalse(clustererPerformanceEvaluator0.isBusy());
      
      filter1.connectionNotification("datat", clustererPerformanceEvaluator0);
      assertFalse(filter1.equals((Object)filter0));
      assertNotSame(filter1, filter0);
      assertFalse(filter1.isBusy());
      assertFalse(filter1.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertTrue(clustererPerformanceEvaluator0.getFocusTraversalKeysEnabled());
      assertEquals("ClustererPerformanceEvaluator", clustererPerformanceEvaluator0.getCustomName());
      assertFalse(clustererPerformanceEvaluator0.isFocusTraversalPolicySet());
      assertFalse(clustererPerformanceEvaluator0.getIgnoreRepaint());
      assertEquals("Evaluate the performance of batch trained clusterers.", clustererPerformanceEvaluator0.globalInfo());
      assertFalse(clustererPerformanceEvaluator0.isFocusTraversalPolicyProvider());
      assertFalse(clustererPerformanceEvaluator0.isFocusCycleRoot());
      assertFalse(clustererPerformanceEvaluator0.isBusy());
      
      CostBenefitAnalysis costBenefitAnalysis0 = new CostBenefitAnalysis();
      assertNotNull(costBenefitAnalysis0);
      assertFalse(costBenefitAnalysis0.isFocusCycleRoot());
      assertEquals("Visualize performance charts (such as ROC).", costBenefitAnalysis0.globalInfo());
      assertFalse(costBenefitAnalysis0.isFocusTraversalPolicySet());
      assertFalse(costBenefitAnalysis0.isBusy());
      assertTrue(costBenefitAnalysis0.getFocusTraversalKeysEnabled());
      assertEquals("CostBenefitAnalysis", costBenefitAnalysis0.getCustomName());
      assertFalse(costBenefitAnalysis0.getIgnoreRepaint());
      assertFalse(costBenefitAnalysis0.isFocusTraversalPolicyProvider());
      
      Clusterer clusterer1 = new Clusterer();
      assertFalse(clusterer1.equals((Object)clusterer0));
      assertNotNull(clusterer1);
      assertEquals("<html><font color=blue>Simple EM (expectation maximisation) class.\n\nEM assigns a probability distribution to each instance which indicates the probability of it belonging to each of the clusters</font><br><br> EM can decide how many clusters to create by cross validation, or you may specify apriori how many clusters to generate.<br><br>The cross validation performed to determine the number of clusters is done in the following steps:<br>1. the number of clusters is set to 1<br>2. the training set is split randomly into 10 folds.<br>3. EM is performed 10 times using the 10 folds the usual CV way.<br>4. the loglikelihood is averaged over all 10 results.<br>5.<br>if loglikelihood has increased the number of clusters is increased by 1 and the program continues at step 2.<br><br><br>The number of folds is fixed to 10, as long as the number of instances in the training set is not smaller 10.<br>If this is the case the number of folds is set equal to the number of instances.<br></html>", clusterer1.globalInfo());
      assertEquals("EM", clusterer1.getCustomName());
      assertFalse(clusterer1.hasIncomingBatchInstances());
      assertFalse(clusterer1.isFocusCycleRoot());
      assertFalse(clusterer1.isFocusTraversalPolicyProvider());
      assertFalse(clusterer1.getIgnoreRepaint());
      assertFalse(clusterer1.isBusy());
      assertTrue(clusterer1.getFocusTraversalKeysEnabled());
      assertFalse(clusterer1.isFocusTraversalPolicySet());
      
      TestInstances testInstances0 = new TestInstances();
      assertNotNull(testInstances0);
      assertFalse(testInstances0.getNoClass());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      
      // Undeclared exception!
      try { 
        testInstances0.getRelationalFormat((-2));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -2
         //
         verifyException("weka.core.TestInstances", e);
      }
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      
      Add add0 = new Add();
      assertNotNull(add0);
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.isFirstBatchDone());
      
      filter0.setFilter(add0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.isFirstBatchDone());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      
      IncrementalClassifierEvaluator incrementalClassifierEvaluator0 = new IncrementalClassifierEvaluator();
      assertNotNull(incrementalClassifierEvaluator0);
      assertTrue(incrementalClassifierEvaluator0.getFocusTraversalKeysEnabled());
      assertFalse(incrementalClassifierEvaluator0.getOutputPerClassInfoRetrievalStats());
      assertEquals("For charting only, specify a sliding window size over which to compute performance stats. <= 0 means eval on whole stream", incrementalClassifierEvaluator0.chartingEvalWindowSizeTipText());
      assertEquals("IncrementalClassifierEvaluator", incrementalClassifierEvaluator0.getCustomName());
      assertFalse(incrementalClassifierEvaluator0.isBusy());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicySet());
      assertEquals("Evaluate the performance of incrementally trained classifiers.", incrementalClassifierEvaluator0.globalInfo());
      assertFalse(incrementalClassifierEvaluator0.getIgnoreRepaint());
      assertEquals("How often to report progress to the status bar.", incrementalClassifierEvaluator0.statusFrequencyTipText());
      assertEquals(100, incrementalClassifierEvaluator0.getStatusFrequency());
      assertFalse(incrementalClassifierEvaluator0.isFocusCycleRoot());
      assertEquals("Output per-class info retrieval stats. If set to true, predictions get stored so that stats such as AUC can be computed. Note: this consumes some memory.", incrementalClassifierEvaluator0.outputPerClassInfoRetrievalStatsTipText());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals(0, incrementalClassifierEvaluator0.getChartingEvalWindowSize());
      
      Appender appender1 = new Appender();
      assertFalse(appender1.equals((Object)appender0));
      assertNotNull(appender1);
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isBusy());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      
      add0.setAttributeName("E,BoTM^O8");
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("E,BoTM^O8", add0.getAttributeName());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.isFirstBatchDone());
      
      Associator associator0 = new Associator();
      assertNotNull(associator0);
      assertFalse(associator0.isBusy());
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      assertEquals("Apriori", associator0.getCustomName());
      assertTrue(associator0.getFocusTraversalKeysEnabled());
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertFalse(associator0.isFocusCycleRoot());
      assertFalse(associator0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      assertNotNull(trainTestSplitMaker0);
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      
      Filter filter1 = new Filter();
      assertFalse(filter1.equals((Object)filter0));
      assertNotNull(filter1);
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isFocusTraversalPolicySet());
      
      InputMethodListener[] inputMethodListenerArray0 = filter1.getInputMethodListeners();
      assertFalse(filter1.equals((Object)filter0));
      assertNotNull(inputMethodListenerArray0);
      assertNotSame(filter1, filter0);
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isFocusTraversalPolicySet());
      
      AttributedCharacterIterator.Attribute attributedCharacterIterator_Attribute0 = AttributedCharacterIterator.Attribute.LANGUAGE;
      assertNotNull(attributedCharacterIterator_Attribute0);
      
      filter0.removeTestSetListener(filter0);
      assertFalse(filter0.equals((Object)filter1));
      assertNotSame(filter0, filter1);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      
      Sorter.InstanceHolder sorter_InstanceHolder0 = new Sorter.InstanceHolder();
      assertNotNull(sorter_InstanceHolder0);
      
      Sorter.InstanceHolder sorter_InstanceHolder1 = new Sorter.InstanceHolder();
      assertFalse(sorter_InstanceHolder1.equals((Object)sorter_InstanceHolder0));
      assertNotNull(sorter_InstanceHolder1);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      
      ListOptions listOptions0 = new ListOptions();
      assertNotNull(listOptions0);
      assertEquals("weka.core.ListOptions", listOptions0.getClassname());
      
      Enumeration enumeration0 = listOptions0.listOptions();
      assertNotNull(enumeration0);
      assertEquals("weka.core.ListOptions", listOptions0.getClassname());
      
      String string0 = AccessibleContext.ACCESSIBLE_TABLE_ROW_HEADER_CHANGED;
      assertNotNull(string0);
      assertEquals("accessibleTableRowHeaderChanged", string0);
      
      filter0.connectionNotification("instance", listOptions0);
      assertFalse(filter0.equals((Object)filter1));
      assertNotSame(filter0, filter1);
      assertEquals("weka.core.ListOptions", listOptions0.getClassname());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      
      AttributeSelection attributeSelection0 = new AttributeSelection();
      assertNotNull(attributeSelection0);
      assertEquals("A supervised attribute filter that can be used to select attributes. It is very flexible and allows various search and evaluation methods to be combined.", attributeSelection0.globalInfo());
      assertEquals("Determines how attributes/attribute subsets are evaluated.", attributeSelection0.evaluatorTipText());
      assertTrue(attributeSelection0.isNewBatch());
      assertFalse(attributeSelection0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(attributeSelection0.isOutputFormatDefined());
      assertFalse(attributeSelection0.isFirstBatchDone());
      assertEquals("Determines the search method.", attributeSelection0.searchTipText());
      
      filter0.connectionNotification("accessibleTableRowHeaderChanged", attributeSelection0);
      assertFalse(filter0.equals((Object)filter1));
      assertNotSame(filter0, filter1);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("A supervised attribute filter that can be used to select attributes. It is very flexible and allows various search and evaluation methods to be combined.", attributeSelection0.globalInfo());
      assertEquals("Determines how attributes/attribute subsets are evaluated.", attributeSelection0.evaluatorTipText());
      assertTrue(attributeSelection0.isNewBatch());
      assertFalse(attributeSelection0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(attributeSelection0.isOutputFormatDefined());
      assertFalse(attributeSelection0.isFirstBatchDone());
      assertEquals("Determines the search method.", attributeSelection0.searchTipText());
      
      filter1.addTestSetListener(filter0);
      assertFalse(filter0.equals((Object)filter1));
      assertFalse(filter1.equals((Object)filter0));
      assertNotSame(filter0, filter1);
      assertNotSame(filter1, filter0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isFocusTraversalPolicySet());
      
      filter0.removeInstanceListener(filter1);
      assertFalse(filter0.equals((Object)filter1));
      assertFalse(filter1.equals((Object)filter0));
      assertNotSame(filter0, filter1);
      assertNotSame(filter1, filter0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isFocusTraversalPolicySet());
      
      filter0.setFilter(attributeSelection0);
      assertFalse(filter0.equals((Object)filter1));
      assertNotSame(filter0, filter1);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>A supervised attribute filter that can be used to select attributes</font><br><br> It is very flexible and allows various search and evaluation methods to be combined.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("AttributeSelection", filter0.getCustomName());
      assertEquals("A supervised attribute filter that can be used to select attributes. It is very flexible and allows various search and evaluation methods to be combined.", attributeSelection0.globalInfo());
      assertEquals("Determines how attributes/attribute subsets are evaluated.", attributeSelection0.evaluatorTipText());
      assertTrue(attributeSelection0.isNewBatch());
      assertFalse(attributeSelection0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(attributeSelection0.isOutputFormatDefined());
      assertFalse(attributeSelection0.isFirstBatchDone());
      assertEquals("Determines the search method.", attributeSelection0.searchTipText());
      
      // Undeclared exception!
      try { 
        filter1.setWrappedAlgorithm(appender1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // class weka.gui.beans.Appender : incorrect type of algorithm (Filter)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }
}
