/*
 * This file was automatically generated by EvoSuite
 * Sat Jul 07 04:10:05 GMT 2018
 */

package weka.classifiers;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.BorderLayout;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.event.KeyEvent;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import java.util.TreeSet;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import javax.swing.JLayeredPane;
import javax.swing.JSplitPane;
import javax.swing.JTree;
import javax.swing.plaf.nimbus.NimbusStyle;
import javax.swing.text.DefaultEditorKit;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.mock.java.util.MockRandom;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.EvoSuiteURL;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.testdata.NetworkHandling;
import org.junit.runner.RunWith;
import weka.attributeSelection.InfoGainAttributeEval;
import weka.classifiers.AbstractClassifier;
import weka.classifiers.Classifier;
import weka.classifiers.CostMatrix;
import weka.classifiers.Evaluation;
import weka.classifiers.bayes.BayesNet;
import weka.classifiers.bayes.NaiveBayesMultinomial;
import weka.classifiers.bayes.NaiveBayesMultinomialText;
import weka.classifiers.evaluation.output.prediction.XML;
import weka.classifiers.functions.GaussianProcesses;
import weka.classifiers.functions.SGDText;
import weka.classifiers.functions.SimpleLogistic;
import weka.classifiers.functions.supportVector.StringKernel;
import weka.classifiers.lazy.IBk;
import weka.classifiers.lazy.kstar.KStarConstants;
import weka.classifiers.meta.AdditiveRegression;
import weka.classifiers.meta.CVParameterSelection;
import weka.classifiers.meta.CostSensitiveClassifier;
import weka.classifiers.meta.RegressionByDiscretization;
import weka.classifiers.misc.InputMappedClassifier;
import weka.classifiers.misc.SerializedClassifier;
import weka.classifiers.rules.JRip;
import weka.classifiers.trees.DecisionStump;
import weka.classifiers.trees.J48;
import weka.classifiers.trees.LMT;
import weka.classifiers.trees.M5P;
import weka.clusterers.EM;
import weka.clusterers.SimpleKMeans;
import weka.core.Attribute;
import weka.core.BinarySparseInstance;
import weka.core.Capabilities;
import weka.core.DenseInstance;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.ListOptions;
import weka.core.SparseInstance;
import weka.core.TestInstances;
import weka.core.Utils;
import weka.core.converters.ArffLoader;
import weka.core.converters.C45Loader;
import weka.core.converters.DatabaseLoader;
import weka.core.converters.MatlabLoader;
import weka.core.converters.SVMLightLoader;
import weka.core.converters.SerializedInstancesLoader;
import weka.core.converters.TextDirectoryLoader;
import weka.core.converters.XRFFLoader;
import weka.core.neighboursearch.CoverTree;
import weka.filters.AllFilter;
import weka.filters.Filter;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class Evaluation_ESTest extends Evaluation_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      textDirectoryLoader0.reset();
      FileSystemHandling.shouldAllThrowIOExceptions();
      textDirectoryLoader0.listOptions();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      textDirectoryLoader0.setOutputFilename(true);
      Evaluation evaluation0 = new Evaluation(instances0);
      Utils.SMALL = (-10.0);
      double double0 = NimbusStyle.SMALL_SCALE;
      evaluation0.numFalseNegatives(17);
      evaluation0.SFPriorEntropy();
      evaluation0.rootMeanPriorSquaredError();
      assertEquals(0.0, evaluation0.SFEntropyGain(), 0.01);
      
      evaluation0.useNoPriors();
      assertEquals(Double.NaN, evaluation0.SFPriorEntropy(), 0.01);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      TestInstances testInstances0 = new TestInstances();
      assertNotNull(testInstances0);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals(0, testInstances0.getNumString());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(20, testInstances0.getNumInstances());
      assertFalse(testInstances0.getNoClass());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals("Testdata", testInstances0.getRelation());
      
      IBk iBk0 = new IBk();
      assertNotNull(iBk0);
      assertEquals(2, IBk.WEIGHT_INVERSE);
      assertEquals(1, IBk.WEIGHT_NONE);
      assertEquals(4, IBk.WEIGHT_SIMILARITY);
      assertEquals(1, iBk0.getKNN());
      assertEquals("Whether the mean squared error is used rather than mean absolute error when doing cross-validation for regression problems.", iBk0.meanSquaredTipText());
      assertEquals("Whether hold-one-out cross-validation will be used to select the best k value.", iBk0.crossValidateTipText());
      assertEquals("The nearest neighbour search algorithm to use (Default: weka.core.neighboursearch.LinearNNSearch).", iBk0.nearestNeighbourSearchAlgorithmTipText());
      assertEquals("Gets the maximum number of instances allowed in the training pool. The addition of new instances above this value will result in old instances being removed. A value of 0 signifies no limit to the number of training instances.", iBk0.windowSizeTipText());
      assertEquals(0, iBk0.getWindowSize());
      assertFalse(iBk0.getDebug());
      assertFalse(iBk0.getMeanSquared());
      assertEquals("The number of neighbours to use.", iBk0.KNNTipText());
      assertEquals("Gets the distance weighting method used.", iBk0.distanceWeightingTipText());
      assertFalse(iBk0.getCrossValidate());
      assertEquals("If set to true, classifier may output additional info to the console.", iBk0.debugTipText());
      
      AbstractClassifier.runClassifier(iBk0, testInstances0.DEFAULT_WORDS);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals(2, IBk.WEIGHT_INVERSE);
      assertEquals(1, IBk.WEIGHT_NONE);
      assertEquals(4, IBk.WEIGHT_SIMILARITY);
      assertEquals(0, testInstances0.getNumString());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(20, testInstances0.getNumInstances());
      assertFalse(testInstances0.getNoClass());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(1, iBk0.getKNN());
      assertEquals("Whether the mean squared error is used rather than mean absolute error when doing cross-validation for regression problems.", iBk0.meanSquaredTipText());
      assertEquals("Whether hold-one-out cross-validation will be used to select the best k value.", iBk0.crossValidateTipText());
      assertEquals("The nearest neighbour search algorithm to use (Default: weka.core.neighboursearch.LinearNNSearch).", iBk0.nearestNeighbourSearchAlgorithmTipText());
      assertEquals("Gets the maximum number of instances allowed in the training pool. The addition of new instances above this value will result in old instances being removed. A value of 0 signifies no limit to the number of training instances.", iBk0.windowSizeTipText());
      assertEquals(0, iBk0.getWindowSize());
      assertFalse(iBk0.getDebug());
      assertFalse(iBk0.getMeanSquared());
      assertEquals("The number of neighbours to use.", iBk0.KNNTipText());
      assertEquals("Gets the distance weighting method used.", iBk0.distanceWeightingTipText());
      assertFalse(iBk0.getCrossValidate());
      assertEquals("If set to true, classifier may output additional info to the console.", iBk0.debugTipText());
      
      Instances instances0 = testInstances0.generate();
      assertNotNull(instances0);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals(0, testInstances0.getNumString());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(20, testInstances0.getNumInstances());
      assertFalse(testInstances0.getNoClass());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals("Testdata", testInstances0.getRelation());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals(20, instances0.numInstances());
      assertEquals(1, instances0.classIndex());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(20, instances0.size());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      
      Evaluation evaluation0 = new Evaluation(instances0);
      assertNotNull(evaluation0);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals(0, testInstances0.getNumString());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(20, testInstances0.getNumInstances());
      assertFalse(testInstances0.getNoClass());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals("Testdata", testInstances0.getRelation());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals(20, instances0.numInstances());
      assertEquals(1, instances0.classIndex());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(20, instances0.size());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals(1.0, evaluation0.kappa(), 0.01);
      assertEquals(Double.NaN, evaluation0.sizeOfPredictedRegions(), 0.01);
      assertEquals(Double.NaN, evaluation0.meanAbsoluteError(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedTruePositiveRate(), 0.01);
      assertEquals(0.0, evaluation0.incorrect(), 0.01);
      assertEquals(0.0, evaluation0.totalCost(), 0.01);
      assertEquals(Double.NaN, evaluation0.meanPriorAbsoluteError(), 0.01);
      assertEquals(Double.NaN, evaluation0.pctIncorrect(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedFalsePositiveRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.errorRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedPrecision(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedRecall(), 0.01);
      assertEquals(Double.NaN, evaluation0.pctUnclassified(), 0.01);
      assertEquals(Double.NaN, evaluation0.rootMeanSquaredError(), 0.01);
      assertEquals(Double.NaN, evaluation0.relativeAbsoluteError(), 0.01);
      assertEquals(Double.NaN, evaluation0.rootMeanPriorSquaredError(), 0.01);
      assertFalse(evaluation0.getDiscardPredictions());
      assertEquals(Double.NaN, evaluation0.rootRelativeSquaredError(), 0.01);
      assertEquals(0.0, evaluation0.correct(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedFalseNegativeRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.SFMeanEntropyGain(), 0.01);
      assertEquals(0.0, evaluation0.SFEntropyGain(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedTrueNegativeRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.unweightedMicroFmeasure(), 0.01);
      assertEquals(Double.NaN, evaluation0.SFMeanPriorEntropy(), 0.01);
      assertEquals(0.0, evaluation0.SFPriorEntropy(), 0.01);
      assertEquals(0.0, evaluation0.unclassified(), 0.01);
      assertEquals(Double.NaN, evaluation0.SFMeanSchemeEntropy(), 0.01);
      assertEquals(0.0, evaluation0.SFSchemeEntropy(), 0.01);
      assertEquals(Double.NaN, evaluation0.avgCost(), 0.01);
      assertEquals(0.0, evaluation0.numInstances(), 0.01);
      assertEquals(Double.NaN, evaluation0.pctCorrect(), 0.01);
      assertEquals(Double.NaN, evaluation0.coverageOfTestCasesByPredictedRegions(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedFMeasure(), 0.01);
      
      Double double0 = new Double(1);
      assertNotNull(double0);
      assertEquals(1.0, (double)double0, 0.01);
      
      System.setCurrentTimeMillis(1);
      String string0 = Evaluation.getGlobalInfo(iBk0);
      assertNotNull(string0);
      assertEquals(2, IBk.WEIGHT_INVERSE);
      assertEquals(1, IBk.WEIGHT_NONE);
      assertEquals(4, IBk.WEIGHT_SIMILARITY);
      assertEquals(1, iBk0.getKNN());
      assertEquals("Whether the mean squared error is used rather than mean absolute error when doing cross-validation for regression problems.", iBk0.meanSquaredTipText());
      assertEquals("Whether hold-one-out cross-validation will be used to select the best k value.", iBk0.crossValidateTipText());
      assertEquals("The nearest neighbour search algorithm to use (Default: weka.core.neighboursearch.LinearNNSearch).", iBk0.nearestNeighbourSearchAlgorithmTipText());
      assertEquals("Gets the maximum number of instances allowed in the training pool. The addition of new instances above this value will result in old instances being removed. A value of 0 signifies no limit to the number of training instances.", iBk0.windowSizeTipText());
      assertEquals(0, iBk0.getWindowSize());
      assertFalse(iBk0.getDebug());
      assertFalse(iBk0.getMeanSquared());
      assertEquals("The number of neighbours to use.", iBk0.KNNTipText());
      assertEquals("Gets the distance weighting method used.", iBk0.distanceWeightingTipText());
      assertFalse(iBk0.getCrossValidate());
      assertEquals("If set to true, classifier may output additional info to the console.", iBk0.debugTipText());
      assertEquals("\nSynopsis for weka.classifiers.lazy.IBk:\n\nK-nearest neighbours classifier. Can select appropriate value of K based on cross-validation. Can also do distance weighting.\n\nFor more information, see\n\nD. Aha, D. Kibler (1991). Instance-based learning algorithms. Machine Learning. 6:37-66.", string0);
      
      Instances instances1 = evaluation0.getHeader();
      assertNotSame(instances0, instances1);
      assertNotSame(instances1, instances0);
      assertFalse(instances1.equals((Object)instances0));
      assertNotNull(instances1);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals(0, testInstances0.getNumString());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(20, testInstances0.getNumInstances());
      assertFalse(testInstances0.getNoClass());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals("Testdata", testInstances0.getRelation());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals(20, instances0.numInstances());
      assertEquals(1, instances0.classIndex());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(20, instances0.size());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals(1.0, evaluation0.kappa(), 0.01);
      assertEquals(Double.NaN, evaluation0.sizeOfPredictedRegions(), 0.01);
      assertEquals(Double.NaN, evaluation0.meanAbsoluteError(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedTruePositiveRate(), 0.01);
      assertEquals(0.0, evaluation0.incorrect(), 0.01);
      assertEquals(0.0, evaluation0.totalCost(), 0.01);
      assertEquals(Double.NaN, evaluation0.meanPriorAbsoluteError(), 0.01);
      assertEquals(Double.NaN, evaluation0.pctIncorrect(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedFalsePositiveRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.errorRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedPrecision(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedRecall(), 0.01);
      assertEquals(Double.NaN, evaluation0.pctUnclassified(), 0.01);
      assertEquals(Double.NaN, evaluation0.rootMeanSquaredError(), 0.01);
      assertEquals(Double.NaN, evaluation0.relativeAbsoluteError(), 0.01);
      assertEquals(Double.NaN, evaluation0.rootMeanPriorSquaredError(), 0.01);
      assertFalse(evaluation0.getDiscardPredictions());
      assertEquals(Double.NaN, evaluation0.rootRelativeSquaredError(), 0.01);
      assertEquals(0.0, evaluation0.correct(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedFalseNegativeRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.SFMeanEntropyGain(), 0.01);
      assertEquals(0.0, evaluation0.SFEntropyGain(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedTrueNegativeRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.unweightedMicroFmeasure(), 0.01);
      assertEquals(Double.NaN, evaluation0.SFMeanPriorEntropy(), 0.01);
      assertEquals(0.0, evaluation0.SFPriorEntropy(), 0.01);
      assertEquals(0.0, evaluation0.unclassified(), 0.01);
      assertEquals(Double.NaN, evaluation0.SFMeanSchemeEntropy(), 0.01);
      assertEquals(0.0, evaluation0.SFSchemeEntropy(), 0.01);
      assertEquals(Double.NaN, evaluation0.avgCost(), 0.01);
      assertEquals(0.0, evaluation0.numInstances(), 0.01);
      assertEquals(Double.NaN, evaluation0.pctCorrect(), 0.01);
      assertEquals(Double.NaN, evaluation0.coverageOfTestCasesByPredictedRegions(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedFMeasure(), 0.01);
      assertEquals(1, instances1.classIndex());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals("Testdata", instances1.relationName());
      assertEquals(2, instances1.numClasses());
      assertEquals(0, instances1.numInstances());
      assertEquals(2, instances1.numAttributes());
      assertFalse(instances1.checkForStringAttributes());
      assertEquals(0, instances1.size());
      
      double double1 = evaluation0.areaUnderROC(2);
      assertNotSame(instances0, instances1);
      assertFalse(instances0.equals((Object)instances1));
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals(0, testInstances0.getNumString());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(20, testInstances0.getNumInstances());
      assertFalse(testInstances0.getNoClass());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals("Testdata", testInstances0.getRelation());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals(20, instances0.numInstances());
      assertEquals(1, instances0.classIndex());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(20, instances0.size());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals(1.0, evaluation0.kappa(), 0.01);
      assertEquals(Double.NaN, evaluation0.sizeOfPredictedRegions(), 0.01);
      assertEquals(Double.NaN, evaluation0.meanAbsoluteError(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedTruePositiveRate(), 0.01);
      assertEquals(0.0, evaluation0.incorrect(), 0.01);
      assertEquals(0.0, evaluation0.totalCost(), 0.01);
      assertEquals(Double.NaN, evaluation0.meanPriorAbsoluteError(), 0.01);
      assertEquals(Double.NaN, evaluation0.pctIncorrect(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedFalsePositiveRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.errorRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedPrecision(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedRecall(), 0.01);
      assertEquals(Double.NaN, evaluation0.pctUnclassified(), 0.01);
      assertEquals(Double.NaN, evaluation0.rootMeanSquaredError(), 0.01);
      assertEquals(Double.NaN, evaluation0.relativeAbsoluteError(), 0.01);
      assertEquals(Double.NaN, evaluation0.rootMeanPriorSquaredError(), 0.01);
      assertFalse(evaluation0.getDiscardPredictions());
      assertEquals(Double.NaN, evaluation0.rootRelativeSquaredError(), 0.01);
      assertEquals(0.0, evaluation0.correct(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedFalseNegativeRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.SFMeanEntropyGain(), 0.01);
      assertEquals(0.0, evaluation0.SFEntropyGain(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedTrueNegativeRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.unweightedMicroFmeasure(), 0.01);
      assertEquals(Double.NaN, evaluation0.SFMeanPriorEntropy(), 0.01);
      assertEquals(0.0, evaluation0.SFPriorEntropy(), 0.01);
      assertEquals(0.0, evaluation0.unclassified(), 0.01);
      assertEquals(Double.NaN, evaluation0.SFMeanSchemeEntropy(), 0.01);
      assertEquals(0.0, evaluation0.SFSchemeEntropy(), 0.01);
      assertEquals(Double.NaN, evaluation0.avgCost(), 0.01);
      assertEquals(0.0, evaluation0.numInstances(), 0.01);
      assertEquals(Double.NaN, evaluation0.pctCorrect(), 0.01);
      assertEquals(Double.NaN, evaluation0.coverageOfTestCasesByPredictedRegions(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedFMeasure(), 0.01);
      assertEquals(Double.NaN, double1, 0.01);
      
      evaluation0.weightedRecall();
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      assertNotNull(inputMappedClassifier0);
      assertEquals("The base classifier to be used.", inputMappedClassifier0.classifierTipText());
      assertEquals("Set the path from which to load a model. Loading occurs when the first test instance is received. Environment variables can be used in the supplied path.", inputMappedClassifier0.modelPathTipText());
      assertEquals("Wrapper classifier that addresses incompatible training and test data by building a mapping between the training data that a classifier has been built with and the incoming test instances' structure. Model attributes that are not found in the incoming instances receive missing values, so do incoming nominal attribute values that the classifier has not seen before. A new classifier can be trained or an existing one loaded from a file.", inputMappedClassifier0.globalInfo());
      assertFalse(inputMappedClassifier0.getSuppressMappingReport());
      assertEquals(0, inputMappedClassifier0.graphType());
      assertEquals("Ignore case when matching attribute names and nomina values.", inputMappedClassifier0.ignoreCaseForNamesTipText());
      assertEquals("Trim white space from each end of attribute names and nominal values before matching.", inputMappedClassifier0.trimTipText());
      assertFalse(inputMappedClassifier0.getDebug());
      assertEquals("", inputMappedClassifier0.getModelPath());
      assertTrue(inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals("If set to true, classifier may output additional info to the console.", inputMappedClassifier0.debugTipText());
      assertTrue(inputMappedClassifier0.getTrim());
      assertEquals("Don't output a report of model-to-input mappings.", inputMappedClassifier0.suppressMappingReportTipText());
      
      IBk iBk0 = new IBk();
      assertNotNull(iBk0);
      assertEquals(2, IBk.WEIGHT_INVERSE);
      assertEquals(1, IBk.WEIGHT_NONE);
      assertEquals(4, IBk.WEIGHT_SIMILARITY);
      assertFalse(iBk0.getCrossValidate());
      assertEquals("The number of neighbours to use.", iBk0.KNNTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", iBk0.debugTipText());
      assertEquals("Whether the mean squared error is used rather than mean absolute error when doing cross-validation for regression problems.", iBk0.meanSquaredTipText());
      assertEquals(0, iBk0.getWindowSize());
      assertEquals("Whether hold-one-out cross-validation will be used to select the best k value.", iBk0.crossValidateTipText());
      assertEquals(1, iBk0.getKNN());
      assertEquals("Gets the distance weighting method used.", iBk0.distanceWeightingTipText());
      assertEquals("The nearest neighbour search algorithm to use (Default: weka.core.neighboursearch.LinearNNSearch).", iBk0.nearestNeighbourSearchAlgorithmTipText());
      assertEquals("Gets the maximum number of instances allowed in the training pool. The addition of new instances above this value will result in old instances being removed. A value of 0 signifies no limit to the number of training instances.", iBk0.windowSizeTipText());
      assertFalse(iBk0.getDebug());
      assertFalse(iBk0.getMeanSquared());
      
      TestInstances testInstances0 = new TestInstances();
      assertNotNull(testInstances0);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(1, testInstances0.getSeed());
      
      Instances instances0 = testInstances0.generate((String) null);
      assertNotNull(instances0);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, instances0.classIndex());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(20, instances0.size());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals("Testdata", instances0.relationName());
      
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 1;
      doubleArray0[1] = (double) 2;
      doubleArray0[2] = (double) 1;
      Instances instances1 = iBk0.pruneToK(instances0, doubleArray0, (-1024));
      assertNotSame(instances0, instances1);
      assertNotSame(instances1, instances0);
      assertFalse(instances1.equals((Object)instances0));
      assertNotNull(instances1);
      assertEquals(2, IBk.WEIGHT_INVERSE);
      assertEquals(1, IBk.WEIGHT_NONE);
      assertEquals(4, IBk.WEIGHT_SIMILARITY);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertFalse(iBk0.getCrossValidate());
      assertEquals("The number of neighbours to use.", iBk0.KNNTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", iBk0.debugTipText());
      assertEquals("Whether the mean squared error is used rather than mean absolute error when doing cross-validation for regression problems.", iBk0.meanSquaredTipText());
      assertEquals(0, iBk0.getWindowSize());
      assertEquals("Whether hold-one-out cross-validation will be used to select the best k value.", iBk0.crossValidateTipText());
      assertEquals(1, iBk0.getKNN());
      assertEquals("Gets the distance weighting method used.", iBk0.distanceWeightingTipText());
      assertEquals("The nearest neighbour search algorithm to use (Default: weka.core.neighboursearch.LinearNNSearch).", iBk0.nearestNeighbourSearchAlgorithmTipText());
      assertEquals("Gets the maximum number of instances allowed in the training pool. The addition of new instances above this value will result in old instances being removed. A value of 0 signifies no limit to the number of training instances.", iBk0.windowSizeTipText());
      assertFalse(iBk0.getDebug());
      assertFalse(iBk0.getMeanSquared());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, instances0.classIndex());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(20, instances0.size());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(1, instances1.numInstances());
      assertEquals(2, instances1.numAttributes());
      assertEquals(1.0, instances1.sumOfWeights(), 0.01);
      assertEquals(1, instances1.size());
      assertEquals(1, instances1.classIndex());
      assertEquals("Testdata", instances1.relationName());
      assertFalse(instances1.checkForStringAttributes());
      assertEquals(2, instances1.numClasses());
      assertArrayEquals(new double[] {1.0, 2.0, 1.0}, doubleArray0, 0.01);
      
      Instances instances2 = inputMappedClassifier0.getModelHeader(instances1);
      assertNotSame(instances0, instances2);
      assertNotSame(instances0, instances1);
      assertNotSame(instances1, instances0);
      assertNotSame(instances1, instances2);
      assertNotSame(instances2, instances0);
      assertNotSame(instances2, instances1);
      assertFalse(instances0.equals((Object)instances1));
      assertFalse(instances1.equals((Object)instances0));
      assertFalse(instances2.equals((Object)instances0));
      assertFalse(instances2.equals((Object)instances1));
      assertNotNull(instances2);
      assertEquals(2, IBk.WEIGHT_INVERSE);
      assertEquals(1, IBk.WEIGHT_NONE);
      assertEquals(4, IBk.WEIGHT_SIMILARITY);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals("The base classifier to be used.", inputMappedClassifier0.classifierTipText());
      assertEquals("Set the path from which to load a model. Loading occurs when the first test instance is received. Environment variables can be used in the supplied path.", inputMappedClassifier0.modelPathTipText());
      assertEquals("Wrapper classifier that addresses incompatible training and test data by building a mapping between the training data that a classifier has been built with and the incoming test instances' structure. Model attributes that are not found in the incoming instances receive missing values, so do incoming nominal attribute values that the classifier has not seen before. A new classifier can be trained or an existing one loaded from a file.", inputMappedClassifier0.globalInfo());
      assertFalse(inputMappedClassifier0.getSuppressMappingReport());
      assertEquals(0, inputMappedClassifier0.graphType());
      assertEquals("Ignore case when matching attribute names and nomina values.", inputMappedClassifier0.ignoreCaseForNamesTipText());
      assertEquals("Trim white space from each end of attribute names and nominal values before matching.", inputMappedClassifier0.trimTipText());
      assertFalse(inputMappedClassifier0.getDebug());
      assertEquals("", inputMappedClassifier0.getModelPath());
      assertTrue(inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals("If set to true, classifier may output additional info to the console.", inputMappedClassifier0.debugTipText());
      assertTrue(inputMappedClassifier0.getTrim());
      assertEquals("Don't output a report of model-to-input mappings.", inputMappedClassifier0.suppressMappingReportTipText());
      assertFalse(iBk0.getCrossValidate());
      assertEquals("The number of neighbours to use.", iBk0.KNNTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", iBk0.debugTipText());
      assertEquals("Whether the mean squared error is used rather than mean absolute error when doing cross-validation for regression problems.", iBk0.meanSquaredTipText());
      assertEquals(0, iBk0.getWindowSize());
      assertEquals("Whether hold-one-out cross-validation will be used to select the best k value.", iBk0.crossValidateTipText());
      assertEquals(1, iBk0.getKNN());
      assertEquals("Gets the distance weighting method used.", iBk0.distanceWeightingTipText());
      assertEquals("The nearest neighbour search algorithm to use (Default: weka.core.neighboursearch.LinearNNSearch).", iBk0.nearestNeighbourSearchAlgorithmTipText());
      assertEquals("Gets the maximum number of instances allowed in the training pool. The addition of new instances above this value will result in old instances being removed. A value of 0 signifies no limit to the number of training instances.", iBk0.windowSizeTipText());
      assertFalse(iBk0.getDebug());
      assertFalse(iBk0.getMeanSquared());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, instances0.classIndex());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(20, instances0.size());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(1, instances1.numInstances());
      assertEquals(2, instances1.numAttributes());
      assertEquals(1.0, instances1.sumOfWeights(), 0.01);
      assertEquals(1, instances1.size());
      assertEquals(1, instances1.classIndex());
      assertEquals("Testdata", instances1.relationName());
      assertFalse(instances1.checkForStringAttributes());
      assertEquals(2, instances1.numClasses());
      assertFalse(instances2.checkForStringAttributes());
      assertEquals(0, instances2.numInstances());
      assertEquals(2, instances2.numAttributes());
      assertEquals(0, instances2.size());
      assertEquals(0.0, instances2.sumOfWeights(), 0.01);
      assertEquals("Testdata", instances2.relationName());
      assertEquals(1, instances2.classIndex());
      assertEquals(2, instances2.numClasses());
      assertArrayEquals(new double[] {1.0, 2.0, 1.0}, doubleArray0, 0.01);
      
      Evaluation evaluation0 = new Evaluation(instances1);
      assertFalse(instances0.equals((Object)instances2));
      assertFalse(instances0.equals((Object)instances1));
      assertFalse(instances1.equals((Object)instances0));
      assertFalse(instances1.equals((Object)instances2));
      assertNotNull(evaluation0);
      assertEquals(2, IBk.WEIGHT_INVERSE);
      assertEquals(1, IBk.WEIGHT_NONE);
      assertEquals(4, IBk.WEIGHT_SIMILARITY);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertFalse(iBk0.getCrossValidate());
      assertEquals("The number of neighbours to use.", iBk0.KNNTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", iBk0.debugTipText());
      assertEquals("Whether the mean squared error is used rather than mean absolute error when doing cross-validation for regression problems.", iBk0.meanSquaredTipText());
      assertEquals(0, iBk0.getWindowSize());
      assertEquals("Whether hold-one-out cross-validation will be used to select the best k value.", iBk0.crossValidateTipText());
      assertEquals(1, iBk0.getKNN());
      assertEquals("Gets the distance weighting method used.", iBk0.distanceWeightingTipText());
      assertEquals("The nearest neighbour search algorithm to use (Default: weka.core.neighboursearch.LinearNNSearch).", iBk0.nearestNeighbourSearchAlgorithmTipText());
      assertEquals("Gets the maximum number of instances allowed in the training pool. The addition of new instances above this value will result in old instances being removed. A value of 0 signifies no limit to the number of training instances.", iBk0.windowSizeTipText());
      assertFalse(iBk0.getDebug());
      assertFalse(iBk0.getMeanSquared());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, instances0.classIndex());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(20, instances0.size());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(1, instances1.numInstances());
      assertEquals(2, instances1.numAttributes());
      assertEquals(1.0, instances1.sumOfWeights(), 0.01);
      assertEquals(1, instances1.size());
      assertEquals(1, instances1.classIndex());
      assertEquals("Testdata", instances1.relationName());
      assertFalse(instances1.checkForStringAttributes());
      assertEquals(2, instances1.numClasses());
      assertEquals(Double.NaN, evaluation0.sizeOfPredictedRegions(), 0.01);
      assertEquals(Double.NaN, evaluation0.meanPriorAbsoluteError(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedFalsePositiveRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.pctIncorrect(), 0.01);
      assertEquals(1.0, evaluation0.kappa(), 0.01);
      assertEquals(0.0, evaluation0.incorrect(), 0.01);
      assertEquals(Double.NaN, evaluation0.coverageOfTestCasesByPredictedRegions(), 0.01);
      assertEquals(0.0, evaluation0.SFPriorEntropy(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedPrecision(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedRecall(), 0.01);
      assertEquals(0.0, evaluation0.SFEntropyGain(), 0.01);
      assertEquals(Double.NaN, evaluation0.errorRate(), 0.01);
      assertEquals(0.0, evaluation0.totalCost(), 0.01);
      assertEquals(Double.NaN, evaluation0.meanAbsoluteError(), 0.01);
      assertEquals(Double.NaN, evaluation0.relativeAbsoluteError(), 0.01);
      assertEquals(0.0, evaluation0.unclassified(), 0.01);
      assertEquals(Double.NaN, evaluation0.SFMeanEntropyGain(), 0.01);
      assertEquals(Double.NaN, evaluation0.rootRelativeSquaredError(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedFalseNegativeRate(), 0.01);
      assertEquals(0.0, evaluation0.correct(), 0.01);
      assertEquals(Double.NaN, evaluation0.avgCost(), 0.01);
      assertEquals(Double.NaN, evaluation0.pctUnclassified(), 0.01);
      assertFalse(evaluation0.getDiscardPredictions());
      assertEquals(Double.NaN, evaluation0.rootMeanSquaredError(), 0.01);
      assertEquals(Double.NaN, evaluation0.SFMeanPriorEntropy(), 0.01);
      assertEquals(Double.NaN, evaluation0.rootMeanPriorSquaredError(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedTrueNegativeRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedFMeasure(), 0.01);
      assertEquals(Double.NaN, evaluation0.pctCorrect(), 0.01);
      assertEquals(0.0, evaluation0.numInstances(), 0.01);
      assertEquals(0.0, evaluation0.SFSchemeEntropy(), 0.01);
      assertEquals(Double.NaN, evaluation0.unweightedMicroFmeasure(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedTruePositiveRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.SFMeanSchemeEntropy(), 0.01);
      assertArrayEquals(new double[] {1.0, 2.0, 1.0}, doubleArray0, 0.01);
      
      Instances instances3 = instances2.resampleWithWeights((Random) null);
      assertNotSame(instances0, instances2);
      assertNotSame(instances0, instances3);
      assertNotSame(instances0, instances1);
      assertNotSame(instances1, instances0);
      assertNotSame(instances1, instances3);
      assertNotSame(instances1, instances2);
      assertNotSame(instances2, instances0);
      assertNotSame(instances2, instances3);
      assertNotSame(instances2, instances1);
      assertNotSame(instances3, instances1);
      assertNotSame(instances3, instances0);
      assertNotSame(instances3, instances2);
      assertFalse(instances0.equals((Object)instances2));
      assertFalse(instances0.equals((Object)instances1));
      assertFalse(instances1.equals((Object)instances0));
      assertFalse(instances1.equals((Object)instances2));
      assertFalse(instances2.equals((Object)instances0));
      assertFalse(instances2.equals((Object)instances1));
      assertTrue(instances3.equals((Object)instances2));
      assertFalse(instances3.equals((Object)instances1));
      assertFalse(instances3.equals((Object)instances0));
      assertNotNull(instances3);
      assertEquals(2, IBk.WEIGHT_INVERSE);
      assertEquals(1, IBk.WEIGHT_NONE);
      assertEquals(4, IBk.WEIGHT_SIMILARITY);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals("The base classifier to be used.", inputMappedClassifier0.classifierTipText());
      assertEquals("Set the path from which to load a model. Loading occurs when the first test instance is received. Environment variables can be used in the supplied path.", inputMappedClassifier0.modelPathTipText());
      assertEquals("Wrapper classifier that addresses incompatible training and test data by building a mapping between the training data that a classifier has been built with and the incoming test instances' structure. Model attributes that are not found in the incoming instances receive missing values, so do incoming nominal attribute values that the classifier has not seen before. A new classifier can be trained or an existing one loaded from a file.", inputMappedClassifier0.globalInfo());
      assertFalse(inputMappedClassifier0.getSuppressMappingReport());
      assertEquals(0, inputMappedClassifier0.graphType());
      assertEquals("Ignore case when matching attribute names and nomina values.", inputMappedClassifier0.ignoreCaseForNamesTipText());
      assertEquals("Trim white space from each end of attribute names and nominal values before matching.", inputMappedClassifier0.trimTipText());
      assertFalse(inputMappedClassifier0.getDebug());
      assertEquals("", inputMappedClassifier0.getModelPath());
      assertTrue(inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals("If set to true, classifier may output additional info to the console.", inputMappedClassifier0.debugTipText());
      assertTrue(inputMappedClassifier0.getTrim());
      assertEquals("Don't output a report of model-to-input mappings.", inputMappedClassifier0.suppressMappingReportTipText());
      assertFalse(iBk0.getCrossValidate());
      assertEquals("The number of neighbours to use.", iBk0.KNNTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", iBk0.debugTipText());
      assertEquals("Whether the mean squared error is used rather than mean absolute error when doing cross-validation for regression problems.", iBk0.meanSquaredTipText());
      assertEquals(0, iBk0.getWindowSize());
      assertEquals("Whether hold-one-out cross-validation will be used to select the best k value.", iBk0.crossValidateTipText());
      assertEquals(1, iBk0.getKNN());
      assertEquals("Gets the distance weighting method used.", iBk0.distanceWeightingTipText());
      assertEquals("The nearest neighbour search algorithm to use (Default: weka.core.neighboursearch.LinearNNSearch).", iBk0.nearestNeighbourSearchAlgorithmTipText());
      assertEquals("Gets the maximum number of instances allowed in the training pool. The addition of new instances above this value will result in old instances being removed. A value of 0 signifies no limit to the number of training instances.", iBk0.windowSizeTipText());
      assertFalse(iBk0.getDebug());
      assertFalse(iBk0.getMeanSquared());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, instances0.classIndex());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(20, instances0.size());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(1, instances1.numInstances());
      assertEquals(2, instances1.numAttributes());
      assertEquals(1.0, instances1.sumOfWeights(), 0.01);
      assertEquals(1, instances1.size());
      assertEquals(1, instances1.classIndex());
      assertEquals("Testdata", instances1.relationName());
      assertFalse(instances1.checkForStringAttributes());
      assertEquals(2, instances1.numClasses());
      assertFalse(instances2.checkForStringAttributes());
      assertEquals(0, instances2.numInstances());
      assertEquals(2, instances2.numAttributes());
      assertEquals(0, instances2.size());
      assertEquals(0.0, instances2.sumOfWeights(), 0.01);
      assertEquals("Testdata", instances2.relationName());
      assertEquals(1, instances2.classIndex());
      assertEquals(2, instances2.numClasses());
      assertEquals(0, instances3.numInstances());
      assertEquals(2, instances3.numAttributes());
      assertEquals(2, instances3.numClasses());
      assertEquals("Testdata", instances3.relationName());
      assertEquals(1, instances3.classIndex());
      assertEquals(0, instances3.size());
      assertEquals(0.0, instances3.sumOfWeights(), 0.01);
      assertFalse(instances3.checkForStringAttributes());
      assertArrayEquals(new double[] {1.0, 2.0, 1.0}, doubleArray0, 0.01);
      
      String string0 = Evaluation.makeOptionString(inputMappedClassifier0, false);
      assertNotNull(string0);
      assertEquals("The base classifier to be used.", inputMappedClassifier0.classifierTipText());
      assertEquals("Set the path from which to load a model. Loading occurs when the first test instance is received. Environment variables can be used in the supplied path.", inputMappedClassifier0.modelPathTipText());
      assertEquals("Wrapper classifier that addresses incompatible training and test data by building a mapping between the training data that a classifier has been built with and the incoming test instances' structure. Model attributes that are not found in the incoming instances receive missing values, so do incoming nominal attribute values that the classifier has not seen before. A new classifier can be trained or an existing one loaded from a file.", inputMappedClassifier0.globalInfo());
      assertFalse(inputMappedClassifier0.getSuppressMappingReport());
      assertEquals(0, inputMappedClassifier0.graphType());
      assertEquals("Ignore case when matching attribute names and nomina values.", inputMappedClassifier0.ignoreCaseForNamesTipText());
      assertEquals("Trim white space from each end of attribute names and nominal values before matching.", inputMappedClassifier0.trimTipText());
      assertFalse(inputMappedClassifier0.getDebug());
      assertEquals("", inputMappedClassifier0.getModelPath());
      assertTrue(inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals("If set to true, classifier may output additional info to the console.", inputMappedClassifier0.debugTipText());
      assertTrue(inputMappedClassifier0.getTrim());
      assertEquals("Don't output a report of model-to-input mappings.", inputMappedClassifier0.suppressMappingReportTipText());
      
      double double0 = evaluation0.weightedAreaUnderROC();
      assertNotSame(instances0, instances2);
      assertNotSame(instances0, instances3);
      assertNotSame(instances0, instances1);
      assertNotSame(instances1, instances0);
      assertNotSame(instances1, instances3);
      assertNotSame(instances1, instances2);
      assertFalse(instances0.equals((Object)instances2));
      assertFalse(instances0.equals((Object)instances3));
      assertFalse(instances0.equals((Object)instances1));
      assertFalse(instances1.equals((Object)instances0));
      assertFalse(instances1.equals((Object)instances3));
      assertFalse(instances1.equals((Object)instances2));
      assertEquals(2, IBk.WEIGHT_INVERSE);
      assertEquals(1, IBk.WEIGHT_NONE);
      assertEquals(4, IBk.WEIGHT_SIMILARITY);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertFalse(iBk0.getCrossValidate());
      assertEquals("The number of neighbours to use.", iBk0.KNNTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", iBk0.debugTipText());
      assertEquals("Whether the mean squared error is used rather than mean absolute error when doing cross-validation for regression problems.", iBk0.meanSquaredTipText());
      assertEquals(0, iBk0.getWindowSize());
      assertEquals("Whether hold-one-out cross-validation will be used to select the best k value.", iBk0.crossValidateTipText());
      assertEquals(1, iBk0.getKNN());
      assertEquals("Gets the distance weighting method used.", iBk0.distanceWeightingTipText());
      assertEquals("The nearest neighbour search algorithm to use (Default: weka.core.neighboursearch.LinearNNSearch).", iBk0.nearestNeighbourSearchAlgorithmTipText());
      assertEquals("Gets the maximum number of instances allowed in the training pool. The addition of new instances above this value will result in old instances being removed. A value of 0 signifies no limit to the number of training instances.", iBk0.windowSizeTipText());
      assertFalse(iBk0.getDebug());
      assertFalse(iBk0.getMeanSquared());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, instances0.classIndex());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(20, instances0.size());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(1, instances1.numInstances());
      assertEquals(2, instances1.numAttributes());
      assertEquals(1.0, instances1.sumOfWeights(), 0.01);
      assertEquals(1, instances1.size());
      assertEquals(1, instances1.classIndex());
      assertEquals("Testdata", instances1.relationName());
      assertFalse(instances1.checkForStringAttributes());
      assertEquals(2, instances1.numClasses());
      assertEquals(Double.NaN, evaluation0.sizeOfPredictedRegions(), 0.01);
      assertEquals(Double.NaN, evaluation0.meanPriorAbsoluteError(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedFalsePositiveRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.pctIncorrect(), 0.01);
      assertEquals(1.0, evaluation0.kappa(), 0.01);
      assertEquals(0.0, evaluation0.incorrect(), 0.01);
      assertEquals(Double.NaN, evaluation0.coverageOfTestCasesByPredictedRegions(), 0.01);
      assertEquals(0.0, evaluation0.SFPriorEntropy(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedPrecision(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedRecall(), 0.01);
      assertEquals(0.0, evaluation0.SFEntropyGain(), 0.01);
      assertEquals(Double.NaN, evaluation0.errorRate(), 0.01);
      assertEquals(0.0, evaluation0.totalCost(), 0.01);
      assertEquals(Double.NaN, evaluation0.meanAbsoluteError(), 0.01);
      assertEquals(Double.NaN, evaluation0.relativeAbsoluteError(), 0.01);
      assertEquals(0.0, evaluation0.unclassified(), 0.01);
      assertEquals(Double.NaN, evaluation0.SFMeanEntropyGain(), 0.01);
      assertEquals(Double.NaN, evaluation0.rootRelativeSquaredError(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedFalseNegativeRate(), 0.01);
      assertEquals(0.0, evaluation0.correct(), 0.01);
      assertEquals(Double.NaN, evaluation0.avgCost(), 0.01);
      assertEquals(Double.NaN, evaluation0.pctUnclassified(), 0.01);
      assertFalse(evaluation0.getDiscardPredictions());
      assertEquals(Double.NaN, evaluation0.rootMeanSquaredError(), 0.01);
      assertEquals(Double.NaN, evaluation0.SFMeanPriorEntropy(), 0.01);
      assertEquals(Double.NaN, evaluation0.rootMeanPriorSquaredError(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedTrueNegativeRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedFMeasure(), 0.01);
      assertEquals(Double.NaN, evaluation0.pctCorrect(), 0.01);
      assertEquals(0.0, evaluation0.numInstances(), 0.01);
      assertEquals(0.0, evaluation0.SFSchemeEntropy(), 0.01);
      assertEquals(Double.NaN, evaluation0.unweightedMicroFmeasure(), 0.01);
      assertEquals(Double.NaN, evaluation0.weightedTruePositiveRate(), 0.01);
      assertEquals(Double.NaN, evaluation0.SFMeanSchemeEntropy(), 0.01);
      assertEquals(Double.NaN, double0, 0.01);
      assertArrayEquals(new double[] {1.0, 2.0, 1.0}, doubleArray0, 0.01);
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      CostMatrix costMatrix0 = new CostMatrix(0);
      Evaluation evaluation0 = new Evaluation(instances0, costMatrix0);
      evaluation0.totalCost();
      evaluation0.toClassDetailsString();
      evaluation0.coverageOfTestCasesByPredictedRegions();
      evaluation0.confusionMatrix();
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.getModelHeader(instances0);
      Instances instances1 = new Instances(instances0);
      String string0 = JTree.TREE_MODEL_PROPERTY;
      AllFilter allFilter0 = new AllFilter();
      evaluation0.falseNegativeRate(480);
      evaluation0.KBMeanInformation();
      System.setCurrentTimeMillis(0L);
      evaluation0.SFMeanPriorEntropy();
      evaluation0.weightedMatthewsCorrelation();
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      textDirectoryLoader0.setDebug(false);
      Instances instances0 = textDirectoryLoader0.getStructure();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      textDirectoryLoader0.setOutputFilename(false);
      Evaluation evaluation0 = new Evaluation(instances0);
      Utils.SMALL = (-10.0);
      evaluation0.KBMeanInformation();
      evaluation0.numFalseNegatives(17);
      double double0 = evaluation0.m_WithClass;
      evaluation0.rootMeanPriorSquaredError();
      evaluation0.weightedFMeasure();
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      try { 
        Evaluation.handleCostOption("A", 2597);
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // Can't open file null.
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      J48 j48_0 = new J48();
      j48_0.enumerateMeasures();
      try { 
        Evaluation.wekaStaticWrapper(j48_0, "Clas asto be nominal if costmatrix given!");
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.trees.J48", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      CostSensitiveClassifier costSensitiveClassifier0 = new CostSensitiveClassifier();
      costSensitiveClassifier0.getCostMatrix();
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.getRevision();
      evaluation0.coverageOfTestCasesByPredictedRegions();
      evaluation0.addNumericTrainClass(359.74466345, (-1.0));
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      IBk iBk0 = new IBk(245);
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate((String) null);
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 1;
      doubleArray0[1] = (double) 2;
      doubleArray0[2] = 0.0;
      Instances instances1 = iBk0.pruneToK(instances0, doubleArray0, (-1024));
      Instances instances2 = inputMappedClassifier0.getModelHeader(instances1);
      Instances instances3 = new Instances(instances2);
      Evaluation evaluation0 = new Evaluation(instances3);
      instances2.resampleWithWeights((Random) null);
      evaluation0.useNoPriors();
      evaluation0.weightedRecall();
      Evaluation.main(testInstances0.DEFAULT_WORDS);
      evaluation0.meanPriorAbsoluteError();
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate((String) null);
      FileSystemHandling.shouldAllThrowIOExceptions();
      Evaluation evaluation0 = new Evaluation(instances0);
      String string0 = BorderLayout.PAGE_START;
      evaluation0.weightedAreaUnderPRC();
      evaluation0.m_ClassPriorsSum = (-1065.250832);
      RegressionByDiscretization regressionByDiscretization0 = new RegressionByDiscretization();
      try { 
        evaluation0.correlationCoefficient();
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // Can't compute correlation coefficient: class is nominal!
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      TestInstances testInstances0 = new TestInstances();
      testInstances0.setSeed((-1));
      Instances instances0 = testInstances0.generate((String) null);
      instances0.parallelStream();
      IBk iBk0 = new IBk((-1));
      iBk0.buildClassifier(instances0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      textDirectoryLoader0.setOutputFilename(true);
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.KBMeanInformation();
      evaluation0.numFalseNegatives((-1112551771));
      evaluation0.SFPriorEntropy();
      evaluation0.rootMeanPriorSquaredError();
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      TestInstances testInstances0 = new TestInstances();
      testInstances0.setSeed(2775);
      Instances instances0 = testInstances0.generate((String) null);
      instances0.parallelStream();
      IBk iBk0 = new IBk((-1));
      iBk0.buildClassifier(instances0);
      Instances instances1 = new Instances(instances0, 7);
      inputMappedClassifier0.setSuppressMappingReport(false);
      Evaluation evaluation0 = new Evaluation(instances1);
      evaluation0.useNoPriors();
      inputMappedClassifier0.setClassifier(iBk0);
      testInstances0.setNumNominalValues((-52377651));
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(1);
      instances0.spliterator();
      NaiveBayesMultinomial naiveBayesMultinomial0 = new NaiveBayesMultinomial();
      Evaluation.getGlobalInfo(naiveBayesMultinomial0);
      ArffLoader arffLoader0 = new ArffLoader();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) (-2);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, true);
      MockRandom mockRandom0 = new MockRandom(585L);
      evaluation0.addNumericTrainClass((-1), 1);
      evaluation0.weightedFalsePositiveRate();
      evaluation0.meanAbsoluteError();
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate((String) null);
      CostMatrix costMatrix0 = null;
      Evaluation evaluation0 = new Evaluation(instances0, (CostMatrix) null);
      evaluation0.toClassDetailsString();
      evaluation0.coverageOfTestCasesByPredictedRegions();
      // Undeclared exception!
      try { 
        evaluation0.makeDistribution(2718.97705);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2718
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate((String) null);
      instances0.parallelStream();
      Instances instances1 = testInstances0.getData();
      Instances instances2 = new Instances(instances1);
      Evaluation evaluation0 = new Evaluation(instances2);
      String string0 = XML.TAG_ATTRIBUTES;
      evaluation0.matthewsCorrelationCoefficient((-220));
      evaluation0.falseNegativeRate(195225776);
      evaluation0.KBMeanInformation();
      System.setCurrentTimeMillis(20);
      evaluation0.SFMeanSchemeEntropy();
      // Undeclared exception!
      try { 
        evaluation0.makeDistribution((-1878.932));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1878
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate();
      IBk iBk0 = new IBk();
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.matthewsCorrelationCoefficient(1);
      Double double0 = new Double((-1));
      String string0 = DefaultEditorKit.EndOfLineStringProperty;
      evaluation0.toSummaryString(true);
      evaluation0.KBRelativeInformation();
      System.setCurrentTimeMillis((-1));
      DecisionStump decisionStump0 = new DecisionStump();
      evaluation0.meanAbsoluteError();
      evaluation0.priorEntropy();
      evaluation0.rootRelativeSquaredError();
      Evaluation.main(testInstances0.DEFAULT_WORDS);
      evaluation0.toCumulativeMarginDistributionString();
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      textDirectoryLoader0.getDataSet();
      TestInstances testInstances0 = new TestInstances();
      IBk iBk0 = new IBk();
      AbstractClassifier.runClassifier(iBk0, testInstances0.DEFAULT_WORDS);
      testInstances0.setNumRelationalString(0);
      Instances instances0 = testInstances0.generate();
      Evaluation evaluation0 = new Evaluation(instances0);
      Double double0 = new Double(1);
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      evaluation0.KBMeanInformation();
      evaluation0.weightedPrecision();
      double double1 = KStarConstants.INITIAL_STEP;
      double double2 = evaluation0.m_MaxTarget;
      evaluation0.getDiscardPredictions();
      evaluation0.numFalsePositives(1);
      evaluation0.SFMeanEntropyGain();
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      IBk iBk0 = new IBk(245);
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate((String) null);
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 1;
      doubleArray0[1] = (double) 2;
      doubleArray0[2] = 0.0;
      iBk0.pruneToK(instances0, doubleArray0, 1);
      Instances instances1 = new Instances(instances0);
      Evaluation evaluation0 = new Evaluation(instances1);
      evaluation0.falsePositiveRate((-1));
      evaluation0.useNoPriors();
      evaluation0.weightedRecall();
      evaluation0.SFEntropyGain();
      evaluation0.falseNegativeRate(1166);
      evaluation0.SFMeanPriorEntropy();
      evaluation0.weightedMatthewsCorrelation();
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      IBk iBk0 = new IBk();
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate((String) null);
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.trueNegativeRate(4);
      double double0 = evaluation0.m_SumSqrClass;
      try { 
        evaluation0.correlationCoefficient();
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // Can't compute correlation coefficient: class is nominal!
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getStructure();
      FileSystemHandling.shouldAllThrowIOExceptions();
      textDirectoryLoader0.listOptions();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      textDirectoryLoader0.setOutputFilename(false);
      Evaluation evaluation0 = new Evaluation(instances0);
      Utils.SMALL = (-10.0);
      double double0 = NimbusStyle.SMALL_SCALE;
      evaluation0.numFalseNegatives(17);
      evaluation0.meanPriorAbsoluteError();
      evaluation0.setDiscardPredictions(true);
      evaluation0.KBRelativeInformation();
      evaluation0.numInstances();
      evaluation0.meanAbsoluteError();
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      IBk iBk0 = new IBk();
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate(" ");
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 1;
      doubleArray0[1] = (double) 2;
      doubleArray0[2] = (double) 1;
      Instances instances1 = iBk0.pruneToK(instances0, doubleArray0, (-1024));
      Instances instances2 = inputMappedClassifier0.getModelHeader(instances1);
      Evaluation evaluation0 = new Evaluation(instances1);
      instances2.resampleWithWeights((Random) null);
      Evaluation.makeOptionString(inputMappedClassifier0, false);
      evaluation0.weightedFalseNegativeRate();
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate(" ");
      Evaluation evaluation0 = new Evaluation(instances0);
      double double0 = KStarConstants.LOG2;
      evaluation0.toMatrixString();
      Evaluation.makeOptionString(inputMappedClassifier0, false);
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      IBk iBk0 = new IBk(245);
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate((String) null);
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 1;
      doubleArray0[1] = (double) 2;
      doubleArray0[2] = 0.0;
      Instances instances1 = iBk0.pruneToK(instances0, doubleArray0, (-1024));
      Instances instances2 = inputMappedClassifier0.getModelHeader(instances1);
      Instances instances3 = new Instances(instances2);
      Evaluation evaluation0 = new Evaluation(instances3);
      evaluation0.correct();
      evaluation0.numInstances();
      CostMatrix costMatrix0 = null;
      try {
        costMatrix0 = new CostMatrix((-1024));
        fail("Expecting exception: NegativeArraySizeException");
      
      } catch(NegativeArraySizeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.CostMatrix", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      FileSystemHandling.shouldAllThrowIOExceptions();
      Evaluation.handleCostOption("", 2615);
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate();
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.getModelHeader(instances0);
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.toSummaryString(true);
      double double0 = evaluation0.m_SumClass;
      String string0 = JSplitPane.RIGHT;
      evaluation0.relativeAbsoluteError();
      TreeSet<Attribute> treeSet0 = new TreeSet<Attribute>();
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>(treeSet0);
      Instances instances1 = new Instances("getShrinkage", arrayList0, 2615);
      Evaluation evaluation1 = null;
      try {
        evaluation1 = new Evaluation(instances1, (CostMatrix) null);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // Class index is negative (not set)!
         //
         verifyException("weka.core.Instances", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      CostMatrix costMatrix0 = new CostMatrix(0);
      Evaluation evaluation0 = new Evaluation(instances0, costMatrix0);
      SerializedClassifier serializedClassifier0 = new SerializedClassifier();
      String[] stringArray0 = new String[6];
      stringArray0[0] = "@relation";
      stringArray0[3] = ".bsi";
      stringArray0[4] = ".cost";
      stringArray0[5] = "@data";
      double[] doubleArray0 = new double[3];
      doubleArray0[1] = (double) (-1024);
      doubleArray0[2] = (double) 0;
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.getModelHeader(instances0);
      evaluation0.useNoPriors();
      evaluation0.weightedRecall();
      Evaluation.main(stringArray0);
      evaluation0.toClassDetailsString();
      evaluation0.getClassPriors();
      evaluation0.weightedFalseNegativeRate();
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate((String) null);
      NetworkHandling.createRemoteTextFile((EvoSuiteURL) null, "Zz7`>y2");
      Evaluation evaluation0 = new Evaluation(instances0);
      double double0 = evaluation0.m_TotalCoverage;
      evaluation0.errorRate();
      evaluation0.KBMeanInformation();
      evaluation0.meanPriorAbsoluteError();
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      TestInstances testInstances0 = new TestInstances();
      testInstances0.setSeed(2779);
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/home/users/apanichella/wekafiles");
      FileSystemHandling.shouldAllThrowIOExceptions();
      Instances instances0 = testInstances0.generate((String) null);
      IBk iBk0 = new IBk((-1));
      iBk0.buildClassifier(instances0);
      Instances instances1 = new Instances(instances0, 7);
      Evaluation evaluation0 = new Evaluation(instances1);
      evaluation0.useNoPriors();
      inputMappedClassifier0.setClassifier(iBk0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      FileSystemHandling.appendStringToFile(evoSuiteFile0, "seedTipText");
      inputMappedClassifier0.getCapabilities();
      evaluation0.weightedRecall();
      Evaluation.main(testInstances0.DEFAULT_WORDS);
      String string0 = JSplitPane.RIGHT;
      evaluation0.relativeAbsoluteError();
      try { 
        evaluation0.evaluateModel((Classifier) inputMappedClassifier0, instances1, (Object[]) iBk0.TAGS_WEIGHTING);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // weka.core.Tag cannot be cast to weka.classifiers.evaluation.output.prediction.AbstractOutput
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      CostMatrix costMatrix0 = new CostMatrix(0);
      Evaluation evaluation0 = new Evaluation(instances0, costMatrix0);
      SerializedClassifier serializedClassifier0 = new SerializedClassifier();
      String[] stringArray0 = new String[6];
      stringArray0[0] = "@relation";
      stringArray0[2] = "@data";
      stringArray0[3] = ".bsi";
      TestInstances testInstances0 = new TestInstances();
      evaluation0.addNumericTrainClass(0.0, (-11.0));
      String string0 = XML.TAG_ATTRIBUTES;
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/mnt/gaiagpfs/users/homedirs/apanichella/Evosuite_performance/Dataset/gordon_script_sum/projects/9_weka");
      FileSystemHandling.setPermissions(evoSuiteFile0, true, true, false);
      IBk iBk0 = new IBk(6);
      iBk0.setCrossValidate(true);
      evaluation0.matthewsCorrelationCoefficient((-1832));
      evaluation0.falseNegativeRate(109);
      evaluation0.errorRate();
      evaluation0.sizeOfPredictedRegions();
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate((String) null);
      Evaluation evaluation0 = new Evaluation(instances0);
      double double0 = KStarConstants.LOG2;
      evaluation0.toMatrixString();
      try { 
        evaluation0.evaluateModelOnceAndRecordPrediction((Classifier) inputMappedClassifier0, (Instance) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate((String) null);
      int int0 = (-1024);
      IBk iBk0 = new IBk();
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = 5516.809250627;
      doubleArray0[1] = (double) (-2);
      doubleArray0[2] = (double) 2;
      Instances instances1 = iBk0.pruneToK(instances0, doubleArray0, (-1024));
      Instances instances2 = inputMappedClassifier0.getModelHeader(instances1);
      Instances instances3 = new Instances(instances0);
      Evaluation evaluation0 = new Evaluation(instances0);
      Instances instances4 = new Instances(instances2, 1);
      String string0 = XML.TAG_ATTRIBUTES;
      MockRandom mockRandom0 = new MockRandom((-1L));
      try { 
        evaluation0.crossValidateModel("pr?&|W&{Kz(~", instances4, (-354), testInstances0.DEFAULT_WORDS, (Random) mockRandom0);
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // Can't find class called: pr?&|W&{Kz(~
         //
         verifyException("weka.core.Utils", e);
      }
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      CostMatrix costMatrix0 = new CostMatrix(0);
      Evaluation evaluation0 = new Evaluation(instances0, costMatrix0);
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = (double) 0;
      doubleArray0[1] = (double) 0;
      doubleArray0[3] = (double) 0;
      doubleArray0[4] = (double) 0;
      doubleArray0[5] = (double) 0;
      String string0 = JSplitPane.RIGHT;
      Attribute attribute0 = new Attribute(".arff", instances0, 0);
      instances0.renameAttribute(attribute0, "string");
      Object[] objectArray0 = new Object[1];
      evaluation0.setDiscardPredictions(false);
      evaluation0.rootMeanPriorSquaredError();
      evaluation0.weightedTrueNegativeRate();
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate(" ");
      Evaluation evaluation0 = new Evaluation(instances0);
      double double0 = evaluation0.m_TotalCoverage;
      evaluation0.sizeOfPredictedRegions();
      evaluation0.addNumericTrainClass(0.125, 0.0);
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, true);
      Evaluation.handleCostOption("", 2597);
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate();
      Evaluation evaluation0 = new Evaluation(instances0, (CostMatrix) null);
      double[] doubleArray0 = new double[3];
      evaluation0.addNumericTrainClass((-1), (-1));
      AllFilter allFilter0 = new AllFilter();
      // Undeclared exception!
      try { 
        allFilter0.output();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // No output instance format defined
         //
         verifyException("weka.filters.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      IBk iBk0 = new IBk(245);
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate((String) null);
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 1;
      doubleArray0[1] = (double) 2;
      doubleArray0[2] = 0.0;
      Instances instances1 = iBk0.pruneToK(instances0, doubleArray0, (-1024));
      Evaluation evaluation0 = new Evaluation(instances1);
      evaluation0.falsePositiveRate((-1));
      evaluation0.useNoPriors();
      evaluation0.weightedRecall();
      evaluation0.SFEntropyGain();
      evaluation0.toMatrixString();
      evaluation0.errorRate();
      evaluation0.sizeOfPredictedRegions();
      evaluation0.SFPriorEntropy();
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      IBk iBk0 = new IBk();
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate("\n=== Predictions under cross-validation ===\n\n");
      Evaluation evaluation0 = new Evaluation(instances0);
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      Integer integer0 = JLayeredPane.POPUP_LAYER;
      evaluation0.KBMeanInformation();
      inputMappedClassifier0.buildClassifier(instances0);
      System.setCurrentTimeMillis(0L);
      evaluation0.SFMeanPriorEntropy();
      RegressionByDiscretization regressionByDiscretization0 = new RegressionByDiscretization();
      try { 
        evaluation0.updateStatsForConditionalDensityEstimator(regressionByDiscretization0, (Instance) null, Double.NaN);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.meta.RegressionByDiscretization", e);
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate();
      IBk iBk0 = new IBk();
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      AbstractClassifier.makeCopy(inputMappedClassifier0);
      inputMappedClassifier0.getModelHeader(instances0);
      Evaluation evaluation0 = new Evaluation(instances0);
      Double double0 = new Double((-1));
      String string0 = DefaultEditorKit.EndOfLineStringProperty;
      evaluation0.toSummaryString(true);
      evaluation0.KBRelativeInformation();
      System.setCurrentTimeMillis((-1));
      DecisionStump decisionStump0 = new DecisionStump();
      Predicate<Object> predicate0 = Predicate.isEqual((Object) decisionStump0);
      Predicate<Object> predicate1 = predicate0.negate();
      evaluation0.SFPriorEntropy();
      instances0.removeIf(predicate1);
      evaluation0.SFSchemeEntropy();
      evaluation0.SFMeanPriorEntropy();
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      TestInstances testInstances0 = new TestInstances();
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, (byte[]) null);
      IBk iBk0 = new IBk((-2));
      TestInstances testInstances1 = new TestInstances();
      Instances instances0 = testInstances1.generate("getClass");
      UnaryOperator<Instance> unaryOperator0 = UnaryOperator.identity();
      instances0.replaceAll(unaryOperator0);
      Evaluation evaluation0 = new Evaluation(instances0, (CostMatrix) null);
      evaluation0.falseNegativeRate((-2));
      Evaluation evaluation1 = new Evaluation(instances0, (CostMatrix) null);
      evaluation1.falsePositiveRate(91);
      evaluation0.weightedRecall();
      StringKernel stringKernel0 = new StringKernel();
      Capabilities capabilities0 = stringKernel0.getCapabilities();
      TestInstances testInstances2 = TestInstances.forCapabilities(capabilities0);
      testInstances2.getOptions();
      Evaluation evaluation2 = new Evaluation(instances0);
      Evaluation evaluation3 = new Evaluation(instances0, (CostMatrix) null);
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = (double) (-1);
      doubleArray0[1] = Double.NaN;
      evaluation3.updateNumericScores(doubleArray0, doubleArray0, 2147483645);
      SimpleLogistic simpleLogistic0 = new SimpleLogistic();
      evaluation2.weightedTrueNegativeRate();
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      Evaluation.handleCostOption("", 2615);
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate();
      IBk iBk0 = new IBk();
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      Instances instances1 = inputMappedClassifier0.getModelHeader(instances0);
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.matthewsCorrelationCoefficient(1);
      InputMappedClassifier inputMappedClassifier1 = new InputMappedClassifier();
      InputMappedClassifier inputMappedClassifier2 = new InputMappedClassifier();
      Instances instances2 = inputMappedClassifier2.getModelHeader(instances1);
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(2615);
      evaluation0.areaUnderPRC(1);
      Evaluation evaluation1 = new Evaluation(instances2, (CostMatrix) null);
      evaluation1.trueNegativeRate(1);
      // Undeclared exception!
      try { 
        evaluation1.fMeasure(122);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 122
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      SimpleLogistic simpleLogistic0 = new SimpleLogistic();
      AdditiveRegression additiveRegression0 = new AdditiveRegression(simpleLogistic0);
      Capabilities capabilities0 = additiveRegression0.getCapabilities();
      TestInstances testInstances0 = TestInstances.forCapabilities(capabilities0);
      Instances instances0 = testInstances0.generate("weka/core/Capabilities.props");
      TestInstances.main(testInstances0.DEFAULT_WORDS);
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      Instances instances1 = inputMappedClassifier0.getModelHeader(instances0);
      Instances instances2 = new Instances(instances1);
      String string0 = DefaultEditorKit.selectParagraphAction;
      Evaluation evaluation0 = new Evaluation(instances2);
      IBk iBk0 = new IBk();
      iBk0.setCrossValidate(false);
      evaluation0.falseNegativeRate((-3359));
      double[] doubleArray0 = new double[0];
      DenseInstance denseInstance0 = new DenseInstance(0.125, doubleArray0);
      Attribute attribute0 = null;
      // Undeclared exception!
      try { 
        evaluation0.trueNegativeRate((-3359));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      SimpleLogistic simpleLogistic0 = new SimpleLogistic();
      AdditiveRegression additiveRegression0 = new AdditiveRegression(simpleLogistic0);
      Capabilities capabilities0 = additiveRegression0.getCapabilities();
      TestInstances testInstances0 = TestInstances.forCapabilities(capabilities0);
      Instances instances0 = testInstances0.generate("weka/core/Capabilities.props");
      Evaluation evaluation0 = new Evaluation(instances0);
      double double0 = evaluation0.m_TotalCoverage;
      evaluation0.correlationCoefficient();
      try { 
        evaluation0.toMatrixString();
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // Evaluation: No confusion matrix possible!
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      CostMatrix costMatrix0 = new CostMatrix(0);
      Evaluation evaluation0 = new Evaluation(instances0, costMatrix0);
      SerializedClassifier serializedClassifier0 = new SerializedClassifier();
      String[] stringArray0 = new String[6];
      stringArray0[0] = "@relation";
      stringArray0[2] = "@data";
      stringArray0[3] = ".bsi";
      stringArray0[4] = ".cost";
      stringArray0[5] = "@data";
      double[] doubleArray0 = new double[3];
      doubleArray0[2] = (double) (-1024);
      doubleArray0[2] = (double) 0;
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.getModelHeader(instances0);
      evaluation0.useNoPriors();
      evaluation0.weightedRecall();
      Evaluation.main(stringArray0);
      String string0 = DefaultEditorKit.selectParagraphAction;
      evaluation0.toMatrixString();
      SparseInstance sparseInstance0 = new SparseInstance(0);
      DenseInstance denseInstance0 = new DenseInstance(sparseInstance0);
      evaluation0.KBMeanInformation();
      System.setCurrentTimeMillis(3141L);
      evaluation0.SFMeanPriorEntropy();
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      TestInstances testInstances0 = new TestInstances();
      IBk iBk0 = new IBk();
      AbstractClassifier.runClassifier(iBk0, testInstances0.DEFAULT_WORDS);
      Instances instances1 = testInstances0.generate();
      Double double0 = new Double(1);
      System.setCurrentTimeMillis(1);
      Evaluation evaluation0 = new Evaluation(instances1);
      evaluation0.toSummaryString();
      Evaluation.getGlobalInfo(iBk0);
      Evaluation evaluation1 = new Evaluation(instances0, (CostMatrix) null);
      evaluation1.SFMeanPriorEntropy();
      // Undeclared exception!
      try { 
        evaluation0.fMeasure((-2));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -2
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      TestInstances testInstances0 = new TestInstances();
      try { 
        Evaluation.evaluateModel((Classifier) null, testInstances0.DEFAULT_WORDS);
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // 
         // Weka exception: No training file and no object input file given.
         // 
         // General options:
         // 
         // -h or -help
         // \tOutput help information.
         // -synopsis or -info
         // \tOutput synopsis for classifier (use in conjunction  with -h)
         // -t <name of training file>
         // \tSets training file.
         // -T <name of test file>
         // \tSets test file. If missing, a cross-validation will be performed
         // \ton the training data.
         // -c <class index>
         // \tSets index of class attribute (default: last).
         // -x <number of folds>
         // \tSets number of folds for cross-validation (default: 10).
         // -no-cv
         // \tDo not perform any cross validation.
         // -split-percentage <percentage>
         // \tSets the percentage for the train/test set split, e.g., 66.
         // -preserve-order
         // \tPreserves the order in the percentage split.
         // -s <random number seed>
         // \tSets random number seed for cross-validation or percentage split
         // \t(default: 1).
         // -m <name of file with cost matrix>
         // \tSets file with cost matrix.
         // -l <name of input file>
         // \tSets model input file. In case the filename ends with '.xml',
         // \ta PMML file is loaded or, if that fails, options are loaded
         // \tfrom the XML file.
         // -d <name of output file>
         // \tSets model output file. In case the filename ends with '.xml',
         // \tonly the options are saved to the XML file, not the model.
         // -v
         // \tOutputs no statistics for training data.
         // -o
         // \tOutputs statistics only, not the classifier.
         // -i
         // \tOutputs detailed information-retrieval statistics for each class.
         // -k
         // \tOutputs information-theoretic statistics.
         // -classifications \"weka.classifiers.evaluation.output.prediction.AbstractOutput + options\"
         // \tUses the specified class for generating the classification output.
         // \tE.g.: weka.classifiers.evaluation.output.prediction.PlainText
         // -p range
         // \tOutputs predictions for test instances (or the train instances if
         // \tno test instances provided and -no-cv is used), along with the 
         // \tattributes in the specified range (and nothing else). 
         // \tUse '-p 0' if no attributes are desired.
         // \tDeprecated: use \"-classifications ...\" instead.
         // -distribution
         // \tOutputs the distribution instead of only the prediction
         // \tin conjunction with the '-p' option (only nominal classes).
         // \tDeprecated: use \"-classifications ...\" instead.
         // -r
         // \tOnly outputs cumulative margin distribution.
         // -xml filename | xml-string
         // \tRetrieves the options from the XML-data instead of the command line.
         // -threshold-file <file>
         // \tThe file to save the threshold data to.
         // \tThe format is determined by the extensions, e.g., '.arff' for ARFF 
         // \tformat or '.csv' for CSV.
         // -threshold-label <label>
         // \tThe class label to determine the threshold data for
         // \t(default is the first label)
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      TestInstances testInstances0 = new TestInstances();
      Instances instances1 = testInstances0.generate(".arff");
      UnaryOperator.identity();
      testInstances0.generate("@data");
      int int0 = 2077;
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.unweightedMacroFmeasure();
      evaluation0.KBMeanInformation();
      evaluation0.falseNegativeRate(2077);
      Instances instances2 = null;
      try {
        instances2 = new Instances(instances1, 1, 2077);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Parameters first and/or toCopy out of range
         //
         verifyException("weka.core.Instances", e);
      }
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      SimpleLogistic simpleLogistic0 = new SimpleLogistic();
      AdditiveRegression additiveRegression0 = new AdditiveRegression(simpleLogistic0);
      Capabilities capabilities0 = additiveRegression0.getCapabilities();
      TestInstances testInstances0 = TestInstances.forCapabilities(capabilities0);
      Instances instances0 = testInstances0.generate("weka/core/Capabilities.props");
      CostMatrix costMatrix0 = null;
      Evaluation evaluation0 = new Evaluation(instances0, (CostMatrix) null);
      try { 
        evaluation0.toClassDetailsString();
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // Evaluation: No per class statistics possible!
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      textDirectoryLoader0.getDataSet();
      TestInstances testInstances0 = new TestInstances();
      IBk iBk0 = new IBk();
      AbstractClassifier.runClassifier(iBk0, testInstances0.DEFAULT_WORDS);
      Instances instances0 = testInstances0.generate();
      Evaluation evaluation0 = new Evaluation(instances0);
      Double double0 = new Double(1);
      System.setCurrentTimeMillis(1);
      Evaluation.getGlobalInfo(iBk0);
      double double1 = evaluation0.m_TotalSizeOfRegions;
      textDirectoryLoader0.getDataSet();
      evaluation0.toCumulativeMarginDistributionString();
      evaluation0.areaUnderROC(2);
      double double2 = evaluation0.m_TotalSizeOfRegions;
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      IBk iBk0 = new IBk(245);
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate((String) null);
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 1;
      doubleArray0[1] = (double) 2;
      doubleArray0[2] = 0.0;
      Instances instances1 = iBk0.pruneToK(instances0, doubleArray0, (-1024));
      Instances instances2 = inputMappedClassifier0.getModelHeader(instances1);
      Instances instances3 = new Instances(instances2);
      Evaluation evaluation0 = new Evaluation(instances3);
      String string0 = JTree.TREE_MODEL_PROPERTY;
      SparseInstance sparseInstance0 = new SparseInstance(245);
      try { 
        evaluation0.evaluateModelOnceAndRecordPrediction((Classifier) inputMappedClassifier0, (Instance) sparseInstance0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.misc.InputMappedClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      IBk iBk0 = new IBk(245);
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate((String) null);
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 1;
      doubleArray0[1] = (double) 2;
      doubleArray0[2] = 0.0;
      iBk0.pruneToK(instances0, doubleArray0, 1);
      Instances instances1 = new Instances(instances0);
      Evaluation evaluation0 = new Evaluation(instances1);
      evaluation0.falsePositiveRate((-1));
      evaluation0.useNoPriors();
      evaluation0.weightedRecall();
      evaluation0.SFEntropyGain();
      evaluation0.falseNegativeRate(1166);
      evaluation0.toCumulativeMarginDistributionString();
      evaluation0.KBInformation();
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      SVMLightLoader sVMLightLoader0 = new SVMLightLoader();
      NaiveBayesMultinomialText naiveBayesMultinomialText0 = new NaiveBayesMultinomialText();
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getStructure();
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.getDiscardPredictions();
      evaluation0.addNumericTrainClass(17, 17);
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getStructure();
      textDirectoryLoader0.reset();
      FileSystemHandling.shouldAllThrowIOExceptions();
      textDirectoryLoader0.listOptions();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      textDirectoryLoader0.setOutputFilename(false);
      Evaluation evaluation0 = new Evaluation(instances0);
      Utils.SMALL = (-10.0);
      double double0 = NimbusStyle.SMALL_SCALE;
      evaluation0.numFalseNegatives(17);
      evaluation0.SFPriorEntropy();
      evaluation0.rootMeanPriorSquaredError();
      evaluation0.SFEntropyGain();
  }

  @Test(timeout = 4000)
  public void test49()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/mnt/gaiagpfs/users/homedirs/apanichella/Evosuite_performance/Dataset/gordon_script_sum/projects/9_weka");
      FileSystemHandling.appendLineToFile(evoSuiteFile0, "@data");
      SerializedClassifier serializedClassifier0 = new SerializedClassifier();
      String[] stringArray0 = new String[4];
      EvoSuiteFile evoSuiteFile1 = new EvoSuiteFile("/mnt/gaiagpfs/users/homedirs/apanichella/Evosuite_performance/Dataset/gordon_script_sum/projects/9_weka");
      FileSystemHandling.shouldAllThrowIOExceptions();
      FileSystemHandling.setPermissions(evoSuiteFile1, true, true, true);
      stringArray0[3] = ".bsi";
      String string0 = DefaultEditorKit.selectParagraphAction;
      Evaluation evaluation0 = new Evaluation(instances0);
      IBk iBk0 = new IBk();
      IBk iBk1 = new IBk();
      iBk1.getDistanceWeighting();
      iBk1.setCrossValidate(true);
      double double0 = KStarConstants.LOG2;
      evaluation0.KBMeanInformation();
      double[] doubleArray0 = new double[0];
      DenseInstance denseInstance0 = new DenseInstance(Double.NaN, doubleArray0);
      evaluation0.getRevision();
      evaluation0.trueNegativeRate((-1));
      evaluation0.updateNumericScores(doubleArray0, doubleArray0, 2);
      RegressionByDiscretization regressionByDiscretization0 = new RegressionByDiscretization();
      // Undeclared exception!
      try { 
        denseInstance0.relationalValue((Attribute) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.core.AbstractInstance", e);
      }
  }

  @Test(timeout = 4000)
  public void test50()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate((String) null);
      TestInstances testInstances1 = new TestInstances();
      IBk iBk0 = new IBk();
      AbstractClassifier.runClassifier(iBk0, testInstances1.DEFAULT_WORDS);
      testInstances1.generate();
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.falsePositiveRate(3719);
      evaluation0.weightedRecall();
      evaluation0.toSummaryString();
      evaluation0.SFEntropyGain();
      evaluation0.sizeOfPredictedRegions();
      evaluation0.SFPriorEntropy();
      evaluation0.unweightedMicroFmeasure();
  }

  @Test(timeout = 4000)
  public void test51()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getStructure();
      textDirectoryLoader0.reset();
      textDirectoryLoader0.setOutputFilename(false);
      Utils.SMALL = (-10.0);
      System.setCurrentTimeMillis((-1L));
      double[] doubleArray0 = new double[20];
      doubleArray0[0] = (-10.0);
      doubleArray0[1] = (-10.0);
      doubleArray0[2] = (-467.8983773047206);
      doubleArray0[3] = 0.125;
      doubleArray0[6] = 0.125;
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance((-467.8983773047206), doubleArray0);
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.numInstances();
      evaluation0.pctUnclassified();
  }

  @Test(timeout = 4000)
  public void test52()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      String string0 = DefaultEditorKit.EndOfLineStringProperty;
      FileSystemHandling.shouldAllThrowIOExceptions();
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(2615);
      NaiveBayesMultinomial naiveBayesMultinomial0 = new NaiveBayesMultinomial();
      Evaluation.getGlobalInfo(naiveBayesMultinomial0);
      ArffLoader arffLoader0 = new ArffLoader();
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      Evaluation evaluation0 = new Evaluation(instances0);
      Object[] objectArray0 = new Object[2];
      objectArray0[0] = (Object) "\nSynopsis for weka.classifiers.bayes.NaiveBayesMultinomial:\n\nClass for building and using a multinomial Naive Bayes classifier. For more information see,\n\nAndrew Mccallum, Kamal Nigam: A Comparison of Event Models for Naive Bayes Text Classification. In: AAAI-98 Workshop on 'Learning for Text Categorization', 1998.\n\nThe core equation for this classifier:\n\nP[Ci|D] = (P[D|Ci] x P[Ci]) / P[D] (Bayes rule)\n\nwhere Ci is class i and D is a document.";
      objectArray0[1] = (Object) binarySparseInstance0;
      try { 
        evaluation0.evaluateModel((Classifier) inputMappedClassifier0, instances0, objectArray0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // java.lang.String cannot be cast to weka.classifiers.evaluation.output.prediction.AbstractOutput
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test53()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      TestInstances testInstances0 = new TestInstances();
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      TestInstances testInstances1 = new TestInstances();
      testInstances0.generate(" ");
      UnaryOperator.identity();
      testInstances1.generate("+`0;5R*~yR");
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.falseNegativeRate(2036);
      String string0 = XML.TAG_PREDICTIONS;
      evaluation0.kappa();
      evaluation0.SFMeanPriorEntropy();
      Instances instances1 = null;
      try {
        instances1 = new Instances((Instances) null, (-3790), (-2));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.core.Instances", e);
      }
  }

  @Test(timeout = 4000)
  public void test54()  throws Throwable  {
      FileSystemHandling.shouldAllThrowIOExceptions();
      Evaluation.handleCostOption("", 2615);
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate();
      IBk iBk0 = new IBk();
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.getModelHeader(instances0);
      double double0 = KStarConstants.ROOT_FINDER_ACCURACY;
      Double double1 = new Double((-1));
      String string0 = DefaultEditorKit.EndOfLineStringProperty;
      Instances instances1 = new Instances(instances0);
      Evaluation evaluation0 = new Evaluation(instances1);
      double[] doubleArray0 = new double[5];
      doubleArray0[2] = (double) 2;
      evaluation0.kappa();
      Double double2 = new Double(2215.010485256509);
      Evaluation evaluation1 = new Evaluation(instances1, (CostMatrix) null);
  }

  @Test(timeout = 4000)
  public void test55()  throws Throwable  {
      SimpleLogistic simpleLogistic0 = new SimpleLogistic();
      AdditiveRegression additiveRegression0 = new AdditiveRegression(simpleLogistic0);
      Capabilities capabilities0 = additiveRegression0.getCapabilities();
      TestInstances testInstances0 = TestInstances.forCapabilities(capabilities0);
      CostMatrix costMatrix0 = null;
      DecisionStump decisionStump0 = new DecisionStump();
      FileSystemHandling.shouldAllThrowIOExceptions();
      AbstractClassifier.runClassifier(decisionStump0, testInstances0.DEFAULT_WORDS);
      BayesNet bayesNet0 = new BayesNet();
      Instances instances0 = bayesNet0.m_Instances;
      AllFilter allFilter0 = new AllFilter();
      AllFilter allFilter1 = null;
      XRFFLoader xRFFLoader0 = new XRFFLoader();
      SerializedInstancesLoader serializedInstancesLoader0 = new SerializedInstancesLoader();
      try { 
        serializedInstancesLoader0.getStructure();
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // No source has been specified
         //
         verifyException("weka.core.converters.SerializedInstancesLoader", e);
      }
  }

  @Test(timeout = 4000)
  public void test56()  throws Throwable  {
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate((String) null);
      Evaluation evaluation0 = new Evaluation(instances0);
      double double0 = evaluation0.m_TotalCoverage;
      double double1 = evaluation0.m_SumPriorEntropy;
      DecisionStump decisionStump0 = new DecisionStump();
      evaluation0.equals(decisionStump0);
      AllFilter allFilter0 = new AllFilter();
      // Undeclared exception!
      try { 
        allFilter0.outputPeek();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // No output instance format defined
         //
         verifyException("weka.filters.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test57()  throws Throwable  {
      SimpleLogistic simpleLogistic0 = new SimpleLogistic();
      AdditiveRegression additiveRegression0 = new AdditiveRegression(simpleLogistic0);
      Capabilities capabilities0 = additiveRegression0.getCapabilities();
      TestInstances testInstances0 = TestInstances.forCapabilities(capabilities0);
      Instances instances0 = testInstances0.generate("weka/core/Capabilities.props");
      NetworkHandling.createRemoteTextFile((EvoSuiteURL) null, "y-a.adX3-ZP(/.((XF");
      Evaluation evaluation0 = new Evaluation(instances0);
      double double0 = evaluation0.m_TotalCoverage;
      evaluation0.errorRate();
      double double1 = evaluation0.m_SumClassPredicted;
      Evaluation evaluation1 = new Evaluation(instances0);
      evaluation1.meanPriorAbsoluteError();
      evaluation0.rootMeanPriorSquaredError();
      String string0 = DefaultEditorKit.selectParagraphAction;
      double double2 = evaluation0.m_ConfLevel;
      CostMatrix costMatrix0 = null;
      try {
        costMatrix0 = new CostMatrix((-2));
        fail("Expecting exception: NegativeArraySizeException");
      
      } catch(NegativeArraySizeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.CostMatrix", e);
      }
  }

  @Test(timeout = 4000)
  public void test58()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getStructure();
      textDirectoryLoader0.reset();
      Instances instances1 = new Instances(instances0, (-1875));
      Evaluation evaluation0 = new Evaluation(instances1);
      evaluation0.useNoPriors();
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      SimpleLogistic simpleLogistic0 = new SimpleLogistic(280106558, false, false);
      inputMappedClassifier0.getCapabilities();
      double double0 = evaluation0.m_WithClass;
      String[] stringArray0 = new String[0];
      Evaluation.main(stringArray0);
      evaluation0.toClassDetailsString();
      M5P m5P0 = new M5P();
      Evaluation.makeOptionString(m5P0, true);
      MatlabLoader matlabLoader0 = new MatlabLoader();
      evaluation0.evaluateModel((Classifier) inputMappedClassifier0, instances0, (Object[]) stringArray0);
      evaluation0.pctUnclassified();
      evaluation0.setDiscardPredictions(true);
      evaluation0.correct();
      evaluation0.weightedTruePositiveRate();
      try { 
        evaluation0.correlationCoefficient();
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // Can't compute correlation coefficient: class is nominal!
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test59()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      CostMatrix costMatrix0 = new CostMatrix(0);
      Evaluation evaluation0 = new Evaluation(instances0, costMatrix0);
      String[] stringArray0 = new String[6];
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/mnt/gaiagpfs/users/homedirs/apanichella/Evosuite_performance/Dataset/gordon_script_sum/projects/9_weka");
      FileSystemHandling.setPermissions(evoSuiteFile0, true, true, true);
      stringArray0[0] = "@relation";
      stringArray0[3] = ".bsi";
      stringArray0[3] = ".cost";
      stringArray0[5] = ".bsi";
      double[] doubleArray0 = new double[3];
      doubleArray0[1] = (double) (-1024);
      doubleArray0[2] = (double) 0;
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.getModelHeader(instances0);
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(0);
      try { 
        evaluation0.evaluateModelOnce(doubleArray0, (Instance) binarySparseInstance0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // DenseInstance doesn't have access to a dataset!
         //
         verifyException("weka.core.AbstractInstance", e);
      }
  }

  @Test(timeout = 4000)
  public void test60()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      CostMatrix costMatrix0 = new CostMatrix(0);
      Evaluation evaluation0 = new Evaluation(instances0, costMatrix0);
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.getModelHeader(instances0);
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(0);
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = (double) 0;
      doubleArray0[1] = (double) (-1);
      doubleArray0[2] = (double) (-1024);
      doubleArray0[3] = (double) (-1);
      doubleArray0[4] = (double) 0;
      doubleArray0[5] = (double) 0;
      doubleArray0[6] = 2668.1261223;
      doubleArray0[7] = (double) 0;
      doubleArray0[8] = (double) (-1);
      try { 
        evaluation0.evaluateModelOnce(doubleArray0, (Instance) binarySparseInstance0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // DenseInstance doesn't have access to a dataset!
         //
         verifyException("weka.core.AbstractInstance", e);
      }
  }

  @Test(timeout = 4000)
  public void test61()  throws Throwable  {
      TestInstances testInstances0 = new TestInstances();
      IBk iBk0 = new IBk();
      TestInstances testInstances1 = new TestInstances();
      Instances instances0 = testInstances1.generate("getClass");
      MockRandom mockRandom0 = new MockRandom(0L);
      UnaryOperator<Instance> unaryOperator0 = UnaryOperator.identity();
      instances0.replaceAll(unaryOperator0);
      Evaluation evaluation0 = new Evaluation(instances0, (CostMatrix) null);
      double double0 = new Long(4);
      Evaluation evaluation1 = new Evaluation(instances0);
      evaluation0.m_CoverageStatisticsAvailable = false;
      evaluation1.unweightedMacroFmeasure();
      instances0.resample(mockRandom0);
      evaluation0.matthewsCorrelationCoefficient(4);
      double double1 = evaluation1.m_TotalCoverage;
      evaluation0.sizeOfPredictedRegions();
      evaluation0.SFSchemeEntropy();
  }

  @Test(timeout = 4000)
  public void test62()  throws Throwable  {
      TestInstances testInstances0 = new TestInstances();
      testInstances0.setSeed(2779);
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/home/users/apanichella/wekafiles");
      FileSystemHandling.shouldAllThrowIOExceptions();
      Instances instances0 = testInstances0.generate((String) null);
      IBk iBk0 = new IBk((-1));
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.useNoPriors();
      FileSystemHandling.shouldAllThrowIOExceptions();
      FileSystemHandling.appendStringToFile(evoSuiteFile0, "seedTipText");
      Evaluation.main(testInstances0.DEFAULT_WORDS);
      M5P m5P0 = new M5P();
      Evaluation.makeOptionString(m5P0, false);
      MatlabLoader matlabLoader0 = new MatlabLoader();
      FileSystemHandling.appendLineToFile(evoSuiteFile0, "@relation");
      Object[] objectArray0 = new Object[2];
      objectArray0[0] = (Object) null;
      evaluation0.KBMeanInformation();
      DenseInstance denseInstance0 = new DenseInstance(492);
      CostSensitiveClassifier costSensitiveClassifier0 = new CostSensitiveClassifier();
      evaluation0.pctIncorrect();
      Evaluation.makeOptionString(costSensitiveClassifier0, false);
      CostMatrix costMatrix0 = costSensitiveClassifier0.getCostMatrix();
      CostMatrix costMatrix1 = new CostMatrix(costMatrix0);
      Evaluation evaluation1 = null;
      try {
        evaluation1 = new Evaluation(instances0, costMatrix1);
        fail("Expecting exception: Exception");
      
      } catch(Throwable e) {
         //
         // Cost matrix not compatible with data!
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test63()  throws Throwable  {
      TestInstances testInstances0 = new TestInstances();
      testInstances0.setSeed(2779);
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/home/users/apanichella/wekafiles");
      FileSystemHandling.shouldAllThrowIOExceptions();
      Instances instances0 = testInstances0.generate((String) null);
      IBk iBk0 = new IBk((-1));
      iBk0.buildClassifier(instances0);
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.useNoPriors();
      FileSystemHandling.shouldAllThrowIOExceptions();
      FileSystemHandling.appendStringToFile(evoSuiteFile0, "seedTipText");
      Evaluation.main(testInstances0.DEFAULT_WORDS);
      M5P m5P0 = new M5P();
      Evaluation.makeOptionString(m5P0, false);
      MatlabLoader matlabLoader0 = new MatlabLoader();
      FileSystemHandling.appendLineToFile(evoSuiteFile0, "@relation");
      Object[] objectArray0 = new Object[2];
      objectArray0[0] = (Object) null;
      evaluation0.KBMeanInformation();
      try { 
        evaluation0.evaluateModel((Classifier) m5P0, instances0, objectArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.trees.m5.M5Base", e);
      }
  }

  @Test(timeout = 4000)
  public void test64()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      CostMatrix costMatrix0 = new CostMatrix(0);
      Evaluation evaluation0 = new Evaluation(instances0, costMatrix0);
      SerializedClassifier serializedClassifier0 = new SerializedClassifier();
      String[] stringArray0 = new String[6];
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/mnt/gaiagpfs/users/homedirs/apanichella/Evosuite_performance/Dataset/gordon_script_sum/projects/9_weka");
      MockFile mockFile0 = new MockFile("@data");
      FileSystemHandling.setPermissions(evoSuiteFile0, true, true, true);
      stringArray0[0] = "@relation";
      FileSystemHandling.shouldAllThrowIOExceptions();
      stringArray0[3] = ".bsi";
      stringArray0[4] = ".cost";
      evaluation0.falsePositiveRate(500);
      evaluation0.weightedRecall();
      StringKernel stringKernel0 = new StringKernel();
      Capabilities capabilities0 = stringKernel0.getCapabilities();
      evaluation0.KBInformation();
      Capabilities.Capability capabilities_Capability0 = Capabilities.Capability.EMPTY_NOMINAL_ATTRIBUTES;
      capabilities0.enable(capabilities_Capability0);
      CVParameterSelection cVParameterSelection0 = new CVParameterSelection();
      Capabilities capabilities1 = cVParameterSelection0.getCapabilities();
      TestInstances.forCapabilities(capabilities1);
      TestInstances testInstances0 = new TestInstances();
      testInstances0.getOptions();
      Evaluation evaluation1 = new Evaluation(instances0);
      Evaluation evaluation2 = new Evaluation(instances0, costMatrix0);
      JRip jRip0 = new JRip();
      evaluation0.equals((Object) null);
      // Undeclared exception!
      try { 
        evaluation2.makeDistribution(2.0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test65()  throws Throwable  {
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      TestInstances testInstances0 = new TestInstances();
      IBk iBk0 = new IBk();
      double[] doubleArray0 = new double[3];
      doubleArray0[0] = (double) 4;
      AbstractClassifier.runClassifier(iBk0, testInstances0.DEFAULT_WORDS);
      doubleArray0[1] = 45.0;
      doubleArray0[2] = (double) (-1024);
      EM eM0 = new EM();
      Capabilities capabilities0 = eM0.getCapabilities();
      TestInstances.forCapabilities(capabilities0);
      testInstances0.setNumRelationalString(3719);
      Instances instances0 = testInstances0.generate();
      Evaluation evaluation0 = new Evaluation(instances0);
      iBk0.getDistanceWeighting();
      evaluation0.m_WithClass = 1660.027;
      evaluation0.m_ClassPriorsSum = (double) 1;
      evaluation0.incorrect();
      evaluation0.toMatrixString();
      evaluation0.SFMeanSchemeEntropy();
      evaluation0.makeDistribution(1.0);
      evaluation0.unweightedMicroFmeasure();
      evaluation0.weightedFalseNegativeRate();
      evaluation0.makeDistribution(Double.NaN);
      evaluation0.SFMeanPriorEntropy();
  }

  @Test(timeout = 4000)
  public void test66()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      CostMatrix costMatrix0 = new CostMatrix(0);
      Evaluation evaluation0 = new Evaluation(instances0, costMatrix0);
      DenseInstance denseInstance0 = new DenseInstance(0);
      try { 
        evaluation0.evaluateModelOnce((double) 0, (Instance) denseInstance0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 0
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test67()  throws Throwable  {
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      Evaluation.handleCostOption("", 2615);
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate();
      IBk iBk0 = new IBk();
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      Instances instances1 = inputMappedClassifier0.getModelHeader(instances0);
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.matthewsCorrelationCoefficient(1);
      Double.valueOf((double) (-1));
      String string0 = DefaultEditorKit.EndOfLineStringProperty;
      evaluation0.falsePositiveRate((-635));
      evaluation0.weightedRecall();
      MockRandom mockRandom0 = new MockRandom();
      double double0 = evaluation0.m_MissingClass;
      iBk0.setCrossValidate(false);
      InputMappedClassifier inputMappedClassifier1 = new InputMappedClassifier();
      inputMappedClassifier0.buildClassifier(instances1);
      System.setCurrentTimeMillis(2);
      evaluation0.SFMeanPriorEntropy();
      GaussianProcesses gaussianProcesses0 = new GaussianProcesses();
      evaluation0.m_CoverageStatisticsAvailable = true;
      Evaluation evaluation1 = new Evaluation(instances1);
      evaluation1.coverageOfTestCasesByPredictedRegions();
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(2615);
      evaluation1.confusionMatrix();
      evaluation0.weightedFalsePositiveRate();
  }

  @Test(timeout = 4000)
  public void test68()  throws Throwable  {
      SimpleLogistic simpleLogistic0 = new SimpleLogistic();
      AdditiveRegression additiveRegression0 = new AdditiveRegression(simpleLogistic0);
      Capabilities capabilities0 = additiveRegression0.getCapabilities();
      TestInstances testInstances0 = TestInstances.forCapabilities(capabilities0);
      Instances instances0 = testInstances0.generate("weka/core/Capabilities.props");
      TestInstances.main(testInstances0.DEFAULT_WORDS);
      Evaluation evaluation0 = new Evaluation(instances0);
      double[] doubleArray0 = evaluation0.makeDistribution((-2));
      IBk iBk0 = new IBk((-1));
      // Undeclared exception!
      try { 
        iBk0.pruneToK(instances0, doubleArray0, 460);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("weka.classifiers.lazy.IBk", e);
      }
  }

  @Test(timeout = 4000)
  public void test69()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      CostMatrix costMatrix0 = new CostMatrix(0);
      Evaluation evaluation0 = new Evaluation(instances0, costMatrix0);
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.getModelHeader(instances0);
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(0);
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = (double) 0;
      doubleArray0[1] = (double) 0;
      doubleArray0[3] = (double) (-1);
      doubleArray0[4] = (double) 0;
      doubleArray0[5] = (double) 0;
      evaluation0.updateMargins(doubleArray0, 0, (-180.79049959725));
      CoverTree coverTree0 = new CoverTree();
      try { 
        coverTree0.kNearestNeighbours(binarySparseInstance0, (-1));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.core.Instances", e);
      }
  }

  @Test(timeout = 4000)
  public void test70()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      CostMatrix costMatrix0 = new CostMatrix(0);
      Evaluation evaluation0 = new Evaluation(instances0, costMatrix0);
      evaluation0.totalCost();
      evaluation0.coverageOfTestCasesByPredictedRegions();
      LMT lMT0 = new LMT();
      Capabilities.forInstances(instances0);
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      Instances instances1 = inputMappedClassifier0.getModelHeader(instances0);
      String string0 = JTree.TREE_MODEL_PROPERTY;
      MockRandom mockRandom0 = new MockRandom(0);
      Object[] objectArray0 = new Object[2];
      objectArray0[0] = (Object) evaluation0;
      objectArray0[1] = (Object) instances1;
      evaluation0.KBRelativeInformation();
      System.setCurrentTimeMillis(828L);
      evaluation0.SFSchemeEntropy();
      CostMatrix costMatrix1 = new CostMatrix(costMatrix0);
      Evaluation evaluation1 = new Evaluation(instances0, costMatrix1);
      JRip jRip0 = new JRip();
      ListOptions listOptions0 = new ListOptions();
      evaluation1.equals(evaluation0);
      jRip0.setSeed(0);
      MockRandom mockRandom1 = new MockRandom();
      MockRandom mockRandom2 = new MockRandom((-1519L));
      mockRandom1.ints();
      try { 
        evaluation0.crossValidateModel((Classifier) lMT0, instances0, 24, (Random) mockRandom1, objectArray0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // weka.classifiers.Evaluation cannot be cast to weka.classifiers.evaluation.output.prediction.AbstractOutput
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test71()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      textDirectoryLoader0.reset();
      CostMatrix costMatrix0 = new CostMatrix(0);
      TestInstances testInstances0 = new TestInstances();
      IBk iBk0 = new IBk();
      AbstractClassifier.runClassifier(iBk0, testInstances0.DEFAULT_WORDS);
      testInstances0.setNumRelationalString(3129);
      Instances instances0 = testInstances0.generate();
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.toCumulativeMarginDistributionString();
      Double double0 = new Double((-1));
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.setDebug(true);
      evaluation0.KBMeanInformation();
      evaluation0.weightedPrecision();
      double double1 = KStarConstants.INITIAL_STEP;
      double double2 = evaluation0.m_MaxTarget;
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(3129);
      evaluation0.addNumericTrainClass(2.0, 4.8);
      try { 
        evaluation0.evaluateModelOnce((Classifier) inputMappedClassifier0, (Instance) binarySparseInstance0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.misc.InputMappedClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test72()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      TestInstances testInstances0 = new TestInstances();
      testInstances0.setSeed(2775);
      Instances instances0 = testInstances0.generate((String) null);
      instances0.deleteStringAttributes();
      instances0.parallelStream();
      IBk iBk0 = new IBk((-1));
      iBk0.buildClassifier(instances0);
      Instances instances1 = new Instances(instances0, 7);
      inputMappedClassifier0.setSuppressMappingReport(false);
      Evaluation evaluation0 = new Evaluation(instances1);
      evaluation0.useNoPriors();
      inputMappedClassifier0.setClassifier(iBk0);
      testInstances0.setNumNominalValues((-52377651));
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(1);
      instances0.spliterator();
      NaiveBayesMultinomial naiveBayesMultinomial0 = new NaiveBayesMultinomial();
      Evaluation.getGlobalInfo(naiveBayesMultinomial0);
      ArffLoader arffLoader0 = new ArffLoader();
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = (double) (-2);
      MockRandom mockRandom0 = new MockRandom();
      mockRandom0.ints();
      evaluation0.setDiscardPredictions(false);
      evaluation0.KBRelativeInformation();
      evaluation0.meanAbsoluteError();
  }

  @Test(timeout = 4000)
  public void test73()  throws Throwable  {
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate();
      IBk iBk0 = new IBk();
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.getModelHeader(instances0);
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.matthewsCorrelationCoefficient(1);
      Double double0 = new Double((-1));
      String string0 = DefaultEditorKit.EndOfLineStringProperty;
      evaluation0.falsePositiveRate((-635));
      evaluation0.weightedRecall();
      evaluation0.meanAbsoluteError();
      Instances instances1 = new Instances(instances0);
      Evaluation evaluation1 = new Evaluation(instances1);
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = (double) (-2);
      doubleArray0[2] = (double) (-2);
      doubleArray0[3] = 0.0;
      doubleArray0[4] = (double) 473;
      doubleArray0[5] = Double.NaN;
      doubleArray0[6] = (double) 473;
      doubleArray0[7] = (double) (-1);
      doubleArray0[8] = (double) (-635);
      // Undeclared exception!
      try { 
        evaluation1.updateMargins(doubleArray0, 4, 1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 118500
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test74()  throws Throwable  {
      SimpleLogistic simpleLogistic0 = new SimpleLogistic();
      AdditiveRegression additiveRegression0 = new AdditiveRegression(simpleLogistic0);
      Capabilities capabilities0 = additiveRegression0.getCapabilities();
      TestInstances testInstances0 = TestInstances.forCapabilities(capabilities0);
      Instances instances0 = testInstances0.generate("|8&N>(G");
      UnaryOperator<Instance> unaryOperator0 = UnaryOperator.identity();
      instances0.replaceAll(unaryOperator0);
      Instances instances1 = testInstances0.generate(".bsi");
      Evaluation evaluation0 = new Evaluation(instances0, (CostMatrix) null);
      evaluation0.rootMeanPriorSquaredError();
      double double0 = evaluation0.m_ConfLevel;
      Evaluation evaluation1 = new Evaluation(instances0);
      IBk iBk0 = new IBk();
      String string0 = JTree.TREE_MODEL_PROPERTY;
      MockRandom mockRandom0 = new MockRandom(2152L);
      double double1 = evaluation1.m_MissingClass;
      iBk0.setCrossValidate(false);
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.buildClassifier(instances1);
      System.setCurrentTimeMillis(2152L);
      evaluation1.SFMeanPriorEntropy();
      RegressionByDiscretization regressionByDiscretization0 = new RegressionByDiscretization();
      try { 
        evaluation0.updateStatsForConditionalDensityEstimator(regressionByDiscretization0, (Instance) null, (-2));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.meta.RegressionByDiscretization", e);
      }
  }

  @Test(timeout = 4000)
  public void test75()  throws Throwable  {
      SimpleLogistic simpleLogistic0 = new SimpleLogistic();
      AdditiveRegression additiveRegression0 = new AdditiveRegression();
      Capabilities capabilities0 = additiveRegression0.getCapabilities();
      TestInstances testInstances0 = TestInstances.forCapabilities(capabilities0);
      Instances instances0 = testInstances0.generate("weka/core/Capabilities.props");
      UnaryOperator<Instance> unaryOperator0 = UnaryOperator.identity();
      instances0.replaceAll(unaryOperator0);
      Evaluation evaluation0 = new Evaluation(instances0);
      double double0 = evaluation0.m_ConfLevel;
      IBk iBk0 = new IBk();
      evaluation0.m_SumPriorAbsErr = (double) 4;
      MockRandom mockRandom0 = new MockRandom();
      double double1 = evaluation0.m_MissingClass;
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.buildClassifier(instances0);
      double[] doubleArray0 = new double[6];
      doubleArray0[2] = (double) (-1);
      doubleArray0[4] = (double) (-2);
      evaluation0.updateMargins(doubleArray0, 2, 0.0);
      MockRandom mockRandom1 = new MockRandom(0L);
      evaluation0.meanPriorAbsoluteError();
      TestInstances testInstances1 = new TestInstances();
      testInstances1.setHandler(inputMappedClassifier0);
      evaluation0.setDiscardPredictions(false);
      try { 
        evaluation0.KBRelativeInformation();
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // Can't compute K&B Info score: class numeric!
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test76()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      CostMatrix costMatrix0 = new CostMatrix(0);
      Evaluation evaluation0 = new Evaluation(instances0, costMatrix0);
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      Instances instances1 = inputMappedClassifier0.getModelHeader(instances0);
      instances0.retainAll(instances1);
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(0);
      double[] doubleArray0 = new double[9];
      doubleArray0[0] = (double) 0;
      doubleArray0[1] = (double) 0;
      doubleArray0[3] = (double) 0;
      inputMappedClassifier0.getCapabilities();
      doubleArray0[4] = (double) 0;
      doubleArray0[5] = (double) 0;
      String[] stringArray0 = new String[6];
      stringArray0[0] = ".arff";
      stringArray0[1] = ".arff";
      stringArray0[2] = ".arff";
      stringArray0[3] = ".bsi";
      evaluation0.priorEntropy();
      stringArray0[4] = "@data";
      stringArray0[5] = ".bsi";
      textDirectoryLoader0.setOptions(stringArray0);
      String string0 = JSplitPane.RIGHT;
      Object[] objectArray0 = new Object[1];
      objectArray0[0] = (Object) inputMappedClassifier0;
      evaluation0.relativeAbsoluteError();
      evaluation0.pctCorrect();
      try { 
        evaluation0.evaluateModel((Classifier) inputMappedClassifier0, instances0, objectArray0);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // weka.classifiers.misc.InputMappedClassifier cannot be cast to weka.classifiers.evaluation.output.prediction.AbstractOutput
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test77()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      TestInstances testInstances0 = new TestInstances();
      testInstances0.setSeed(2775);
      Instances instances0 = testInstances0.generate((String) null);
      instances0.parallelStream();
      IBk iBk0 = new IBk((-1));
      iBk0.buildClassifier(instances0);
      Instances instances1 = new Instances(instances0, 7);
      inputMappedClassifier0.setSuppressMappingReport(false);
      IBk.main(testInstances0.DEFAULT_WORDS);
      Evaluation evaluation0 = new Evaluation(instances1);
      evaluation0.useNoPriors();
      inputMappedClassifier0.setClassifier(iBk0);
      testInstances0.setNumNominalValues((-52377651));
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(1);
      instances0.spliterator();
      NaiveBayesMultinomial naiveBayesMultinomial0 = new NaiveBayesMultinomial();
      Evaluation.getGlobalInfo(naiveBayesMultinomial0);
      ArffLoader arffLoader0 = new ArffLoader();
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) (-2);
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, true);
      instances1.add((Instance) binarySparseInstance0);
      evaluation0.weightedTruePositiveRate();
      evaluation0.meanPriorAbsoluteError();
      evaluation0.priorEntropy();
      try { 
        evaluation0.updateStatsForClassifier(doubleArray0, binarySparseInstance0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // DenseInstance doesn't have access to a dataset!
         //
         verifyException("weka.core.AbstractInstance", e);
      }
  }

  @Test(timeout = 4000)
  public void test78()  throws Throwable  {
      SimpleLogistic simpleLogistic0 = new SimpleLogistic();
      AdditiveRegression additiveRegression0 = new AdditiveRegression(simpleLogistic0);
      Capabilities capabilities0 = additiveRegression0.getCapabilities();
      TestInstances testInstances0 = TestInstances.forCapabilities(capabilities0);
      Instances instances0 = testInstances0.generate("weka/core/Capabilities.props");
      UnaryOperator<Instance> unaryOperator0 = UnaryOperator.identity();
      instances0.replaceAll(unaryOperator0);
      Instances instances1 = testInstances0.generate();
      Evaluation evaluation0 = new Evaluation(instances0, (CostMatrix) null);
      double double0 = evaluation0.m_ConfLevel;
      IBk iBk0 = new IBk();
      evaluation0.m_SumPriorAbsErr = (-392.25286295);
      MockRandom mockRandom0 = new MockRandom();
      double double1 = evaluation0.m_MissingClass;
      additiveRegression0.getOptions();
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.buildClassifier(instances1);
      double[] doubleArray0 = new double[6];
      doubleArray0[2] = (double) (-1);
      doubleArray0[4] = (double) (-2);
      doubleArray0[5] = (double) 2152L;
      evaluation0.updateMargins(doubleArray0, 2, 0.0);
      MockRandom mockRandom1 = new MockRandom(0L);
      MockRandom mockRandom2 = new MockRandom((-1));
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/home/users/apanichella/wekafiles");
      FileSystemHandling.appendLineToFile(evoSuiteFile0, ".arff");
      mockRandom1.ints();
      Evaluation evaluation1 = new Evaluation(instances1, (CostMatrix) null);
      evaluation0.areaUnderPRC((-2900));
      Evaluation evaluation2 = new Evaluation(instances0);
      Evaluation evaluation3 = new Evaluation(instances1, (CostMatrix) null);
      evaluation3.SFMeanSchemeEntropy();
      evaluation0.meanPriorAbsoluteError();
      try { 
        evaluation0.priorEntropy();
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // Can't compute entropy of class prior: class numeric!
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test79()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      CostMatrix costMatrix0 = new CostMatrix(0);
      Evaluation evaluation0 = new Evaluation(instances0, costMatrix0);
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/home/users/apanichella/wekafiles/props/Capabilities.props");
      FileSystemHandling.setPermissions(evoSuiteFile0, true, true, true);
      evaluation0.totalCost();
      evaluation0.coverageOfTestCasesByPredictedRegions();
      LMT lMT0 = new LMT();
      lMT0.getCapabilities();
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      Instances instances1 = inputMappedClassifier0.getModelHeader(instances0);
      String string0 = JTree.TREE_MODEL_PROPERTY;
      MockRandom mockRandom0 = new MockRandom(0);
      Object[] objectArray0 = new Object[2];
      objectArray0[0] = (Object) evaluation0;
      objectArray0[1] = (Object) instances1;
      Float float0 = new Float((double) 0);
      char[] charArray0 = new char[1];
      charArray0[0] = 'H';
      evaluation0.num2ShortID(0, charArray0, 207);
      System.setCurrentTimeMillis(814L);
      double double0 = evaluation0.m_SumPredicted;
      CostMatrix costMatrix1 = new CostMatrix(costMatrix0);
      Evaluation evaluation1 = new Evaluation(instances0, costMatrix1);
      JRip jRip0 = new JRip();
      ListOptions listOptions0 = new ListOptions();
      evaluation1.equals(evaluation0);
      evaluation1.coverageOfTestCasesByPredictedRegions();
      AllFilter allFilter0 = new AllFilter();
      // Undeclared exception!
      try { 
        allFilter0.output();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // No output instance format defined
         //
         verifyException("weka.filters.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test80()  throws Throwable  {
      SimpleLogistic simpleLogistic0 = new SimpleLogistic();
      AdditiveRegression additiveRegression0 = new AdditiveRegression(simpleLogistic0);
      Capabilities capabilities0 = additiveRegression0.getCapabilities();
      TestInstances testInstances0 = TestInstances.forCapabilities(capabilities0);
      Instances instances0 = testInstances0.generate("weka/core/Capabilities.props");
      UnaryOperator<Instance> unaryOperator0 = UnaryOperator.identity();
      instances0.replaceAll(unaryOperator0);
      Evaluation evaluation0 = new Evaluation(instances0, (CostMatrix) null);
      double double0 = evaluation0.m_ConfLevel;
      IBk iBk0 = new IBk();
      evaluation0.m_SumPriorAbsErr = (double) 4;
      MockRandom mockRandom0 = new MockRandom();
      double double1 = evaluation0.m_MissingClass;
      additiveRegression0.getOptions();
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.buildClassifier(instances0);
      double[] doubleArray0 = new double[6];
      doubleArray0[2] = (double) (-1);
      doubleArray0[4] = (double) (-2);
      evaluation0.updateMargins(doubleArray0, 2, 0.0);
      MockRandom mockRandom1 = new MockRandom(38L);
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance((-1.0), doubleArray0);
      try { 
        evaluation0.evaluateModelOnce(doubleArray0, (Instance) binarySparseInstance0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // DenseInstance doesn't have access to a dataset!
         //
         verifyException("weka.core.AbstractInstance", e);
      }
  }

  @Test(timeout = 4000)
  public void test81()  throws Throwable  {
      SimpleLogistic simpleLogistic0 = new SimpleLogistic();
      AdditiveRegression additiveRegression0 = new AdditiveRegression(simpleLogistic0);
      Capabilities capabilities0 = additiveRegression0.getCapabilities();
      TestInstances testInstances0 = TestInstances.forCapabilities(capabilities0);
      Instances instances0 = testInstances0.generate("weka/core/Capabilities.props");
      double[] doubleArray0 = new double[8];
      doubleArray0[4] = 1200.4020821250945;
      doubleArray0[5] = 1200.4020821250945;
      doubleArray0[6] = Double.POSITIVE_INFINITY;
      doubleArray0[7] = 1200.4020821250945;
      DenseInstance denseInstance0 = new DenseInstance(Double.POSITIVE_INFINITY, doubleArray0);
      Evaluation evaluation0 = new Evaluation(instances0, (CostMatrix) null);
      try { 
        evaluation0.KBMeanInformation();
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // Can't compute K&B Info score: class numeric!
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test82()  throws Throwable  {
      SimpleLogistic simpleLogistic0 = new SimpleLogistic();
      AdditiveRegression additiveRegression0 = new AdditiveRegression(simpleLogistic0);
      Capabilities capabilities0 = additiveRegression0.getCapabilities();
      TestInstances testInstances0 = TestInstances.forCapabilities(capabilities0);
      Instances instances0 = testInstances0.generate("weka/core/Capabilities.props");
      UnaryOperator<Instance> unaryOperator0 = UnaryOperator.identity();
      instances0.replaceAll(unaryOperator0);
      CostMatrix costMatrix0 = null;
      Instances instances1 = testInstances0.generate();
      Evaluation evaluation0 = new Evaluation(instances0, (CostMatrix) null);
      double double0 = evaluation0.m_ConfLevel;
      IBk iBk0 = new IBk();
      evaluation0.m_SumPriorAbsErr = (double) 4;
      MockRandom mockRandom0 = new MockRandom();
      double double1 = evaluation0.m_MissingClass;
      additiveRegression0.getOptions();
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.buildClassifier(instances1);
      JRip jRip0 = new JRip();
      ListOptions listOptions0 = new ListOptions();
      evaluation0.equals((Object) null);
      jRip0.setSeed(1339L);
      MockRandom mockRandom1 = new MockRandom();
      try { 
        evaluation0.crossValidateModel((Classifier) jRip0, instances0, 2, (Random) mockRandom0, (Object[]) testInstances0.DEFAULT_WORDS);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // java.lang.String cannot be cast to weka.classifiers.evaluation.output.prediction.AbstractOutput
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test83()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      TestInstances testInstances0 = new TestInstances();
      testInstances0.setSeed(2779);
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/home/users/apanichella/wekafiles");
      Instances instances0 = testInstances0.generate((String) null);
      instances0.parallelStream();
      IBk iBk0 = new IBk((-1));
      iBk0.buildClassifier(instances0);
      Instances instances1 = new Instances(instances0, 7);
      Evaluation evaluation0 = new Evaluation(instances1);
      evaluation0.useNoPriors();
      inputMappedClassifier0.setClassifier(iBk0);
      FileSystemHandling.appendStringToFile(evoSuiteFile0, "seedTipText");
      inputMappedClassifier0.getCapabilities();
      TestInstances testInstances1 = new TestInstances();
      testInstances1.setNumNominal(1);
      KeyEvent.getKeyModifiersText((-1));
      evaluation0.KBMeanInformation();
      evaluation0.meanAbsoluteError();
      evaluation0.SFMeanEntropyGain();
      MockRandom mockRandom0 = new MockRandom();
      MockRandom mockRandom1 = new MockRandom(7);
      mockRandom1.ints();
      try { 
        evaluation0.crossValidateModel((Classifier) iBk0, instances0, 1980, (Random) mockRandom0, (Object[]) testInstances1.DEFAULT_WORDS);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // java.lang.String cannot be cast to weka.classifiers.evaluation.output.prediction.AbstractOutput
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test84()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      TestInstances testInstances0 = new TestInstances();
      TestInstances testInstances1 = new TestInstances();
      testInstances0.setNumNumeric((-2));
      IBk iBk0 = new IBk((-2));
      TestInstances testInstances2 = new TestInstances();
      Instances instances0 = testInstances1.generate(" ");
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.falseNegativeRate(1);
      Evaluation evaluation1 = new Evaluation(instances0);
      evaluation0.falsePositiveRate(2);
      double double0 = evaluation0.m_SumSqrClass;
      evaluation1.toMatrixString();
      double double1 = NimbusStyle.SMALL_SCALE;
      testInstances0.setNumNominal(4);
      KeyEvent.getKeyModifiersText(1);
      evaluation1.KBMeanInformation();
      double double2 = KStarConstants.INITIAL_STEP;
      evaluation1.SFMeanEntropyGain();
      MockRandom mockRandom0 = new MockRandom();
      double[] doubleArray0 = new double[6];
      doubleArray0[0] = (double) (-2);
      doubleArray0[1] = (double) (-1);
      doubleArray0[2] = 0.0;
      doubleArray0[3] = 1.7976931348623157E308;
      evaluation0.updateMargins(doubleArray0, 1, (-1));
      CostMatrix costMatrix0 = null;
      try {
        costMatrix0 = new CostMatrix((-1190));
        fail("Expecting exception: NegativeArraySizeException");
      
      } catch(NegativeArraySizeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.CostMatrix", e);
      }
  }

  @Test(timeout = 4000)
  public void test85()  throws Throwable  {
      SGDText sGDText0 = new SGDText();
      AdditiveRegression additiveRegression0 = new AdditiveRegression(sGDText0);
      Capabilities capabilities0 = additiveRegression0.getCapabilities();
      TestInstances testInstances0 = TestInstances.forCapabilities(capabilities0);
      Instances instances0 = testInstances0.generate("weka/core/Capabilities.props");
      UnaryOperator<Instance> unaryOperator0 = UnaryOperator.identity();
      instances0.replaceAll(unaryOperator0);
      Instances instances1 = testInstances0.generate();
      CostMatrix costMatrix0 = new CostMatrix(1);
      Evaluation evaluation0 = null;
      try {
        evaluation0 = new Evaluation(instances1, costMatrix0);
        fail("Expecting exception: Exception");
      
      } catch(Throwable e) {
         //
         // Class has to be nominal if cost matrix given!
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test86()  throws Throwable  {
      TestInstances testInstances0 = new TestInstances();
      testInstances0.setNumNumeric((-1060150156));
      IBk iBk0 = new IBk((-2));
      TestInstances testInstances1 = new TestInstances();
      Instances instances0 = testInstances1.generate("getCla");
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.falseNegativeRate((-2));
      double double0 = evaluation0.m_WithClass;
      double double1 = evaluation0.m_SumSqrClass;
      evaluation0.toMatrixString();
      Evaluation.main(testInstances1.DEFAULT_WORDS);
      evaluation0.toClassDetailsString();
      M5P m5P0 = new M5P();
      SimpleLogistic simpleLogistic0 = new SimpleLogistic(2473, false, true);
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = (double) (-1);
      doubleArray0[1] = 1217.801549;
      doubleArray0[2] = (double) (-1060150156);
      doubleArray0[3] = (double) 1;
      doubleArray0[4] = 0.0;
      SparseInstance sparseInstance0 = new SparseInstance(4);
      try { 
        evaluation0.evaluateModelOnceAndRecordPrediction(doubleArray0, (Instance) sparseInstance0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // DenseInstance doesn't have access to a dataset!
         //
         verifyException("weka.core.AbstractInstance", e);
      }
  }

  @Test(timeout = 4000)
  public void test87()  throws Throwable  {
      SimpleLogistic simpleLogistic0 = new SimpleLogistic();
      AdditiveRegression additiveRegression0 = new AdditiveRegression(simpleLogistic0);
      Capabilities capabilities0 = additiveRegression0.getCapabilities();
      TestInstances testInstances0 = TestInstances.forCapabilities(capabilities0);
      Instances instances0 = testInstances0.generate("weka/core/Capabilities.props");
      UnaryOperator<Instance> unaryOperator0 = UnaryOperator.identity();
      instances0.replaceAll(unaryOperator0);
      testInstances0.generate();
      Evaluation evaluation0 = new Evaluation(instances0, (CostMatrix) null);
      double double0 = evaluation0.m_ConfLevel;
      IBk iBk0 = new IBk();
      long long0 = 2152L;
      MockRandom mockRandom0 = new MockRandom();
      double double1 = evaluation0.m_MissingClass;
      try { 
        evaluation0.toCumulativeMarginDistributionString();
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // Class must be nominal for margin distributions
         //
         verifyException("weka.classifiers.Evaluation", e);
      }
  }

  @Test(timeout = 4000)
  public void test88()  throws Throwable  {
      TestInstances testInstances0 = new TestInstances();
      testInstances0.setSeed(2775);
      Instances instances0 = testInstances0.generate((String) null);
      instances0.parallelStream();
      IBk iBk0 = new IBk((-1));
      iBk0.buildClassifier(instances0);
      Evaluation evaluation0 = new Evaluation(instances0);
      evaluation0.useNoPriors();
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(113);
      NaiveBayesMultinomial naiveBayesMultinomial0 = new NaiveBayesMultinomial();
      naiveBayesMultinomial0.getTechnicalInformation();
      Evaluation.getGlobalInfo(naiveBayesMultinomial0);
      ArffLoader arffLoader0 = new ArffLoader();
      String string0 = DefaultEditorKit.EndOfLineStringProperty;
      double[] doubleArray0 = new double[1];
      boolean boolean0 = evaluation0.m_NoPriors;
      evaluation0.weightedRecall();
      evaluation0.m_Unclassified = 936.481899486768;
      evaluation0.rootMeanPriorSquaredError();
      evaluation0.numInstances();
      evaluation0.SFMeanEntropyGain();
      evaluation0.areaUnderPRC((-2));
      Evaluation evaluation1 = new Evaluation(instances0);
      evaluation1.SFMeanSchemeEntropy();
      evaluation1.meanPriorAbsoluteError();
      evaluation1.priorEntropy();
  }
}
