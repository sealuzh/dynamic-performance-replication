/*
 * This file was automatically generated by EvoSuite
 * Fri Jul 06 16:54:11 GMT 2018
 */

package weka.gui.beans;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.MockitoExtension.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.AWTEventMulticaster;
import java.awt.AWTKeyStroke;
import java.awt.Canvas;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GraphicsConfiguration;
import java.awt.event.ContainerListener;
import java.awt.event.InputMethodListener;
import java.awt.event.MouseWheelListener;
import java.awt.image.DirectColorModel;
import java.beans.EventSetDescriptor;
import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.time.DateTimeException;
import java.time.chrono.JapaneseDate;
import java.time.chrono.JapaneseEra;
import java.util.Enumeration;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.TimeZone;
import java.util.Vector;
import javax.swing.DebugGraphics;
import javax.swing.JList;
import javax.swing.JMenu;
import javax.swing.JTree;
import javax.swing.KeyStroke;
import javax.swing.MenuElement;
import javax.swing.TransferHandler;
import javax.swing.plaf.PanelUI;
import javax.swing.plaf.metal.MetalComboBoxEditor;
import javax.swing.text.AttributeSet;
import javax.swing.text.StyleConstants;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.mock.java.net.MockURL;
import org.evosuite.runtime.mock.java.time.chrono.MockHijrahDate;
import org.evosuite.runtime.mock.java.time.chrono.MockJapaneseDate;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.EvoSuiteURL;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.testdata.NetworkHandling;
import org.junit.runner.RunWith;
import weka.associations.Apriori;
import weka.associations.FilteredAssociator;
import weka.core.AbstractInstance;
import weka.core.CheckOptionHandler;
import weka.core.EuclideanDistance;
import weka.core.FindWithCapabilities;
import weka.core.Instances;
import weka.core.ListOptions;
import weka.core.NormalizableDistance;
import weka.core.OptionHandlerJavadoc;
import weka.core.SparseInstance;
import weka.core.TestInstances;
import weka.core.converters.ArffLoader;
import weka.core.converters.MatlabLoader;
import weka.core.converters.SVMLightLoader;
import weka.core.converters.TextDirectoryLoader;
import weka.core.tokenizers.AlphabeticTokenizer;
import weka.filters.AllFilter;
import weka.filters.MultiFilter;
import weka.filters.supervised.attribute.ClassOrder;
import weka.filters.supervised.attribute.Discretize;
import weka.filters.supervised.instance.Resample;
import weka.filters.supervised.instance.SpreadSubsample;
import weka.filters.unsupervised.attribute.Add;
import weka.gui.Logger;
import weka.gui.SysErrLog;
import weka.gui.WekaTaskMonitor;
import weka.gui.beans.Appender;
import weka.gui.beans.Associator;
import weka.gui.beans.BeanVisual;
import weka.gui.beans.ClassAssigner;
import weka.gui.beans.ClassValuePicker;
import weka.gui.beans.Classifier;
import weka.gui.beans.ClassifierPerformanceEvaluator;
import weka.gui.beans.ConfigurationListener;
import weka.gui.beans.CrossValidationFoldMaker;
import weka.gui.beans.DataSetEvent;
import weka.gui.beans.Filter;
import weka.gui.beans.FlowByExpression;
import weka.gui.beans.IncrementalClassifierEvaluator;
import weka.gui.beans.InstanceEvent;
import weka.gui.beans.InstanceStreamToBatchMaker;
import weka.gui.beans.KnowledgeFlowApp;
import weka.gui.beans.ModelPerformanceChart;
import weka.gui.beans.PredictionAppender;
import weka.gui.beans.Saver;
import weka.gui.beans.ScatterPlotMatrix;
import weka.gui.beans.SerializedModelSaver;
import weka.gui.beans.Sorter;
import weka.gui.beans.SubstringLabeler;
import weka.gui.beans.SubstringReplacer;
import weka.gui.beans.TestSetEvent;
import weka.gui.beans.TestSetMaker;
import weka.gui.beans.TrainTestSplitMaker;
import weka.gui.beans.TrainingSetEvent;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class Filter_ESTest extends Filter_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Filter filter0 = new Filter();
      BeanVisual beanVisual0 = filter0.getVisual();
      assertEquals("weka/gui/beans/icons/DefaultFilter_animated.gif", beanVisual0.getAnimatedIconPath());
      assertEquals("weka/gui/beans/icons/DefaultFilter.gif", beanVisual0.getIconPath());
      
      filter0.getWrappedAlgorithm();
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Filter filter0 = new Filter();
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      substringLabeler0.getUIClassID();
      BeanVisual beanVisual0 = substringLabeler0.m_visual;
      filter0.setVisual(beanVisual0);
      filter0.addTestSetListener(substringLabeler0);
      assertEquals("SubstringLabeler", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      Filter filter0 = new Filter();
      Appender appender0 = new Appender();
      Logger logger0 = appender0.m_log;
      filter0.setLog((Logger) null);
      filter0.connectionNotification("CNYU)", "CNYU)");
      boolean boolean0 = filter0.connectionAllowed("CNYU)");
      assertFalse(boolean0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.transferFocusBackward();
      filter0.connectionNotification("-aP{Cm#7(Qf|", "-aP{Cm#7(Qf|");
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "-aP{Cm#7(Qf|");
      JMenu jMenu0 = new JMenu("-aP{Cm#7(Qf|");
      filter0.stop();
      filter0.setCustomName("-aP{Cm#7(Qf|");
      assertEquals("-aP{Cm#7(Qf|", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Filter filter0 = new Filter();
      ClassOrder classOrder0 = new ClassOrder();
      DataSetEvent dataSetEvent0 = new DataSetEvent(classOrder0, (Instances) null);
      filter0.acceptDataSet(dataSetEvent0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Filter filter0 = new Filter();
      FilteredAssociator filteredAssociator0 = new FilteredAssociator();
      weka.filters.Filter filter1 = filteredAssociator0.getFilter();
      weka.filters.Filter filter2 = weka.filters.Filter.makeCopy(filter1);
      filter0.setFilter(filter2);
      filter0.globalInfo();
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Filter filter0 = new Filter();
      EvoSuiteFile evoSuiteFile0 = null;
      filter0.updateUI();
      filter0.connectionAllowed(" Error in obtaining post-filter structure. ");
      // Undeclared exception!
      try { 
        filter0.connectionAllowed((EventSetDescriptor) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Filter filter0 = new Filter();
      ListOptions listOptions0 = new ListOptions();
      ListOptions.main((String[]) null);
      ListOptions.main((String[]) null);
      listOptions0.getRevision();
      filter0.getInputMethodListeners();
      String string0 = JTree.SELECTION_MODEL_PROPERTY;
      listOptions0.getOptions();
      DataSetEvent dataSetEvent0 = new DataSetEvent(listOptions0, (Instances) null);
      listOptions0.generate();
      filter0.acceptDataSet(dataSetEvent0);
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      filter0.addConfigurationListener(configurationListener0);
      filter0.globalInfo();
      filter0.getWrappedAlgorithm();
      filter0.acceptInstance((InstanceEvent) null);
      JapaneseEra japaneseEra0 = JapaneseEra.MEIJI;
      TestSetMaker testSetMaker0 = new TestSetMaker();
      // Undeclared exception!
      try { 
        MockJapaneseDate.of(japaneseEra0, (-1048), (-907), (-1048));
        fail("Expecting exception: DateTimeException");
      
      } catch(DateTimeException e) {
         //
         // year, month, and day not valid for Era
         //
         verifyException("java.time.chrono.JapaneseDate", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Filter filter0 = new Filter();
      // Undeclared exception!
      try { 
        filter0.performRequest("h$^[;zvZALifS");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // h$^[;zvZALifS not supported (Filter)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.addMouseWheelListener((MouseWheelListener) null);
      filter0.stop();
      FlowByExpression flowByExpression0 = new FlowByExpression();
      filter0.removeTrainingSetListener(flowByExpression0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.revalidate();
      FileSystemHandling.shouldAllThrowIOExceptions();
      Associator associator0 = new Associator();
      associator0.getStructure(".E(G8");
      TestSetEvent testSetEvent0 = new TestSetEvent(filter0, (Instances) null);
      filter0.acceptTestSet(testSetEvent0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Filter filter0 = new Filter();
      FlowByExpression flowByExpression0 = new FlowByExpression();
      filter0.removeDataSourceListener(flowByExpression0);
      TestInstances testInstances0 = new TestInstances();
      Instances instances0 = testInstances0.generate("can't process streamed instances; can't continue");
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(flowByExpression0, instances0, (-1), (-2));
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Filter filter0 = new Filter();
      InstanceStreamToBatchMaker instanceStreamToBatchMaker0 = new InstanceStreamToBatchMaker();
      MenuElement[] menuElementArray0 = new MenuElement[1];
      filter0.connectionNotification("eLN&W", instanceStreamToBatchMaker0);
      filter0.stop();
      filter0.getFilter();
      AllFilter allFilter0 = new AllFilter();
      filter0.disconnectionNotification("k", allFilter0);
      Saver saver0 = new Saver();
      String string0 = filter0.getCustomName();
      assertEquals("AllFilter", string0);
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Filter filter0 = new Filter();
      weka.gui.LogPanel logPanel0 = new weka.gui.LogPanel();
      KeyStroke.getKeyStroke((-1517), (-1517));
      logPanel0.getAutoscrolls();
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      textDirectoryLoader0.setCharSet("8N ");
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "4mFW");
      textDirectoryLoader0.getDataSet();
      DebugGraphics.logStream();
      boolean boolean0 = filter0.eventGeneratable("trainingSet");
      assertFalse(boolean0);
      
      Filter filter1 = new Filter();
      SerializedModelSaver serializedModelSaver0 = new SerializedModelSaver();
      filter1.disconnectionNotification("trainingSet", serializedModelSaver0);
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      TrainTestSplitMaker trainTestSplitMaker1 = new TrainTestSplitMaker();
      filter0.addTrainingSetListener(trainTestSplitMaker0);
      filter1.performRequest("Stop");
      assertEquals("AllFilter", filter1.getCustomName());
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.updateUI();
      filter0.connectionNotification("jh^^[tzvZ7S{lifS", "jh^^[tzvZ7S{lifS");
      BeanVisual beanVisual0 = filter0.getVisual();
      assertEquals("weka/gui/beans/icons/DefaultFilter.gif", beanVisual0.getIconPath());
      assertEquals("weka/gui/beans/icons/DefaultFilter_animated.gif", beanVisual0.getAnimatedIconPath());
      
      FileSystemHandling.shouldAllThrowIOExceptions();
      FindWithCapabilities findWithCapabilities0 = new FindWithCapabilities();
      DebugGraphics.logStream();
      boolean boolean0 = filter0.eventGeneratable("jh^^[tzvZ7S{lifS");
      assertTrue(boolean0);
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      filter0.disconnectionNotification("BTmeJ`:&4O:B_", "BTmeJ`:&4O:B_");
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      String string0 = filter0.getCustomName();
      assertEquals("AllFilter", string0);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.setBounds(2378, 2378, 2378, 2378);
      filter0.updateUI();
      filter0.setSize(2378, 2);
      filter0.connectionNotification("jh^^[tzvZ7S{lifS", "^d~?7b&mA7");
      filter0.getVisual();
      filter0.acceptInstance((InstanceEvent) null);
      Character.isBmpCodePoint(2);
      FindWithCapabilities findWithCapabilities0 = new FindWithCapabilities();
      filter0.getGraphicsConfiguration();
      Canvas canvas0 = new Canvas((GraphicsConfiguration) null);
      MockJapaneseDate mockJapaneseDate0 = new MockJapaneseDate();
      ClassifierPerformanceEvaluator classifierPerformanceEvaluator0 = new ClassifierPerformanceEvaluator();
      Object object0 = classifierPerformanceEvaluator0.m_listenee;
      Associator associator0 = new Associator();
      ClassValuePicker classValuePicker0 = new ClassValuePicker();
      ScatterPlotMatrix scatterPlotMatrix0 = new ScatterPlotMatrix();
      filter0.connectionNotification("jh^^[tzvZ7S{lifS", scatterPlotMatrix0);
      ClassifierPerformanceEvaluator classifierPerformanceEvaluator1 = new ClassifierPerformanceEvaluator();
      ClassAssigner classAssigner0 = new ClassAssigner();
      SVMLightLoader sVMLightLoader0 = new SVMLightLoader();
      try { 
        MockURL.URL("weka/gui/beans/icons/", "0+", "0+");
        fail("Expecting exception: MalformedURLException");
      
      } catch(MalformedURLException e) {
         //
         // unknown protocol: weka/gui/beans/icons/
         //
         verifyException("java.net.URL", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.stop();
      Appender appender0 = new Appender();
      appender0.setFocusCycleRoot(false);
      Logger logger0 = appender0.m_log;
      filter0.setLog((Logger) null);
      SpreadSubsample spreadSubsample0 = new SpreadSubsample();
      filter0.setWrappedAlgorithm(spreadSubsample0);
      filter0.removeDataSourceListener(appender0);
      filter0.globalInfo();
      assertEquals("<html><font color=blue>Produces a random subsample of a dataset</font><br><br> The original dataset must fit entirely in memory.<br>This filter allows you to specify the maximum \"spread\" between the rarest and most common class.<br>For example, you may specify that there be at most a 2:1 difference in class frequencies.<br>When used in batch mode, subsequent batches are NOT resampled.<br></html>", filter0.globalInfo());
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      Filter filter0 = new Filter();
      PanelUI panelUI0 = filter0.getUI();
      filter0.setUI(panelUI0);
      FindWithCapabilities findWithCapabilities0 = new FindWithCapabilities();
      ClassAssigner classAssigner0 = new ClassAssigner();
      filter0.addInstanceListener(classAssigner0);
      filter0.eventGeneratable("}~fF2eSPoG'5");
      filter0.removeConfigurationListener((ConfigurationListener) null);
      filter0.getCustomName();
      filter0.getFilter();
      FlowByExpression flowByExpression0 = new FlowByExpression();
      InstanceEvent instanceEvent0 = flowByExpression0.m_ie;
      // Undeclared exception!
      try { 
        filter0.notifyInstanceListeners(instanceEvent0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.gui.beans.ClassAssigner", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      Filter filter0 = new Filter();
      ListOptions listOptions0 = new ListOptions();
      InputMethodListener inputMethodListener0 = mock(InputMethodListener.class, new ViolatedAssumptionAnswer());
      AWTEventMulticaster aWTEventMulticaster0 = (AWTEventMulticaster)AWTEventMulticaster.add(inputMethodListener0, inputMethodListener0);
      AWTEventMulticaster.remove((InputMethodListener) aWTEventMulticaster0, (InputMethodListener) aWTEventMulticaster0);
      AWTEventMulticaster.add((InputMethodListener) null, (InputMethodListener) null);
      filter0.removeInputMethodListener(aWTEventMulticaster0);
      filter0.globalInfo();
      Appender appender0 = new Appender();
      Classifier classifier0 = new Classifier();
      appender0.firePropertyChange(" lbgkG4[Gtug", 1, 1);
      MetalComboBoxEditor.UIResource metalComboBoxEditor_UIResource0 = new MetalComboBoxEditor.UIResource();
      classifier0.addFocusListener(aWTEventMulticaster0);
      FlowByExpression flowByExpression0 = new FlowByExpression();
      filter0.addInstanceListener(flowByExpression0);
      filter0.removeTestSetListener(filter0);
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      filter0.addConfigurationListener(configurationListener0);
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      InstanceEvent instanceEvent0 = substringReplacer0.m_ie;
      filter0.notifyInstanceListeners(instanceEvent0);
      // Undeclared exception!
      try { 
        filter0.performRequest(" lbgkG4[Gtug");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         //  lbgkG4[Gtug not supported (Filter)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertNotNull(filter0);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertTrue(multiFilter0.isNewBatch());
      assertNotNull(multiFilter0);
      
      Add add0 = new Add();
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertNotNull(add0);
      
      filter0.setFilter(add0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertFalse(textDirectoryLoader0.getDebug());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertNotNull(textDirectoryLoader0);
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      Appender appender0 = new Appender();
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      assertNotNull(appender0);
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(0, instanceEvent0.getStatus());
      assertNotNull(instanceEvent0);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      assertEquals(0, instanceEvent0.getStatus());
      
      String string0 = filter0.globalInfo();
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", string0);
      assertNotNull(string0);
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertNotNull(filter0);
      
      filter0.updateUI();
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertNotNull(multiFilter0);
      
      filter0.setFilter(multiFilter0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      
      filter0.firePropertyChange("<!x", (-1), (-1));
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      ListOptions listOptions0 = new ListOptions();
      assertEquals("weka.core.ListOptions", listOptions0.getClassname());
      assertNotNull(listOptions0);
      
      String[] stringArray0 = TimeZone.getAvailableIDs();
      assertNotNull(stringArray0);
      
      FindWithCapabilities findWithCapabilities0 = new FindWithCapabilities();
      assertEquals("", findWithCapabilities0.getFilename());
      assertNotNull(findWithCapabilities0);
      
      ClassAssigner classAssigner0 = new ClassAssigner();
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertFalse(classAssigner0.isBusy());
      assertEquals("last", classAssigner0.getClassColumn());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertNotNull(classAssigner0);
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertNotNull(substringReplacer0);
      
      DirectColorModel directColorModel0 = (DirectColorModel)substringReplacer0.getColorModel();
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertEquals(3, directColorModel0.getNumColorComponents());
      assertEquals(32, directColorModel0.getPixelSize());
      assertEquals(4, directColorModel0.getNumComponents());
      assertEquals((-16777216), directColorModel0.getAlphaMask());
      assertEquals(3, directColorModel0.getTransferType());
      assertEquals(3, directColorModel0.getTransparency());
      assertEquals(255, directColorModel0.getBlueMask());
      assertEquals(16711680, directColorModel0.getRedMask());
      assertFalse(directColorModel0.isAlphaPremultiplied());
      assertEquals(65280, directColorModel0.getGreenMask());
      assertTrue(directColorModel0.hasAlpha());
      assertNotNull(directColorModel0);
      
      SubstringReplacer substringReplacer1 = new SubstringReplacer();
      assertFalse(substringReplacer1.isFocusTraversalPolicySet());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer1.globalInfo());
      assertFalse(substringReplacer1.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer1.getCustomName());
      assertFalse(substringReplacer1.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer1.isBusy());
      assertEquals("", substringReplacer1.getMatchReplaceDetails());
      assertFalse(substringReplacer1.getIgnoreRepaint());
      assertTrue(substringReplacer1.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer1.equals((Object)substringReplacer0));
      assertNotNull(substringReplacer1);
      
      SubstringReplacer substringReplacer2 = new SubstringReplacer();
      assertFalse(substringReplacer2.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer2.getCustomName());
      assertFalse(substringReplacer2.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer2.globalInfo());
      assertFalse(substringReplacer2.isBusy());
      assertEquals("", substringReplacer2.getMatchReplaceDetails());
      assertFalse(substringReplacer2.getIgnoreRepaint());
      assertFalse(substringReplacer2.isFocusTraversalPolicySet());
      assertTrue(substringReplacer2.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer2.equals((Object)substringReplacer0));
      assertFalse(substringReplacer2.equals((Object)substringReplacer1));
      assertNotNull(substringReplacer2);
      
      InstanceEvent instanceEvent0 = substringReplacer2.m_ie;
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(0, instanceEvent0.getStatus());
      assertNotNull(instanceEvent0);
      
      instanceEvent0.setStatus((-1));
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertNotSame(substringReplacer2, substringReplacer0);
      assertNotSame(substringReplacer2, substringReplacer1);
      assertFalse(substringReplacer2.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer2.getCustomName());
      assertFalse(substringReplacer2.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer2.globalInfo());
      assertFalse(substringReplacer2.isBusy());
      assertEquals("", substringReplacer2.getMatchReplaceDetails());
      assertFalse(substringReplacer2.getIgnoreRepaint());
      assertFalse(substringReplacer2.isFocusTraversalPolicySet());
      assertTrue(substringReplacer2.getFocusTraversalKeysEnabled());
      assertEquals((-1), instanceEvent0.getStatus());
      assertFalse(substringReplacer2.equals((Object)substringReplacer0));
      assertFalse(substringReplacer2.equals((Object)substringReplacer1));
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertNotSame(substringReplacer2, substringReplacer0);
      assertNotSame(substringReplacer2, substringReplacer1);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer2.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer2.getCustomName());
      assertFalse(substringReplacer2.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer2.globalInfo());
      assertFalse(substringReplacer2.isBusy());
      assertEquals("", substringReplacer2.getMatchReplaceDetails());
      assertFalse(substringReplacer2.getIgnoreRepaint());
      assertFalse(substringReplacer2.isFocusTraversalPolicySet());
      assertTrue(substringReplacer2.getFocusTraversalKeysEnabled());
      assertEquals((-1), instanceEvent0.getStatus());
      assertFalse(substringReplacer2.equals((Object)substringReplacer0));
      assertFalse(substringReplacer2.equals((Object)substringReplacer1));
      
      instanceEvent0.setStatus((-1));
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertNotSame(substringReplacer2, substringReplacer0);
      assertNotSame(substringReplacer2, substringReplacer1);
      assertFalse(substringReplacer2.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer2.getCustomName());
      assertFalse(substringReplacer2.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer2.globalInfo());
      assertFalse(substringReplacer2.isBusy());
      assertEquals("", substringReplacer2.getMatchReplaceDetails());
      assertFalse(substringReplacer2.getIgnoreRepaint());
      assertFalse(substringReplacer2.isFocusTraversalPolicySet());
      assertTrue(substringReplacer2.getFocusTraversalKeysEnabled());
      assertEquals((-1), instanceEvent0.getStatus());
      assertFalse(substringReplacer2.equals((Object)substringReplacer0));
      assertFalse(substringReplacer2.equals((Object)substringReplacer1));
      
      // Undeclared exception!
      try { 
        MockHijrahDate.of((-1812834680), 2, 1);
        fail("Expecting exception: DateTimeException");
      
      } catch(DateTimeException e) {
         //
         // Invalid Hijrah date, year: -1812834680, month: 2
         //
         verifyException("java.time.chrono.HijrahChronology", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertNotNull(filter0);
      
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/mnt/gaiagpfs/users/homedirs/apanichella/Evosuite_performance/Dataset/gordon_script_sum/projects/9_weka");
      byte[] byteArray0 = new byte[2];
      byteArray0[0] = (byte) (-7);
      byteArray0[1] = (byte)46;
      boolean boolean0 = FileSystemHandling.appendDataToFile(evoSuiteFile0, byteArray0);
      assertArrayEquals(new byte[] {(byte) (-7), (byte)46}, byteArray0);
      assertFalse(boolean0);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertNotNull(textDirectoryLoader0);
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertNotNull(instances0);
      
      AlphabeticTokenizer alphabeticTokenizer0 = new AlphabeticTokenizer();
      assertEquals("Alphabetic string tokenizer, tokens are to be formed only from contiguous alphabetic sequences.", alphabeticTokenizer0.globalInfo());
      assertNotNull(alphabeticTokenizer0);
      
      JapaneseDate japaneseDate0 = MockJapaneseDate.now();
      assertNotNull(japaneseDate0);
      
      TestSetEvent testSetEvent0 = new TestSetEvent(textDirectoryLoader0, instances0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, testSetEvent0.getSetNumber());
      assertTrue(testSetEvent0.isStructureOnly());
      assertEquals(1, testSetEvent0.getRunNumber());
      assertEquals(0, testSetEvent0.getMaxSetNumber());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertNotNull(testSetEvent0);
      
      filter0.acceptTestSet(testSetEvent0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, testSetEvent0.getSetNumber());
      assertTrue(testSetEvent0.isStructureOnly());
      assertEquals(1, testSetEvent0.getRunNumber());
      assertEquals(0, testSetEvent0.getMaxSetNumber());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      
      JapaneseDate japaneseDate1 = MockJapaneseDate.now();
      assertNotSame(japaneseDate1, japaneseDate0);
      assertTrue(japaneseDate1.equals((Object)japaneseDate0));
      assertNotNull(japaneseDate1);
      
      TextDirectoryLoader textDirectoryLoader1 = new TextDirectoryLoader();
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader1.globalInfo());
      assertFalse(textDirectoryLoader1.getDebug());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader1.charSetTipText());
      assertFalse(textDirectoryLoader1.getOutputFilename());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader1.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader1.outputFilenameTipText());
      assertEquals("", textDirectoryLoader1.getCharSet());
      assertEquals("Directories", textDirectoryLoader1.getFileDescription());
      assertFalse(textDirectoryLoader1.equals((Object)textDirectoryLoader0));
      assertNotNull(textDirectoryLoader1);
      
      MockFile mockFile0 = new MockFile(".arff");
      assertFalse(mockFile0.isAbsolute());
      assertEquals(0L, mockFile0.getTotalSpace());
      assertNull(mockFile0.getParent());
      assertEquals(0L, mockFile0.getFreeSpace());
      assertFalse(mockFile0.canExecute());
      assertTrue(mockFile0.isFile());
      assertEquals(".arff", mockFile0.toString());
      assertTrue(mockFile0.isHidden());
      assertFalse(mockFile0.canRead());
      assertFalse(mockFile0.exists());
      assertEquals(0L, mockFile0.getUsableSpace());
      assertEquals(".arff", mockFile0.getName());
      assertFalse(mockFile0.isDirectory());
      assertEquals(0L, mockFile0.length());
      assertEquals(0L, mockFile0.lastModified());
      assertFalse(mockFile0.canWrite());
      assertNotNull(mockFile0);
      
      try { 
        textDirectoryLoader1.setSource((File) mockFile0);
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // Directory '.arff' not found
         //
         verifyException("weka.core.converters.TextDirectoryLoader", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertNotNull(filter0);
      
      boolean boolean0 = filter0.isBusy();
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(boolean0);
      
      LinkedHashSet<AWTKeyStroke> linkedHashSet0 = new LinkedHashSet<AWTKeyStroke>();
      assertTrue(linkedHashSet0.isEmpty());
      assertEquals(0, linkedHashSet0.size());
      assertNotNull(linkedHashSet0);
      
      JapaneseDate japaneseDate0 = MockJapaneseDate.now();
      assertNotNull(japaneseDate0);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertNotNull(textDirectoryLoader0);
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertNotNull(instances0);
      
      filter0.acceptInstance((InstanceEvent) null);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      
      Sorter sorter0 = new Sorter();
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isBusy());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.getIgnoreRepaint());
      assertNull(sorter0.getSortDetails());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNotNull(sorter0);
      
      InputMethodListener inputMethodListener0 = mock(InputMethodListener.class, new ViolatedAssumptionAnswer());
      GraphicsConfiguration graphicsConfiguration0 = filter0.getGraphicsConfiguration();
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertNull(graphicsConfiguration0);
      
      DataSetEvent dataSetEvent0 = new DataSetEvent(textDirectoryLoader0, instances0);
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertTrue(dataSetEvent0.isStructureOnly());
      assertNotNull(dataSetEvent0);
      
      filter0.acceptDataSet(dataSetEvent0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertTrue(dataSetEvent0.isStructureOnly());
      
      Sorter sorter1 = new Sorter();
      assertFalse(sorter1.isFocusTraversalPolicySet());
      assertFalse(sorter1.isFocusTraversalPolicyProvider());
      assertFalse(sorter1.isFocusCycleRoot());
      assertNull(sorter1.getSortDetails());
      assertFalse(sorter1.isBusy());
      assertEquals("", sorter1.getTempDirectory());
      assertTrue(sorter1.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter1.globalInfo());
      assertEquals("10000", sorter1.getBufferSize());
      assertFalse(sorter1.getIgnoreRepaint());
      assertEquals("Sorter", sorter1.getCustomName());
      assertFalse(sorter1.equals((Object)sorter0));
      assertNotNull(sorter1);
      
      Dimension dimension0 = sorter1.getMaximumSize();
      assertEquals(Integer.MAX_VALUE, dimension0.width);
      assertEquals(Integer.MAX_VALUE, dimension0.height);
      assertNotSame(sorter1, sorter0);
      assertFalse(sorter1.isFocusTraversalPolicySet());
      assertFalse(sorter1.isFocusTraversalPolicyProvider());
      assertFalse(sorter1.isFocusCycleRoot());
      assertNull(sorter1.getSortDetails());
      assertFalse(sorter1.isBusy());
      assertEquals("", sorter1.getTempDirectory());
      assertTrue(sorter1.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter1.globalInfo());
      assertEquals("10000", sorter1.getBufferSize());
      assertFalse(sorter1.getIgnoreRepaint());
      assertEquals("Sorter", sorter1.getCustomName());
      assertEquals(2.147483647E9, dimension0.getWidth(), 0.01);
      assertEquals(2.147483647E9, dimension0.getHeight(), 0.01);
      assertFalse(sorter1.equals((Object)sorter0));
      assertNotNull(dimension0);
      
      Instances instances1 = sorter1.getStructure("h^^[tzvZ7:]S{lifS");
      assertNotSame(sorter1, sorter0);
      assertFalse(sorter1.isFocusTraversalPolicySet());
      assertFalse(sorter1.isFocusTraversalPolicyProvider());
      assertFalse(sorter1.isFocusCycleRoot());
      assertNull(sorter1.getSortDetails());
      assertFalse(sorter1.isBusy());
      assertEquals("", sorter1.getTempDirectory());
      assertTrue(sorter1.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter1.globalInfo());
      assertEquals("10000", sorter1.getBufferSize());
      assertFalse(sorter1.getIgnoreRepaint());
      assertEquals("Sorter", sorter1.getCustomName());
      assertFalse(sorter1.equals((Object)sorter0));
      assertNull(instances1);
      
      DataSetEvent dataSetEvent1 = null;
      try {
        dataSetEvent1 = new DataSetEvent((Object) null, (Instances) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // null source
         //
         verifyException("java.util.EventObject", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertNotNull(filter0);
      
      ContainerListener containerListener0 = mock(ContainerListener.class, new ViolatedAssumptionAnswer());
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertNotNull(textDirectoryLoader0);
      
      Instances instances0 = textDirectoryLoader0.getStructure();
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals(2, instances0.numAttributes());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numInstances());
      assertNotNull(instances0);
      
      Sorter sorter0 = new Sorter();
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.isBusy());
      assertNotNull(sorter0);
      
      TransferHandler transferHandler0 = sorter0.getTransferHandler();
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.isBusy());
      assertNull(transferHandler0);
      
      GraphicsConfiguration graphicsConfiguration0 = filter0.getGraphicsConfiguration();
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertNull(graphicsConfiguration0);
      
      WekaTaskMonitor wekaTaskMonitor0 = new WekaTaskMonitor();
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicySet());
      assertTrue(wekaTaskMonitor0.getFocusTraversalKeysEnabled());
      assertFalse(wekaTaskMonitor0.getIgnoreRepaint());
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicyProvider());
      assertFalse(wekaTaskMonitor0.isFocusCycleRoot());
      assertNotNull(wekaTaskMonitor0);
      
      FindWithCapabilities findWithCapabilities0 = new FindWithCapabilities();
      assertEquals("", findWithCapabilities0.getFilename());
      assertNotNull(findWithCapabilities0);
      
      ClassAssigner classAssigner0 = new ClassAssigner();
      assertEquals("last", classAssigner0.getClassColumn());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertFalse(classAssigner0.isBusy());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertNotNull(classAssigner0);
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertNotNull(substringReplacer0);
      
      InstanceEvent instanceEvent0 = substringReplacer0.m_ie;
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, instanceEvent0.getStatus());
      assertNotNull(instanceEvent0);
      
      Appender appender0 = new Appender();
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertNotNull(appender0);
      
      Appender appender1 = new Appender();
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusCycleRoot());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.equals((Object)appender0));
      assertNotNull(appender1);
      
      Instances instances1 = sorter0.getStructure("vi[A*%CPeEGZ?A!");
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.isBusy());
      assertNull(instances1);
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(instanceEvent0, instances0, (-953), (-51));
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals(2, instances0.numAttributes());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numInstances());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals((-953), trainingSetEvent0.getSetNumber());
      assertEquals((-51), trainingSetEvent0.getMaxSetNumber());
      assertNotNull(trainingSetEvent0);
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals(2, instances0.numAttributes());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numInstances());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals((-953), trainingSetEvent0.getSetNumber());
      assertEquals((-51), trainingSetEvent0.getMaxSetNumber());
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertNotNull(filter0);
      
      filter0.updateUI();
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      boolean boolean1 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean1 == boolean0);
      assertFalse(boolean1);
      
      FindWithCapabilities findWithCapabilities0 = new FindWithCapabilities();
      assertEquals("", findWithCapabilities0.getFilename());
      assertNotNull(findWithCapabilities0);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertNotNull(textDirectoryLoader0);
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertNotNull(instances0);
      
      Classifier classifier0 = new Classifier();
      assertTrue(classifier0.getFocusTraversalKeysEnabled());
      assertEquals("", classifier0.getLoadClassifierFileName());
      assertEquals("ZeroR", classifier0.getCustomName());
      assertFalse(classifier0.hasIncomingBatchInstances());
      assertFalse(classifier0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Class for building and using a 0-R classifier</font><br><br> Predicts the mean (for a numeric class) or the mode (for a nominal class).<br></html>", classifier0.globalInfo());
      assertFalse(classifier0.isFocusTraversalPolicyProvider());
      assertFalse(classifier0.getBlockOnLastFold());
      assertFalse(classifier0.isFocusCycleRoot());
      assertFalse(classifier0.isFocusTraversalPolicySet());
      assertEquals(2, classifier0.getExecutionSlots());
      assertFalse(classifier0.getResetIncrementalClassifier());
      assertTrue(classifier0.getUpdateIncrementalClassifier());
      assertFalse(classifier0.hasIncomingStreamInstances());
      assertNotNull(classifier0);
      
      Appender appender0 = new Appender();
      assertFalse(appender0.getIgnoreRepaint());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertNotNull(appender0);
      
      Sorter sorter0 = new Sorter();
      assertEquals("", sorter0.getTempDirectory());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.getIgnoreRepaint());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertNull(sorter0.getSortDetails());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNotNull(sorter0);
      
      filter0.addTrainingSetListener(appender0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(appender0.getIgnoreRepaint());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      
      GraphicsConfiguration graphicsConfiguration0 = filter0.getGraphicsConfiguration();
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertNull(graphicsConfiguration0);
      
      Canvas canvas0 = new Canvas((GraphicsConfiguration) null);
      assertEquals(0.5F, canvas0.getAlignmentX(), 0.01F);
      assertFalse(canvas0.isDoubleBuffered());
      assertTrue(canvas0.getFocusTraversalKeysEnabled());
      assertFalse(canvas0.isOpaque());
      assertFalse(canvas0.getIgnoreRepaint());
      assertEquals(0.5F, canvas0.getAlignmentY(), 0.01F);
      assertEquals(Component.BaselineResizeBehavior.OTHER, canvas0.getBaselineResizeBehavior());
      assertEquals(0, canvas0.getWidth());
      assertEquals(0, canvas0.getX());
      assertEquals(0, canvas0.getHeight());
      assertEquals(0, canvas0.getY());
      assertNotNull(canvas0);
      
      MockJapaneseDate mockJapaneseDate0 = new MockJapaneseDate();
      assertNotNull(mockJapaneseDate0);
      
      ClassifierPerformanceEvaluator classifierPerformanceEvaluator0 = new ClassifierPerformanceEvaluator();
      assertFalse(classifierPerformanceEvaluator0.getIgnoreRepaint());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals("Set the number of evaluation tasks to run in parallel.", classifierPerformanceEvaluator0.executionSlotsTipText());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicySet());
      assertEquals(2, classifierPerformanceEvaluator0.getExecutionSlots());
      assertFalse(classifierPerformanceEvaluator0.isFocusCycleRoot());
      assertTrue(classifierPerformanceEvaluator0.getFocusTraversalKeysEnabled());
      assertEquals("ClassifierPerformanceEvaluator", classifierPerformanceEvaluator0.getCustomName());
      assertEquals("Evaluate the performance of batch trained classifiers.", classifierPerformanceEvaluator0.globalInfo());
      assertNotNull(classifierPerformanceEvaluator0);
      
      Object object0 = classifierPerformanceEvaluator0.m_listenee;
      assertNull(object0);
      
      Resample resample0 = new Resample();
      assertFalse(resample0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals(100.0, resample0.getSampleSizePercent(), 0.01);
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample0.invertSelectionTipText());
      assertEquals("Disables the replacement of instances.", resample0.noReplacementTipText());
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample0.biasToUniformClassTipText());
      assertEquals("The subsample size as a percentage of the original set.", resample0.sampleSizePercentTipText());
      assertTrue(resample0.isNewBatch());
      assertFalse(resample0.getNoReplacement());
      assertFalse(resample0.isFirstBatchDone());
      assertEquals(1, resample0.getRandomSeed());
      assertFalse(resample0.getInvertSelection());
      assertEquals("Sets the random number seed for subsampling.", resample0.randomSeedTipText());
      assertEquals(0.0, resample0.getBiasToUniformClass(), 0.01);
      assertFalse(resample0.isOutputFormatDefined());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample0.globalInfo());
      assertNotNull(resample0);
      
      filter0.disconnectionNotification("@data", resample0);
      assertFalse(resample0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals(100.0, resample0.getSampleSizePercent(), 0.01);
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample0.invertSelectionTipText());
      assertEquals("Disables the replacement of instances.", resample0.noReplacementTipText());
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample0.biasToUniformClassTipText());
      assertEquals("The subsample size as a percentage of the original set.", resample0.sampleSizePercentTipText());
      assertTrue(resample0.isNewBatch());
      assertFalse(resample0.getNoReplacement());
      assertFalse(resample0.isFirstBatchDone());
      assertEquals(1, resample0.getRandomSeed());
      assertFalse(resample0.getInvertSelection());
      assertEquals("Sets the random number seed for subsampling.", resample0.randomSeedTipText());
      assertEquals(0.0, resample0.getBiasToUniformClass(), 0.01);
      assertFalse(resample0.isOutputFormatDefined());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      
      ClassValuePicker classValuePicker0 = new ClassValuePicker();
      assertNull(classValuePicker0.getClassValue());
      assertFalse(classValuePicker0.isFocusTraversalPolicySet());
      assertEquals("Designate which class value is to be considered the \"positive\" class value (useful for ROC style curves).", classValuePicker0.globalInfo());
      assertTrue(classValuePicker0.getFocusTraversalKeysEnabled());
      assertEquals("ClassValuePicker", classValuePicker0.getCustomName());
      assertFalse(classValuePicker0.getIgnoreRepaint());
      assertFalse(classValuePicker0.isBusy());
      assertFalse(classValuePicker0.isFocusTraversalPolicyProvider());
      assertFalse(classValuePicker0.isFocusCycleRoot());
      assertNotNull(classValuePicker0);
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(classifierPerformanceEvaluator0, instances0, (-1363), 46);
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals((-1363), trainingSetEvent0.getSetNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals(46, trainingSetEvent0.getMaxSetNumber());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertFalse(classifierPerformanceEvaluator0.getIgnoreRepaint());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals("Set the number of evaluation tasks to run in parallel.", classifierPerformanceEvaluator0.executionSlotsTipText());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicySet());
      assertEquals(2, classifierPerformanceEvaluator0.getExecutionSlots());
      assertFalse(classifierPerformanceEvaluator0.isFocusCycleRoot());
      assertTrue(classifierPerformanceEvaluator0.getFocusTraversalKeysEnabled());
      assertEquals("ClassifierPerformanceEvaluator", classifierPerformanceEvaluator0.getCustomName());
      assertEquals("Evaluate the performance of batch trained classifiers.", classifierPerformanceEvaluator0.globalInfo());
      assertNotNull(trainingSetEvent0);
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals((-1363), trainingSetEvent0.getSetNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals(46, trainingSetEvent0.getMaxSetNumber());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertFalse(classifierPerformanceEvaluator0.getIgnoreRepaint());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals("Set the number of evaluation tasks to run in parallel.", classifierPerformanceEvaluator0.executionSlotsTipText());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicySet());
      assertEquals(2, classifierPerformanceEvaluator0.getExecutionSlots());
      assertFalse(classifierPerformanceEvaluator0.isFocusCycleRoot());
      assertTrue(classifierPerformanceEvaluator0.getFocusTraversalKeysEnabled());
      assertEquals("ClassifierPerformanceEvaluator", classifierPerformanceEvaluator0.getCustomName());
      assertEquals("Evaluate the performance of batch trained classifiers.", classifierPerformanceEvaluator0.globalInfo());
      
      Discretize discretize0 = new Discretize();
      assertEquals("Use Kononenko's MDL criterion. If set to false uses the Fayyad & Irani criterion.", discretize0.useKononenkoTipText());
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertFalse(discretize0.getUseBetterEncoding());
      assertFalse(discretize0.getUseBinNumbers());
      assertTrue(discretize0.isNewBatch());
      assertEquals("Uses a more efficient split point encoding.", discretize0.useBetterEncodingTipText());
      assertFalse(discretize0.getUseKononenko());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.isOutputFormatDefined());
      assertNotNull(discretize0);
      
      // Undeclared exception!
      try { 
        filter0.connectionNotification("@relation", (Object) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Hashtable", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      Filter filter0 = new Filter();
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertNotNull(filter0);
      
      filter0.updateUI();
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      
      filter0.acceptDataSet((DataSetEvent) null);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      
      Sorter sorter0 = new Sorter();
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNull(sorter0.getSortDetails());
      assertEquals("", sorter0.getTempDirectory());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isFocusCycleRoot());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertNotNull(sorter0);
      
      Dimension dimension0 = sorter0.getMaximumSize();
      assertEquals(Integer.MAX_VALUE, dimension0.width);
      assertEquals(Integer.MAX_VALUE, dimension0.height);
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNull(sorter0.getSortDetails());
      assertEquals("", sorter0.getTempDirectory());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isFocusCycleRoot());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals(2.147483647E9, dimension0.getWidth(), 0.01);
      assertEquals(2.147483647E9, dimension0.getHeight(), 0.01);
      assertNotNull(dimension0);
      
      Instances instances0 = sorter0.getStructure(" Error in obtaining post-filter structure. ");
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNull(sorter0.getSortDetails());
      assertEquals("", sorter0.getTempDirectory());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isFocusCycleRoot());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertNull(instances0);
      
      DataSetEvent dataSetEvent0 = new DataSetEvent(sorter0, (Instances) null);
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNull(sorter0.getSortDetails());
      assertEquals("", sorter0.getTempDirectory());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isFocusCycleRoot());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(dataSetEvent0.isStructureOnly());
      assertNotNull(dataSetEvent0);
      
      filter0.acceptDataSet(dataSetEvent0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNull(sorter0.getSortDetails());
      assertEquals("", sorter0.getTempDirectory());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isFocusCycleRoot());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(dataSetEvent0.isStructureOnly());
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      filter0.addConfigurationListener(configurationListener0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      
      filter0.addTestSetListener(sorter0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNull(sorter0.getSortDetails());
      assertEquals("", sorter0.getTempDirectory());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isFocusCycleRoot());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      
      BeanVisual beanVisual0 = filter0.getVisual();
      assertEquals(3, BeanVisual.WEST_CONNECTOR);
      assertEquals(0, BeanVisual.NORTH_CONNECTOR);
      assertEquals(1, BeanVisual.SOUTH_CONNECTOR);
      assertEquals(2, BeanVisual.EAST_CONNECTOR);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(beanVisual0.getFocusTraversalKeysEnabled());
      assertEquals("weka/gui/beans/icons/DefaultFilter.gif", beanVisual0.getIconPath());
      assertFalse(beanVisual0.getIgnoreRepaint());
      assertEquals("weka/gui/beans/icons/DefaultFilter_animated.gif", beanVisual0.getAnimatedIconPath());
      assertFalse(beanVisual0.isFocusCycleRoot());
      assertFalse(beanVisual0.isFocusTraversalPolicySet());
      assertFalse(beanVisual0.isFocusTraversalPolicyProvider());
      assertEquals("AllFilter", beanVisual0.getText());
      assertNotNull(beanVisual0);
      
      CheckOptionHandler checkOptionHandler0 = new CheckOptionHandler();
      assertFalse(checkOptionHandler0.getSilent());
      assertFalse(checkOptionHandler0.getDebug());
      assertFalse(checkOptionHandler0.getSuccess());
      assertNotNull(checkOptionHandler0);
      
      // Undeclared exception!
      try { 
        filter0.setWrappedAlgorithm(checkOptionHandler0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // class weka.core.CheckOptionHandler : incorrect type of algorithm (Filter)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertNotNull(filter0);
      
      weka.gui.LogPanel logPanel0 = new weka.gui.LogPanel();
      assertTrue(logPanel0.getFocusTraversalKeysEnabled());
      assertFalse(logPanel0.getIgnoreRepaint());
      assertFalse(logPanel0.isFocusCycleRoot());
      assertFalse(logPanel0.isFocusTraversalPolicyProvider());
      assertFalse(logPanel0.isFocusTraversalPolicySet());
      assertNotNull(logPanel0);
      
      filter0.setLog(logPanel0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertTrue(logPanel0.getFocusTraversalKeysEnabled());
      assertFalse(logPanel0.getIgnoreRepaint());
      assertFalse(logPanel0.isFocusCycleRoot());
      assertFalse(logPanel0.isFocusTraversalPolicyProvider());
      assertFalse(logPanel0.isFocusTraversalPolicySet());
      
      Object object0 = filter0.getClientProperty("weka.Tore.converters.CSVSaver");
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertNull(object0);
      
      ClassAssigner classAssigner0 = new ClassAssigner();
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertEquals("last", classAssigner0.getClassColumn());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertFalse(classAssigner0.isBusy());
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertNotNull(classAssigner0);
      
      filter0.acceptInstance((InstanceEvent) null);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      
      BeanVisual beanVisual0 = filter0.getVisual();
      assertEquals(2, BeanVisual.EAST_CONNECTOR);
      assertEquals(0, BeanVisual.NORTH_CONNECTOR);
      assertEquals(3, BeanVisual.WEST_CONNECTOR);
      assertEquals(1, BeanVisual.SOUTH_CONNECTOR);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(beanVisual0.getIgnoreRepaint());
      assertEquals("AllFilter", beanVisual0.getText());
      assertFalse(beanVisual0.isFocusTraversalPolicyProvider());
      assertFalse(beanVisual0.isFocusTraversalPolicySet());
      assertEquals("weka/gui/beans/icons/DefaultFilter_animated.gif", beanVisual0.getAnimatedIconPath());
      assertFalse(beanVisual0.isFocusCycleRoot());
      assertTrue(beanVisual0.getFocusTraversalKeysEnabled());
      assertEquals("weka/gui/beans/icons/DefaultFilter.gif", beanVisual0.getIconPath());
      assertNotNull(beanVisual0);
      
      boolean boolean0 = filter0.connectionAllowed("configuration");
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      Filter filter0 = new Filter();
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertNotNull(filter0);
      
      boolean boolean0 = filter0.isBusy();
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(boolean0);
      
      LinkedHashSet<AWTKeyStroke> linkedHashSet0 = new LinkedHashSet<AWTKeyStroke>();
      assertEquals(0, linkedHashSet0.size());
      assertTrue(linkedHashSet0.isEmpty());
      assertNotNull(linkedHashSet0);
      
      JapaneseDate japaneseDate0 = MockJapaneseDate.now();
      assertNotNull(japaneseDate0);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertNotNull(textDirectoryLoader0);
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertNotNull(instances0);
      
      Classifier classifier0 = new Classifier();
      assertEquals("<html><font color=blue>Class for building and using a 0-R classifier</font><br><br> Predicts the mean (for a numeric class) or the mode (for a nominal class).<br></html>", classifier0.globalInfo());
      assertFalse(classifier0.isFocusCycleRoot());
      assertFalse(classifier0.isFocusTraversalPolicySet());
      assertEquals(2, classifier0.getExecutionSlots());
      assertFalse(classifier0.hasIncomingStreamInstances());
      assertFalse(classifier0.getIgnoreRepaint());
      assertEquals("", classifier0.getLoadClassifierFileName());
      assertTrue(classifier0.getFocusTraversalKeysEnabled());
      assertFalse(classifier0.isFocusTraversalPolicyProvider());
      assertFalse(classifier0.hasIncomingBatchInstances());
      assertTrue(classifier0.getUpdateIncrementalClassifier());
      assertFalse(classifier0.getBlockOnLastFold());
      assertFalse(classifier0.getResetIncrementalClassifier());
      assertEquals("ZeroR", classifier0.getCustomName());
      assertNotNull(classifier0);
      
      InputMethodListener inputMethodListener0 = mock(InputMethodListener.class, new ViolatedAssumptionAnswer());
      GraphicsConfiguration graphicsConfiguration0 = filter0.getGraphicsConfiguration();
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertNull(graphicsConfiguration0);
      
      Canvas canvas0 = new Canvas((GraphicsConfiguration) null);
      assertEquals(Component.BaselineResizeBehavior.OTHER, canvas0.getBaselineResizeBehavior());
      assertFalse(canvas0.isOpaque());
      assertEquals(0, canvas0.getWidth());
      assertEquals(0.5F, canvas0.getAlignmentY(), 0.01F);
      assertEquals(0.5F, canvas0.getAlignmentX(), 0.01F);
      assertFalse(canvas0.isDoubleBuffered());
      assertFalse(canvas0.getIgnoreRepaint());
      assertEquals(0, canvas0.getX());
      assertTrue(canvas0.getFocusTraversalKeysEnabled());
      assertEquals(0, canvas0.getY());
      assertEquals(0, canvas0.getHeight());
      assertNotNull(canvas0);
      
      MockJapaneseDate mockJapaneseDate0 = new MockJapaneseDate();
      assertNotNull(mockJapaneseDate0);
      
      ClassifierPerformanceEvaluator classifierPerformanceEvaluator0 = new ClassifierPerformanceEvaluator();
      assertFalse(classifierPerformanceEvaluator0.getIgnoreRepaint());
      assertEquals("Evaluate the performance of batch trained classifiers.", classifierPerformanceEvaluator0.globalInfo());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals("ClassifierPerformanceEvaluator", classifierPerformanceEvaluator0.getCustomName());
      assertEquals(2, classifierPerformanceEvaluator0.getExecutionSlots());
      assertFalse(classifierPerformanceEvaluator0.isFocusTraversalPolicySet());
      assertFalse(classifierPerformanceEvaluator0.isFocusCycleRoot());
      assertEquals("Set the number of evaluation tasks to run in parallel.", classifierPerformanceEvaluator0.executionSlotsTipText());
      assertTrue(classifierPerformanceEvaluator0.getFocusTraversalKeysEnabled());
      assertNotNull(classifierPerformanceEvaluator0);
      
      Object object0 = classifierPerformanceEvaluator0.m_listenee;
      assertNull(object0);
      
      filter0.disconnectionNotification(".arff", (Object) null);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      
      Associator associator0 = new Associator();
      assertEquals("Apriori", associator0.getCustomName());
      assertTrue(associator0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      assertFalse(associator0.isBusy());
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertFalse(associator0.getIgnoreRepaint());
      assertFalse(associator0.isFocusCycleRoot());
      assertNotNull(associator0);
      
      instances0.compactify();
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      
      ClassValuePicker classValuePicker0 = new ClassValuePicker();
      assertEquals("ClassValuePicker", classValuePicker0.getCustomName());
      assertFalse(classValuePicker0.isFocusCycleRoot());
      assertFalse(classValuePicker0.isFocusTraversalPolicyProvider());
      assertNull(classValuePicker0.getClassValue());
      assertFalse(classValuePicker0.getIgnoreRepaint());
      assertFalse(classValuePicker0.isFocusTraversalPolicySet());
      assertFalse(classValuePicker0.isBusy());
      assertEquals("Designate which class value is to be considered the \"positive\" class value (useful for ROC style curves).", classValuePicker0.globalInfo());
      assertTrue(classValuePicker0.getFocusTraversalKeysEnabled());
      assertNotNull(classValuePicker0);
      
      textDirectoryLoader0.setOutputFilename(true);
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertTrue(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      
      Discretize discretize0 = new Discretize();
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Use Kononenko's MDL criterion. If set to false uses the Fayyad & Irani criterion.", discretize0.useKononenkoTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Uses a more efficient split point encoding.", discretize0.useBetterEncodingTipText());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseKononenko());
      assertFalse(discretize0.getUseBetterEncoding());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.getMakeBinary());
      assertNotNull(discretize0);
      
      TestSetMaker testSetMaker0 = new TestSetMaker();
      assertFalse(testSetMaker0.isFocusTraversalPolicyProvider());
      assertEquals("Designate an incoming data set as a test set.", testSetMaker0.globalInfo());
      assertFalse(testSetMaker0.isFocusCycleRoot());
      assertFalse(testSetMaker0.isBusy());
      assertTrue(testSetMaker0.getFocusTraversalKeysEnabled());
      assertFalse(testSetMaker0.getIgnoreRepaint());
      assertEquals("TestSetMaker", testSetMaker0.getCustomName());
      assertFalse(testSetMaker0.isFocusTraversalPolicySet());
      assertNotNull(testSetMaker0);
      
      filter0.addDataSourceListener(testSetMaker0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(testSetMaker0.isFocusTraversalPolicyProvider());
      assertEquals("Designate an incoming data set as a test set.", testSetMaker0.globalInfo());
      assertFalse(testSetMaker0.isFocusCycleRoot());
      assertFalse(testSetMaker0.isBusy());
      assertTrue(testSetMaker0.getFocusTraversalKeysEnabled());
      assertFalse(testSetMaker0.getIgnoreRepaint());
      assertEquals("TestSetMaker", testSetMaker0.getCustomName());
      assertFalse(testSetMaker0.isFocusTraversalPolicySet());
      
      DataSetEvent dataSetEvent0 = new DataSetEvent(linkedHashSet0, instances0);
      assertEquals(0, linkedHashSet0.size());
      assertTrue(linkedHashSet0.isEmpty());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertTrue(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertTrue(dataSetEvent0.isStructureOnly());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertNotNull(dataSetEvent0);
      
      filter0.acceptDataSet(dataSetEvent0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals(0, linkedHashSet0.size());
      assertTrue(linkedHashSet0.isEmpty());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertTrue(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertTrue(dataSetEvent0.isStructureOnly());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      
      filter0.removeInstanceListener(classifier0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>Class for building and using a 0-R classifier</font><br><br> Predicts the mean (for a numeric class) or the mode (for a nominal class).<br></html>", classifier0.globalInfo());
      assertFalse(classifier0.isFocusCycleRoot());
      assertFalse(classifier0.isFocusTraversalPolicySet());
      assertEquals(2, classifier0.getExecutionSlots());
      assertFalse(classifier0.hasIncomingStreamInstances());
      assertFalse(classifier0.getIgnoreRepaint());
      assertEquals("", classifier0.getLoadClassifierFileName());
      assertTrue(classifier0.getFocusTraversalKeysEnabled());
      assertFalse(classifier0.isFocusTraversalPolicyProvider());
      assertFalse(classifier0.hasIncomingBatchInstances());
      assertTrue(classifier0.getUpdateIncrementalClassifier());
      assertFalse(classifier0.getBlockOnLastFold());
      assertFalse(classifier0.getResetIncrementalClassifier());
      assertEquals("ZeroR", classifier0.getCustomName());
      
      filter0.addDataSourceListener(associator0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Apriori", associator0.getCustomName());
      assertTrue(associator0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      assertFalse(associator0.isBusy());
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertFalse(associator0.getIgnoreRepaint());
      assertFalse(associator0.isFocusCycleRoot());
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertNotNull(filter0);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertNotNull(multiFilter0);
      
      filter0.setFilter(multiFilter0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isOutputFormatDefined());
      
      ContainerListener containerListener0 = mock(ContainerListener.class, new ViolatedAssumptionAnswer());
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertNotNull(textDirectoryLoader0);
      
      Instances instances0 = textDirectoryLoader0.getStructure();
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertNotNull(instances0);
      
      Sorter sorter0 = new Sorter();
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.isFocusCycleRoot());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isBusy());
      assertNotNull(sorter0);
      
      TransferHandler transferHandler0 = sorter0.getTransferHandler();
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.isFocusCycleRoot());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isBusy());
      assertNull(transferHandler0);
      
      GraphicsConfiguration graphicsConfiguration0 = filter0.getGraphicsConfiguration();
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertNull(graphicsConfiguration0);
      
      WekaTaskMonitor wekaTaskMonitor0 = new WekaTaskMonitor();
      assertTrue(wekaTaskMonitor0.getFocusTraversalKeysEnabled());
      assertFalse(wekaTaskMonitor0.isFocusCycleRoot());
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicySet());
      assertFalse(wekaTaskMonitor0.getIgnoreRepaint());
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicyProvider());
      assertNotNull(wekaTaskMonitor0);
      
      FindWithCapabilities findWithCapabilities0 = new FindWithCapabilities();
      assertEquals("", findWithCapabilities0.getFilename());
      assertNotNull(findWithCapabilities0);
      
      ClassAssigner classAssigner0 = new ClassAssigner();
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertEquals("last", classAssigner0.getClassColumn());
      assertFalse(classAssigner0.isBusy());
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertNotNull(classAssigner0);
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isBusy());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertNotNull(substringReplacer0);
      
      InstanceEvent instanceEvent0 = substringReplacer0.m_ie;
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, instanceEvent0.getStatus());
      assertNotNull(instanceEvent0);
      
      Appender appender0 = new Appender();
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertNotNull(appender0);
      
      Appender appender1 = new Appender();
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.isFocusCycleRoot());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertFalse(appender1.equals((Object)appender0));
      assertNotNull(appender1);
      
      Instances instances1 = sorter0.getStructure("vi[A*%CPeEGZ?A!");
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.isFocusCycleRoot());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isBusy());
      assertNull(instances1);
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(instanceEvent0, instances0, 0, (-51));
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals((-51), trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isBusy());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertEquals(0, instanceEvent0.getStatus());
      assertNotNull(trainingSetEvent0);
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals((-51), trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isBusy());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertEquals(0, instanceEvent0.getStatus());
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertNotNull(filter0);
      
      ListOptions listOptions0 = new ListOptions();
      assertEquals("weka.core.ListOptions", listOptions0.getClassname());
      assertNotNull(listOptions0);
      
      filter0.updateUI();
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, ">P-i");
      assertFalse(boolean0);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      assertNotNull(multiFilter0);
      
      filter0.setFilter(multiFilter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      
      Discretize discretize0 = new Discretize();
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Use Kononenko's MDL criterion. If set to false uses the Fayyad & Irani criterion.", discretize0.useKononenkoTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Uses a more efficient split point encoding.", discretize0.useBetterEncodingTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertFalse(discretize0.getUseBetterEncoding());
      assertFalse(discretize0.getUseBinNumbers());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getUseKononenko());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertNotNull(discretize0);
      
      String[] stringArray0 = listOptions0.getOptions();
      assertEquals("weka.core.ListOptions", listOptions0.getClassname());
      assertNotNull(stringArray0);
      
      FindWithCapabilities findWithCapabilities0 = new FindWithCapabilities();
      assertEquals("", findWithCapabilities0.getFilename());
      assertNotNull(findWithCapabilities0);
      
      ClassAssigner classAssigner0 = new ClassAssigner();
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertFalse(classAssigner0.isBusy());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertEquals("last", classAssigner0.getClassColumn());
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertNotNull(classAssigner0);
      
      Apriori apriori0 = new Apriori();
      assertEquals("conf", apriori0.metricString());
      assertEquals("Upper bound for minimum support. Start iteratively decreasing minimum support from this value.", apriori0.upperBoundMinSupportTipText());
      assertEquals(10, apriori0.getNumRules());
      assertFalse(apriori0.getTreatZeroAsMissing());
      assertEquals("Remove columns with all missing values.", apriori0.removeAllMissingColsTipText());
      assertEquals("If enabled class association rules are mined instead of (general) association rules.", apriori0.carTipText());
      assertEquals("Minimum metric score. Consider only rules with scores higher than this value.", apriori0.minMetricTipText());
      assertEquals(0.05, apriori0.getDelta(), 0.01);
      assertFalse(apriori0.getCar());
      assertFalse(apriori0.getVerbose());
      assertEquals("Number of rules to find.", apriori0.numRulesTipText());
      assertEquals("Significance level. Significance test (confidence metric only).", apriori0.significanceLevelTipText());
      assertFalse(apriori0.getOutputItemSets());
      assertEquals("If enabled, zero (that is, the first value of a nominal) is treated in the same way as a missing value.", apriori0.treatZeroAsMissingTipText());
      assertEquals("If enabled the algorithm will be run in verbose mode.", apriori0.verboseTipText());
      assertEquals("Set the type of metric by which to rank rules. Confidence is the proportion of the examples covered by the premise that are also covered by the consequence (Class association rules can only be mined using confidence). Lift is confidence divided by the proportion of all examples that are covered by the consequence. This is a measure of the importance of the association that is independent of support. Leverage is the proportion of additional examples covered by both the premise and consequence above those expected if the premise and consequence were independent of each other. The total number of examples that this represents is presented in brackets following the leverage. Conviction is another measure of departure from independence. Conviction is given by P(premise)P(!consequence) / P(premise, !consequence).", apriori0.metricTypeTipText());
      assertEquals("Index of the class attribute. If set to -1, the last attribute is taken as class attribute.", apriori0.classIndexTipText());
      assertFalse(apriori0.getRemoveAllMissingCols());
      assertEquals(1.0, apriori0.getUpperBoundMinSupport(), 0.01);
      assertEquals(0.1, apriori0.getLowerBoundMinSupport(), 0.01);
      assertEquals((-1), apriori0.getClassIndex());
      assertTrue(apriori0.canProduceRules());
      assertEquals("If enabled the itemsets are output as well.", apriori0.outputItemSetsTipText());
      assertEquals((-1.0), apriori0.getSignificanceLevel(), 0.01);
      assertEquals("Lower bound for minimum support.", apriori0.lowerBoundMinSupportTipText());
      assertEquals("Iteratively decrease support by this factor. Reduces support until min support is reached or required number of rules has been generated.", apriori0.deltaTipText());
      assertEquals(0.9, apriori0.getMinMetric(), 0.01);
      assertNotNull(apriori0);
      
      Instances instances0 = apriori0.getInstancesOnlyClass();
      assertEquals("conf", apriori0.metricString());
      assertEquals("Upper bound for minimum support. Start iteratively decreasing minimum support from this value.", apriori0.upperBoundMinSupportTipText());
      assertEquals(10, apriori0.getNumRules());
      assertFalse(apriori0.getTreatZeroAsMissing());
      assertEquals("Remove columns with all missing values.", apriori0.removeAllMissingColsTipText());
      assertEquals("If enabled class association rules are mined instead of (general) association rules.", apriori0.carTipText());
      assertEquals("Minimum metric score. Consider only rules with scores higher than this value.", apriori0.minMetricTipText());
      assertEquals(0.05, apriori0.getDelta(), 0.01);
      assertFalse(apriori0.getCar());
      assertFalse(apriori0.getVerbose());
      assertEquals("Number of rules to find.", apriori0.numRulesTipText());
      assertEquals("Significance level. Significance test (confidence metric only).", apriori0.significanceLevelTipText());
      assertFalse(apriori0.getOutputItemSets());
      assertEquals("If enabled, zero (that is, the first value of a nominal) is treated in the same way as a missing value.", apriori0.treatZeroAsMissingTipText());
      assertEquals("If enabled the algorithm will be run in verbose mode.", apriori0.verboseTipText());
      assertEquals("Set the type of metric by which to rank rules. Confidence is the proportion of the examples covered by the premise that are also covered by the consequence (Class association rules can only be mined using confidence). Lift is confidence divided by the proportion of all examples that are covered by the consequence. This is a measure of the importance of the association that is independent of support. Leverage is the proportion of additional examples covered by both the premise and consequence above those expected if the premise and consequence were independent of each other. The total number of examples that this represents is presented in brackets following the leverage. Conviction is another measure of departure from independence. Conviction is given by P(premise)P(!consequence) / P(premise, !consequence).", apriori0.metricTypeTipText());
      assertEquals("Index of the class attribute. If set to -1, the last attribute is taken as class attribute.", apriori0.classIndexTipText());
      assertFalse(apriori0.getRemoveAllMissingCols());
      assertEquals(1.0, apriori0.getUpperBoundMinSupport(), 0.01);
      assertEquals(0.1, apriori0.getLowerBoundMinSupport(), 0.01);
      assertEquals((-1), apriori0.getClassIndex());
      assertTrue(apriori0.canProduceRules());
      assertEquals("If enabled the itemsets are output as well.", apriori0.outputItemSetsTipText());
      assertEquals((-1.0), apriori0.getSignificanceLevel(), 0.01);
      assertEquals("Lower bound for minimum support.", apriori0.lowerBoundMinSupportTipText());
      assertEquals("Iteratively decrease support by this factor. Reduces support until min support is reached or required number of rules has been generated.", apriori0.deltaTipText());
      assertEquals(0.9, apriori0.getMinMetric(), 0.01);
      assertNull(instances0);
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertNotNull(substringReplacer0);
      
      InstanceEvent instanceEvent0 = substringReplacer0.m_ie;
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, instanceEvent0.getStatus());
      assertNotNull(instanceEvent0);
      
      PredictionAppender predictionAppender0 = new PredictionAppender();
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertFalse(predictionAppender0.isFocusCycleRoot());
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertFalse(predictionAppender0.isBusy());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      assertNotNull(predictionAppender0);
      
      Vector vector0 = predictionAppender0.m_trainingSetListeners;
      assertEquals(10, vector0.capacity());
      assertEquals("[]", vector0.toString());
      assertTrue(vector0.isEmpty());
      assertEquals(0, vector0.size());
      assertNotNull(vector0);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertNotNull(substringLabeler0);
      
      filter0.removeDataSourceListener(classAssigner0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertFalse(classAssigner0.isBusy());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertEquals("last", classAssigner0.getClassColumn());
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      
      MultiFilter multiFilter1 = (MultiFilter)filter0.getWrappedAlgorithm();
      assertSame(multiFilter1, multiFilter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(multiFilter1.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter1.getDebug());
      assertTrue(multiFilter1.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      assertNotNull(multiFilter1);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals(0, instanceEvent0.getStatus());
      
      JapaneseEra japaneseEra0 = JapaneseEra.HEISEI;
      assertNotNull(japaneseEra0);
      
      MultiFilter multiFilter2 = (MultiFilter)filter0.getWrappedAlgorithm();
      assertSame(multiFilter2, multiFilter1);
      assertSame(multiFilter2, multiFilter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("The base filters to be used.", multiFilter2.filtersTipText());
      assertFalse(multiFilter2.isFirstBatchDone());
      assertFalse(multiFilter2.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter2.debugTipText());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter2.globalInfo());
      assertFalse(multiFilter2.getDebug());
      assertFalse(multiFilter2.isOutputFormatDefined());
      assertTrue(multiFilter2.isNewBatch());
      assertNotNull(multiFilter2);
      
      System.setCurrentTimeMillis(0);
      CrossValidationFoldMaker crossValidationFoldMaker0 = new CrossValidationFoldMaker();
      assertEquals(10, crossValidationFoldMaker0.getFolds());
      assertFalse(crossValidationFoldMaker0.isFocusCycleRoot());
      assertEquals("CrossValidationFoldMaker", crossValidationFoldMaker0.getCustomName());
      assertEquals(1, crossValidationFoldMaker0.getSeed());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicyProvider());
      assertFalse(crossValidationFoldMaker0.getIgnoreRepaint());
      assertEquals("The number of train and test splits to produce", crossValidationFoldMaker0.foldsTipText());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicySet());
      assertTrue(crossValidationFoldMaker0.getFocusTraversalKeysEnabled());
      assertEquals("The randomization seed", crossValidationFoldMaker0.seedTipText());
      assertFalse(crossValidationFoldMaker0.isBusy());
      assertEquals("Split an incoming data set into cross validation folds. Separate train and test sets are produced for each of the k folds.", crossValidationFoldMaker0.globalInfo());
      assertFalse(crossValidationFoldMaker0.getPreserveOrder());
      assertNotNull(crossValidationFoldMaker0);
      
      StyleConstants styleConstants0 = (StyleConstants)AttributeSet.ResolveAttribute;
      assertNotNull(styleConstants0);
      
      DataSetEvent dataSetEvent0 = new DataSetEvent(discretize0, (Instances) null);
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Use Kononenko's MDL criterion. If set to false uses the Fayyad & Irani criterion.", discretize0.useKononenkoTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Uses a more efficient split point encoding.", discretize0.useBetterEncodingTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertFalse(discretize0.getUseBetterEncoding());
      assertFalse(discretize0.getUseBinNumbers());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getUseKononenko());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(dataSetEvent0.isStructureOnly());
      assertNotNull(dataSetEvent0);
      
      filter0.acceptDataSet(dataSetEvent0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Use Kononenko's MDL criterion. If set to false uses the Fayyad & Irani criterion.", discretize0.useKononenkoTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Uses a more efficient split point encoding.", discretize0.useBetterEncodingTipText());
      assertFalse(discretize0.isFirstBatchDone());
      assertFalse(discretize0.getUseBetterEncoding());
      assertFalse(discretize0.getUseBinNumbers());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getUseKononenko());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(dataSetEvent0.isStructureOnly());
      
      OptionHandlerJavadoc optionHandlerJavadoc0 = new OptionHandlerJavadoc();
      assertEquals("", optionHandlerJavadoc0.getDir());
      assertEquals("weka.core.Javadoc", optionHandlerJavadoc0.getClassname());
      assertTrue(optionHandlerJavadoc0.getUseStars());
      assertTrue(optionHandlerJavadoc0.getProlog());
      assertFalse(optionHandlerJavadoc0.getSilent());
      assertNotNull(optionHandlerJavadoc0);
      
      IncrementalClassifierEvaluator incrementalClassifierEvaluator0 = new IncrementalClassifierEvaluator();
      assertTrue(incrementalClassifierEvaluator0.getFocusTraversalKeysEnabled());
      assertFalse(incrementalClassifierEvaluator0.isBusy());
      assertFalse(incrementalClassifierEvaluator0.getIgnoreRepaint());
      assertEquals("Evaluate the performance of incrementally trained classifiers.", incrementalClassifierEvaluator0.globalInfo());
      assertFalse(incrementalClassifierEvaluator0.getOutputPerClassInfoRetrievalStats());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals("IncrementalClassifierEvaluator", incrementalClassifierEvaluator0.getCustomName());
      assertEquals("For charting only, specify a sliding window size over which to compute performance stats. <= 0 means eval on whole stream", incrementalClassifierEvaluator0.chartingEvalWindowSizeTipText());
      assertEquals(0, incrementalClassifierEvaluator0.getChartingEvalWindowSize());
      assertEquals("Output per-class info retrieval stats. If set to true, predictions get stored so that stats such as AUC can be computed. Note: this consumes some memory.", incrementalClassifierEvaluator0.outputPerClassInfoRetrievalStatsTipText());
      assertEquals(100, incrementalClassifierEvaluator0.getStatusFrequency());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicySet());
      assertFalse(incrementalClassifierEvaluator0.isFocusCycleRoot());
      assertEquals("How often to report progress to the status bar.", incrementalClassifierEvaluator0.statusFrequencyTipText());
      assertNotNull(incrementalClassifierEvaluator0);
      
      incrementalClassifierEvaluator0.printComponents((Graphics) null);
      assertTrue(incrementalClassifierEvaluator0.getFocusTraversalKeysEnabled());
      assertFalse(incrementalClassifierEvaluator0.isBusy());
      assertFalse(incrementalClassifierEvaluator0.getIgnoreRepaint());
      assertEquals("Evaluate the performance of incrementally trained classifiers.", incrementalClassifierEvaluator0.globalInfo());
      assertFalse(incrementalClassifierEvaluator0.getOutputPerClassInfoRetrievalStats());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals("IncrementalClassifierEvaluator", incrementalClassifierEvaluator0.getCustomName());
      assertEquals("For charting only, specify a sliding window size over which to compute performance stats. <= 0 means eval on whole stream", incrementalClassifierEvaluator0.chartingEvalWindowSizeTipText());
      assertEquals(0, incrementalClassifierEvaluator0.getChartingEvalWindowSize());
      assertEquals("Output per-class info retrieval stats. If set to true, predictions get stored so that stats such as AUC can be computed. Note: this consumes some memory.", incrementalClassifierEvaluator0.outputPerClassInfoRetrievalStatsTipText());
      assertEquals(100, incrementalClassifierEvaluator0.getStatusFrequency());
      assertFalse(incrementalClassifierEvaluator0.isFocusTraversalPolicySet());
      assertFalse(incrementalClassifierEvaluator0.isFocusCycleRoot());
      assertEquals("How often to report progress to the status bar.", incrementalClassifierEvaluator0.statusFrequencyTipText());
      
      EuclideanDistance euclideanDistance0 = new EuclideanDistance();
      assertEquals(1, NormalizableDistance.R_MAX);
      assertEquals(0, NormalizableDistance.R_MIN);
      assertEquals(2, NormalizableDistance.R_WIDTH);
      assertEquals("", euclideanDistance0.toString());
      assertEquals("Whether if the normalization of attributes should be turned off for distance calculation (Default: false i.e. attribute values are normalized). ", euclideanDistance0.dontNormalizeTipText());
      assertEquals("Set attribute selection mode. If false, only selected attributes in the range will be used in the distance calculation; if true, only non-selected attributes will be used for the calculation.", euclideanDistance0.invertSelectionTipText());
      assertFalse(euclideanDistance0.rangesSet());
      assertFalse(euclideanDistance0.getDontNormalize());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", euclideanDistance0.attributeIndicesTipText());
      assertNotNull(euclideanDistance0);
      
      InstanceEvent instanceEvent1 = new InstanceEvent(euclideanDistance0);
      assertEquals(1, NormalizableDistance.R_MAX);
      assertEquals(0, NormalizableDistance.R_MIN);
      assertEquals(2, NormalizableDistance.R_WIDTH);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals("", euclideanDistance0.toString());
      assertEquals("Whether if the normalization of attributes should be turned off for distance calculation (Default: false i.e. attribute values are normalized). ", euclideanDistance0.dontNormalizeTipText());
      assertEquals("Set attribute selection mode. If false, only selected attributes in the range will be used in the distance calculation; if true, only non-selected attributes will be used for the calculation.", euclideanDistance0.invertSelectionTipText());
      assertFalse(euclideanDistance0.rangesSet());
      assertFalse(euclideanDistance0.getDontNormalize());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", euclideanDistance0.attributeIndicesTipText());
      assertEquals(0, instanceEvent1.getStatus());
      assertFalse(instanceEvent1.equals((Object)instanceEvent0));
      assertNotNull(instanceEvent1);
      
      filter0.addConfigurationListener((ConfigurationListener) null);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertEquals("MultiFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      Filter filter0 = new Filter();
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertNotNull(filter0);
      
      filter0.updateUI();
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertNotNull(multiFilter0);
      
      filter0.setFilter(multiFilter0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      
      Discretize discretize0 = new Discretize();
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getUseBetterEncoding());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Uses a more efficient split point encoding.", discretize0.useBetterEncodingTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.isOutputFormatDefined());
      assertEquals("Use Kononenko's MDL criterion. If set to false uses the Fayyad & Irani criterion.", discretize0.useKononenkoTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertFalse(discretize0.getUseKononenko());
      assertFalse(discretize0.getMakeBinary());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertNotNull(discretize0);
      
      FindWithCapabilities findWithCapabilities0 = new FindWithCapabilities();
      assertEquals("", findWithCapabilities0.getFilename());
      assertNotNull(findWithCapabilities0);
      
      WekaTaskMonitor wekaTaskMonitor0 = new WekaTaskMonitor();
      assertFalse(wekaTaskMonitor0.getIgnoreRepaint());
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicySet());
      assertTrue(wekaTaskMonitor0.getFocusTraversalKeysEnabled());
      assertFalse(wekaTaskMonitor0.isFocusCycleRoot());
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicyProvider());
      assertNotNull(wekaTaskMonitor0);
      
      weka.gui.LogPanel logPanel0 = new weka.gui.LogPanel();
      assertFalse(logPanel0.isFocusTraversalPolicyProvider());
      assertFalse(logPanel0.getIgnoreRepaint());
      assertTrue(logPanel0.getFocusTraversalKeysEnabled());
      assertFalse(logPanel0.isFocusTraversalPolicySet());
      assertFalse(logPanel0.isFocusCycleRoot());
      assertNotNull(logPanel0);
      
      filter0.setLog(logPanel0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(logPanel0.isFocusTraversalPolicyProvider());
      assertFalse(logPanel0.getIgnoreRepaint());
      assertTrue(logPanel0.getFocusTraversalKeysEnabled());
      assertFalse(logPanel0.isFocusTraversalPolicySet());
      assertFalse(logPanel0.isFocusCycleRoot());
      
      String[] stringArray0 = Locale.getISOCountries();
      assertNotNull(stringArray0);
      
      FindWithCapabilities findWithCapabilities1 = new FindWithCapabilities();
      assertEquals("", findWithCapabilities1.getFilename());
      assertFalse(findWithCapabilities1.equals((Object)findWithCapabilities0));
      assertNotNull(findWithCapabilities1);
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isBusy());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertNotNull(substringReplacer0);
      
      InstanceEvent instanceEvent0 = substringReplacer0.m_ie;
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, instanceEvent0.getStatus());
      assertNotNull(instanceEvent0);
      
      Appender appender0 = new Appender();
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertNotNull(appender0);
      
      Appender appender1 = new Appender();
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender1.getCustomName());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.equals((Object)appender0));
      assertNotNull(appender1);
      
      boolean boolean0 = substringReplacer0.m_busy;
      assertFalse(boolean0);
      
      instanceEvent0.setStatus(67);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isBusy());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals(67, instanceEvent0.getStatus());
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isBusy());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals(67, instanceEvent0.getStatus());
      
      ClassAssigner classAssigner0 = new ClassAssigner();
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertEquals("last", classAssigner0.getClassColumn());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertFalse(classAssigner0.isBusy());
      assertNotNull(classAssigner0);
      
      ClassAssigner classAssigner1 = new ClassAssigner();
      assertFalse(classAssigner1.isFocusTraversalPolicySet());
      assertFalse(classAssigner1.isFocusCycleRoot());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner1.classColumnTipText());
      assertTrue(classAssigner1.getFocusTraversalKeysEnabled());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner1.globalInfo());
      assertFalse(classAssigner1.getIgnoreRepaint());
      assertEquals("last", classAssigner1.getClassColumn());
      assertFalse(classAssigner1.isFocusTraversalPolicyProvider());
      assertEquals("ClassAssigner", classAssigner1.getCustomName());
      assertFalse(classAssigner1.isBusy());
      assertFalse(classAssigner1.equals((Object)classAssigner0));
      assertNotNull(classAssigner1);
      
      MockJapaneseDate mockJapaneseDate0 = new MockJapaneseDate();
      assertNotNull(mockJapaneseDate0);
      
      ClassAssigner classAssigner2 = new ClassAssigner();
      assertEquals("last", classAssigner2.getClassColumn());
      assertFalse(classAssigner2.getIgnoreRepaint());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner2.globalInfo());
      assertEquals("ClassAssigner", classAssigner2.getCustomName());
      assertFalse(classAssigner2.isFocusCycleRoot());
      assertFalse(classAssigner2.isBusy());
      assertFalse(classAssigner2.isFocusTraversalPolicyProvider());
      assertFalse(classAssigner2.isFocusTraversalPolicySet());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner2.classColumnTipText());
      assertTrue(classAssigner2.getFocusTraversalKeysEnabled());
      assertFalse(classAssigner2.equals((Object)classAssigner1));
      assertFalse(classAssigner2.equals((Object)classAssigner0));
      assertNotNull(classAssigner2);
      
      Classifier classifier0 = new Classifier();
      assertEquals(2, classifier0.getExecutionSlots());
      assertFalse(classifier0.isFocusTraversalPolicySet());
      assertFalse(classifier0.isFocusCycleRoot());
      assertFalse(classifier0.getBlockOnLastFold());
      assertFalse(classifier0.getResetIncrementalClassifier());
      assertTrue(classifier0.getUpdateIncrementalClassifier());
      assertFalse(classifier0.hasIncomingStreamInstances());
      assertTrue(classifier0.getFocusTraversalKeysEnabled());
      assertEquals("ZeroR", classifier0.getCustomName());
      assertFalse(classifier0.hasIncomingBatchInstances());
      assertFalse(classifier0.getIgnoreRepaint());
      assertEquals("", classifier0.getLoadClassifierFileName());
      assertEquals("<html><font color=blue>Class for building and using a 0-R classifier</font><br><br> Predicts the mean (for a numeric class) or the mode (for a nominal class).<br></html>", classifier0.globalInfo());
      assertFalse(classifier0.isFocusTraversalPolicyProvider());
      assertNotNull(classifier0);
      
      filter0.addTrainingSetListener(classifier0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals(2, classifier0.getExecutionSlots());
      assertFalse(classifier0.isFocusTraversalPolicySet());
      assertFalse(classifier0.isFocusCycleRoot());
      assertFalse(classifier0.getBlockOnLastFold());
      assertFalse(classifier0.getResetIncrementalClassifier());
      assertTrue(classifier0.getUpdateIncrementalClassifier());
      assertFalse(classifier0.hasIncomingStreamInstances());
      assertTrue(classifier0.getFocusTraversalKeysEnabled());
      assertEquals("ZeroR", classifier0.getCustomName());
      assertFalse(classifier0.hasIncomingBatchInstances());
      assertFalse(classifier0.getIgnoreRepaint());
      assertEquals("", classifier0.getLoadClassifierFileName());
      assertEquals("<html><font color=blue>Class for building and using a 0-R classifier</font><br><br> Predicts the mean (for a numeric class) or the mode (for a nominal class).<br></html>", classifier0.globalInfo());
      assertFalse(classifier0.isFocusTraversalPolicyProvider());
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      Filter filter0 = new Filter();
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertNotNull(filter0);
      
      boolean boolean0 = filter0.eventGeneratable("configuration");
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(boolean0);
      
      SpreadSubsample spreadSubsample0 = new SpreadSubsample();
      assertFalse(spreadSubsample0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Sets the random number seed for subsampling.", spreadSubsample0.randomSeedTipText());
      assertEquals("The maximum count for any class value (0 = unlimited).", spreadSubsample0.maxCountTipText());
      assertFalse(spreadSubsample0.getAdjustWeights());
      assertEquals(0.0, spreadSubsample0.getMaxCount(), 0.01);
      assertEquals("Produces a random subsample of a dataset. The original dataset must fit entirely in memory. This filter allows you to specify the maximum \"spread\" between the rarest and most common class. For example, you may specify that there be at most a 2:1 difference in class frequencies. When used in batch mode, subsequent batches are NOT resampled.", spreadSubsample0.globalInfo());
      assertFalse(spreadSubsample0.isOutputFormatDefined());
      assertEquals("The maximum class distribution spread. (0 = no maximum spread, 1 = uniform distribution, 10 = allow at most a 10:1 ratio between the classes).", spreadSubsample0.distributionSpreadTipText());
      assertTrue(spreadSubsample0.isNewBatch());
      assertEquals(0.0, spreadSubsample0.getDistributionSpread(), 0.01);
      assertEquals(1, spreadSubsample0.getRandomSeed());
      assertEquals("Wether instance weights will be adjusted to maintain total weight per class.", spreadSubsample0.adjustWeightsTipText());
      assertFalse(spreadSubsample0.isFirstBatchDone());
      assertNotNull(spreadSubsample0);
      
      filter0.setFilter(spreadSubsample0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Produces a random subsample of a dataset</font><br><br> The original dataset must fit entirely in memory.<br>This filter allows you to specify the maximum \"spread\" between the rarest and most common class.<br>For example, you may specify that there be at most a 2:1 difference in class frequencies.<br>When used in batch mode, subsequent batches are NOT resampled.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertEquals("SpreadSubsample", filter0.getCustomName());
      assertFalse(spreadSubsample0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Sets the random number seed for subsampling.", spreadSubsample0.randomSeedTipText());
      assertEquals("The maximum count for any class value (0 = unlimited).", spreadSubsample0.maxCountTipText());
      assertFalse(spreadSubsample0.getAdjustWeights());
      assertEquals(0.0, spreadSubsample0.getMaxCount(), 0.01);
      assertEquals("Produces a random subsample of a dataset. The original dataset must fit entirely in memory. This filter allows you to specify the maximum \"spread\" between the rarest and most common class. For example, you may specify that there be at most a 2:1 difference in class frequencies. When used in batch mode, subsequent batches are NOT resampled.", spreadSubsample0.globalInfo());
      assertFalse(spreadSubsample0.isOutputFormatDefined());
      assertEquals("The maximum class distribution spread. (0 = no maximum spread, 1 = uniform distribution, 10 = allow at most a 10:1 ratio between the classes).", spreadSubsample0.distributionSpreadTipText());
      assertTrue(spreadSubsample0.isNewBatch());
      assertEquals(0.0, spreadSubsample0.getDistributionSpread(), 0.01);
      assertEquals(1, spreadSubsample0.getRandomSeed());
      assertEquals("Wether instance weights will be adjusted to maintain total weight per class.", spreadSubsample0.adjustWeightsTipText());
      assertFalse(spreadSubsample0.isFirstBatchDone());
      
      WekaTaskMonitor wekaTaskMonitor0 = new WekaTaskMonitor();
      assertFalse(wekaTaskMonitor0.getIgnoreRepaint());
      assertTrue(wekaTaskMonitor0.getFocusTraversalKeysEnabled());
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicySet());
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicyProvider());
      assertFalse(wekaTaskMonitor0.isFocusCycleRoot());
      assertNotNull(wekaTaskMonitor0);
      
      weka.gui.LogPanel logPanel0 = new weka.gui.LogPanel();
      assertTrue(logPanel0.getFocusTraversalKeysEnabled());
      assertFalse(logPanel0.isFocusCycleRoot());
      assertFalse(logPanel0.isFocusTraversalPolicySet());
      assertFalse(logPanel0.getIgnoreRepaint());
      assertFalse(logPanel0.isFocusTraversalPolicyProvider());
      assertNotNull(logPanel0);
      
      SysErrLog sysErrLog0 = new SysErrLog();
      assertNotNull(sysErrLog0);
      
      sysErrLog0.statusMessage("configuration");
      filter0.setLog(sysErrLog0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Produces a random subsample of a dataset</font><br><br> The original dataset must fit entirely in memory.<br>This filter allows you to specify the maximum \"spread\" between the rarest and most common class.<br>For example, you may specify that there be at most a 2:1 difference in class frequencies.<br>When used in batch mode, subsequent batches are NOT resampled.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertEquals("SpreadSubsample", filter0.getCustomName());
      
      FindWithCapabilities findWithCapabilities0 = new FindWithCapabilities();
      assertEquals("", findWithCapabilities0.getFilename());
      assertNotNull(findWithCapabilities0);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertNotNull(substringLabeler0);
      
      InstanceEvent instanceEvent0 = substringLabeler0.m_ie;
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, instanceEvent0.getStatus());
      assertNotNull(instanceEvent0);
      
      ClassValuePicker classValuePicker0 = new ClassValuePicker();
      assertNull(classValuePicker0.getClassValue());
      assertFalse(classValuePicker0.isFocusTraversalPolicySet());
      assertFalse(classValuePicker0.isBusy());
      assertFalse(classValuePicker0.isFocusTraversalPolicyProvider());
      assertFalse(classValuePicker0.isFocusCycleRoot());
      assertFalse(classValuePicker0.getIgnoreRepaint());
      assertTrue(classValuePicker0.getFocusTraversalKeysEnabled());
      assertEquals("Designate which class value is to be considered the \"positive\" class value (useful for ROC style curves).", classValuePicker0.globalInfo());
      assertEquals("ClassValuePicker", classValuePicker0.getCustomName());
      assertNotNull(classValuePicker0);
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertNotNull(substringReplacer0);
      
      SubstringLabeler substringLabeler1 = new SubstringLabeler();
      assertFalse(substringLabeler1.isFocusCycleRoot());
      assertFalse(substringLabeler1.isFocusTraversalPolicySet());
      assertEquals("Match", substringLabeler1.getMatchAttributeName());
      assertFalse(substringLabeler1.isFocusTraversalPolicyProvider());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler1.globalInfo());
      assertFalse(substringLabeler1.getNominalBinary());
      assertFalse(substringLabeler1.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler1.getCustomName());
      assertTrue(substringLabeler1.getFocusTraversalKeysEnabled());
      assertEquals("", substringLabeler1.getMatchDetails());
      assertFalse(substringLabeler1.getIgnoreRepaint());
      assertFalse(substringLabeler1.isBusy());
      assertFalse(substringLabeler1.equals((Object)substringLabeler0));
      assertNotNull(substringLabeler1);
      
      boolean boolean1 = substringLabeler1.m_consumeNonMatchingInstances;
      assertFalse(boolean1 == boolean0);
      assertFalse(boolean1);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertNotSame(substringLabeler0, substringLabeler1);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Produces a random subsample of a dataset</font><br><br> The original dataset must fit entirely in memory.<br>This filter allows you to specify the maximum \"spread\" between the rarest and most common class.<br>For example, you may specify that there be at most a 2:1 difference in class frequencies.<br>When used in batch mode, subsequent batches are NOT resampled.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertEquals("SpreadSubsample", filter0.getCustomName());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals(0, instanceEvent0.getStatus());
      assertFalse(substringLabeler0.equals((Object)substringLabeler1));
      
      ClassAssigner classAssigner0 = new ClassAssigner();
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertFalse(classAssigner0.isBusy());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertEquals("last", classAssigner0.getClassColumn());
      assertNotNull(classAssigner0);
      
      SparseInstance sparseInstance0 = null;
      try {
        sparseInstance0 = new SparseInstance((-1120791890));
        fail("Expecting exception: NegativeArraySizeException");
      
      } catch(NegativeArraySizeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.core.SparseInstance", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertNotNull(filter0);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertTrue(multiFilter0.isNewBatch());
      assertNotNull(multiFilter0);
      
      filter0.setFilter(multiFilter0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertTrue(multiFilter0.isNewBatch());
      
      ContainerListener containerListener0 = mock(ContainerListener.class, new ViolatedAssumptionAnswer());
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertNotNull(textDirectoryLoader0);
      
      Instances instances0 = textDirectoryLoader0.getStructure();
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertNotNull(instances0);
      
      Sorter sorter0 = new Sorter();
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isBusy());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertNotNull(sorter0);
      
      TransferHandler transferHandler0 = sorter0.getTransferHandler();
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isBusy());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertNull(transferHandler0);
      
      GraphicsConfiguration graphicsConfiguration0 = filter0.getGraphicsConfiguration();
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertNull(graphicsConfiguration0);
      
      WekaTaskMonitor wekaTaskMonitor0 = new WekaTaskMonitor();
      assertTrue(wekaTaskMonitor0.getFocusTraversalKeysEnabled());
      assertFalse(wekaTaskMonitor0.getIgnoreRepaint());
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicySet());
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicyProvider());
      assertFalse(wekaTaskMonitor0.isFocusCycleRoot());
      assertNotNull(wekaTaskMonitor0);
      
      FindWithCapabilities findWithCapabilities0 = new FindWithCapabilities();
      assertEquals("", findWithCapabilities0.getFilename());
      assertNotNull(findWithCapabilities0);
      
      ClassAssigner classAssigner0 = new ClassAssigner();
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertFalse(classAssigner0.isBusy());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertEquals("last", classAssigner0.getClassColumn());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertNotNull(classAssigner0);
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertNotNull(substringReplacer0);
      
      InstanceEvent instanceEvent0 = substringReplacer0.m_ie;
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, instanceEvent0.getStatus());
      assertNotNull(instanceEvent0);
      
      Appender appender0 = new Appender();
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertNotNull(appender0);
      
      Appender appender1 = new Appender();
      assertFalse(appender1.getIgnoreRepaint());
      assertEquals("Appender", appender1.getCustomName());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.equals((Object)appender0));
      assertNotNull(appender1);
      
      instanceEvent0.setStatus(10000);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertEquals(10000, instanceEvent0.getStatus());
      
      Appender appender2 = new Appender();
      assertFalse(appender2.isBusy());
      assertFalse(appender2.isFocusTraversalPolicyProvider());
      assertFalse(appender2.isFocusCycleRoot());
      assertFalse(appender2.isFocusTraversalPolicySet());
      assertFalse(appender2.getIgnoreRepaint());
      assertTrue(appender2.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender2.getCustomName());
      assertFalse(appender2.equals((Object)appender1));
      assertFalse(appender2.equals((Object)appender0));
      assertNotNull(appender2);
      
      instanceEvent0.setStructure(instances0);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertEquals(0, instanceEvent0.getStatus());
      
      boolean boolean0 = FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "@relation");
      assertFalse(boolean0);
      
      boolean boolean1 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean1 == boolean0);
      assertTrue(boolean1);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertEquals(0, instanceEvent0.getStatus());
      
      ClassAssigner classAssigner1 = new ClassAssigner();
      assertFalse(classAssigner1.isFocusTraversalPolicySet());
      assertFalse(classAssigner1.isFocusCycleRoot());
      assertFalse(classAssigner1.isFocusTraversalPolicyProvider());
      assertEquals("ClassAssigner", classAssigner1.getCustomName());
      assertFalse(classAssigner1.isBusy());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner1.classColumnTipText());
      assertTrue(classAssigner1.getFocusTraversalKeysEnabled());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner1.globalInfo());
      assertEquals("last", classAssigner1.getClassColumn());
      assertFalse(classAssigner1.getIgnoreRepaint());
      assertFalse(classAssigner1.equals((Object)classAssigner0));
      assertNotNull(classAssigner1);
      
      Classifier classifier0 = new Classifier();
      assertTrue(classifier0.getUpdateIncrementalClassifier());
      assertFalse(classifier0.getResetIncrementalClassifier());
      assertEquals("ZeroR", classifier0.getCustomName());
      assertFalse(classifier0.getBlockOnLastFold());
      assertFalse(classifier0.isFocusTraversalPolicyProvider());
      assertEquals(2, classifier0.getExecutionSlots());
      assertTrue(classifier0.getFocusTraversalKeysEnabled());
      assertFalse(classifier0.hasIncomingStreamInstances());
      assertFalse(classifier0.getIgnoreRepaint());
      assertEquals("", classifier0.getLoadClassifierFileName());
      assertEquals("<html><font color=blue>Class for building and using a 0-R classifier</font><br><br> Predicts the mean (for a numeric class) or the mode (for a nominal class).<br></html>", classifier0.globalInfo());
      assertFalse(classifier0.isFocusCycleRoot());
      assertFalse(classifier0.hasIncomingBatchInstances());
      assertFalse(classifier0.isFocusTraversalPolicySet());
      assertNotNull(classifier0);
      
      KeyStroke keyStroke0 = KeyStroke.getKeyStroke(".arff");
      assertNull(keyStroke0);
      
      // Undeclared exception!
      try { 
        filter0.setWrappedAlgorithm((Object) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertNotNull(filter0);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertNotNull(multiFilter0);
      
      Add add0 = new Add();
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertNotNull(add0);
      
      Enumeration enumeration0 = add0.listOptions();
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertNotNull(enumeration0);
      
      filter0.setFilter(add0);
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertNotNull(textDirectoryLoader0);
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      Sorter sorter0 = new Sorter();
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("Sorter", sorter0.getCustomName());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertFalse(sorter0.isFocusCycleRoot());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isBusy());
      assertNull(sorter0.getSortDetails());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("", sorter0.getTempDirectory());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNotNull(sorter0);
      
      WekaTaskMonitor wekaTaskMonitor0 = new WekaTaskMonitor();
      assertTrue(wekaTaskMonitor0.getFocusTraversalKeysEnabled());
      assertFalse(wekaTaskMonitor0.getIgnoreRepaint());
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicyProvider());
      assertFalse(wekaTaskMonitor0.isFocusCycleRoot());
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicySet());
      assertNotNull(wekaTaskMonitor0);
      
      ClassAssigner classAssigner0 = new ClassAssigner();
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertFalse(classAssigner0.isBusy());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertEquals("last", classAssigner0.getClassColumn());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertNotNull(classAssigner0);
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertNotNull(substringReplacer0);
      
      InstanceEvent instanceEvent0 = substringReplacer0.m_ie;
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, instanceEvent0.getStatus());
      assertNotNull(instanceEvent0);
      
      Appender appender0 = new Appender();
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertNotNull(appender0);
      
      Appender appender1 = new Appender();
      assertFalse(appender1.isFocusCycleRoot());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.equals((Object)appender0));
      assertNotNull(appender1);
      
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 0;
      instanceEvent0.setStatus(2);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals(2, instanceEvent0.getStatus());
      
      boolean boolean0 = appender1.m_busy;
      assertFalse(boolean0);
      
      boolean boolean1 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean1 == boolean0);
      assertTrue(boolean1);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals(2, instanceEvent0.getStatus());
      
      ClassAssigner classAssigner1 = new ClassAssigner();
      assertTrue(classAssigner1.getFocusTraversalKeysEnabled());
      assertFalse(classAssigner1.getIgnoreRepaint());
      assertEquals("last", classAssigner1.getClassColumn());
      assertFalse(classAssigner1.isFocusTraversalPolicyProvider());
      assertFalse(classAssigner1.isFocusCycleRoot());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner1.globalInfo());
      assertFalse(classAssigner1.isFocusTraversalPolicySet());
      assertEquals("ClassAssigner", classAssigner1.getCustomName());
      assertFalse(classAssigner1.isBusy());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner1.classColumnTipText());
      assertFalse(classAssigner1.equals((Object)classAssigner0));
      assertNotNull(classAssigner1);
      
      ArffLoader arffLoader0 = new ArffLoader();
      assertEquals(".arff", arffLoader0.getFileExtension());
      assertEquals("http://", arffLoader0.retrieveURL());
      assertEquals("Reads a source that is in arff (attribute relation file format) format. ", arffLoader0.globalInfo());
      assertFalse(arffLoader0.getUseRelativePath());
      assertEquals("Arff data files", arffLoader0.getFileDescription());
      assertEquals("Use relative rather than absolute paths", arffLoader0.useRelativePathTipText());
      assertNotNull(arffLoader0);
      
      try { 
        arffLoader0.getDataSet();
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // No source has been specified
         //
         verifyException("weka.core.converters.ArffLoader", e);
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertNotNull(filter0);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertNotNull(multiFilter0);
      
      Add add0 = new Add();
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertFalse(add0.isOutputFormatDefined());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertNotNull(add0);
      
      filter0.setFilter(add0);
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertFalse(add0.isOutputFormatDefined());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertNotNull(textDirectoryLoader0);
      
      GraphicsConfiguration graphicsConfiguration0 = filter0.getGraphicsConfiguration();
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertNull(graphicsConfiguration0);
      
      WekaTaskMonitor wekaTaskMonitor0 = new WekaTaskMonitor();
      assertFalse(wekaTaskMonitor0.isFocusCycleRoot());
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicyProvider());
      assertFalse(wekaTaskMonitor0.getIgnoreRepaint());
      assertTrue(wekaTaskMonitor0.getFocusTraversalKeysEnabled());
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicySet());
      assertNotNull(wekaTaskMonitor0);
      
      GraphicsConfiguration graphicsConfiguration1 = filter0.getGraphicsConfiguration();
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertNull(graphicsConfiguration1);
      
      WekaTaskMonitor wekaTaskMonitor1 = new WekaTaskMonitor();
      assertFalse(wekaTaskMonitor1.isFocusTraversalPolicySet());
      assertFalse(wekaTaskMonitor1.isFocusTraversalPolicyProvider());
      assertFalse(wekaTaskMonitor1.isFocusCycleRoot());
      assertFalse(wekaTaskMonitor1.getIgnoreRepaint());
      assertTrue(wekaTaskMonitor1.getFocusTraversalKeysEnabled());
      assertFalse(wekaTaskMonitor1.equals((Object)wekaTaskMonitor0));
      assertNotNull(wekaTaskMonitor1);
      
      FindWithCapabilities findWithCapabilities0 = new FindWithCapabilities();
      assertEquals("", findWithCapabilities0.getFilename());
      assertNotNull(findWithCapabilities0);
      
      ClassAssigner classAssigner0 = new ClassAssigner();
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertEquals("last", classAssigner0.getClassColumn());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertFalse(classAssigner0.isBusy());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertNotNull(classAssigner0);
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertNotNull(substringReplacer0);
      
      InstanceEvent instanceEvent0 = substringReplacer0.m_ie;
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(0, instanceEvent0.getStatus());
      assertNotNull(instanceEvent0);
      
      Appender appender0 = new Appender();
      assertFalse(appender0.getIgnoreRepaint());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertNotNull(appender0);
      
      Appender appender1 = new Appender();
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isBusy());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.equals((Object)appender0));
      assertNotNull(appender1);
      
      PanelUI panelUI0 = substringReplacer0.getUI();
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertNotNull(panelUI0);
      
      double[] doubleArray0 = new double[0];
      SparseInstance sparseInstance0 = new SparseInstance(0.0, doubleArray0);
      assertArrayEquals(new double[] {}, doubleArray0, 0.01);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      assertEquals(0, sparseInstance0.numAttributes());
      assertEquals(0.0, sparseInstance0.weight(), 0.01);
      assertEquals(0, sparseInstance0.numValues());
      assertNotNull(sparseInstance0);
      
      instanceEvent0.setInstance(sparseInstance0);
      assertArrayEquals(new double[] {}, doubleArray0, 0.01);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(0, sparseInstance0.numAttributes());
      assertEquals(0.0, sparseInstance0.weight(), 0.01);
      assertEquals(0, sparseInstance0.numValues());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertEquals(0, instanceEvent0.getStatus());
      
      boolean boolean0 = substringReplacer0.m_busy;
      assertFalse(boolean0);
      
      instanceEvent0.setStatus((-906));
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertEquals((-906), instanceEvent0.getStatus());
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertEquals((-906), instanceEvent0.getStatus());
      
      ClassAssigner classAssigner1 = new ClassAssigner();
      assertFalse(classAssigner1.isFocusTraversalPolicyProvider());
      assertFalse(classAssigner1.isBusy());
      assertEquals("ClassAssigner", classAssigner1.getCustomName());
      assertFalse(classAssigner1.isFocusCycleRoot());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner1.classColumnTipText());
      assertTrue(classAssigner1.getFocusTraversalKeysEnabled());
      assertEquals("last", classAssigner1.getClassColumn());
      assertFalse(classAssigner1.getIgnoreRepaint());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner1.globalInfo());
      assertFalse(classAssigner1.isFocusTraversalPolicySet());
      assertFalse(classAssigner1.equals((Object)classAssigner0));
      assertNotNull(classAssigner1);
      
      ClassAssigner classAssigner2 = new ClassAssigner();
      assertTrue(classAssigner2.getFocusTraversalKeysEnabled());
      assertFalse(classAssigner2.getIgnoreRepaint());
      assertFalse(classAssigner2.isFocusTraversalPolicySet());
      assertEquals("last", classAssigner2.getClassColumn());
      assertFalse(classAssigner2.isFocusTraversalPolicyProvider());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner2.globalInfo());
      assertEquals("ClassAssigner", classAssigner2.getCustomName());
      assertFalse(classAssigner2.isFocusCycleRoot());
      assertFalse(classAssigner2.isBusy());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner2.classColumnTipText());
      assertFalse(classAssigner2.equals((Object)classAssigner1));
      assertFalse(classAssigner2.equals((Object)classAssigner0));
      assertNotNull(classAssigner2);
      
      MockJapaneseDate mockJapaneseDate0 = new MockJapaneseDate();
      assertNotNull(mockJapaneseDate0);
      
      Add add1 = new Add();
      assertEquals("The format of the date values (see ISO-8601).", add1.dateFormatTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add1.attributeIndexTipText());
      assertFalse(add1.isOutputFormatDefined());
      assertEquals("unnamed", add1.getAttributeName());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add1.globalInfo());
      assertEquals("Set the new attribute's name.", add1.attributeNameTipText());
      assertEquals("last", add1.getAttributeIndex());
      assertFalse(add1.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add1.isNewBatch());
      assertFalse(add1.isFirstBatchDone());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add1.nominalLabelsTipText());
      assertEquals("Defines the type of the attribute to generate.", add1.attributeTypeTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add1.getDateFormat());
      assertFalse(add1.equals((Object)add0));
      assertNotNull(add1);
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      Filter filter0 = new Filter();
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertNotNull(filter0);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertNotNull(multiFilter0);
      
      Add add0 = new Add();
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertNotNull(add0);
      
      filter0.setFilter(add0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertNotNull(textDirectoryLoader0);
      
      GraphicsConfiguration graphicsConfiguration0 = filter0.getGraphicsConfiguration();
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertNull(graphicsConfiguration0);
      
      GraphicsConfiguration graphicsConfiguration1 = filter0.getGraphicsConfiguration();
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertNull(graphicsConfiguration1);
      
      WekaTaskMonitor wekaTaskMonitor0 = new WekaTaskMonitor();
      assertFalse(wekaTaskMonitor0.getIgnoreRepaint());
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicyProvider());
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicySet());
      assertFalse(wekaTaskMonitor0.isFocusCycleRoot());
      assertTrue(wekaTaskMonitor0.getFocusTraversalKeysEnabled());
      assertNotNull(wekaTaskMonitor0);
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(2, instances0.numAttributes());
      assertTrue(instances0.checkForStringAttributes());
      assertNotNull(instances0);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertNotNull(substringLabeler0);
      
      InstanceEvent instanceEvent0 = substringLabeler0.m_ie;
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, instanceEvent0.getStatus());
      assertNotNull(instanceEvent0);
      
      instanceEvent0.setStructure(instances0);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(2, instances0.numAttributes());
      assertTrue(instances0.checkForStringAttributes());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals(0, instanceEvent0.getStatus());
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isBusy());
      assertNotNull(substringReplacer0);
      
      boolean boolean0 = substringLabeler0.m_nominalBinary;
      assertFalse(boolean0);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals(0, instanceEvent0.getStatus());
      
      instanceEvent0.setStatus((-2016375513));
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals((-2016375513), instanceEvent0.getStatus());
      
      Sorter sorter0 = new Sorter();
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNull(sorter0.getSortDetails());
      assertEquals("", sorter0.getTempDirectory());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusCycleRoot());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertNotNull(sorter0);
      
      boolean boolean1 = sorter0.m_busy;
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
      
      boolean boolean2 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean2 == boolean0);
      assertFalse(boolean2 == boolean1);
      assertTrue(boolean2);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals((-2016375513), instanceEvent0.getStatus());
      
      boolean boolean3 = substringLabeler0.m_consumeNonMatchingInstances;
      assertTrue(boolean3 == boolean0);
      assertFalse(boolean3 == boolean2);
      assertTrue(boolean3 == boolean1);
      assertFalse(boolean3);
      
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertNotNull(trainTestSplitMaker0);
      
      ClassAssigner classAssigner0 = new ClassAssigner();
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertEquals("last", classAssigner0.getClassColumn());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertFalse(classAssigner0.isBusy());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertNotNull(classAssigner0);
      
      classAssigner0.updateUI();
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertEquals("last", classAssigner0.getClassColumn());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertFalse(classAssigner0.isBusy());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      
      ArffLoader arffLoader0 = new ArffLoader();
      assertEquals("Arff data files", arffLoader0.getFileDescription());
      assertEquals("Use relative rather than absolute paths", arffLoader0.useRelativePathTipText());
      assertFalse(arffLoader0.getUseRelativePath());
      assertEquals("http://", arffLoader0.retrieveURL());
      assertEquals("Reads a source that is in arff (attribute relation file format) format. ", arffLoader0.globalInfo());
      assertEquals(".arff", arffLoader0.getFileExtension());
      assertNotNull(arffLoader0);
      
      KnowledgeFlowApp knowledgeFlowApp0 = null;
      try {
        knowledgeFlowApp0 = new KnowledgeFlowApp(false);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // org.evosuite.instrumentation.InstrumentingClassLoader cannot be cast to java.net.URLClassLoader
         //
         verifyException("weka.core.ClassCache", e);
      }
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertNotNull(filter0);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertNotNull(multiFilter0);
      
      Add add0 = new Add();
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertNotNull(add0);
      
      Enumeration enumeration0 = add0.listOptions();
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertNotNull(enumeration0);
      
      filter0.setFilter(add0);
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertNotNull(textDirectoryLoader0);
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      Sorter sorter0 = new Sorter();
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("Sorter", sorter0.getCustomName());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isBusy());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusCycleRoot());
      assertEquals("", sorter0.getTempDirectory());
      assertNotNull(sorter0);
      
      WekaTaskMonitor wekaTaskMonitor0 = new WekaTaskMonitor();
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicySet());
      assertTrue(wekaTaskMonitor0.getFocusTraversalKeysEnabled());
      assertFalse(wekaTaskMonitor0.getIgnoreRepaint());
      assertFalse(wekaTaskMonitor0.isFocusCycleRoot());
      assertFalse(wekaTaskMonitor0.isFocusTraversalPolicyProvider());
      assertNotNull(wekaTaskMonitor0);
      
      ClassAssigner classAssigner0 = new ClassAssigner();
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertEquals("last", classAssigner0.getClassColumn());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertFalse(classAssigner0.isBusy());
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertNotNull(classAssigner0);
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertNotNull(substringReplacer0);
      
      InstanceEvent instanceEvent0 = substringReplacer0.m_ie;
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(0, instanceEvent0.getStatus());
      assertNotNull(instanceEvent0);
      
      Appender appender0 = new Appender();
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.getIgnoreRepaint());
      assertNotNull(appender0);
      
      Appender appender1 = new Appender();
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.equals((Object)appender0));
      assertNotNull(appender1);
      
      double[] doubleArray0 = new double[1];
      doubleArray0[0] = (double) 0;
      SparseInstance sparseInstance0 = new SparseInstance(0);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(0, sparseInstance0.numAttributes());
      assertEquals(0, sparseInstance0.numValues());
      assertNotNull(sparseInstance0);
      
      instanceEvent0.setInstance(sparseInstance0);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(0, sparseInstance0.numAttributes());
      assertEquals(0, sparseInstance0.numValues());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertEquals(0, instanceEvent0.getStatus());
      
      instanceEvent0.setStatus(2);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertEquals(2, instanceEvent0.getStatus());
      
      boolean boolean0 = appender1.m_busy;
      assertFalse(boolean0);
      
      boolean boolean1 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean1 == boolean0);
      assertTrue(boolean1);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertEquals(2, instanceEvent0.getStatus());
      
      ClassAssigner classAssigner1 = new ClassAssigner();
      assertFalse(classAssigner1.isFocusTraversalPolicySet());
      assertTrue(classAssigner1.getFocusTraversalKeysEnabled());
      assertEquals("ClassAssigner", classAssigner1.getCustomName());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner1.globalInfo());
      assertFalse(classAssigner1.getIgnoreRepaint());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner1.classColumnTipText());
      assertEquals("last", classAssigner1.getClassColumn());
      assertFalse(classAssigner1.isFocusCycleRoot());
      assertFalse(classAssigner1.isBusy());
      assertFalse(classAssigner1.isFocusTraversalPolicyProvider());
      assertFalse(classAssigner1.equals((Object)classAssigner0));
      assertNotNull(classAssigner1);
      
      ArffLoader arffLoader0 = new ArffLoader();
      assertEquals("Reads a source that is in arff (attribute relation file format) format. ", arffLoader0.globalInfo());
      assertEquals("Arff data files", arffLoader0.getFileDescription());
      assertEquals("Use relative rather than absolute paths", arffLoader0.useRelativePathTipText());
      assertFalse(arffLoader0.getUseRelativePath());
      assertEquals("http://", arffLoader0.retrieveURL());
      assertEquals(".arff", arffLoader0.getFileExtension());
      assertNotNull(arffLoader0);
      
      try { 
        arffLoader0.getDataSet();
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // No source has been specified
         //
         verifyException("weka.core.converters.ArffLoader", e);
      }
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      Filter filter0 = new Filter();
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertNotNull(filter0);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertNotNull(multiFilter0);
      
      Add add0 = new Add();
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertNotNull(add0);
      
      SpreadSubsample spreadSubsample0 = new SpreadSubsample();
      assertEquals("Wether instance weights will be adjusted to maintain total weight per class.", spreadSubsample0.adjustWeightsTipText());
      assertFalse(spreadSubsample0.isOutputFormatDefined());
      assertEquals(0.0, spreadSubsample0.getMaxCount(), 0.01);
      assertEquals(0.0, spreadSubsample0.getDistributionSpread(), 0.01);
      assertFalse(spreadSubsample0.isFirstBatchDone());
      assertEquals(1, spreadSubsample0.getRandomSeed());
      assertFalse(spreadSubsample0.getAdjustWeights());
      assertEquals("Sets the random number seed for subsampling.", spreadSubsample0.randomSeedTipText());
      assertFalse(spreadSubsample0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("The maximum count for any class value (0 = unlimited).", spreadSubsample0.maxCountTipText());
      assertTrue(spreadSubsample0.isNewBatch());
      assertEquals("Produces a random subsample of a dataset. The original dataset must fit entirely in memory. This filter allows you to specify the maximum \"spread\" between the rarest and most common class. For example, you may specify that there be at most a 2:1 difference in class frequencies. When used in batch mode, subsequent batches are NOT resampled.", spreadSubsample0.globalInfo());
      assertEquals("The maximum class distribution spread. (0 = no maximum spread, 1 = uniform distribution, 10 = allow at most a 10:1 ratio between the classes).", spreadSubsample0.distributionSpreadTipText());
      assertNotNull(spreadSubsample0);
      
      filter0.setFilter(multiFilter0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      
      FindWithCapabilities findWithCapabilities0 = new FindWithCapabilities();
      assertEquals("", findWithCapabilities0.getFilename());
      assertNotNull(findWithCapabilities0);
      
      weka.gui.LogPanel logPanel0 = new weka.gui.LogPanel();
      assertFalse(logPanel0.isFocusTraversalPolicySet());
      assertFalse(logPanel0.isFocusCycleRoot());
      assertTrue(logPanel0.getFocusTraversalKeysEnabled());
      assertFalse(logPanel0.getIgnoreRepaint());
      assertFalse(logPanel0.isFocusTraversalPolicyProvider());
      assertNotNull(logPanel0);
      
      filter0.setLog(logPanel0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(logPanel0.isFocusTraversalPolicySet());
      assertFalse(logPanel0.isFocusCycleRoot());
      assertTrue(logPanel0.getFocusTraversalKeysEnabled());
      assertFalse(logPanel0.getIgnoreRepaint());
      assertFalse(logPanel0.isFocusTraversalPolicyProvider());
      
      FindWithCapabilities findWithCapabilities1 = new FindWithCapabilities();
      assertEquals("", findWithCapabilities1.getFilename());
      assertFalse(findWithCapabilities1.equals((Object)findWithCapabilities0));
      assertNotNull(findWithCapabilities1);
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isBusy());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertNotNull(substringReplacer0);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertNotNull(substringLabeler0);
      
      InstanceEvent instanceEvent0 = substringLabeler0.m_ie;
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, instanceEvent0.getStatus());
      assertNotNull(instanceEvent0);
      
      ClassValuePicker classValuePicker0 = new ClassValuePicker();
      assertEquals("Designate which class value is to be considered the \"positive\" class value (useful for ROC style curves).", classValuePicker0.globalInfo());
      assertFalse(classValuePicker0.isFocusCycleRoot());
      assertFalse(classValuePicker0.isFocusTraversalPolicyProvider());
      assertFalse(classValuePicker0.isFocusTraversalPolicySet());
      assertFalse(classValuePicker0.isBusy());
      assertFalse(classValuePicker0.getIgnoreRepaint());
      assertNull(classValuePicker0.getClassValue());
      assertEquals("ClassValuePicker", classValuePicker0.getCustomName());
      assertTrue(classValuePicker0.getFocusTraversalKeysEnabled());
      assertNotNull(classValuePicker0);
      
      Instances instances0 = classValuePicker0.getStructure();
      assertEquals("Designate which class value is to be considered the \"positive\" class value (useful for ROC style curves).", classValuePicker0.globalInfo());
      assertFalse(classValuePicker0.isFocusCycleRoot());
      assertFalse(classValuePicker0.isFocusTraversalPolicyProvider());
      assertFalse(classValuePicker0.isFocusTraversalPolicySet());
      assertFalse(classValuePicker0.isBusy());
      assertFalse(classValuePicker0.getIgnoreRepaint());
      assertNull(classValuePicker0.getClassValue());
      assertEquals("ClassValuePicker", classValuePicker0.getCustomName());
      assertTrue(classValuePicker0.getFocusTraversalKeysEnabled());
      assertNull(instances0);
      
      instanceEvent0.setStructure((Instances) null);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals(0, instanceEvent0.getStatus());
      
      SubstringReplacer substringReplacer1 = new SubstringReplacer();
      assertTrue(substringReplacer1.getFocusTraversalKeysEnabled());
      assertEquals("SubstringReplacer", substringReplacer1.getCustomName());
      assertFalse(substringReplacer1.isBusy());
      assertEquals("", substringReplacer1.getMatchReplaceDetails());
      assertFalse(substringReplacer1.isFocusTraversalPolicyProvider());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer1.globalInfo());
      assertFalse(substringReplacer1.isFocusCycleRoot());
      assertFalse(substringReplacer1.getIgnoreRepaint());
      assertFalse(substringReplacer1.isFocusTraversalPolicySet());
      assertFalse(substringReplacer1.equals((Object)substringReplacer0));
      assertNotNull(substringReplacer1);
      
      boolean boolean0 = substringLabeler0.m_consumeNonMatchingInstances;
      assertFalse(boolean0);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals(0, instanceEvent0.getStatus());
      
      ClassAssigner classAssigner0 = new ClassAssigner();
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertFalse(classAssigner0.isBusy());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertEquals("last", classAssigner0.getClassColumn());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertNotNull(classAssigner0);
      
      SparseInstance sparseInstance0 = new SparseInstance(1);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      assertEquals(1, sparseInstance0.numValues());
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(1, sparseInstance0.numAttributes());
      assertNotNull(sparseInstance0);
      
      instanceEvent0.setStatus((-2096626318));
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals((-2096626318), instanceEvent0.getStatus());
      
      String string0 = sparseInstance0.toString();
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      assertEquals(1, sparseInstance0.numValues());
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(1, sparseInstance0.numAttributes());
      assertEquals("{0 ?}", string0);
      assertNotNull(string0);
      
      Sorter sorter0 = new Sorter();
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusCycleRoot());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNull(sorter0.getSortDetails());
      assertEquals("", sorter0.getTempDirectory());
      assertNotNull(sorter0);
      
      boolean boolean1 = sorter0.m_busy;
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
      
      boolean boolean2 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean2 == boolean0);
      assertFalse(boolean2 == boolean1);
      assertTrue(boolean2);
      
      instanceEvent0.setInstance(sparseInstance0);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(1, sparseInstance0.numValues());
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(1, sparseInstance0.numAttributes());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals((-2096626318), instanceEvent0.getStatus());
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals((-2096626318), instanceEvent0.getStatus());
      
      ClassAssigner classAssigner1 = new ClassAssigner();
      assertTrue(classAssigner1.getFocusTraversalKeysEnabled());
      assertFalse(classAssigner1.isFocusTraversalPolicyProvider());
      assertFalse(classAssigner1.isBusy());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner1.classColumnTipText());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner1.globalInfo());
      assertEquals("ClassAssigner", classAssigner1.getCustomName());
      assertFalse(classAssigner1.isFocusCycleRoot());
      assertFalse(classAssigner1.getIgnoreRepaint());
      assertFalse(classAssigner1.isFocusTraversalPolicySet());
      assertEquals("last", classAssigner1.getClassColumn());
      assertFalse(classAssigner1.equals((Object)classAssigner0));
      assertNotNull(classAssigner1);
      
      classAssigner1.updateUI();
      assertNotSame(classAssigner1, classAssigner0);
      assertTrue(classAssigner1.getFocusTraversalKeysEnabled());
      assertFalse(classAssigner1.isFocusTraversalPolicyProvider());
      assertFalse(classAssigner1.isBusy());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner1.classColumnTipText());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner1.globalInfo());
      assertEquals("ClassAssigner", classAssigner1.getCustomName());
      assertFalse(classAssigner1.isFocusCycleRoot());
      assertFalse(classAssigner1.getIgnoreRepaint());
      assertFalse(classAssigner1.isFocusTraversalPolicySet());
      assertEquals("last", classAssigner1.getClassColumn());
      assertFalse(classAssigner1.equals((Object)classAssigner0));
      
      ArffLoader arffLoader0 = new ArffLoader();
      assertFalse(arffLoader0.getUseRelativePath());
      assertEquals("Arff data files", arffLoader0.getFileDescription());
      assertEquals("Use relative rather than absolute paths", arffLoader0.useRelativePathTipText());
      assertEquals(".arff", arffLoader0.getFileExtension());
      assertEquals("http://", arffLoader0.retrieveURL());
      assertEquals("Reads a source that is in arff (attribute relation file format) format. ", arffLoader0.globalInfo());
      assertNotNull(arffLoader0);
      
      KnowledgeFlowApp knowledgeFlowApp0 = null;
      try {
        knowledgeFlowApp0 = new KnowledgeFlowApp(false);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // org.evosuite.instrumentation.InstrumentingClassLoader cannot be cast to java.net.URLClassLoader
         //
         verifyException("weka.core.ClassCache", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertNotNull(filter0);
      
      Classifier classifier0 = new Classifier();
      assertFalse(classifier0.getResetIncrementalClassifier());
      assertTrue(classifier0.getUpdateIncrementalClassifier());
      assertFalse(classifier0.isFocusTraversalPolicyProvider());
      assertFalse(classifier0.getBlockOnLastFold());
      assertEquals("", classifier0.getLoadClassifierFileName());
      assertFalse(classifier0.hasIncomingBatchInstances());
      assertFalse(classifier0.getIgnoreRepaint());
      assertFalse(classifier0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Class for building and using a 0-R classifier</font><br><br> Predicts the mean (for a numeric class) or the mode (for a nominal class).<br></html>", classifier0.globalInfo());
      assertFalse(classifier0.isFocusCycleRoot());
      assertFalse(classifier0.hasIncomingStreamInstances());
      assertTrue(classifier0.getFocusTraversalKeysEnabled());
      assertEquals("ZeroR", classifier0.getCustomName());
      assertEquals(2, classifier0.getExecutionSlots());
      assertNotNull(classifier0);
      
      filter0.connectionNotification("jh^^[tzvZ7S{lifS", classifier0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(classifier0.getResetIncrementalClassifier());
      assertTrue(classifier0.getUpdateIncrementalClassifier());
      assertFalse(classifier0.isFocusTraversalPolicyProvider());
      assertFalse(classifier0.getBlockOnLastFold());
      assertEquals("", classifier0.getLoadClassifierFileName());
      assertFalse(classifier0.hasIncomingBatchInstances());
      assertFalse(classifier0.getIgnoreRepaint());
      assertFalse(classifier0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Class for building and using a 0-R classifier</font><br><br> Predicts the mean (for a numeric class) or the mode (for a nominal class).<br></html>", classifier0.globalInfo());
      assertFalse(classifier0.isFocusCycleRoot());
      assertFalse(classifier0.hasIncomingStreamInstances());
      assertTrue(classifier0.getFocusTraversalKeysEnabled());
      assertEquals("ZeroR", classifier0.getCustomName());
      assertEquals(2, classifier0.getExecutionSlots());
      
      boolean boolean0 = NetworkHandling.createRemoteTextFile((EvoSuiteURL) null, "jh^^[tzvZ7S{lifS");
      assertFalse(boolean0);
      
      boolean boolean1 = filter0.eventGeneratable("jh^^[tzvZ7S{lifS");
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
      
      JList<ModelPerformanceChart> jList0 = new JList<ModelPerformanceChart>();
      assertFalse(jList0.getIgnoreRepaint());
      assertFalse(jList0.isFocusTraversalPolicyProvider());
      assertFalse(jList0.isFocusTraversalPolicySet());
      assertFalse(jList0.isFocusCycleRoot());
      assertTrue(jList0.getFocusTraversalKeysEnabled());
      assertNotNull(jList0);
      
      Appender appender0 = new Appender();
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      assertNotNull(appender0);
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, instanceEvent0.getStatus());
      assertNotNull(instanceEvent0);
      
      Resample resample0 = new Resample();
      assertEquals("The subsample size as a percentage of the original set.", resample0.sampleSizePercentTipText());
      assertTrue(resample0.isNewBatch());
      assertFalse(resample0.getNoReplacement());
      assertFalse(resample0.isFirstBatchDone());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample0.globalInfo());
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample0.invertSelectionTipText());
      assertEquals(0.0, resample0.getBiasToUniformClass(), 0.01);
      assertFalse(resample0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals(100.0, resample0.getSampleSizePercent(), 0.01);
      assertFalse(resample0.isOutputFormatDefined());
      assertEquals(1, resample0.getRandomSeed());
      assertEquals("Disables the replacement of instances.", resample0.noReplacementTipText());
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample0.biasToUniformClassTipText());
      assertFalse(resample0.getInvertSelection());
      assertEquals("Sets the random number seed for subsampling.", resample0.randomSeedTipText());
      assertNotNull(resample0);
      
      InstanceEvent instanceEvent1 = new InstanceEvent(resample0);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals("The subsample size as a percentage of the original set.", resample0.sampleSizePercentTipText());
      assertTrue(resample0.isNewBatch());
      assertFalse(resample0.getNoReplacement());
      assertFalse(resample0.isFirstBatchDone());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample0.globalInfo());
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample0.invertSelectionTipText());
      assertEquals(0.0, resample0.getBiasToUniformClass(), 0.01);
      assertFalse(resample0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals(100.0, resample0.getSampleSizePercent(), 0.01);
      assertFalse(resample0.isOutputFormatDefined());
      assertEquals(1, resample0.getRandomSeed());
      assertEquals("Disables the replacement of instances.", resample0.noReplacementTipText());
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample0.biasToUniformClassTipText());
      assertFalse(resample0.getInvertSelection());
      assertEquals("Sets the random number seed for subsampling.", resample0.randomSeedTipText());
      assertEquals(0, instanceEvent1.getStatus());
      assertFalse(instanceEvent1.equals((Object)instanceEvent0));
      assertNotNull(instanceEvent1);
      
      filter0.acceptInstance(instanceEvent1);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertNotSame(instanceEvent1, instanceEvent0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("The subsample size as a percentage of the original set.", resample0.sampleSizePercentTipText());
      assertTrue(resample0.isNewBatch());
      assertFalse(resample0.getNoReplacement());
      assertFalse(resample0.isFirstBatchDone());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample0.globalInfo());
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample0.invertSelectionTipText());
      assertEquals(0.0, resample0.getBiasToUniformClass(), 0.01);
      assertFalse(resample0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals(100.0, resample0.getSampleSizePercent(), 0.01);
      assertFalse(resample0.isOutputFormatDefined());
      assertEquals(1, resample0.getRandomSeed());
      assertEquals("Disables the replacement of instances.", resample0.noReplacementTipText());
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample0.biasToUniformClassTipText());
      assertFalse(resample0.getInvertSelection());
      assertEquals("Sets the random number seed for subsampling.", resample0.randomSeedTipText());
      assertEquals(0, instanceEvent1.getStatus());
      assertFalse(instanceEvent1.equals((Object)instanceEvent0));
      
      boolean boolean2 = filter0.isBusy();
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(boolean2 == boolean0);
      assertTrue(boolean2 == boolean1);
      assertFalse(boolean2);
      
      Enumeration enumeration0 = filter0.enumerateRequests();
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertNotNull(enumeration0);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertNotNull(multiFilter0);
      
      MatlabLoader matlabLoader0 = new MatlabLoader();
      assertEquals("Use relative rather than absolute paths", matlabLoader0.useRelativePathTipText());
      assertEquals("Reads a Matlab file containing a single matrix in ASCII format.", matlabLoader0.globalInfo());
      assertFalse(matlabLoader0.getUseRelativePath());
      assertEquals("http://", matlabLoader0.retrieveURL());
      assertEquals(".m", matlabLoader0.getFileExtension());
      assertEquals("Matlab ASCII files", matlabLoader0.getFileDescription());
      assertNotNull(matlabLoader0);
      
      try { 
        matlabLoader0.getDataSet();
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // No source has been specified
         //
         verifyException("weka.core.converters.MatlabLoader", e);
      }
  }
}
