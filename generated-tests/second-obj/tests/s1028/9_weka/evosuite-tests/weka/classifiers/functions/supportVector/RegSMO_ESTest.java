/*
 * This file was automatically generated by EvoSuite
 * Sat Jul 07 13:44:31 GMT 2018
 */

package weka.classifiers.functions.supportVector;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.Enumeration;
import java.util.Locale;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.mock.java.util.MockRandom;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;
import weka.classifiers.AbstractClassifier;
import weka.classifiers.functions.SMOreg;
import weka.classifiers.functions.supportVector.RegSMO;
import weka.classifiers.functions.supportVector.StringKernel;
import weka.classifiers.meta.RandomSubSpace;
import weka.classifiers.meta.Vote;
import weka.core.Instances;
import weka.core.TechnicalInformation;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class RegSMO_ESTest extends RegSMO_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      try { 
        regSMO0.wrapUp();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegOptimizer", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      try { 
        regSMO0.takeStep(2245, (-3090), (-3090), (-3090), 2245);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      regSMO0.findOptimalPointOnLine((-759), (-759), (-759), (-759), 35, (-759), 35, (-759), 2871.1700847462116, (-759), (-759));
      System.setCurrentTimeMillis((-759));
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Random.setNextRandom(55);
      RegSMO regSMO0 = new RegSMO();
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(55, 55, 55, 55, (-317), (-317), 55, (-317), 419.22177028754, 1298.8196679946902, (-1.0));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      String[] stringArray0 = new String[1];
      stringArray0[0] = "F/";
      regSMO0.setOptions(stringArray0);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-817), (-817), (-817), (-817), (-817), (-817), (-817), (-817), (-817), 1700.305736693097, 6.7);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      String string0 = regSMO0.globalInfo();
      assertEquals("Implementation of SMO for support vector regression as described in :\n\nA.J. Smola, B. Schoelkopf (1998). A tutorial on support vector regression.", string0);
      
      regSMO0.getOptions();
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      Instances instances0 = regSMO0.m_data;
      // Undeclared exception!
      try { 
        regSMO0.secondChoiceHeuristic(0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      regSMO0.setEpsilon((-1592.55));
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, 0, 0.0, (-1592.55), 0, (-299.9522), 0.0, (-411.33), 1.0E-10, 3290.5656705, 2201.210444267623);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(1523, 3237.761561, 1523, 3237.761561, 1523, (-1.0E100), (-2.0), 41.738, 41.738, 1.7976931348623157E308, (-549.0));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertNotNull(regSMO0);
      
      regSMO0.setEpsilon((-1592.55));
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1592.55), regSMO0.getEpsilon(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, 1.0E-12, (-1.0), 1.0E-10, 0, 0, (-1.0), (-1.0), (-4936.085), 1.0E-10, 1.0E-10);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-817), (-817), 1.0, 3202.466454157335, (-817), 3202.466454157335, (-817), 9.99875737761613E-11, (-817), 1700.305736693097, 1700.305736693097);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Random.setNextRandom(28);
      RegSMO regSMO0 = new RegSMO();
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertNotNull(regSMO0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(28, (-3233.0), 28, 3202.466454157335, 31, 1.0E-75, 28, 31, 1.0E-10, 31, 1.0E-10);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertNotNull(regSMO0);
      
      String string0 = regSMO0.epsilonTipText();
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertNotNull(string0);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", string0);
      
      regSMO0.setEpsilon(1.0E-12);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      
      String string1 = regSMO0.getRevision();
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertNotNull(string1);
      assertFalse(string1.equals((Object)string0));
      assertEquals("8034", string1);
      
      int int0 = 102;
      regSMO0.m_C = (-3233.0);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2142275480, 2142275480, 2142275480, 3049.340819295754, 102, 3049.340819295754, (-1896.0), 1.0E-10, 513.553937038773, 0.1, 2142275480);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertNotNull(regSMO0);
      
      double double0 = 0.5;
      double double1 = (-2385.3869);
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      double double2 = 0.0;
      int int0 = (-2493);
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-204), 59, 5257.201736709993, (-204), (-2493), 0.0, (-2385.3869), (-204), (-204), 59, (-204));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[18];
      regSMO0.m_alpha = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      String[] stringArray0 = regSMO0.getOptions();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertNotNull(stringArray0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(17, 3899.3295438163645, 0.0, 3899.3295438163645, 17, 3899.3295438163645, 0.0, 3899.3295438163645, 0.0, 3049.340819295754, 3899.3295438163645);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-2146819614), (-2146819614), 1.0, 1.0, (-817), 1.0, (-2146819614), 9.99875737761613E-11, 4083.7154, 1700.305736693097, 6.7);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      String[] stringArray0 = new String[6];
      stringArray0[0] = "U>r";
      stringArray0[1] = "'^";
      stringArray0[2] = "]CIx7nc{?]0z1jIP";
      stringArray0[3] = "-P";
      stringArray0[4] = "-P";
      stringArray0[5] = "NeuroCOLT2 Technical Report NC2-TR-1998-030";
      try { 
        regSMO0.setOptions(stringArray0);
        fail("Expecting exception: NumberFormatException");
      
      } catch(NumberFormatException e) {
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertNotNull(regSMO0);
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-759), 0.0, (-1.0), (-299.9522), (-759), (-4048.302547923879), (-4048.302547923879), 14.874031974027314, 1.0, 1279.17, (-299.9522));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[0];
      regSMO0.m_alpha = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      double double0 = regSMO0.getEpsilon();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, double0, 0.01);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(29, 1.0E-12, 99.0, 29, 29, 1.0E-12, 99.0, 99.0, 99.0, 45.0, 0.0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 29
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertNotNull(regSMO0);
      
      boolean boolean0 = FileSystemHandling.createFolder((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(28, 28, 28, 3202.466454157335, 31, 1.0E-75, 28, 31, 31, 31, 31);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(regSMO0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2, 2558.81, 2089.798, 2089.798, 2, 2089.798, (-1.0), 2558.81, 2334.404685941721, 210.288532651, 1.0E-10);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      Instances instances0 = regSMO0.m_data;
      assertNull(instances0);
      
      try { 
        regSMO0.buildClassifier((Instances) null);
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // SVM not initialized in optimizer. Use RegOptimizer.setSVMReg()
         //
         verifyException("weka.classifiers.functions.supportVector.RegOptimizer", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      Random.setNextRandom(28);
      RegSMO regSMO0 = new RegSMO();
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(4210, (-3233.0), 4210, 3202.466454157335, 31, 1.0E-75, 28, 31, 1.0E-10, 31, 1.0E-10);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = (-934.0427);
      double double0 = regSMO0.getScore();
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.0, double0, 0.01);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-604), (-934.0427), 1437.0206369, 844.407234058, (-1080), 1000.7014967, 1.0E-10, 1.0E-10, (-604), 1.0E-12, (-604));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertNotNull(regSMO0);
      
      int int0 = 57;
      boolean boolean0 = true;
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(46, 57, 46, 46, 46, 39.0, 57, 57, 1.0E-8, 46, 2.4490895438217537);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertNotNull(regSMO0);
      
      double double0 = 1.0E-10;
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-100), 1921.0, 2664.4433298039758, 2229.526505865192, (-100), 2229.526505865192, 1.0E-10, 1.0E-10, 1.0E-10, 0.9923718855184396, 2664.4433298039758);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(regSMO0);
      
      double double0 = 1.0E-10;
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-100), 1921.0, 2664.4433298039758, 2229.526505865192, (-100), 2229.526505865192, 1.0E-10, 1.0E-10, 1.0E-10, 2664.4433298039758, 2664.4433298039758);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[15];
      doubleArray0[1] = 1.0E-12;
      regSMO0.m_alpha = doubleArray0;
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(3, 1.0E-12, 1.0E-12, (-2.1474836085262756E9), 3, 0.0, 0.0, (-0.4375), 2631.89911, 26.4139999973586, 3);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(regSMO0);
      
      int int0 = 2142275480;
      String string0 = regSMO0.getRevision();
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(string0);
      assertEquals("8034", string0);
      
      int int1 = 102;
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2142275480, (-1896.0), 1.0E-8, 102, 71, (-3233.0), 0.1, 1.0E-10, (-1.0), 71, (-4027.379457));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[18];
      regSMO0.m_alpha = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      
      boolean boolean0 = regSMO0.m_bModelBuilt;
      assertFalse(boolean0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, (-4.0), 0.0, (-4.0), 0, 3899.3295438163645, 0.0, 3899.3295438163645, 0.0, 3049.340819295754, (-1082.68316578));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      int int0 = 2142275501;
      int int1 = 102;
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2142275501, (-1896.0), 102, 102, 71, (-3233.0), 2142275501, 102, (-1.0), 71, 102);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[2];
      doubleArray0[1] = 1.2046060474757736;
      regSMO0.m_alpha = doubleArray0;
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, (-4.0), 1.2046060474757736, (-4.0), 0, 5.5, 0.0, (-934.0427), 1.2046060474757736, 3049.340819295754, (-1082.68316578));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertNotNull(regSMO0);
      
      int int0 = (-604);
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(3, 80, 436.3191402002, 1501.17867, (-604), (-934.0427), 1000.7014967, 2142275480, 933.716266096877, 80, (-3.0));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertNotNull(regSMO0);
      
      TechnicalInformation technicalInformation0 = regSMO0.getTechnicalInformation();
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertFalse(technicalInformation0.hasAdditional());
      assertEquals(TechnicalInformation.Type.MISC, technicalInformation0.getType());
      assertNotNull(technicalInformation0);
      
      int int0 = 2;
      regSMO0.m_classIndex = 2;
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      double[] doubleArray0 = new double[8];
      double double0 = regSMO0.getScore();
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.0, double0, 0.01);
      
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      doubleArray0[0] = (double) 2;
      regSMO0.m_alpha = doubleArray0;
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(3, 2755.837041, 1.0E-12, 3, 3, 1.0E-12, 0.0, 31.141442968254857, 0.0, 1.0E-12, (-215.27270669470664));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertNotNull(regSMO0);
      
      int int0 = 804;
      int int1 = 95;
      double double0 = (-1.0);
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(804, (-1896.0), 7.046923427346423, 95, 71, (-3233.0), 0.1, 1.0E-10, (-1.0), 71, 1.0E-10);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[2];
      doubleArray0[0] = (-934.0427);
      doubleArray0[0] = 1.0E-12;
      regSMO0.m_alpha = doubleArray0;
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      int int0 = regSMO0.secondChoiceHeuristic(350);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, int0);
      
      try { 
        regSMO0.optimize();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[13];
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      SMOreg sMOreg0 = new SMOreg();
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertNotNull(sMOreg0);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      
      regSMO0.m_alphaStar = doubleArray0;
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      String string0 = sMOreg0.toString();
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertNotNull(string0);
      assertEquals("SMOreg: No model built yet.", string0);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      
      boolean boolean1 = FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "I|");
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
      
      String[] stringArray0 = Locale.getISOCountries();
      assertNotNull(stringArray0);
      
      SMOreg sMOreg1 = (SMOreg)AbstractClassifier.makeCopy(sMOreg0);
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertFalse(sMOreg1.getDebug());
      assertEquals("The learning algorithm.", sMOreg1.regOptimizerTipText());
      assertEquals("The kernel to use.", sMOreg1.kernelTipText());
      assertEquals(1.0, sMOreg1.getC(), 0.01);
      assertEquals("Determines how/if the data will be transformed.", sMOreg1.filterTypeTipText());
      assertEquals("The complexity parameter C.", sMOreg1.cTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg1.debugTipText());
      assertNotNull(sMOreg1);
      assertFalse(sMOreg1.equals((Object)sMOreg0));
      assertNotSame(sMOreg0, sMOreg1);
      assertNotSame(sMOreg1, sMOreg0);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2, 817.0, 1, 0.002, 31, 0, 2, 817.0, 0, 4.6, (-176.0));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertNotNull(regSMO0);
      
      regSMO0.setSeed((-263));
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals((-263), regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      Random.setNextRandom(1);
      Enumeration enumeration0 = regSMO0.listOptions();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals((-263), regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertNotNull(enumeration0);
      
      int int0 = regSMO0.takeStep((-263), (-263), (-263), 9.999999999E-4, 9.999999999E-4);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals((-263), regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, int0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2068, (-263), 2354.56, 2354.56, (-2354), (-2354), 9.999999999E-4, 770.2, (-6.78214234), 1.0E-12, 2354.56);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertNotNull(regSMO0);
      
      int int0 = 2142275480;
      int int1 = 102;
      int int2 = 71;
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2142275480, (-1896.0), 1.0E-8, 102, 71, (-3233.0), 0.1, 7.046923427346423, (-1.0), 71, 7.046923427346423);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertNotNull(regSMO0);
      
      regSMO0.m_classIndex = 2;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      
      double[] doubleArray0 = new double[8];
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      
      doubleArray0[0] = (double) 2;
      regSMO0.m_alpha = regSMO0.m_alphaStar;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      
      int int0 = regSMO0.secondChoiceHeuristic(2);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals((-1), int0);
      
      int int1 = Vote.AVERAGE_RULE;
      assertFalse(int1 == int0);
      assertEquals(1, int1);
      
      try { 
        regSMO0.optimize();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.createFolder((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[7];
      SMOreg sMOreg0 = new SMOreg();
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertNotNull(sMOreg0);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      
      MockRandom mockRandom0 = new MockRandom();
      assertNotNull(mockRandom0);
      
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      regSMO0.m_alpha = regSMO0.m_alphaStar;
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      boolean boolean1 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean1 == boolean0);
      assertTrue(boolean1);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, 0, 2, 1, 1, 1, 1, 2, 45.0, 1, 0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[5];
      regSMO0.m_alpha = doubleArray0;
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      regSMO0.m_alphaStar = doubleArray0;
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      regSMO0.m_target = regSMO0.m_alphaStar;
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      regSMO0.optimize();
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(regSMO0);
      
      double double0 = regSMO0.getScore();
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.0, double0, 0.01);
      
      regSMO0.m_nInstances = 112;
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      
      regSMO0.m_alpha1 = (double) 112;
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      
      try { 
        regSMO0.optimize();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[27];
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      
      String[] stringArray0 = regSMO0.getOptions();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(stringArray0);
      
      int int0 = regSMO0.secondChoiceHeuristic(1025);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), int0);
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(regSMO0);
      
      boolean boolean0 = regSMO0.m_bModelBuilt;
      assertFalse(boolean0);
      
      regSMO0.m_C = 890.607915541191;
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      boolean boolean1 = FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
      
      double[] doubleArray0 = new double[4];
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      SMOreg sMOreg0 = regSMO0.m_SVM;
      assertNull(sMOreg0);
      
      boolean boolean2 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean2 == boolean0);
      assertFalse(boolean2 == boolean1);
      assertTrue(boolean2);
      
      regSMO0.m_alpha = regSMO0.m_alphaStar;
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      int int0 = regSMO0.secondChoiceHeuristic(2);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), int0);
      
      double double0 = regSMO0.m_epsilon;
      assertEquals(0.001, double0, 0.01);
      
      regSMO0.setEpsilon(2);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(2.0, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, 1.0E-12, 890.607915541191, 1.0E-12, 2, 2, 1.0E-12, 0.001, 0.001, 1.0E-12, 1155.0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[18];
      regSMO0.m_alphaStar = doubleArray0;
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      regSMO0.m_alpha = doubleArray0;
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      String[] stringArray0 = regSMO0.getOptions();
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(stringArray0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(17, (-4.0), 0.0, (-4.0), 17, 3899.3295438163645, 0.0, 3899.3295438163645, 0.0, 3049.340819295754, (-1813.532575401));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[18];
      SMOreg sMOreg0 = new SMOreg();
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertNotNull(sMOreg0);
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      StringKernel stringKernel0 = new StringKernel();
      assertFalse(stringKernel0.getUseNormalization());
      assertEquals("The maximum subsequence length (theta in the paper)", stringKernel0.maxSubsequenceLengthTipText());
      assertEquals("The size of the cache (a prime number).", stringKernel0.cacheSizeTipText());
      assertFalse(stringKernel0.getDebug());
      assertEquals("The pruning method.", stringKernel0.pruningMethodTipText());
      assertEquals(9, stringKernel0.getMaxSubsequenceLength());
      assertEquals(200003, stringKernel0.getInternalCacheSize());
      assertEquals((-1), stringKernel0.numCacheHits());
      assertEquals(0, stringKernel0.numEvals());
      assertEquals("Turns on the output of debugging information.", stringKernel0.debugTipText());
      assertEquals("Penalizes non-continuous subsequence matches, from (0,1)", stringKernel0.lambdaTipText());
      assertEquals("Whether to use normalization.", stringKernel0.useNormalizationTipText());
      assertEquals("The subsequence length.", stringKernel0.subsequenceLengthTipText());
      assertEquals(250007, stringKernel0.getCacheSize());
      assertEquals("The size of the internal cache (a prime number).", stringKernel0.internalCacheSizeTipText());
      assertEquals("Turns time-consuming checks off - use with caution.", stringKernel0.checksTurnedOffTipText());
      assertEquals(0.5, stringKernel0.getLambda(), 0.01);
      assertEquals(3, stringKernel0.getSubsequenceLength());
      assertFalse(stringKernel0.getChecksTurnedOff());
      assertNotNull(stringKernel0);
      assertEquals(0, StringKernel.PRUNING_NONE);
      assertEquals(1, StringKernel.PRUNING_LAMBDA);
      
      sMOreg0.setKernel(stringKernel0);
      assertEquals("The complexity parameter C.", sMOreg0.cTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sMOreg0.debugTipText());
      assertEquals(1.0, sMOreg0.getC(), 0.01);
      assertEquals("Determines how/if the data will be transformed.", sMOreg0.filterTypeTipText());
      assertFalse(sMOreg0.getDebug());
      assertEquals("The kernel to use.", sMOreg0.kernelTipText());
      assertEquals("The learning algorithm.", sMOreg0.regOptimizerTipText());
      assertFalse(stringKernel0.getUseNormalization());
      assertEquals("The maximum subsequence length (theta in the paper)", stringKernel0.maxSubsequenceLengthTipText());
      assertEquals("The size of the cache (a prime number).", stringKernel0.cacheSizeTipText());
      assertFalse(stringKernel0.getDebug());
      assertEquals("The pruning method.", stringKernel0.pruningMethodTipText());
      assertEquals(9, stringKernel0.getMaxSubsequenceLength());
      assertEquals(200003, stringKernel0.getInternalCacheSize());
      assertEquals((-1), stringKernel0.numCacheHits());
      assertEquals(0, stringKernel0.numEvals());
      assertEquals("Turns on the output of debugging information.", stringKernel0.debugTipText());
      assertEquals("Penalizes non-continuous subsequence matches, from (0,1)", stringKernel0.lambdaTipText());
      assertEquals("Whether to use normalization.", stringKernel0.useNormalizationTipText());
      assertEquals("The subsequence length.", stringKernel0.subsequenceLengthTipText());
      assertEquals(250007, stringKernel0.getCacheSize());
      assertEquals("The size of the internal cache (a prime number).", stringKernel0.internalCacheSizeTipText());
      assertEquals("Turns time-consuming checks off - use with caution.", stringKernel0.checksTurnedOffTipText());
      assertEquals(0.5, stringKernel0.getLambda(), 0.01);
      assertEquals(3, stringKernel0.getSubsequenceLength());
      assertFalse(stringKernel0.getChecksTurnedOff());
      assertEquals(1, SMOreg.FILTER_STANDARDIZE);
      assertEquals(2, SMOreg.FILTER_NONE);
      assertEquals(0, SMOreg.FILTER_NORMALIZE);
      assertEquals(0, StringKernel.PRUNING_NONE);
      assertEquals(1, StringKernel.PRUNING_LAMBDA);
      
      String[] stringArray0 = Locale.getISOLanguages();
      assertNotNull(stringArray0);
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(1, 482.1496492231504, 482.1496492231504, 1.717986918E9, 2, 0, 1, 0.0, (-1057.879126508687), 1, 1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertNotNull(regSMO0);
      
      byte[] byteArray0 = new byte[6];
      boolean boolean0 = FileSystemHandling.createFolder((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      byteArray0[0] = (byte)81;
      boolean boolean1 = FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, true);
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
      
      SMOreg sMOreg0 = regSMO0.m_SVM;
      assertNull(sMOreg0);
      
      boolean boolean2 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean2 == boolean1);
      assertFalse(boolean2 == boolean0);
      assertTrue(boolean2);
      
      regSMO0.setEpsilon((-9.99999999E-4));
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-9.99999999E-4), regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((byte)81, 1.0E-12, 1, 0.5495926938627457, 1, (-966.0), 0, (-9.99999999E-4), (-1959.0), 19.7, (byte)81);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test49()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(regSMO0);
      
      boolean boolean0 = regSMO0.m_bModelBuilt;
      assertFalse(boolean0);
      
      regSMO0.m_C = 890.607915541191;
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      boolean boolean1 = FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
      
      double[] doubleArray0 = new double[4];
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      SMOreg sMOreg0 = regSMO0.m_SVM;
      assertNull(sMOreg0);
      
      boolean boolean2 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean2 == boolean1);
      assertFalse(boolean2 == boolean0);
      assertTrue(boolean2);
      
      regSMO0.m_alpha = regSMO0.m_alphaStar;
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      regSMO0.setEpsilon(2);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(2.0, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, 1.0E-12, 890.607915541191, 1.0E-12, 2, 2, 1.0E-12, 0, 0, 1.0E-12, 1155.0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test50()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertNotNull(regSMO0);
      
      int int0 = 2;
      regSMO0.m_classIndex = 2;
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      double[] doubleArray0 = new double[8];
      double double0 = regSMO0.getScore();
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.0, double0, 0.01);
      
      regSMO0.m_alphaStar = doubleArray0;
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      doubleArray0[0] = (double) 2;
      regSMO0.m_alpha = doubleArray0;
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(3, 2755.837041, 1.0E-12, 3, 3, 1.0E-12, 0.0, 0.0, 0.0, 1.0E-12, (-215.27270669470664));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test51()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[5];
      SMOreg sMOreg0 = regSMO0.m_SVM;
      assertNull(sMOreg0);
      
      RandomSubSpace randomSubSpace0 = new RandomSubSpace();
      assertEquals(1, randomSubSpace0.getSeed());
      assertEquals(10, randomSubSpace0.getNumIterations());
      assertFalse(randomSubSpace0.getDebug());
      assertEquals("Size of each subSpace: if less than 1 as a percentage of the number of attributes, otherwise the absolute number of attributes.", randomSubSpace0.subSpaceSizeTipText());
      assertEquals(1, randomSubSpace0.getNumExecutionSlots());
      assertEquals("The number of iterations to be performed.", randomSubSpace0.numIterationsTipText());
      assertEquals("The base classifier to be used.", randomSubSpace0.classifierTipText());
      assertEquals("The random number seed to be used.", randomSubSpace0.seedTipText());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", randomSubSpace0.numExecutionSlotsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", randomSubSpace0.debugTipText());
      assertEquals(0.5, randomSubSpace0.getSubSpaceSize(), 0.01);
      assertNotNull(randomSubSpace0);
      
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2, 0, 0.0, 0, 2, 2, 0.0, 2, 0.0, 2, 0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test52()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[6];
      regSMO0.m_weights = null;
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      regSMO0.m_sparseWeights = doubleArray0;
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      doubleArray0[0] = (double) (byte)76;
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      regSMO0.m_target = regSMO0.m_alphaStar;
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      try { 
        regSMO0.optimize();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test53()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertNotNull(regSMO0);
      
      regSMO0.m_C = 915.987857834;
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      double[] doubleArray0 = new double[4];
      boolean boolean1 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "");
      assertFalse(boolean1 == boolean0);
      assertFalse(boolean1);
      
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      SMOreg sMOreg0 = regSMO0.m_SVM;
      assertNull(sMOreg0);
      
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      boolean boolean2 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean2 == boolean1);
      assertFalse(boolean2 == boolean0);
      assertFalse(boolean2);
      
      System.setCurrentTimeMillis(1);
      regSMO0.m_alpha = doubleArray0;
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      int int0 = regSMO0.secondChoiceHeuristic(2);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals((-1), int0);
      
      double double0 = regSMO0.getScore();
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.0, double0, 0.01);
      
      regSMO0.setEpsilon(2);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(2.0, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      
      boolean boolean3 = regSMO0.findOptimalPointOnLine(2, 0, 0.0, 0, 2, 2, 0.0, 2, 0.0, 2, 0);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(2.0, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertTrue(boolean3 == boolean2);
      assertTrue(boolean3 == boolean1);
      assertFalse(boolean3 == boolean0);
      assertFalse(boolean3);
      
      try { 
        regSMO0.optimize();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test54()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      byte[] byteArray0 = new byte[6];
      boolean boolean0 = FileSystemHandling.createFolder((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      byteArray0[0] = (byte)81;
      byteArray0[1] = (byte)79;
      byteArray0[2] = (byte) (-26);
      byteArray0[5] = (byte) (-110);
      boolean boolean1 = FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      assertArrayEquals(new byte[] {(byte)81, (byte)79, (byte) (-26), (byte)0, (byte)0, (byte) (-110)}, byteArray0);
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
      
      regSMO0.m_C = (double) (byte)79;
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      double[] doubleArray0 = new double[4];
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      SMOreg sMOreg0 = regSMO0.m_SVM;
      assertNull(sMOreg0);
      
      boolean boolean2 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean2 == boolean0);
      assertFalse(boolean2 == boolean1);
      assertTrue(boolean2);
      
      regSMO0.m_alpha = regSMO0.m_alphaStar;
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      int int0 = regSMO0.secondChoiceHeuristic(2);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), int0);
      
      doubleArray0[0] = (double) (byte)79;
      String string0 = regSMO0.globalInfo();
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(string0);
      assertEquals("Implementation of SMO for support vector regression as described in :\n\nA.J. Smola, B. Schoelkopf (1998). A tutorial on support vector regression.", string0);
      
      regSMO0.setEpsilon(2);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(2.0, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2, 0, 0.0, 0, 2, 2, 79.0, 2, 0.0, 2, 0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }
}
