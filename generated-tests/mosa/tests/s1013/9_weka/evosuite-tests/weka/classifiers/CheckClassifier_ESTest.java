/*
 * This file was automatically generated by EvoSuite
 * Sat Jul 07 04:59:51 GMT 2018
 */

package weka.classifiers;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.Arrays;
import java.util.Enumeration;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;
import weka.classifiers.CheckClassifier;
import weka.classifiers.Classifier;
import weka.classifiers.CostMatrix;
import weka.classifiers.Evaluation;
import weka.classifiers.functions.SimpleLogistic;
import weka.classifiers.rules.ZeroR;
import weka.clusterers.SimpleKMeans;
import weka.core.CheckScheme;
import weka.core.Instances;
import weka.core.TechnicalInformation;
import weka.core.Utils;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class CheckClassifier_ESTest extends CheckClassifier_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      String[] stringArray0 = new String[0];
      CheckClassifier.main(stringArray0);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/home/users/apanichella/wekafiles");
      FileSystemHandling.createFolder(evoSuiteFile0);
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.getRevision();
      ZeroR zeroR0 = (ZeroR)checkClassifier0.getClassifier();
      assertEquals("If set to true, classifier may output additional info to the console.", zeroR0.debugTipText());
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(true, false, true, false, true, false, (-2900));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-2900' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.listOptions();
      checkClassifier0.testsPerClassType(0, false, false, false);
      checkClassifier0.getOptions();
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      boolean boolean0 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(true, false, true, false, false, true, (-1479));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1479' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(true, true, true, true, false, false, 37);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '37' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      boolean[] booleanArray0 = checkClassifier0.updatingEquality(false, false, true, false, false, false, 1);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      
      boolean[] booleanArray1 = checkClassifier0.declaresSerialVersionUID();
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(true, false, false, false, true, false, 48);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '48' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      boolean boolean0 = false;
      checkClassifier0.testToString();
      boolean boolean1 = false;
      int int0 = 1001;
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(false, false, false, false, false, false, 1001, false, false);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '1001' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      boolean boolean0 = false;
      boolean boolean1 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(false, false, false, true, false, false, 24);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '24' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.printAttributeSummary(true, false, true, false, true, true, 1461);
      checkClassifier0.testToString();
      checkClassifier0.getWords();
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(false, true, false, false, true, true, 4);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      CheckClassifier checkClassifier1 = new CheckClassifier();
      checkClassifier1.getWords();
      checkClassifier0.weightedInstancesHandler();
      checkClassifier1.updateableClassifier();
      // Undeclared exception!
      try { 
        checkClassifier1.correctBuildInitialisation(false, true, false, false, true, true, 4);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      ZeroR zeroR0 = (ZeroR)checkClassifier0.getClassifier();
      assertNotNull(zeroR0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals("If set to true, classifier may output additional info to the console.", zeroR0.debugTipText());
      assertEquals("Class for building and using a 0-R classifier. Predicts the mean (for a numeric class) or the mode (for a nominal class).", zeroR0.globalInfo());
      assertFalse(zeroR0.getDebug());
      
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(false, true, true, false, true, true, (-1999));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1999' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      ZeroR zeroR0 = (ZeroR)checkClassifier0.getClassifier();
      assertNotNull(zeroR0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(zeroR0.getDebug());
      assertEquals("If set to true, classifier may output additional info to the console.", zeroR0.debugTipText());
      assertEquals("Class for building and using a 0-R classifier. Predicts the mean (for a numeric class) or the mode (for a nominal class).", zeroR0.globalInfo());
      
      checkClassifier0.setNumDate((-840));
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals((-840), checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(true, false, false, true, false, false, 1840);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Illegal Capacity: -836
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      
      // Undeclared exception!
      try { 
        checkClassifier0.testsPerClassType(0, true, true, true);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      SimpleLogistic simpleLogistic0 = new SimpleLogistic((-455), false, true);
      assertNotNull(simpleLogistic0);
      assertFalse(simpleLogistic0.getUseAIC());
      assertEquals(50, simpleLogistic0.getHeuristicStop());
      assertEquals("The AIC is used to determine when to stop LogitBoost iterations (instead of cross-validation or training error).", simpleLogistic0.useAICTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", simpleLogistic0.debugTipText());
      assertFalse(simpleLogistic0.getUseCrossValidation());
      assertEquals("Set the beta value used for weight trimming in LogitBoost. Only instances carrying (1 - beta)% of the weight from previous iteration are used in the next iteration. Set to 0 for no weight trimming. The default value is 0.", simpleLogistic0.weightTrimBetaTipText());
      assertEquals("Sets the maximum number of iterations for LogitBoost. Default value is 500, for very small/large datasets a lower/higher value might be preferable.", simpleLogistic0.maxBoostingIterationsTipText());
      assertEquals("Sets whether the number of LogitBoost iterations is to be cross-validated or the stopping criterion on the training set should be used. If not set (and no fixed number of iterations was given), the number of LogitBoost iterations is used that minimizes the error on the training set (misclassification error or error on probabilities depending on errorOnProbabilities).", simpleLogistic0.useCrossValidationTipText());
      assertEquals(0.0, simpleLogistic0.getWeightTrimBeta(), 0.01);
      assertEquals((-455), simpleLogistic0.getNumBoostingIterations());
      assertEquals("Use error on the probabilties as error measure when determining the best number of LogitBoost iterations. If set, the number of LogitBoost iterations is chosen that minimizes the root mean squared error (either on the training set or in the cross-validation, depending on useCrossValidation).", simpleLogistic0.errorOnProbabilitiesTipText());
      assertTrue(simpleLogistic0.getErrorOnProbabilities());
      assertEquals("If heuristicStop > 0, the heuristic for greedy stopping while cross-validating the number of LogitBoost iterations is enabled. This means LogitBoost is stopped if no new error minimum has been reached in the last heuristicStop iterations. It is recommended to use this heuristic, it gives a large speed-up especially on small datasets. The default value is 50.", simpleLogistic0.heuristicStopTipText());
      assertEquals(500, simpleLogistic0.getMaxBoostingIterations());
      assertFalse(simpleLogistic0.getDebug());
      assertEquals("Set fixed number of iterations for LogitBoost. If >= 0, this sets the number of LogitBoost iterations to perform. If < 0, the number is cross-validated or a stopping criterion on the training set is used (depending on the value of useCrossValidation).", simpleLogistic0.numBoostingIterationsTipText());
      
      checkClassifier0.m_Classifier = (Classifier) simpleLogistic0;
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(simpleLogistic0.getUseAIC());
      assertEquals(50, simpleLogistic0.getHeuristicStop());
      assertEquals("The AIC is used to determine when to stop LogitBoost iterations (instead of cross-validation or training error).", simpleLogistic0.useAICTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", simpleLogistic0.debugTipText());
      assertFalse(simpleLogistic0.getUseCrossValidation());
      assertEquals("Set the beta value used for weight trimming in LogitBoost. Only instances carrying (1 - beta)% of the weight from previous iteration are used in the next iteration. Set to 0 for no weight trimming. The default value is 0.", simpleLogistic0.weightTrimBetaTipText());
      assertEquals("Sets the maximum number of iterations for LogitBoost. Default value is 500, for very small/large datasets a lower/higher value might be preferable.", simpleLogistic0.maxBoostingIterationsTipText());
      assertEquals("Sets whether the number of LogitBoost iterations is to be cross-validated or the stopping criterion on the training set should be used. If not set (and no fixed number of iterations was given), the number of LogitBoost iterations is used that minimizes the error on the training set (misclassification error or error on probabilities depending on errorOnProbabilities).", simpleLogistic0.useCrossValidationTipText());
      assertEquals(0.0, simpleLogistic0.getWeightTrimBeta(), 0.01);
      assertEquals((-455), simpleLogistic0.getNumBoostingIterations());
      assertEquals("Use error on the probabilties as error measure when determining the best number of LogitBoost iterations. If set, the number of LogitBoost iterations is chosen that minimizes the root mean squared error (either on the training set or in the cross-validation, depending on useCrossValidation).", simpleLogistic0.errorOnProbabilitiesTipText());
      assertTrue(simpleLogistic0.getErrorOnProbabilities());
      assertEquals("If heuristicStop > 0, the heuristic for greedy stopping while cross-validating the number of LogitBoost iterations is enabled. This means LogitBoost is stopped if no new error minimum has been reached in the last heuristicStop iterations. It is recommended to use this heuristic, it gives a large speed-up especially on small datasets. The default value is 50.", simpleLogistic0.heuristicStopTipText());
      assertEquals(500, simpleLogistic0.getMaxBoostingIterations());
      assertFalse(simpleLogistic0.getDebug());
      assertEquals("Set fixed number of iterations for LogitBoost. If >= 0, this sets the number of LogitBoost iterations to perform. If < 0, the number is cross-validated or a stopping criterion on the training set is used (depending on the value of useCrossValidation).", simpleLogistic0.numBoostingIterationsTipText());
      
      boolean[] booleanArray0 = checkClassifier0.testToString();
      assertNotNull(booleanArray0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      String[] stringArray0 = simpleLogistic0.getOptions();
      assertNotNull(stringArray0);
      assertFalse(simpleLogistic0.getUseAIC());
      assertEquals(50, simpleLogistic0.getHeuristicStop());
      assertEquals("The AIC is used to determine when to stop LogitBoost iterations (instead of cross-validation or training error).", simpleLogistic0.useAICTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", simpleLogistic0.debugTipText());
      assertFalse(simpleLogistic0.getUseCrossValidation());
      assertEquals("Set the beta value used for weight trimming in LogitBoost. Only instances carrying (1 - beta)% of the weight from previous iteration are used in the next iteration. Set to 0 for no weight trimming. The default value is 0.", simpleLogistic0.weightTrimBetaTipText());
      assertEquals("Sets the maximum number of iterations for LogitBoost. Default value is 500, for very small/large datasets a lower/higher value might be preferable.", simpleLogistic0.maxBoostingIterationsTipText());
      assertEquals("Sets whether the number of LogitBoost iterations is to be cross-validated or the stopping criterion on the training set should be used. If not set (and no fixed number of iterations was given), the number of LogitBoost iterations is used that minimizes the error on the training set (misclassification error or error on probabilities depending on errorOnProbabilities).", simpleLogistic0.useCrossValidationTipText());
      assertEquals(0.0, simpleLogistic0.getWeightTrimBeta(), 0.01);
      assertEquals((-455), simpleLogistic0.getNumBoostingIterations());
      assertEquals("Use error on the probabilties as error measure when determining the best number of LogitBoost iterations. If set, the number of LogitBoost iterations is chosen that minimizes the root mean squared error (either on the training set or in the cross-validation, depending on useCrossValidation).", simpleLogistic0.errorOnProbabilitiesTipText());
      assertTrue(simpleLogistic0.getErrorOnProbabilities());
      assertEquals("If heuristicStop > 0, the heuristic for greedy stopping while cross-validating the number of LogitBoost iterations is enabled. This means LogitBoost is stopped if no new error minimum has been reached in the last heuristicStop iterations. It is recommended to use this heuristic, it gives a large speed-up especially on small datasets. The default value is 50.", simpleLogistic0.heuristicStopTipText());
      assertEquals(500, simpleLogistic0.getMaxBoostingIterations());
      assertFalse(simpleLogistic0.getDebug());
      assertEquals("Set fixed number of iterations for LogitBoost. If >= 0, this sets the number of LogitBoost iterations to perform. If < 0, the number is cross-validated or a stopping criterion on the training set is used (depending on the value of useCrossValidation).", simpleLogistic0.numBoostingIterationsTipText());
      
      boolean[] booleanArray1 = checkClassifier0.canHandleMissing(false, false, false, false, true, false, 0, false, false, 0);
      assertNotNull(booleanArray1);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      boolean[] booleanArray2 = checkClassifier0.multiInstanceHandler();
      assertNotNull(booleanArray2);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray2));
      assertNotSame(booleanArray2, booleanArray0);
      assertNotSame(booleanArray2, booleanArray1);
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      
      CheckScheme.PostProcessor checkScheme_PostProcessor0 = new CheckScheme.PostProcessor();
      assertNotNull(checkScheme_PostProcessor0);
      
      String string0 = checkScheme_PostProcessor0.getRevision();
      assertNotNull(string0);
      assertEquals("8034", string0);
      
      String string1 = checkScheme_PostProcessor0.getRevision();
      assertNotNull(string1);
      assertEquals("8034", string1);
      assertTrue(string1.equals((Object)string0));
      
      String string2 = checkScheme_PostProcessor0.getRevision();
      assertNotNull(string2);
      assertEquals("8034", string2);
      assertTrue(string2.equals((Object)string1));
      assertTrue(string2.equals((Object)string0));
      
      Utils.SMALL = 3407.66702274849;
      String string3 = checkScheme_PostProcessor0.getRevision();
      assertNotNull(string3);
      assertEquals("8034", string3);
      assertTrue(string3.equals((Object)string2));
      assertTrue(string3.equals((Object)string1));
      assertTrue(string3.equals((Object)string0));
      
      String string4 = checkScheme_PostProcessor0.getRevision();
      assertNotNull(string4);
      assertEquals("8034", string4);
      assertTrue(string4.equals((Object)string0));
      assertTrue(string4.equals((Object)string2));
      assertTrue(string4.equals((Object)string3));
      assertTrue(string4.equals((Object)string1));
      
      String string5 = checkScheme_PostProcessor0.getRevision();
      assertNotNull(string5);
      assertEquals("8034", string5);
      assertTrue(string5.equals((Object)string2));
      assertTrue(string5.equals((Object)string4));
      assertTrue(string5.equals((Object)string1));
      assertTrue(string5.equals((Object)string3));
      assertTrue(string5.equals((Object)string0));
      
      String string6 = checkScheme_PostProcessor0.getRevision();
      assertNotNull(string6);
      assertEquals("8034", string6);
      assertTrue(string6.equals((Object)string1));
      assertTrue(string6.equals((Object)string3));
      assertTrue(string6.equals((Object)string4));
      assertTrue(string6.equals((Object)string2));
      assertTrue(string6.equals((Object)string0));
      assertTrue(string6.equals((Object)string5));
      
      checkClassifier0.setPostProcessor(checkScheme_PostProcessor0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      TechnicalInformation technicalInformation0 = simpleLogistic0.getTechnicalInformation();
      assertNotNull(technicalInformation0);
      assertTrue(technicalInformation0.hasAdditional());
      assertEquals(TechnicalInformation.Type.ARTICLE, technicalInformation0.getType());
      assertFalse(simpleLogistic0.getUseAIC());
      assertEquals(50, simpleLogistic0.getHeuristicStop());
      assertEquals("The AIC is used to determine when to stop LogitBoost iterations (instead of cross-validation or training error).", simpleLogistic0.useAICTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", simpleLogistic0.debugTipText());
      assertFalse(simpleLogistic0.getUseCrossValidation());
      assertEquals("Set the beta value used for weight trimming in LogitBoost. Only instances carrying (1 - beta)% of the weight from previous iteration are used in the next iteration. Set to 0 for no weight trimming. The default value is 0.", simpleLogistic0.weightTrimBetaTipText());
      assertEquals("Sets the maximum number of iterations for LogitBoost. Default value is 500, for very small/large datasets a lower/higher value might be preferable.", simpleLogistic0.maxBoostingIterationsTipText());
      assertEquals("Sets whether the number of LogitBoost iterations is to be cross-validated or the stopping criterion on the training set should be used. If not set (and no fixed number of iterations was given), the number of LogitBoost iterations is used that minimizes the error on the training set (misclassification error or error on probabilities depending on errorOnProbabilities).", simpleLogistic0.useCrossValidationTipText());
      assertEquals(0.0, simpleLogistic0.getWeightTrimBeta(), 0.01);
      assertEquals((-455), simpleLogistic0.getNumBoostingIterations());
      assertEquals("Use error on the probabilties as error measure when determining the best number of LogitBoost iterations. If set, the number of LogitBoost iterations is chosen that minimizes the root mean squared error (either on the training set or in the cross-validation, depending on useCrossValidation).", simpleLogistic0.errorOnProbabilitiesTipText());
      assertTrue(simpleLogistic0.getErrorOnProbabilities());
      assertEquals("If heuristicStop > 0, the heuristic for greedy stopping while cross-validating the number of LogitBoost iterations is enabled. This means LogitBoost is stopped if no new error minimum has been reached in the last heuristicStop iterations. It is recommended to use this heuristic, it gives a large speed-up especially on small datasets. The default value is 50.", simpleLogistic0.heuristicStopTipText());
      assertEquals(500, simpleLogistic0.getMaxBoostingIterations());
      assertFalse(simpleLogistic0.getDebug());
      assertEquals("Set fixed number of iterations for LogitBoost. If >= 0, this sets the number of LogitBoost iterations to perform. If < 0, the number is cross-validated or a stopping criterion on the training set is used (depending on the value of useCrossValidation).", simpleLogistic0.numBoostingIterationsTipText());
      
      // Undeclared exception!
      try { 
        checkClassifier0.testsPerClassType(0, true, true, true);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      Enumeration enumeration0 = checkClassifier0.listOptions();
      assertNotNull(enumeration0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      boolean[] booleanArray0 = checkClassifier0.declaresSerialVersionUID();
      assertNotNull(booleanArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      boolean boolean0 = true;
      int int0 = 42;
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleMissing(true, true, false, true, false, true, 706, true, true, 42);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '706' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      Enumeration enumeration0 = checkClassifier0.listOptions();
      assertNotNull(enumeration0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      String[] stringArray0 = checkClassifier0.getOptions();
      assertNotNull(stringArray0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(true, false, false, true, true, true, 1458, true, true);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '1458' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      String[] stringArray0 = checkClassifier0.getOptions();
      assertNotNull(stringArray0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(false, true, false, true, true, false, (-797));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-797' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      
      boolean[] booleanArray0 = checkClassifier0.testToString();
      assertNotNull(booleanArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      String string0 = checkClassifier0.getWords();
      assertNotNull(string0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals("The,quick,brown,fox,jumps,over,the,lazy,dog", string0);
      
      int int0 = 4;
      boolean[] booleanArray1 = checkClassifier0.weightedInstancesHandler();
      assertNotNull(booleanArray1);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      boolean[] booleanArray2 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray2);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray2));
      assertNotSame(booleanArray2, booleanArray0);
      assertNotSame(booleanArray2, booleanArray1);
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      
      boolean boolean0 = false;
      boolean boolean1 = false;
      boolean boolean2 = false;
      boolean[] booleanArray3 = checkClassifier0.correctBuildInitialisation(false, false, true, false, false, false, 4);
      assertNotNull(booleanArray3);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray3));
      assertNotSame(booleanArray3, booleanArray1);
      assertNotSame(booleanArray3, booleanArray0);
      assertNotSame(booleanArray3, booleanArray2);
      assertFalse(booleanArray3.equals((Object)booleanArray1));
      assertFalse(booleanArray3.equals((Object)booleanArray0));
      assertFalse(booleanArray3.equals((Object)booleanArray2));
      
      String[] stringArray0 = checkClassifier0.getOptions();
      assertNotNull(stringArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      
      boolean boolean3 = false;
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleOnlyClass(false, false, false, false, false, 20);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '20' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      checkClassifier0.printAttributeSummary(true, false, true, false, true, true, 1461);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      boolean[] booleanArray0 = checkClassifier0.testToString();
      assertNotNull(booleanArray0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      String string0 = checkClassifier0.getWords();
      assertNotNull(string0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals("The,quick,brown,fox,jumps,over,the,lazy,dog", string0);
      
      boolean[] booleanArray1 = checkClassifier0.weightedInstancesHandler();
      assertNotNull(booleanArray1);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      boolean[] booleanArray2 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray2);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray2));
      assertNotSame(booleanArray2, booleanArray1);
      assertNotSame(booleanArray2, booleanArray0);
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      
      boolean[] booleanArray3 = checkClassifier0.datasetIntegrity(false, true, true, true, false, false, 4, false, true);
      assertNotNull(booleanArray3);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray3));
      assertNotSame(booleanArray3, booleanArray1);
      assertNotSame(booleanArray3, booleanArray0);
      assertNotSame(booleanArray3, booleanArray2);
      assertFalse(booleanArray3.equals((Object)booleanArray1));
      assertFalse(booleanArray3.equals((Object)booleanArray0));
      assertFalse(booleanArray3.equals((Object)booleanArray2));
      
      boolean[] booleanArray4 = checkClassifier0.correctBuildInitialisation(false, false, false, true, true, false, 4);
      assertNotNull(booleanArray4);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray4));
      assertNotSame(booleanArray4, booleanArray2);
      assertNotSame(booleanArray4, booleanArray3);
      assertNotSame(booleanArray4, booleanArray1);
      assertNotSame(booleanArray4, booleanArray0);
      assertFalse(booleanArray4.equals((Object)booleanArray2));
      assertFalse(booleanArray4.equals((Object)booleanArray3));
      assertFalse(booleanArray4.equals((Object)booleanArray1));
      assertFalse(booleanArray4.equals((Object)booleanArray0));
      
      boolean[] booleanArray5 = checkClassifier0.correctBuildInitialisation(false, false, true, false, false, false, 4);
      assertNotNull(booleanArray5);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray5));
      assertNotSame(booleanArray5, booleanArray2);
      assertNotSame(booleanArray5, booleanArray4);
      assertNotSame(booleanArray5, booleanArray0);
      assertNotSame(booleanArray5, booleanArray1);
      assertNotSame(booleanArray5, booleanArray3);
      assertFalse(booleanArray5.equals((Object)booleanArray2));
      assertFalse(booleanArray5.equals((Object)booleanArray4));
      assertFalse(booleanArray5.equals((Object)booleanArray0));
      assertFalse(booleanArray5.equals((Object)booleanArray1));
      assertFalse(booleanArray5.equals((Object)booleanArray3));
      
      String[] stringArray0 = checkClassifier0.getOptions();
      assertNotNull(stringArray0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.printAttributeSummary(true, false, true, false, true, true, 1461);
      checkClassifier0.testToString();
      checkClassifier0.getWords();
      checkClassifier0.weightedInstancesHandler();
      checkClassifier0.updateableClassifier();
      checkClassifier0.datasetIntegrity(false, true, true, true, false, false, 4, false, true);
      String[] stringArray0 = new String[1];
      stringArray0[0] = "The,quick,brown,fox,jumps,over,the,lazy,dog";
      CheckClassifier.main(stringArray0);
      checkClassifier0.getOptions();
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      SimpleLogistic simpleLogistic0 = new SimpleLogistic((-455), false, true);
      FileSystemHandling.shouldAllThrowIOExceptions();
      checkClassifier0.m_Classifier = (Classifier) simpleLogistic0;
      checkClassifier0.testToString();
      String[] stringArray0 = simpleLogistic0.getOptions();
      CheckClassifier.main(stringArray0);
      checkClassifier0.getOptions();
      SimpleKMeans simpleKMeans0 = new SimpleKMeans();
      simpleKMeans0.getClusterCentroids();
      Instances instances0 = null;
      try {
        instances0 = new Instances((Instances) null, (-733));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.core.Instances", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      FileSystemHandling.shouldAllThrowIOExceptions();
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.listOptions();
      checkClassifier0.testToString();
      checkClassifier0.getWords();
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(false, true, true, true, false, false, 4);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: weka.classifiers.rules.ZeroR: Cannot handle relational class!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      CheckClassifier checkClassifier1 = new CheckClassifier();
      checkClassifier0.getWords();
      boolean boolean0 = false;
      boolean boolean1 = true;
      boolean boolean2 = true;
      // Undeclared exception!
      try { 
        checkClassifier1.doesntUseTestClassVal(false, false, false, true, true, false, 4);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: weka.classifiers.rules.ZeroR: Cannot handle relational class!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.listOptions();
      CheckClassifier checkClassifier1 = new CheckClassifier();
      checkClassifier1.printAttributeSummary(false, false, false, false, false, false, 0);
      checkClassifier0.testToString();
      checkClassifier1.getWords();
      // Undeclared exception!
      try { 
        checkClassifier1.doesntUseTestClassVal(false, true, false, false, false, false, 2);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: weka.classifiers.rules.ZeroR: Cannot handle string class!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(false, true, false, false, true, true, 1);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.listOptions();
      checkClassifier0.updatingEquality(true, false, false, true, true, false, 1);
      checkClassifier0.declaresSerialVersionUID();
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.updatingEquality(false, true, true, false, true, true, 1);
      checkClassifier0.getOptions();
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      CheckClassifier checkClassifier1 = new CheckClassifier();
      checkClassifier1.updatingEquality(true, true, false, false, false, false, 1);
      checkClassifier1.declaresSerialVersionUID();
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.listOptions();
      checkClassifier0.canHandleZeroTraining(false, false, false, false, true, false, 3);
      // Undeclared exception!
      try { 
        checkClassifier0.testsPerClassType(0, false, false, false);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Problem determining ZeroR performance: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }
}
