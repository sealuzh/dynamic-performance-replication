/*
 * This file was automatically generated by EvoSuite
 * Fri Jul 06 16:53:56 GMT 2018
 */

package weka.classifiers.bayes.net.search.ci;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Properties;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.mock.java.util.MockRandom;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.util.SystemInUtil;
import org.junit.runner.RunWith;
import weka.attributeSelection.WrapperSubsetEval;
import weka.classifiers.CostMatrix;
import weka.classifiers.bayes.BayesNet;
import weka.classifiers.bayes.net.search.ci.ICSSearchAlgorithm;
import weka.classifiers.functions.SGD;
import weka.classifiers.meta.MultiClassClassifier;
import weka.classifiers.misc.InputMappedClassifier;
import weka.core.AbstractInstance;
import weka.core.Attribute;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.NormalizableDistance;
import weka.core.ProtectedProperties;
import weka.core.SelectedTag;
import weka.core.SparseInstance;
import weka.core.tokenizers.AlphabeticTokenizer;
import weka.core.tokenizers.NGramTokenizer;
import weka.core.tokenizers.WordTokenizer;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class ICSSearchAlgorithm_ESTest extends ICSSearchAlgorithm_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      String string0 = iCSSearchAlgorithm0.globalInfo();
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", string0);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      ICSSearchAlgorithm.main((String[]) null);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      ICSSearchAlgorithm.SeparationSet iCSSearchAlgorithm_SeparationSet0 = iCSSearchAlgorithm0.new SeparationSet();
      boolean boolean0 = iCSSearchAlgorithm_SeparationSet0.contains(1819);
      assertFalse(boolean0);
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      LinkedList<String> linkedList0 = new LinkedList<String>();
      FileSystemHandling.shouldAllThrowIOExceptions();
      AlphabeticTokenizer alphabeticTokenizer0 = new AlphabeticTokenizer();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      String string0 = CostMatrix.FILE_EXTENSION;
      int int0 = NormalizableDistance.R_WIDTH;
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      Properties properties0 = new Properties();
      ProtectedProperties protectedProperties0 = new ProtectedProperties(properties0);
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      iCSSearchAlgorithm0.listOptions();
      String[] stringArray0 = iCSSearchAlgorithm0.getOptions();
      iCSSearchAlgorithm0.setOptions(stringArray0);
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      ICSSearchAlgorithm iCSSearchAlgorithm1 = new ICSSearchAlgorithm();
      ICSSearchAlgorithm.SeparationSet iCSSearchAlgorithm_SeparationSet0 = iCSSearchAlgorithm1.new SeparationSet();
      ICSSearchAlgorithm iCSSearchAlgorithm2 = new ICSSearchAlgorithm();
      boolean[][] booleanArray0 = new boolean[7][8];
      booleanArray0[1] = booleanArray0[0];
      String[] stringArray0 = new String[5];
      iCSSearchAlgorithm_SeparationSet0.contains(0);
      try { 
        iCSSearchAlgorithm1.setOptions(stringArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.core.Utils", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      Instances instances0 = new Instances("Ii4mC3", arrayList0, 2218);
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      iCSSearchAlgorithm0.search((BayesNet) null, instances0);
      boolean[][] booleanArray0 = new boolean[4][0];
      iCSSearchAlgorithm0.setOptions((String[]) null);
      boolean[] booleanArray1 = new boolean[6];
      iCSSearchAlgorithm0.existsSepSet(2, 2218, 2, booleanArray0);
      Random.setNextRandom(2);
      String string0 = iCSSearchAlgorithm0.getRevision();
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("8034", string0);
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      Instances instances0 = new Instances(" not supportd (LMT)", arrayList0, 2231);
      iCSSearchAlgorithm0.search((BayesNet) null, instances0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      boolean[] booleanArray0 = new boolean[14];
      booleanArray0[0] = true;
      SystemInUtil.addInputLine("@data");
      booleanArray0[12] = true;
      Attribute attribute0 = new Attribute(" not supportd (LMT)", instances0);
      attribute0.getRevision();
      NGramTokenizer nGramTokenizer0 = new NGramTokenizer();
      arrayList0.add(attribute0);
      attribute0.value(0);
      iCSSearchAlgorithm0.getRevision();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      int int0 = WrapperSubsetEval.EVAL_AUC;
      FileSystemHandling fileSystemHandling1 = new FileSystemHandling();
      attribute0.copy();
      Attribute.typeToString(attribute0);
      arrayList0.add(attribute0);
      iCSSearchAlgorithm0.listOptions();
      Locale.getISOLanguages();
      boolean[][] booleanArray1 = new boolean[0][0];
      // Undeclared exception!
      try { 
        iCSSearchAlgorithm0.calcVeeNodes(booleanArray1, booleanArray1, (ICSSearchAlgorithm.SeparationSet[][]) null);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 0
         //
         verifyException("weka.classifiers.bayes.net.search.ci.ICSSearchAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      assertNotNull(iCSSearchAlgorithm0);
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      
      Instances instances0 = new Instances("S?;:B;O$", arrayList0, 15000);
      assertNotNull(instances0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("S?;:B;O$", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      
      iCSSearchAlgorithm0.search((BayesNet) null, instances0);
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("S?;:B;O$", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      boolean[] booleanArray0 = new boolean[17];
      booleanArray0[0] = true;
      booleanArray0[0] = true;
      booleanArray0[3] = true;
      String string0 = iCSSearchAlgorithm0.getRevision();
      assertNotNull(string0);
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("8034", string0);
      
      booleanArray0[11] = false;
      Attribute attribute0 = new Attribute("ss");
      assertNotNull(attribute0);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(1, attribute0.ordering());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertTrue(attribute0.isAveragable());
      assertTrue(attribute0.isRegular());
      assertTrue(attribute0.hasZeropoint());
      assertEquals("", attribute0.getDateFormat());
      assertEquals(0, attribute0.numValues());
      assertEquals((-1), attribute0.index());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isString());
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertFalse(attribute0.isNominal());
      assertEquals(0, attribute0.type());
      assertTrue(attribute0.isNumeric());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      boolean boolean1 = arrayList0.add(attribute0);
      assertTrue(boolean1 == boolean0);
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(1, attribute0.ordering());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertTrue(attribute0.isAveragable());
      assertTrue(attribute0.isRegular());
      assertTrue(attribute0.hasZeropoint());
      assertEquals("", attribute0.getDateFormat());
      assertEquals(0, attribute0.numValues());
      assertEquals((-1), attribute0.index());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isString());
      assertEquals(Double.NEGATIVE_INFINITY, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(Double.POSITIVE_INFINITY, attribute0.getUpperNumericBound(), 0.01);
      assertFalse(attribute0.isNominal());
      assertEquals(0, attribute0.type());
      assertTrue(attribute0.isNumeric());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertTrue(boolean1);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      
      boolean[][] booleanArray1 = new boolean[6][6];
      String string1 = iCSSearchAlgorithm0.maxNrOfParentsTipText();
      assertNotNull(string1);
      assertFalse(string1.equals((Object)string0));
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", string1);
      
      ICSSearchAlgorithm.SeparationSet[][] iCSSearchAlgorithm_SeparationSetArray0 = new ICSSearchAlgorithm.SeparationSet[1][2];
      iCSSearchAlgorithm0.calcVeeNodes(booleanArray1, booleanArray1, iCSSearchAlgorithm_SeparationSetArray0);
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      
      Instances instances0 = new Instances("Ty.i4mC3", arrayList0, 2282);
      assertNotNull(instances0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals("Ty.i4mC3", instances0.relationName());
      
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      assertNotNull(inputMappedClassifier0);
      assertFalse(inputMappedClassifier0.getDebug());
      assertEquals("Set the path from which to load a model. Loading occurs when the first test instance is received. Environment variables can be used in the supplied path.", inputMappedClassifier0.modelPathTipText());
      assertFalse(inputMappedClassifier0.getSuppressMappingReport());
      assertEquals("", inputMappedClassifier0.getModelPath());
      assertTrue(inputMappedClassifier0.getTrim());
      assertEquals("Ignore case when matching attribute names and nomina values.", inputMappedClassifier0.ignoreCaseForNamesTipText());
      assertEquals("Don't output a report of model-to-input mappings.", inputMappedClassifier0.suppressMappingReportTipText());
      assertEquals("The base classifier to be used.", inputMappedClassifier0.classifierTipText());
      assertTrue(inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals("If set to true, classifier may output additional info to the console.", inputMappedClassifier0.debugTipText());
      assertEquals("Wrapper classifier that addresses incompatible training and test data by building a mapping between the training data that a classifier has been built with and the incoming test instances' structure. Model attributes that are not found in the incoming instances receive missing values, so do incoming nominal attribute values that the classifier has not seen before. A new classifier can be trained or an existing one loaded from a file.", inputMappedClassifier0.globalInfo());
      assertEquals(0, inputMappedClassifier0.graphType());
      assertEquals("Trim white space from each end of attribute names and nominal values before matching.", inputMappedClassifier0.trimTipText());
      
      LinkedList<String> linkedList0 = new LinkedList<String>();
      assertNotNull(linkedList0);
      assertEquals(0, linkedList0.size());
      
      Attribute attribute0 = new Attribute(".bsi", linkedList0, 2282);
      assertNotNull(attribute0);
      assertEquals(0, linkedList0.size());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(2282, attribute0.index());
      assertFalse(attribute0.isString());
      assertEquals(1, attribute0.type());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertTrue(attribute0.isNominal());
      assertFalse(attribute0.isRegular());
      assertFalse(attribute0.isAveragable());
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.hasZeropoint());
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isNumeric());
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0, attribute0.ordering());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      
      Attribute attribute1 = new Attribute("relational", instances0, 75);
      assertNotNull(attribute1);
      assertFalse(attribute1.equals((Object)attribute0));
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals("Ty.i4mC3", instances0.relationName());
      assertEquals(0, attribute1.ordering());
      assertEquals(75, attribute1.index());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertFalse(attribute1.isNumeric());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertEquals(4, attribute1.type());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.isNominal());
      assertFalse(attribute1.isAveragable());
      assertEquals(0, attribute1.numValues());
      assertTrue(attribute1.isRelationValued());
      assertEquals(0.0, attribute1.getLowerNumericBound(), 0.01);
      assertEquals(0.0, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.isRegular());
      assertEquals("", attribute1.getDateFormat());
      assertFalse(attribute1.hasZeropoint());
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(3, Attribute.DATE);
      
      String string0 = Attribute.typeToString(attribute0);
      assertNotNull(string0);
      assertFalse(attribute0.equals((Object)attribute1));
      assertEquals(0, linkedList0.size());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(2282, attribute0.index());
      assertFalse(attribute0.isString());
      assertEquals(1, attribute0.type());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertTrue(attribute0.isNominal());
      assertFalse(attribute0.isRegular());
      assertFalse(attribute0.isAveragable());
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.hasZeropoint());
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isNumeric());
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0, attribute0.ordering());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("nominal", string0);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertNotSame(attribute0, attribute1);
      
      boolean boolean0 = arrayList0.add(attribute0);
      assertFalse(attribute0.equals((Object)attribute1));
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(0, linkedList0.size());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(2282, attribute0.index());
      assertFalse(attribute0.isString());
      assertEquals(1, attribute0.type());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertTrue(attribute0.isNominal());
      assertFalse(attribute0.isRegular());
      assertFalse(attribute0.isAveragable());
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.hasZeropoint());
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isNumeric());
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0, attribute0.ordering());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(boolean0);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertNotSame(attribute0, attribute1);
      
      String string1 = instances0.toSummaryString();
      assertNotNull(string1);
      assertFalse(string1.equals((Object)string0));
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals("Ty.i4mC3", instances0.relationName());
      assertEquals("Relation Name:  Ty.i4mC3\nNum Instances:  0\nNum Attributes: 1\n\n     Name                      Type  Nom  Int Real     Missing      Unique  Dist\n   1 .bsi                       Nom   0%   0%   0%     0 /  0%     0 /  0%     0 \n", string1);
      
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      assertNotNull(iCSSearchAlgorithm0);
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      
      iCSSearchAlgorithm0.setMaxCardinality(0);
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals(0, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      
      try { 
        iCSSearchAlgorithm0.search((BayesNet) null, instances0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.bayes.net.search.ci.ICSSearchAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      
      Instances instances0 = new Instances("Ty.i4mC3", arrayList0, 2274);
      assertNotNull(instances0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("Ty.i4mC3", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numAttributes());
      assertEquals((-1), instances0.classIndex());
      
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      assertNotNull(inputMappedClassifier0);
      assertFalse(inputMappedClassifier0.getSuppressMappingReport());
      assertEquals("", inputMappedClassifier0.getModelPath());
      assertEquals("Don't output a report of model-to-input mappings.", inputMappedClassifier0.suppressMappingReportTipText());
      assertEquals("Set the path from which to load a model. Loading occurs when the first test instance is received. Environment variables can be used in the supplied path.", inputMappedClassifier0.modelPathTipText());
      assertTrue(inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals("Ignore case when matching attribute names and nomina values.", inputMappedClassifier0.ignoreCaseForNamesTipText());
      assertFalse(inputMappedClassifier0.getDebug());
      assertEquals("The base classifier to be used.", inputMappedClassifier0.classifierTipText());
      assertEquals("Trim white space from each end of attribute names and nominal values before matching.", inputMappedClassifier0.trimTipText());
      assertEquals("Wrapper classifier that addresses incompatible training and test data by building a mapping between the training data that a classifier has been built with and the incoming test instances' structure. Model attributes that are not found in the incoming instances receive missing values, so do incoming nominal attribute values that the classifier has not seen before. A new classifier can be trained or an existing one loaded from a file.", inputMappedClassifier0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", inputMappedClassifier0.debugTipText());
      assertTrue(inputMappedClassifier0.getTrim());
      assertEquals(0, inputMappedClassifier0.graphType());
      
      LinkedList<String> linkedList0 = new LinkedList<String>();
      assertNotNull(linkedList0);
      assertEquals(0, linkedList0.size());
      
      Attribute attribute0 = new Attribute(".bsi", linkedList0, 2274);
      assertNotNull(attribute0);
      assertEquals(0, linkedList0.size());
      assertFalse(attribute0.isNumeric());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertFalse(attribute0.isAveragable());
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.hasZeropoint());
      assertEquals(2274, attribute0.index());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isString());
      assertEquals(1, attribute0.type());
      assertFalse(attribute0.isRelationValued());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.isRegular());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isNominal());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      
      Attribute attribute1 = new Attribute("relational", instances0, 75);
      assertNotNull(attribute1);
      assertFalse(attribute1.equals((Object)attribute0));
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("Ty.i4mC3", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numAttributes());
      assertEquals((-1), instances0.classIndex());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertFalse(attribute1.isString());
      assertEquals(4, attribute1.type());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.hasZeropoint());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertFalse(attribute1.isAveragable());
      assertEquals(75, attribute1.index());
      assertTrue(attribute1.isRelationValued());
      assertEquals(0, attribute1.numValues());
      assertFalse(attribute1.isRegular());
      assertEquals("", attribute1.getDateFormat());
      assertFalse(attribute1.isNumeric());
      assertFalse(attribute1.isNominal());
      assertEquals(0.0, attribute1.getUpperNumericBound(), 0.01);
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertEquals(0.0, attribute1.getLowerNumericBound(), 0.01);
      assertEquals(0, attribute1.ordering());
      assertEquals(3, Attribute.DATE);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      
      String string0 = Attribute.typeToString(attribute0);
      assertNotNull(string0);
      assertFalse(attribute0.equals((Object)attribute1));
      assertEquals(0, linkedList0.size());
      assertFalse(attribute0.isNumeric());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertFalse(attribute0.isAveragable());
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.hasZeropoint());
      assertEquals(2274, attribute0.index());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isString());
      assertEquals(1, attribute0.type());
      assertFalse(attribute0.isRelationValued());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.isRegular());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isNominal());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals("nominal", string0);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertNotSame(attribute0, attribute1);
      
      boolean boolean0 = arrayList0.add(attribute0);
      assertFalse(attribute0.equals((Object)attribute1));
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(0, linkedList0.size());
      assertFalse(attribute0.isNumeric());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertFalse(attribute0.isAveragable());
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.hasZeropoint());
      assertEquals(2274, attribute0.index());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isString());
      assertEquals(1, attribute0.type());
      assertFalse(attribute0.isRelationValued());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.isRegular());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isNominal());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertTrue(boolean0);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertNotSame(attribute0, attribute1);
      
      boolean boolean1 = arrayList0.add(attribute1);
      assertFalse(attribute1.equals((Object)attribute0));
      assertTrue(boolean1 == boolean0);
      assertEquals(2, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals("Ty.i4mC3", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals((-1), instances0.classIndex());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertFalse(attribute1.isString());
      assertEquals(4, attribute1.type());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.hasZeropoint());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertFalse(attribute1.isAveragable());
      assertEquals(75, attribute1.index());
      assertTrue(attribute1.isRelationValued());
      assertEquals(0, attribute1.numValues());
      assertFalse(attribute1.isRegular());
      assertEquals("", attribute1.getDateFormat());
      assertFalse(attribute1.isNumeric());
      assertFalse(attribute1.isNominal());
      assertEquals(0.0, attribute1.getUpperNumericBound(), 0.01);
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertEquals(0.0, attribute1.getLowerNumericBound(), 0.01);
      assertEquals(0, attribute1.ordering());
      assertTrue(boolean1);
      assertEquals(3, Attribute.DATE);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertNotSame(attribute1, attribute0);
      
      String string1 = inputMappedClassifier0.getRevision();
      assertNotNull(string1);
      assertFalse(string1.equals((Object)string0));
      assertFalse(inputMappedClassifier0.getSuppressMappingReport());
      assertEquals("", inputMappedClassifier0.getModelPath());
      assertEquals("Don't output a report of model-to-input mappings.", inputMappedClassifier0.suppressMappingReportTipText());
      assertEquals("Set the path from which to load a model. Loading occurs when the first test instance is received. Environment variables can be used in the supplied path.", inputMappedClassifier0.modelPathTipText());
      assertTrue(inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals("Ignore case when matching attribute names and nomina values.", inputMappedClassifier0.ignoreCaseForNamesTipText());
      assertFalse(inputMappedClassifier0.getDebug());
      assertEquals("The base classifier to be used.", inputMappedClassifier0.classifierTipText());
      assertEquals("Trim white space from each end of attribute names and nominal values before matching.", inputMappedClassifier0.trimTipText());
      assertEquals("Wrapper classifier that addresses incompatible training and test data by building a mapping between the training data that a classifier has been built with and the incoming test instances' structure. Model attributes that are not found in the incoming instances receive missing values, so do incoming nominal attribute values that the classifier has not seen before. A new classifier can be trained or an existing one loaded from a file.", inputMappedClassifier0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", inputMappedClassifier0.debugTipText());
      assertTrue(inputMappedClassifier0.getTrim());
      assertEquals(0, inputMappedClassifier0.graphType());
      assertEquals("8034", string1);
      
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      assertNotNull(iCSSearchAlgorithm0);
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      
      try { 
        iCSSearchAlgorithm0.search((BayesNet) null, instances0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.bayes.net.search.ci.CISearchAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      assertNotNull(iCSSearchAlgorithm0);
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      
      boolean boolean0 = FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      assertFalse(boolean0);
      
      ICSSearchAlgorithm.SeparationSet iCSSearchAlgorithm_SeparationSet0 = iCSSearchAlgorithm0.new SeparationSet();
      assertNotNull(iCSSearchAlgorithm_SeparationSet0);
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      
      int[] intArray0 = new int[2];
      BayesNet bayesNet0 = new BayesNet();
      assertNotNull(bayesNet0);
      assertEquals("Set the name of a file in BIF XML format. A Bayes network learned from data can be compared with the Bayes network represented by the BIF file. Statistics calculated are o.a. the number of missing and extra arcs.", bayesNet0.BIFFileTipText());
      assertEquals("Select Estimator algorithm for finding the conditional probability tables of the Bayes Network.", bayesNet0.estimatorTipText());
      assertEquals(2, bayesNet0.graphType());
      assertFalse(bayesNet0.getDebug());
      assertEquals("Select method used for searching network structures.", bayesNet0.searchAlgorithmTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", bayesNet0.debugTipText());
      assertEquals("When ADTree (the data structure for increasing speed on counts, not to be confused with the classifier under the same name) is used learning time goes down typically. However, because ADTrees are memory intensive, memory problems may occur. Switching this option off makes the structure learning algorithms slower, and run with less memory. By default, ADTrees are used.", bayesNet0.useADTreeTipText());
      assertFalse(bayesNet0.getUseADTree());
      assertEquals("Bayes Network learning using various search algorithms and quality measures.\nBase class for a Bayes Network classifier. Provides datastructures (network structure, conditional probability distributions, etc.) and facilities common to Bayes Network learning algorithms like K2 and B.\n\nFor more information see:\n\nhttp://www.cs.waikato.ac.nz/~remco/weka.pdf", bayesNet0.globalInfo());
      
      iCSSearchAlgorithm0.m_BayesNet = bayesNet0;
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("Set the name of a file in BIF XML format. A Bayes network learned from data can be compared with the Bayes network represented by the BIF file. Statistics calculated are o.a. the number of missing and extra arcs.", bayesNet0.BIFFileTipText());
      assertEquals("Select Estimator algorithm for finding the conditional probability tables of the Bayes Network.", bayesNet0.estimatorTipText());
      assertEquals(2, bayesNet0.graphType());
      assertFalse(bayesNet0.getDebug());
      assertEquals("Select method used for searching network structures.", bayesNet0.searchAlgorithmTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", bayesNet0.debugTipText());
      assertEquals("When ADTree (the data structure for increasing speed on counts, not to be confused with the classifier under the same name) is used learning time goes down typically. However, because ADTrees are memory intensive, memory problems may occur. Switching this option off makes the structure learning algorithms slower, and run with less memory. By default, ADTrees are used.", bayesNet0.useADTreeTipText());
      assertFalse(bayesNet0.getUseADTree());
      assertEquals("Bayes Network learning using various search algorithms and quality measures.\nBase class for a Bayes Network classifier. Provides datastructures (network structure, conditional probability distributions, etc.) and facilities common to Bayes Network learning algorithms like K2 and B.\n\nFor more information see:\n\nhttp://www.cs.waikato.ac.nz/~remco/weka.pdf", bayesNet0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", iCSSearchAlgorithm0.m_BayesNet.debugTipText());
      assertEquals("Set the name of a file in BIF XML format. A Bayes network learned from data can be compared with the Bayes network represented by the BIF file. Statistics calculated are o.a. the number of missing and extra arcs.", iCSSearchAlgorithm0.m_BayesNet.BIFFileTipText());
      assertEquals("Select method used for searching network structures.", iCSSearchAlgorithm0.m_BayesNet.searchAlgorithmTipText());
      assertEquals("Bayes Network learning using various search algorithms and quality measures.\nBase class for a Bayes Network classifier. Provides datastructures (network structure, conditional probability distributions, etc.) and facilities common to Bayes Network learning algorithms like K2 and B.\n\nFor more information see:\n\nhttp://www.cs.waikato.ac.nz/~remco/weka.pdf", iCSSearchAlgorithm0.m_BayesNet.globalInfo());
      assertEquals("Select Estimator algorithm for finding the conditional probability tables of the Bayes Network.", iCSSearchAlgorithm0.m_BayesNet.estimatorTipText());
      assertFalse(iCSSearchAlgorithm0.m_BayesNet.getDebug());
      assertEquals(2, iCSSearchAlgorithm0.m_BayesNet.graphType());
      assertEquals("When ADTree (the data structure for increasing speed on counts, not to be confused with the classifier under the same name) is used learning time goes down typically. However, because ADTrees are memory intensive, memory problems may occur. Switching this option off makes the structure learning algorithms slower, and run with less memory. By default, ADTrees are used.", iCSSearchAlgorithm0.m_BayesNet.useADTreeTipText());
      assertFalse(iCSSearchAlgorithm0.m_BayesNet.getUseADTree());
      
      int int0 = (-1);
      intArray0[0] = (-1);
      iCSSearchAlgorithm_SeparationSet0.m_set = intArray0;
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      
      String string0 = iCSSearchAlgorithm_SeparationSet0.getRevision();
      assertNotNull(string0);
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("8034", string0);
      
      boolean boolean1 = iCSSearchAlgorithm_SeparationSet0.contains((-1));
      assertTrue(boolean1 == boolean0);
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertFalse(boolean1);
      
      String[] stringArray0 = iCSSearchAlgorithm0.getOptions();
      assertNotNull(stringArray0);
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      
      ICSSearchAlgorithm iCSSearchAlgorithm1 = new ICSSearchAlgorithm();
      assertNotNull(iCSSearchAlgorithm1);
      assertFalse(iCSSearchAlgorithm1.equals((Object)iCSSearchAlgorithm0));
      assertFalse(iCSSearchAlgorithm1.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm1.initAsNaiveBayesTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm1.scoreTypeTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm1.toString());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm1.maxCardinalityTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm1.maxNrOfParentsTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm1.markovBlanketClassifierTipText());
      assertEquals(2, iCSSearchAlgorithm1.getMaxCardinality());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm1.globalInfo());
      
      ICSSearchAlgorithm iCSSearchAlgorithm2 = new ICSSearchAlgorithm();
      assertNotNull(iCSSearchAlgorithm2);
      assertFalse(iCSSearchAlgorithm2.equals((Object)iCSSearchAlgorithm0));
      assertFalse(iCSSearchAlgorithm2.equals((Object)iCSSearchAlgorithm1));
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm2.scoreTypeTipText());
      assertFalse(iCSSearchAlgorithm2.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm2.initAsNaiveBayesTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm2.globalInfo());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm2.maxNrOfParentsTipText());
      assertEquals(2, iCSSearchAlgorithm2.getMaxCardinality());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm2.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm2.toString());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm2.maxCardinalityTipText());
      
      // Undeclared exception!
      try { 
        iCSSearchAlgorithm2.calcNodeScore((-1));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.bayes.net.search.local.LocalScoreSearchAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      
      Instances instances0 = new Instances("Ii4mC3", arrayList0, 2218);
      assertNotNull(instances0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("Ii4mC3", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      assertNotNull(iCSSearchAlgorithm0);
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      
      iCSSearchAlgorithm0.search((BayesNet) null, instances0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("Ii4mC3", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      
      boolean[][] booleanArray0 = new boolean[4][0];
      boolean[] booleanArray1 = new boolean[6];
      booleanArray1[3] = false;
      booleanArray1[4] = false;
      ICSSearchAlgorithm.SeparationSet iCSSearchAlgorithm_SeparationSet0 = iCSSearchAlgorithm0.existsSepSet(2218, 2218, 2, booleanArray0);
      assertNull(iCSSearchAlgorithm_SeparationSet0);
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      
      BayesNet bayesNet0 = iCSSearchAlgorithm0.m_BayesNet;
      assertNull(bayesNet0);
      
      LinkedList<String> linkedList0 = new LinkedList<String>();
      assertNotNull(linkedList0);
      assertEquals(0, linkedList0.size());
      
      Attribute attribute0 = new Attribute("@relation", linkedList0, 22);
      assertNotNull(attribute0);
      assertEquals(0, linkedList0.size());
      assertEquals(22, attribute0.index());
      assertFalse(attribute0.isNumeric());
      assertEquals("", attribute0.getDateFormat());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isNominal());
      assertFalse(attribute0.isString());
      assertEquals(1, attribute0.type());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isRegular());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.hasZeropoint());
      assertFalse(attribute0.isAveragable());
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(3, Attribute.DATE);
      
      Stream<String> stream0 = linkedList0.parallelStream();
      assertNotNull(stream0);
      assertEquals(0, linkedList0.size());
      
      boolean boolean0 = arrayList0.add(attribute0);
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(0, linkedList0.size());
      assertEquals(22, attribute0.index());
      assertFalse(attribute0.isNumeric());
      assertEquals("", attribute0.getDateFormat());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isNominal());
      assertFalse(attribute0.isString());
      assertEquals(1, attribute0.type());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isRegular());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.hasZeropoint());
      assertFalse(attribute0.isAveragable());
      assertTrue(boolean0);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(3, Attribute.DATE);
      
      Instances instances1 = new Instances((String) null, arrayList0, 1);
      assertNotNull(instances1);
      assertTrue(instances1.equals((Object)instances0));
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(0, instances1.numInstances());
      assertEquals(1, instances1.numAttributes());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals((-1), instances1.classIndex());
      assertEquals(0, instances1.size());
      assertNull(instances1.relationName());
      assertFalse(instances1.checkForStringAttributes());
      
      Instances instances2 = new Instances("", arrayList0, 1499);
      assertNotNull(instances2);
      assertTrue(instances2.equals((Object)instances0));
      assertTrue(instances2.equals((Object)instances1));
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, instances2.numAttributes());
      assertEquals(0.0, instances2.sumOfWeights(), 0.01);
      assertEquals((-1), instances2.classIndex());
      assertEquals(0, instances2.size());
      assertEquals(0, instances2.numInstances());
      assertEquals("", instances2.relationName());
      assertFalse(instances2.checkForStringAttributes());
      
      SelectedTag selectedTag0 = iCSSearchAlgorithm0.getScoreType();
      assertNotNull(selectedTag0);
      assertEquals("0", selectedTag0.toString());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      
      ArrayList<Attribute> arrayList1 = new ArrayList<Attribute>();
      assertNotNull(arrayList1);
      assertFalse(arrayList1.equals((Object)arrayList0));
      assertTrue(arrayList1.isEmpty());
      assertEquals(0, arrayList1.size());
      
      Attribute attribute1 = new Attribute("d!w,L");
      assertNotNull(attribute1);
      assertFalse(attribute1.equals((Object)attribute0));
      assertTrue(attribute1.isNumeric());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertFalse(attribute1.isNominal());
      assertFalse(attribute1.isDate());
      assertEquals(Double.NEGATIVE_INFINITY, attribute1.getLowerNumericBound(), 0.01);
      assertEquals(0, attribute1.type());
      assertEquals(Double.POSITIVE_INFINITY, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertEquals(0, attribute1.numValues());
      assertEquals((-1), attribute1.index());
      assertTrue(attribute1.isRegular());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.isRelationValued());
      assertEquals("", attribute1.getDateFormat());
      assertTrue(attribute1.hasZeropoint());
      assertEquals(1, attribute1.ordering());
      assertTrue(attribute1.isAveragable());
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.STRING);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      
      boolean boolean1 = arrayList0.add(attribute1);
      assertFalse(arrayList0.equals((Object)arrayList1));
      assertFalse(attribute1.equals((Object)attribute0));
      assertTrue(boolean1 == boolean0);
      assertEquals(2, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertTrue(attribute1.isNumeric());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertFalse(attribute1.isNominal());
      assertFalse(attribute1.isDate());
      assertEquals(Double.NEGATIVE_INFINITY, attribute1.getLowerNumericBound(), 0.01);
      assertEquals(0, attribute1.type());
      assertEquals(Double.POSITIVE_INFINITY, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertEquals(0, attribute1.numValues());
      assertEquals((-1), attribute1.index());
      assertTrue(attribute1.isRegular());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.isRelationValued());
      assertEquals("", attribute1.getDateFormat());
      assertTrue(attribute1.hasZeropoint());
      assertEquals(1, attribute1.ordering());
      assertTrue(attribute1.isAveragable());
      assertTrue(boolean1);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.STRING);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertNotSame(arrayList0, arrayList1);
      assertNotSame(attribute1, attribute0);
      
      String string0 = iCSSearchAlgorithm0.maxCardinalityTipText();
      assertNotNull(string0);
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", string0);
      
      // Undeclared exception!
      try { 
        iCSSearchAlgorithm0.calcArcDirections(booleanArray0, booleanArray0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 1
         //
         verifyException("weka.classifiers.bayes.net.search.ci.ICSSearchAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      assertNotNull(iCSSearchAlgorithm0);
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      
      Instances instances0 = new Instances(" not supported (LMT)", arrayList0, 2229);
      assertNotNull(instances0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, instances0.numInstances());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(" not supported (LMT)", instances0.relationName());
      
      iCSSearchAlgorithm0.search((BayesNet) null, instances0);
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, instances0.numInstances());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(" not supported (LMT)", instances0.relationName());
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      boolean[] booleanArray0 = new boolean[17];
      booleanArray0[0] = false;
      booleanArray0[3] = true;
      String string0 = iCSSearchAlgorithm0.getRevision();
      assertNotNull(string0);
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("8034", string0);
      
      booleanArray0[11] = false;
      Attribute attribute0 = new Attribute(" not supported (LMT)", instances0);
      assertNotNull(attribute0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, instances0.numInstances());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isAveragable());
      assertFalse(attribute0.isRegular());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isRelationValued());
      assertEquals(4, attribute0.type());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertEquals((-1), attribute0.index());
      assertFalse(attribute0.hasZeropoint());
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      
      boolean boolean1 = arrayList0.add(attribute0);
      assertTrue(boolean1 == boolean0);
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(0, instances0.numInstances());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(1, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isAveragable());
      assertFalse(attribute0.isRegular());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isRelationValued());
      assertEquals(4, attribute0.type());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertEquals((-1), attribute0.index());
      assertFalse(attribute0.hasZeropoint());
      assertTrue(boolean1);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      
      String string1 = attribute0.value(1);
      assertNotNull(string1);
      assertFalse(string1.equals((Object)string0));
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(0, instances0.numInstances());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(1, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isAveragable());
      assertFalse(attribute0.isRegular());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isRelationValued());
      assertEquals(4, attribute0.type());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertEquals((-1), attribute0.index());
      assertFalse(attribute0.hasZeropoint());
      assertEquals("", string1);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      int int0 = SGD.LOGLOSS;
      assertEquals(1, int0);
      
      String string2 = iCSSearchAlgorithm0.getRevision();
      assertNotNull(string2);
      assertTrue(string2.equals((Object)string0));
      assertFalse(string2.equals((Object)string1));
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("8034", string2);
      
      String string3 = attribute0.equalsMsg(" not supported (LMT)");
      assertNotNull(string3);
      assertFalse(string3.equals((Object)string0));
      assertFalse(string3.equals((Object)string2));
      assertFalse(string3.equals((Object)string1));
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(0, instances0.numInstances());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(1, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isAveragable());
      assertFalse(attribute0.isRegular());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isRelationValued());
      assertEquals(4, attribute0.type());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertEquals((-1), attribute0.index());
      assertFalse(attribute0.hasZeropoint());
      assertEquals("Object has wrong class", string3);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      
      boolean boolean2 = arrayList0.add(attribute0);
      assertTrue(boolean2 == boolean1);
      assertTrue(boolean2 == boolean0);
      assertEquals(2, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isAveragable());
      assertFalse(attribute0.isRegular());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isRelationValued());
      assertEquals(4, attribute0.type());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertEquals((-1), attribute0.index());
      assertFalse(attribute0.hasZeropoint());
      assertTrue(boolean2);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      
      double[] doubleArray0 = new double[6];
      doubleArray0[0] = (double) 0;
      doubleArray0[1] = (double) 4;
      doubleArray0[3] = (double) 2;
      doubleArray0[4] = 1877.2219042774468;
      doubleArray0[5] = (double) 2;
      SparseInstance sparseInstance0 = new SparseInstance(1, doubleArray0);
      assertNotNull(sparseInstance0);
      assertEquals(4, sparseInstance0.numValues());
      assertEquals(6, sparseInstance0.numAttributes());
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertArrayEquals(new double[] {0.0, 4.0, 0.0, 2.0, 1877.2219042774468, 2.0}, doubleArray0, 0.01);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      boolean boolean3 = instances0.add((Instance) sparseInstance0);
      assertTrue(boolean3 == boolean2);
      assertTrue(boolean3 == boolean0);
      assertTrue(boolean3 == boolean1);
      assertEquals(2, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(2, instances0.numAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(1, instances0.numInstances());
      assertEquals(1, instances0.size());
      assertEquals(1.0, instances0.sumOfWeights(), 0.01);
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(4, sparseInstance0.numValues());
      assertEquals(6, sparseInstance0.numAttributes());
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertArrayEquals(new double[] {0.0, 4.0, 0.0, 2.0, 1877.2219042774468, 2.0}, doubleArray0, 0.01);
      assertTrue(boolean3);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      boolean[][] booleanArray1 = new boolean[3][6];
      ICSSearchAlgorithm.SeparationSet iCSSearchAlgorithm_SeparationSet0 = iCSSearchAlgorithm0.new SeparationSet();
      assertNotNull(iCSSearchAlgorithm_SeparationSet0);
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      
      WordTokenizer wordTokenizer0 = new WordTokenizer();
      assertNotNull(wordTokenizer0);
      assertEquals("A simple tokenizer that is using the java.util.StringTokenizer class to tokenize the strings.", wordTokenizer0.globalInfo());
      assertEquals("Set of delimiter characters to use in tokenizing (\\r, \\n and \\t can be used for carriage-return, line-feed and tab)", wordTokenizer0.delimitersTipText());
      assertEquals(" \r\n\t.,;:'\"()?!", wordTokenizer0.getDelimiters());
      
      System.setCurrentTimeMillis((-2953L));
      iCSSearchAlgorithm0.calcArcDirections(booleanArray1, booleanArray1);
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      assertNotNull(iCSSearchAlgorithm0);
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      
      Instances instances0 = new Instances(" not supported (LMT)", arrayList0, 2229);
      assertNotNull(instances0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      
      boolean boolean0 = instances0.containsAll(arrayList0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertTrue(boolean0);
      
      iCSSearchAlgorithm0.search((BayesNet) null, instances0);
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      
      boolean boolean1 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean1 == boolean0);
      assertTrue(boolean1);
      
      boolean[] booleanArray0 = new boolean[12];
      booleanArray0[0] = true;
      booleanArray0[1] = true;
      booleanArray0[3] = true;
      Attribute attribute0 = new Attribute("@relation", instances0);
      assertNotNull(attribute0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(4, attribute0.type());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.hasZeropoint());
      assertFalse(attribute0.isRegular());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isRelationValued());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.isAveragable());
      assertEquals("", attribute0.getDateFormat());
      assertEquals((-1), attribute0.index());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(0, attribute0.ordering());
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      
      boolean boolean2 = arrayList0.add(attribute0);
      assertTrue(boolean2 == boolean0);
      assertTrue(boolean2 == boolean1);
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(4, attribute0.type());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.hasZeropoint());
      assertFalse(attribute0.isRegular());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isRelationValued());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.isAveragable());
      assertEquals("", attribute0.getDateFormat());
      assertEquals((-1), attribute0.index());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(0, attribute0.ordering());
      assertTrue(boolean2);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      
      Attribute attribute1 = attribute0.copy("real");
      assertNotNull(attribute1);
      assertFalse(attribute1.equals((Object)attribute0));
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(4, attribute0.type());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.hasZeropoint());
      assertFalse(attribute0.isRegular());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isRelationValued());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.isAveragable());
      assertEquals("", attribute0.getDateFormat());
      assertEquals((-1), attribute0.index());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute1.isRegular());
      assertEquals(0, attribute1.numValues());
      assertEquals((-1), attribute1.index());
      assertFalse(attribute1.isAveragable());
      assertFalse(attribute1.hasZeropoint());
      assertTrue(attribute1.isRelationValued());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertEquals(4, attribute1.type());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.isNumeric());
      assertFalse(attribute1.isNominal());
      assertEquals(0, attribute1.ordering());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertEquals("", attribute1.getDateFormat());
      assertEquals(Double.POSITIVE_INFINITY, attribute1.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute1.getLowerNumericBound(), 0.01);
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertNotSame(attribute0, attribute1);
      assertNotSame(attribute1, attribute0);
      
      boolean boolean3 = arrayList0.add(attribute1);
      assertFalse(attribute0.equals((Object)attribute1));
      assertFalse(attribute1.equals((Object)attribute0));
      assertTrue(boolean3 == boolean2);
      assertTrue(boolean3 == boolean1);
      assertTrue(boolean3 == boolean0);
      assertFalse(arrayList0.isEmpty());
      assertEquals(2, arrayList0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(4, attribute0.type());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.hasZeropoint());
      assertFalse(attribute0.isRegular());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isRelationValued());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.isAveragable());
      assertEquals("", attribute0.getDateFormat());
      assertEquals((-1), attribute0.index());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute1.isRegular());
      assertEquals(0, attribute1.numValues());
      assertEquals((-1), attribute1.index());
      assertFalse(attribute1.isAveragable());
      assertFalse(attribute1.hasZeropoint());
      assertTrue(attribute1.isRelationValued());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertEquals(4, attribute1.type());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.isNumeric());
      assertFalse(attribute1.isNominal());
      assertEquals(0, attribute1.ordering());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertEquals("", attribute1.getDateFormat());
      assertEquals(Double.POSITIVE_INFINITY, attribute1.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute1.getLowerNumericBound(), 0.01);
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertTrue(boolean3);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertNotSame(attribute0, attribute1);
      assertNotSame(attribute1, attribute0);
      
      Attribute attribute2 = new Attribute("@end", 1);
      assertNotNull(attribute2);
      assertFalse(attribute2.equals((Object)attribute0));
      assertFalse(attribute2.equals((Object)attribute1));
      assertFalse(attribute2.lowerNumericBoundIsOpen());
      assertEquals(1, attribute2.index());
      assertEquals(0, attribute2.numValues());
      assertEquals(0, attribute2.type());
      assertTrue(attribute2.hasZeropoint());
      assertFalse(attribute2.isDate());
      assertFalse(attribute2.isNominal());
      assertFalse(attribute2.isString());
      assertFalse(attribute2.isRelationValued());
      assertEquals(1.0, attribute2.weight(), 0.01);
      assertEquals("", attribute2.getDateFormat());
      assertTrue(attribute2.isNumeric());
      assertTrue(attribute2.isAveragable());
      assertEquals(1, attribute2.ordering());
      assertEquals(Double.POSITIVE_INFINITY, attribute2.getUpperNumericBound(), 0.01);
      assertEquals(Double.NEGATIVE_INFINITY, attribute2.getLowerNumericBound(), 0.01);
      assertTrue(attribute2.isRegular());
      assertFalse(attribute2.upperNumericBoundIsOpen());
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(3, Attribute.DATE);
      
      boolean[][] booleanArray1 = new boolean[6][7];
      booleanArray1[0] = booleanArray0;
      booleanArray1[1] = booleanArray0;
      booleanArray1[2] = booleanArray0;
      booleanArray1[3] = booleanArray0;
      booleanArray1[4] = booleanArray0;
      booleanArray1[5] = booleanArray0;
      iCSSearchAlgorithm0.calcArcDirections(booleanArray1, booleanArray1);
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      
      Instances instances0 = new Instances("UHIhy.i4mC3", arrayList0, 2253);
      assertNotNull(instances0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("UHIhy.i4mC3", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      assertNotNull(inputMappedClassifier0);
      assertEquals("Wrapper classifier that addresses incompatible training and test data by building a mapping between the training data that a classifier has been built with and the incoming test instances' structure. Model attributes that are not found in the incoming instances receive missing values, so do incoming nominal attribute values that the classifier has not seen before. A new classifier can be trained or an existing one loaded from a file.", inputMappedClassifier0.globalInfo());
      assertEquals("Trim white space from each end of attribute names and nominal values before matching.", inputMappedClassifier0.trimTipText());
      assertTrue(inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals("If set to true, classifier may output additional info to the console.", inputMappedClassifier0.debugTipText());
      assertEquals(0, inputMappedClassifier0.graphType());
      assertEquals("", inputMappedClassifier0.getModelPath());
      assertFalse(inputMappedClassifier0.getSuppressMappingReport());
      assertEquals("Don't output a report of model-to-input mappings.", inputMappedClassifier0.suppressMappingReportTipText());
      assertTrue(inputMappedClassifier0.getTrim());
      assertEquals("Set the path from which to load a model. Loading occurs when the first test instance is received. Environment variables can be used in the supplied path.", inputMappedClassifier0.modelPathTipText());
      assertEquals("The base classifier to be used.", inputMappedClassifier0.classifierTipText());
      assertEquals("Ignore case when matching attribute names and nomina values.", inputMappedClassifier0.ignoreCaseForNamesTipText());
      assertFalse(inputMappedClassifier0.getDebug());
      
      int int0 = instances0.indexOf((Object) null);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("UHIhy.i4mC3", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      assertEquals((-1), int0);
      
      LinkedList<String> linkedList0 = new LinkedList<String>();
      assertNotNull(linkedList0);
      assertEquals(0, linkedList0.size());
      
      Attribute attribute0 = new Attribute((String) null, linkedList0, (-1));
      assertNotNull(attribute0);
      assertEquals(0, linkedList0.size());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertTrue(attribute0.isNominal());
      assertEquals(0, attribute0.ordering());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.hasZeropoint());
      assertFalse(attribute0.isAveragable());
      assertFalse(attribute0.isRegular());
      assertEquals((-1), attribute0.index());
      assertEquals(0, attribute0.numValues());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isString());
      assertEquals(1, attribute0.type());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isRelationValued());
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      
      Attribute attribute1 = new Attribute("date", instances0, 2);
      assertNotNull(attribute1);
      assertFalse(attribute1.equals((Object)attribute0));
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("UHIhy.i4mC3", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0, attribute1.ordering());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertFalse(attribute1.hasZeropoint());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertFalse(attribute1.isAveragable());
      assertEquals("", attribute1.getDateFormat());
      assertEquals(2, attribute1.index());
      assertEquals(0.0, attribute1.getLowerNumericBound(), 0.01);
      assertEquals(0.0, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.isNominal());
      assertFalse(attribute1.isNumeric());
      assertFalse(attribute1.isRegular());
      assertEquals(0, attribute1.numValues());
      assertTrue(attribute1.isRelationValued());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertEquals(4, attribute1.type());
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(3, Attribute.DATE);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      
      linkedList0.push("integer");
      assertEquals(1, linkedList0.size());
      
      String string0 = attribute1.value((-1));
      assertNotNull(string0);
      assertFalse(attribute1.equals((Object)attribute0));
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("UHIhy.i4mC3", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0, attribute1.ordering());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertFalse(attribute1.hasZeropoint());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertFalse(attribute1.isAveragable());
      assertEquals("", attribute1.getDateFormat());
      assertEquals(2, attribute1.index());
      assertEquals(0.0, attribute1.getLowerNumericBound(), 0.01);
      assertEquals(0.0, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.isNominal());
      assertFalse(attribute1.isNumeric());
      assertFalse(attribute1.isRegular());
      assertEquals(0, attribute1.numValues());
      assertTrue(attribute1.isRelationValued());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertEquals(4, attribute1.type());
      assertEquals("", string0);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(3, Attribute.DATE);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertNotSame(attribute1, attribute0);
      
      AlphabeticTokenizer alphabeticTokenizer0 = new AlphabeticTokenizer();
      assertNotNull(alphabeticTokenizer0);
      assertEquals("Alphabetic string tokenizer, tokens are to be formed only from contiguous alphabetic sequences.", alphabeticTokenizer0.globalInfo());
      
      Instances instances1 = new Instances("@relation", arrayList0, 1);
      assertNotNull(instances1);
      assertTrue(instances1.equals((Object)instances0));
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertFalse(instances1.checkForStringAttributes());
      assertEquals(0, instances1.numInstances());
      assertEquals(0, instances1.numAttributes());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(0, instances1.size());
      assertEquals((-1), instances1.classIndex());
      assertEquals("@relation", instances1.relationName());
      
      boolean boolean0 = arrayList0.add(attribute1);
      assertTrue(instances0.equals((Object)instances1));
      assertFalse(attribute1.equals((Object)attribute0));
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("UHIhy.i4mC3", instances0.relationName());
      assertEquals(1, instances0.numAttributes());
      assertEquals(0, attribute1.ordering());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertFalse(attribute1.hasZeropoint());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertFalse(attribute1.isAveragable());
      assertEquals("", attribute1.getDateFormat());
      assertEquals(2, attribute1.index());
      assertEquals(0.0, attribute1.getLowerNumericBound(), 0.01);
      assertEquals(0.0, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.isNominal());
      assertFalse(attribute1.isNumeric());
      assertFalse(attribute1.isRegular());
      assertEquals(0, attribute1.numValues());
      assertTrue(attribute1.isRelationValued());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertEquals(4, attribute1.type());
      assertTrue(boolean0);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(3, Attribute.DATE);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertNotSame(instances0, instances1);
      assertNotSame(attribute1, attribute0);
      
      boolean boolean1 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean1 == boolean0);
      assertTrue(boolean1);
      
      boolean boolean2 = arrayList0.add(attribute1);
      assertTrue(instances0.equals((Object)instances1));
      assertFalse(attribute1.equals((Object)attribute0));
      assertTrue(boolean2 == boolean0);
      assertTrue(boolean2 == boolean1);
      assertEquals(2, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("UHIhy.i4mC3", instances0.relationName());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, attribute1.ordering());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertFalse(attribute1.hasZeropoint());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertFalse(attribute1.isAveragable());
      assertEquals("", attribute1.getDateFormat());
      assertEquals(2, attribute1.index());
      assertEquals(0.0, attribute1.getLowerNumericBound(), 0.01);
      assertEquals(0.0, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.isNominal());
      assertFalse(attribute1.isNumeric());
      assertFalse(attribute1.isRegular());
      assertEquals(0, attribute1.numValues());
      assertTrue(attribute1.isRelationValued());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertEquals(4, attribute1.type());
      assertTrue(boolean2);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(3, Attribute.DATE);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertNotSame(instances0, instances1);
      assertNotSame(attribute1, attribute0);
      
      ListIterator<Attribute> listIterator0 = arrayList0.listIterator();
      assertNotNull(listIterator0);
      assertEquals(2, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertTrue(listIterator0.hasNext());
      assertFalse(listIterator0.hasPrevious());
      
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      assertNotNull(iCSSearchAlgorithm0);
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      
      UnaryOperator<Instance> unaryOperator0 = UnaryOperator.identity();
      assertNotNull(unaryOperator0);
      
      iCSSearchAlgorithm0.setMaxCardinality((-1));
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals((-1), iCSSearchAlgorithm0.getMaxCardinality());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      
      try { 
        iCSSearchAlgorithm0.search((BayesNet) null, instances0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.bayes.net.search.ci.ICSSearchAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      assertNotNull(iCSSearchAlgorithm0);
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      
      Instances instances0 = new Instances(" not supportd (LMT)", arrayList0, 2213);
      assertNotNull(instances0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(" not supportd (LMT)", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      
      iCSSearchAlgorithm0.search((BayesNet) null, instances0);
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(" not supportd (LMT)", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      boolean[] booleanArray0 = new boolean[13];
      booleanArray0[0] = true;
      SystemInUtil.addInputLine("@data");
      booleanArray0[12] = true;
      Attribute attribute0 = new Attribute(" not supportd (LMT)", instances0);
      assertNotNull(attribute0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(" not supportd (LMT)", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals((-1), attribute0.index());
      assertFalse(attribute0.isRegular());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.isAveragable());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.hasZeropoint());
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.isNumeric());
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.isRelationValued());
      assertEquals(0, attribute0.numValues());
      assertEquals(4, attribute0.type());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isNominal());
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      
      String string0 = attribute0.getRevision();
      assertNotNull(string0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(" not supportd (LMT)", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals((-1), attribute0.index());
      assertFalse(attribute0.isRegular());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.isAveragable());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.hasZeropoint());
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.isNumeric());
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.isRelationValued());
      assertEquals(0, attribute0.numValues());
      assertEquals(4, attribute0.type());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isNominal());
      assertEquals("9172", string0);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      
      NGramTokenizer nGramTokenizer0 = new NGramTokenizer();
      assertNotNull(nGramTokenizer0);
      assertEquals("Set of delimiter characters to use in tokenizing (\\r, \\n and \\t can be used for carriage-return, line-feed and tab)", nGramTokenizer0.delimitersTipText());
      assertEquals(1, nGramTokenizer0.getNGramMinSize());
      assertFalse(nGramTokenizer0.hasMoreElements());
      assertEquals(3, nGramTokenizer0.getNGramMaxSize());
      assertEquals("The min N of the NGram.", nGramTokenizer0.NGramMinSizeTipText());
      assertEquals("Splits a string into an n-gram with min and max grams.", nGramTokenizer0.globalInfo());
      assertEquals("The max N of the NGram.", nGramTokenizer0.NGramMaxSizeTipText());
      assertEquals(" \r\n\t.,;:'\"()?!", nGramTokenizer0.getDelimiters());
      
      boolean boolean1 = arrayList0.add(attribute0);
      assertTrue(boolean1 == boolean0);
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(1, instances0.numAttributes());
      assertEquals(" not supportd (LMT)", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals((-1), attribute0.index());
      assertFalse(attribute0.isRegular());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.isAveragable());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.hasZeropoint());
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.isNumeric());
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.isRelationValued());
      assertEquals(0, attribute0.numValues());
      assertEquals(4, attribute0.type());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isNominal());
      assertTrue(boolean1);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      int int0 = MultiClassClassifier.METHOD_ERROR_RANDOM;
      assertEquals(1, int0);
      
      FileSystemHandling fileSystemHandling1 = new FileSystemHandling();
      assertNotNull(fileSystemHandling1);
      assertFalse(fileSystemHandling1.equals((Object)fileSystemHandling0));
      
      Attribute attribute1 = (Attribute)attribute0.copy();
      assertNotNull(attribute1);
      assertEquals(Double.POSITIVE_INFINITY, attribute1.getUpperNumericBound(), 0.01);
      assertEquals(0, attribute1.ordering());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertFalse(attribute1.isDate());
      assertEquals(4, attribute1.type());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertFalse(attribute1.isRegular());
      assertEquals(Double.NEGATIVE_INFINITY, attribute1.getLowerNumericBound(), 0.01);
      assertEquals(0, attribute1.numValues());
      assertTrue(attribute1.isRelationValued());
      assertFalse(attribute1.isNominal());
      assertFalse(attribute1.hasZeropoint());
      assertFalse(attribute1.isAveragable());
      assertEquals((-1), attribute1.index());
      assertFalse(attribute1.isNumeric());
      assertEquals("", attribute1.getDateFormat());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(1, instances0.numAttributes());
      assertEquals(" not supportd (LMT)", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals((-1), attribute0.index());
      assertFalse(attribute0.isRegular());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.isAveragable());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.hasZeropoint());
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.isNumeric());
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.isRelationValued());
      assertEquals(0, attribute0.numValues());
      assertEquals(4, attribute0.type());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isNominal());
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertNotSame(attribute1, attribute0);
      assertNotSame(attribute0, attribute1);
      
      String string1 = Attribute.typeToString(attribute1);
      assertNotNull(string1);
      assertFalse(string1.equals((Object)string0));
      assertEquals(Double.POSITIVE_INFINITY, attribute1.getUpperNumericBound(), 0.01);
      assertEquals(0, attribute1.ordering());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertFalse(attribute1.isDate());
      assertEquals(4, attribute1.type());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertFalse(attribute1.isRegular());
      assertEquals(Double.NEGATIVE_INFINITY, attribute1.getLowerNumericBound(), 0.01);
      assertEquals(0, attribute1.numValues());
      assertTrue(attribute1.isRelationValued());
      assertFalse(attribute1.isNominal());
      assertFalse(attribute1.hasZeropoint());
      assertFalse(attribute1.isAveragable());
      assertEquals((-1), attribute1.index());
      assertFalse(attribute1.isNumeric());
      assertEquals("", attribute1.getDateFormat());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, arrayList0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(1, instances0.numAttributes());
      assertEquals(" not supportd (LMT)", instances0.relationName());
      assertFalse(instances0.checkForStringAttributes());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals((-1), attribute0.index());
      assertFalse(attribute0.isRegular());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.isAveragable());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.hasZeropoint());
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.isNumeric());
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.isRelationValued());
      assertEquals(0, attribute0.numValues());
      assertEquals(4, attribute0.type());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isNominal());
      assertEquals("relational", string1);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertNotSame(attribute1, attribute0);
      assertNotSame(attribute0, attribute1);
      
      boolean boolean2 = arrayList0.add(attribute0);
      assertTrue(boolean2 == boolean0);
      assertTrue(boolean2 == boolean1);
      assertFalse(arrayList0.isEmpty());
      assertEquals(2, arrayList0.size());
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(" not supportd (LMT)", instances0.relationName());
      assertEquals(2, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals((-1), attribute0.index());
      assertFalse(attribute0.isRegular());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.isAveragable());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.hasZeropoint());
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.isNumeric());
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertTrue(attribute0.isRelationValued());
      assertEquals(0, attribute0.numValues());
      assertEquals(4, attribute0.type());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isNominal());
      assertTrue(boolean2);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertNotSame(attribute0, attribute1);
      
      boolean[][] booleanArray1 = new boolean[3][6];
      Enumeration enumeration0 = iCSSearchAlgorithm0.listOptions();
      assertNotNull(enumeration0);
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      
      String[] stringArray0 = Locale.getISOLanguages();
      assertNotNull(stringArray0);
      
      ICSSearchAlgorithm.SeparationSet[][] iCSSearchAlgorithm_SeparationSetArray0 = new ICSSearchAlgorithm.SeparationSet[6][2];
      // Undeclared exception!
      try { 
        iCSSearchAlgorithm0.calcVeeNodes(booleanArray1, booleanArray1, iCSSearchAlgorithm_SeparationSetArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.bayes.net.search.ci.ICSSearchAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      
      Instances instances0 = new Instances("Ihy.i4mC3", arrayList0, 2253);
      assertNotNull(instances0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0, instances0.numAttributes());
      assertEquals("Ihy.i4mC3", instances0.relationName());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      assertNotNull(inputMappedClassifier0);
      assertEquals("The base classifier to be used.", inputMappedClassifier0.classifierTipText());
      assertEquals("Wrapper classifier that addresses incompatible training and test data by building a mapping between the training data that a classifier has been built with and the incoming test instances' structure. Model attributes that are not found in the incoming instances receive missing values, so do incoming nominal attribute values that the classifier has not seen before. A new classifier can be trained or an existing one loaded from a file.", inputMappedClassifier0.globalInfo());
      assertFalse(inputMappedClassifier0.getSuppressMappingReport());
      assertEquals("Trim white space from each end of attribute names and nominal values before matching.", inputMappedClassifier0.trimTipText());
      assertEquals("Set the path from which to load a model. Loading occurs when the first test instance is received. Environment variables can be used in the supplied path.", inputMappedClassifier0.modelPathTipText());
      assertEquals(0, inputMappedClassifier0.graphType());
      assertTrue(inputMappedClassifier0.getTrim());
      assertFalse(inputMappedClassifier0.getDebug());
      assertEquals("Ignore case when matching attribute names and nomina values.", inputMappedClassifier0.ignoreCaseForNamesTipText());
      assertEquals("", inputMappedClassifier0.getModelPath());
      assertTrue(inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals("If set to true, classifier may output additional info to the console.", inputMappedClassifier0.debugTipText());
      assertEquals("Don't output a report of model-to-input mappings.", inputMappedClassifier0.suppressMappingReportTipText());
      
      int int0 = instances0.indexOf((Object) null);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0, instances0.numAttributes());
      assertEquals("Ihy.i4mC3", instances0.relationName());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), int0);
      
      LinkedList<String> linkedList0 = new LinkedList<String>();
      assertNotNull(linkedList0);
      assertEquals(0, linkedList0.size());
      
      Attribute attribute0 = new Attribute((String) null, linkedList0, (-1));
      assertNotNull(attribute0);
      assertEquals(0, linkedList0.size());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.hasZeropoint());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isString());
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isAveragable());
      assertEquals(0, attribute0.ordering());
      assertEquals((-1), attribute0.index());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.isRegular());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isNominal());
      assertEquals(1, attribute0.type());
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      
      Attribute attribute1 = new Attribute("date", instances0, 2);
      assertNotNull(attribute1);
      assertFalse(attribute1.equals((Object)attribute0));
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0, instances0.numAttributes());
      assertEquals("Ihy.i4mC3", instances0.relationName());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0.0, attribute1.getLowerNumericBound(), 0.01);
      assertFalse(attribute1.isAveragable());
      assertEquals(0.0, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.isNominal());
      assertTrue(attribute1.isRelationValued());
      assertEquals(0, attribute1.numValues());
      assertEquals("", attribute1.getDateFormat());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertFalse(attribute1.isNumeric());
      assertEquals(0, attribute1.ordering());
      assertFalse(attribute1.isString());
      assertEquals(4, attribute1.type());
      assertEquals(2, attribute1.index());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertFalse(attribute1.hasZeropoint());
      assertFalse(attribute1.isRegular());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      
      linkedList0.push("integer");
      assertEquals(1, linkedList0.size());
      
      String string0 = attribute1.value((-1));
      assertNotNull(string0);
      assertFalse(attribute1.equals((Object)attribute0));
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0, instances0.numAttributes());
      assertEquals("Ihy.i4mC3", instances0.relationName());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0.0, attribute1.getLowerNumericBound(), 0.01);
      assertFalse(attribute1.isAveragable());
      assertEquals(0.0, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.isNominal());
      assertTrue(attribute1.isRelationValued());
      assertEquals(0, attribute1.numValues());
      assertEquals("", attribute1.getDateFormat());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertFalse(attribute1.isNumeric());
      assertEquals(0, attribute1.ordering());
      assertFalse(attribute1.isString());
      assertEquals(4, attribute1.type());
      assertEquals(2, attribute1.index());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertFalse(attribute1.hasZeropoint());
      assertFalse(attribute1.isRegular());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertEquals("", string0);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertNotSame(attribute1, attribute0);
      
      AlphabeticTokenizer alphabeticTokenizer0 = new AlphabeticTokenizer();
      assertNotNull(alphabeticTokenizer0);
      assertEquals("Alphabetic string tokenizer, tokens are to be formed only from contiguous alphabetic sequences.", alphabeticTokenizer0.globalInfo());
      
      Instances instances1 = new Instances("@relation", arrayList0, 1);
      assertNotNull(instances1);
      assertTrue(instances1.equals((Object)instances0));
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertFalse(instances1.checkForStringAttributes());
      assertEquals(0, instances1.numInstances());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals((-1), instances1.classIndex());
      assertEquals(0, instances1.size());
      assertEquals("@relation", instances1.relationName());
      assertEquals(0, instances1.numAttributes());
      
      boolean boolean0 = arrayList0.add(attribute1);
      assertTrue(instances0.equals((Object)instances1));
      assertFalse(attribute1.equals((Object)attribute0));
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(1, instances0.numAttributes());
      assertEquals("Ihy.i4mC3", instances0.relationName());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0.0, attribute1.getLowerNumericBound(), 0.01);
      assertFalse(attribute1.isAveragable());
      assertEquals(0.0, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.isNominal());
      assertTrue(attribute1.isRelationValued());
      assertEquals(0, attribute1.numValues());
      assertEquals("", attribute1.getDateFormat());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertFalse(attribute1.isNumeric());
      assertEquals(0, attribute1.ordering());
      assertFalse(attribute1.isString());
      assertEquals(4, attribute1.type());
      assertEquals(2, attribute1.index());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertFalse(attribute1.hasZeropoint());
      assertFalse(attribute1.isRegular());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertTrue(boolean0);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertNotSame(instances0, instances1);
      assertNotSame(attribute1, attribute0);
      
      boolean boolean1 = arrayList0.add(attribute1);
      assertTrue(instances0.equals((Object)instances1));
      assertFalse(attribute1.equals((Object)attribute0));
      assertTrue(boolean1 == boolean0);
      assertEquals(2, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals("Ihy.i4mC3", instances0.relationName());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0.0, attribute1.getLowerNumericBound(), 0.01);
      assertFalse(attribute1.isAveragable());
      assertEquals(0.0, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.isNominal());
      assertTrue(attribute1.isRelationValued());
      assertEquals(0, attribute1.numValues());
      assertEquals("", attribute1.getDateFormat());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertFalse(attribute1.isNumeric());
      assertEquals(0, attribute1.ordering());
      assertFalse(attribute1.isString());
      assertEquals(4, attribute1.type());
      assertEquals(2, attribute1.index());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertFalse(attribute1.hasZeropoint());
      assertFalse(attribute1.isRegular());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertTrue(boolean1);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertNotSame(instances0, instances1);
      assertNotSame(attribute1, attribute0);
      
      boolean boolean2 = arrayList0.add(attribute1);
      assertTrue(instances0.equals((Object)instances1));
      assertFalse(attribute1.equals((Object)attribute0));
      assertTrue(boolean2 == boolean1);
      assertTrue(boolean2 == boolean0);
      assertEquals(3, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals("Ihy.i4mC3", instances0.relationName());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(3, instances0.numAttributes());
      assertEquals(0.0, attribute1.getLowerNumericBound(), 0.01);
      assertFalse(attribute1.isAveragable());
      assertEquals(0.0, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.isNominal());
      assertTrue(attribute1.isRelationValued());
      assertEquals(0, attribute1.numValues());
      assertEquals("", attribute1.getDateFormat());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertFalse(attribute1.isNumeric());
      assertEquals(0, attribute1.ordering());
      assertFalse(attribute1.isString());
      assertEquals(4, attribute1.type());
      assertEquals(2, attribute1.index());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertFalse(attribute1.hasZeropoint());
      assertFalse(attribute1.isRegular());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertTrue(boolean2);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(3, Attribute.DATE);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(2, Attribute.STRING);
      assertNotSame(instances0, instances1);
      assertNotSame(attribute1, attribute0);
      
      ListIterator<Attribute> listIterator0 = arrayList0.listIterator();
      assertNotNull(listIterator0);
      assertEquals(3, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertTrue(listIterator0.hasNext());
      assertFalse(listIterator0.hasPrevious());
      
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      assertNotNull(iCSSearchAlgorithm0);
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      
      UnaryOperator<Instance> unaryOperator0 = UnaryOperator.identity();
      assertNotNull(unaryOperator0);
      
      iCSSearchAlgorithm0.setMaxCardinality((-1));
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals((-1), iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      
      try { 
        iCSSearchAlgorithm0.search((BayesNet) null, instances0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.bayes.net.search.ci.ICSSearchAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      
      arrayList0.ensureCapacity((-1619));
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      
      Instances instances0 = new Instances("@ey.i4mT", arrayList0, 2283);
      assertNotNull(instances0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals("@ey.i4mT", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      assertEquals((-1), instances0.classIndex());
      
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      assertNotNull(inputMappedClassifier0);
      assertEquals("Ignore case when matching attribute names and nomina values.", inputMappedClassifier0.ignoreCaseForNamesTipText());
      assertEquals(0, inputMappedClassifier0.graphType());
      assertEquals("Trim white space from each end of attribute names and nominal values before matching.", inputMappedClassifier0.trimTipText());
      assertFalse(inputMappedClassifier0.getDebug());
      assertEquals("Set the path from which to load a model. Loading occurs when the first test instance is received. Environment variables can be used in the supplied path.", inputMappedClassifier0.modelPathTipText());
      assertEquals("Wrapper classifier that addresses incompatible training and test data by building a mapping between the training data that a classifier has been built with and the incoming test instances' structure. Model attributes that are not found in the incoming instances receive missing values, so do incoming nominal attribute values that the classifier has not seen before. A new classifier can be trained or an existing one loaded from a file.", inputMappedClassifier0.globalInfo());
      assertFalse(inputMappedClassifier0.getSuppressMappingReport());
      assertEquals("Don't output a report of model-to-input mappings.", inputMappedClassifier0.suppressMappingReportTipText());
      assertEquals("The base classifier to be used.", inputMappedClassifier0.classifierTipText());
      assertTrue(inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals("If set to true, classifier may output additional info to the console.", inputMappedClassifier0.debugTipText());
      assertEquals("", inputMappedClassifier0.getModelPath());
      assertTrue(inputMappedClassifier0.getTrim());
      
      int int0 = instances0.indexOf("@data");
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals("@ey.i4mT", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals((-1), int0);
      
      LinkedList<String> linkedList0 = new LinkedList<String>();
      assertNotNull(linkedList0);
      assertEquals(0, linkedList0.size());
      
      Attribute attribute0 = new Attribute("@ey.i4mT", linkedList0, (-1));
      assertNotNull(attribute0);
      assertEquals(0, linkedList0.size());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.hasZeropoint());
      assertFalse(attribute0.isString());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isAveragable());
      assertEquals(0, attribute0.ordering());
      assertEquals((-1), attribute0.index());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.isRegular());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isNominal());
      assertEquals(1, attribute0.type());
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      Attribute attribute1 = new Attribute("date", instances0, 2);
      assertNotNull(attribute1);
      assertFalse(attribute1.equals((Object)attribute0));
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals("@ey.i4mT", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      assertEquals((-1), instances0.classIndex());
      assertTrue(attribute1.isRelationValued());
      assertEquals(0, attribute1.numValues());
      assertEquals(0.0, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.isRegular());
      assertEquals(0.0, attribute1.getLowerNumericBound(), 0.01);
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.isNominal());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.isNumeric());
      assertEquals(4, attribute1.type());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertEquals(0, attribute1.ordering());
      assertEquals("", attribute1.getDateFormat());
      assertFalse(attribute1.hasZeropoint());
      assertEquals(2, attribute1.index());
      assertFalse(attribute1.isAveragable());
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      AlphabeticTokenizer alphabeticTokenizer0 = new AlphabeticTokenizer();
      assertNotNull(alphabeticTokenizer0);
      assertEquals("Alphabetic string tokenizer, tokens are to be formed only from contiguous alphabetic sequences.", alphabeticTokenizer0.globalInfo());
      
      boolean boolean1 = arrayList0.add(attribute0);
      assertFalse(attribute0.equals((Object)attribute1));
      assertFalse(boolean1 == boolean0);
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(0, linkedList0.size());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.hasZeropoint());
      assertFalse(attribute0.isString());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isAveragable());
      assertEquals(0, attribute0.ordering());
      assertEquals((-1), attribute0.index());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.isRegular());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isNominal());
      assertEquals(1, attribute0.type());
      assertTrue(boolean1);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertNotSame(attribute0, attribute1);
      
      boolean boolean2 = arrayList0.add(attribute1);
      assertFalse(attribute1.equals((Object)attribute0));
      assertTrue(boolean2 == boolean1);
      assertFalse(boolean2 == boolean0);
      assertFalse(arrayList0.isEmpty());
      assertEquals(2, arrayList0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals("@ey.i4mT", instances0.relationName());
      assertEquals((-1), instances0.classIndex());
      assertTrue(attribute1.isRelationValued());
      assertEquals(0, attribute1.numValues());
      assertEquals(0.0, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.isRegular());
      assertEquals(0.0, attribute1.getLowerNumericBound(), 0.01);
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.isNominal());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.isNumeric());
      assertEquals(4, attribute1.type());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertEquals(0, attribute1.ordering());
      assertEquals("", attribute1.getDateFormat());
      assertFalse(attribute1.hasZeropoint());
      assertEquals(2, attribute1.index());
      assertFalse(attribute1.isAveragable());
      assertTrue(boolean2);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertNotSame(attribute1, attribute0);
      
      boolean boolean3 = arrayList0.add(attribute1);
      assertFalse(attribute1.equals((Object)attribute0));
      assertFalse(boolean3 == boolean0);
      assertTrue(boolean3 == boolean2);
      assertTrue(boolean3 == boolean1);
      assertFalse(arrayList0.isEmpty());
      assertEquals(3, arrayList0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals("@ey.i4mT", instances0.relationName());
      assertEquals(3, instances0.numAttributes());
      assertEquals((-1), instances0.classIndex());
      assertTrue(attribute1.isRelationValued());
      assertEquals(0, attribute1.numValues());
      assertEquals(0.0, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.isRegular());
      assertEquals(0.0, attribute1.getLowerNumericBound(), 0.01);
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.isNominal());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.isNumeric());
      assertEquals(4, attribute1.type());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertEquals(0, attribute1.ordering());
      assertEquals("", attribute1.getDateFormat());
      assertFalse(attribute1.hasZeropoint());
      assertEquals(2, attribute1.index());
      assertFalse(attribute1.isAveragable());
      assertTrue(boolean3);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertNotSame(attribute1, attribute0);
      
      boolean boolean4 = arrayList0.add(attribute0);
      assertFalse(attribute0.equals((Object)attribute1));
      assertTrue(boolean4 == boolean1);
      assertFalse(boolean4 == boolean0);
      assertTrue(boolean4 == boolean2);
      assertTrue(boolean4 == boolean3);
      assertFalse(arrayList0.isEmpty());
      assertEquals(4, arrayList0.size());
      assertEquals(0, linkedList0.size());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertFalse(attribute0.isRelationValued());
      assertFalse(attribute0.hasZeropoint());
      assertFalse(attribute0.isString());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertFalse(attribute0.isAveragable());
      assertEquals(0, attribute0.ordering());
      assertEquals((-1), attribute0.index());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals("", attribute0.getDateFormat());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.isRegular());
      assertFalse(attribute0.isDate());
      assertEquals(0, attribute0.numValues());
      assertTrue(attribute0.isNominal());
      assertEquals(1, attribute0.type());
      assertTrue(boolean4);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertNotSame(attribute0, attribute1);
      
      ListIterator<Attribute> listIterator0 = arrayList0.listIterator();
      assertNotNull(listIterator0);
      assertFalse(arrayList0.isEmpty());
      assertEquals(4, arrayList0.size());
      assertFalse(listIterator0.hasPrevious());
      assertTrue(listIterator0.hasNext());
      
      arrayList0.ensureCapacity(0);
      assertFalse(arrayList0.isEmpty());
      assertEquals(4, arrayList0.size());
      
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      assertNotNull(iCSSearchAlgorithm0);
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      
      boolean boolean5 = linkedList0.add("@attribute");
      assertTrue(boolean5 == boolean4);
      assertTrue(boolean5 == boolean2);
      assertTrue(boolean5 == boolean3);
      assertFalse(boolean5 == boolean0);
      assertTrue(boolean5 == boolean1);
      assertEquals(1, linkedList0.size());
      assertTrue(boolean5);
      
      iCSSearchAlgorithm0.m_BayesNet = null;
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      
      iCSSearchAlgorithm0.setMaxCardinality((-1));
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals((-1), iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      
      ICSSearchAlgorithm.SeparationSet iCSSearchAlgorithm_SeparationSet0 = iCSSearchAlgorithm0.new SeparationSet();
      assertNotNull(iCSSearchAlgorithm_SeparationSet0);
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals((-1), iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      
      try { 
        iCSSearchAlgorithm0.search((BayesNet) null, instances0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.bayes.net.search.ci.ICSSearchAlgorithm", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      assertNotNull(iCSSearchAlgorithm0);
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      
      Instances instances0 = new Instances(" not supported (LMT)", arrayList0, 2229);
      assertNotNull(instances0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(" not supported (LMT)", instances0.relationName());
      
      iCSSearchAlgorithm0.search((BayesNet) null, instances0);
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(" not supported (LMT)", instances0.relationName());
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      boolean boolean1 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean1 == boolean0);
      assertFalse(boolean1);
      
      boolean[] booleanArray0 = new boolean[17];
      booleanArray0[0] = true;
      booleanArray0[1] = true;
      SystemInUtil.addInputLine("@data");
      booleanArray0[3] = false;
      booleanArray0[11] = true;
      Attribute attribute0 = new Attribute("@data", instances0, 2229);
      assertNotNull(attribute0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.isRegular());
      assertEquals(4, attribute0.type());
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertTrue(attribute0.isRelationValued());
      assertEquals("", attribute0.getDateFormat());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertFalse(attribute0.isNominal());
      assertEquals(2229, attribute0.index());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.isAveragable());
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(0, attribute0.ordering());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertFalse(attribute0.hasZeropoint());
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      
      Attribute attribute1 = new Attribute("ss");
      assertNotNull(attribute1);
      assertFalse(attribute1.equals((Object)attribute0));
      assertEquals("", attribute1.getDateFormat());
      assertTrue(attribute1.isRegular());
      assertFalse(attribute1.isNominal());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertEquals((-1), attribute1.index());
      assertTrue(attribute1.hasZeropoint());
      assertEquals(1, attribute1.ordering());
      assertTrue(attribute1.isAveragable());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.isRelationValued());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertEquals(0, attribute1.numValues());
      assertTrue(attribute1.isNumeric());
      assertEquals(Double.NEGATIVE_INFINITY, attribute1.getLowerNumericBound(), 0.01);
      assertEquals(Double.POSITIVE_INFINITY, attribute1.getUpperNumericBound(), 0.01);
      assertEquals(0, attribute1.type());
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(3, Attribute.DATE);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      
      SparseInstance sparseInstance0 = new SparseInstance(0);
      assertNotNull(sparseInstance0);
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(0, sparseInstance0.numValues());
      assertEquals(0, sparseInstance0.numAttributes());
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      int int0 = attribute1.indexOfValue("@attribute");
      assertFalse(attribute1.equals((Object)attribute0));
      assertEquals("", attribute1.getDateFormat());
      assertTrue(attribute1.isRegular());
      assertFalse(attribute1.isNominal());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertEquals((-1), attribute1.index());
      assertTrue(attribute1.hasZeropoint());
      assertEquals(1, attribute1.ordering());
      assertTrue(attribute1.isAveragable());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.isRelationValued());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertEquals(0, attribute1.numValues());
      assertTrue(attribute1.isNumeric());
      assertEquals(Double.NEGATIVE_INFINITY, attribute1.getLowerNumericBound(), 0.01);
      assertEquals(Double.POSITIVE_INFINITY, attribute1.getUpperNumericBound(), 0.01);
      assertEquals(0, attribute1.type());
      assertEquals((-1), int0);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(3, Attribute.DATE);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertNotSame(attribute1, attribute0);
      
      String string0 = attribute0.equalsMsg(" not supported (LMT)");
      assertNotNull(string0);
      assertFalse(attribute0.equals((Object)attribute1));
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.numAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals((-1), instances0.classIndex());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertFalse(attribute0.isRegular());
      assertEquals(4, attribute0.type());
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertTrue(attribute0.isRelationValued());
      assertEquals("", attribute0.getDateFormat());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertFalse(attribute0.isNominal());
      assertEquals(2229, attribute0.index());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.isAveragable());
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(0, attribute0.ordering());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertFalse(attribute0.hasZeropoint());
      assertEquals("Object has wrong class", string0);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertNotSame(attribute0, attribute1);
      
      boolean boolean2 = arrayList0.add(attribute1);
      assertTrue(boolean2 == boolean0);
      assertFalse(boolean2 == boolean1);
      assertFalse(attribute1.equals((Object)attribute0));
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals("", attribute1.getDateFormat());
      assertTrue(attribute1.isRegular());
      assertFalse(attribute1.isNominal());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertEquals((-1), attribute1.index());
      assertTrue(attribute1.hasZeropoint());
      assertEquals(1, attribute1.ordering());
      assertTrue(attribute1.isAveragable());
      assertFalse(attribute1.isDate());
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.isRelationValued());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertEquals(0, attribute1.numValues());
      assertTrue(attribute1.isNumeric());
      assertEquals(Double.NEGATIVE_INFINITY, attribute1.getLowerNumericBound(), 0.01);
      assertEquals(Double.POSITIVE_INFINITY, attribute1.getUpperNumericBound(), 0.01);
      assertEquals(0, attribute1.type());
      assertTrue(boolean2);
      assertEquals(2, Attribute.STRING);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(3, Attribute.DATE);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertNotSame(attribute1, attribute0);
      
      boolean[][] booleanArray1 = new boolean[9][6];
      booleanArray1[0] = booleanArray0;
      ICSSearchAlgorithm.SeparationSet iCSSearchAlgorithm_SeparationSet0 = iCSSearchAlgorithm0.existsSepSet(0, 2, 2, booleanArray1);
      assertNull(iCSSearchAlgorithm_SeparationSet0);
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      
      System.setCurrentTimeMillis(2);
      Enumeration enumeration0 = iCSSearchAlgorithm0.listOptions();
      assertNotNull(enumeration0);
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      assertNotNull(iCSSearchAlgorithm0);
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      
      Instances instances0 = new Instances(" not supported (LMT)", arrayList0, 2229);
      assertNotNull(instances0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.numAttributes());
      
      iCSSearchAlgorithm0.search((BayesNet) null, instances0);
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.numAttributes());
      
      MockRandom mockRandom0 = new MockRandom();
      assertNotNull(mockRandom0);
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      boolean[] booleanArray0 = new boolean[12];
      booleanArray0[0] = true;
      booleanArray0[1] = true;
      booleanArray0[3] = true;
      booleanArray0[11] = true;
      Attribute attribute0 = new Attribute(" not supported (LMT)", instances0);
      assertNotNull(attribute0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.numAttributes());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isNumeric());
      assertEquals("", attribute0.getDateFormat());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals((-1), attribute0.index());
      assertFalse(attribute0.isAveragable());
      assertFalse(attribute0.hasZeropoint());
      assertEquals(4, attribute0.type());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.isRegular());
      assertTrue(attribute0.isRelationValued());
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      
      boolean boolean1 = arrayList0.add(attribute0);
      assertTrue(boolean1 == boolean0);
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(1, instances0.numAttributes());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.isNumeric());
      assertEquals("", attribute0.getDateFormat());
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals((-1), attribute0.index());
      assertFalse(attribute0.isAveragable());
      assertFalse(attribute0.hasZeropoint());
      assertEquals(4, attribute0.type());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals(0, attribute0.ordering());
      assertFalse(attribute0.isRegular());
      assertTrue(attribute0.isRelationValued());
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertTrue(boolean1);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      
      SparseInstance sparseInstance0 = new SparseInstance(1);
      assertNotNull(sparseInstance0);
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(1, sparseInstance0.numValues());
      assertEquals(1, sparseInstance0.numAttributes());
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      boolean[][] booleanArray1 = new boolean[27][9];
      booleanArray1[0] = booleanArray0;
      booleanArray1[1] = booleanArray0;
      booleanArray1[2] = booleanArray0;
      booleanArray1[3] = booleanArray0;
      booleanArray1[4] = booleanArray0;
      booleanArray1[5] = booleanArray0;
      booleanArray1[6] = booleanArray0;
      booleanArray1[1] = booleanArray0;
      ICSSearchAlgorithm.SeparationSet iCSSearchAlgorithm_SeparationSet0 = iCSSearchAlgorithm0.existsSepSet(4, 0, 1, booleanArray1);
      assertNull(iCSSearchAlgorithm_SeparationSet0);
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      ICSSearchAlgorithm iCSSearchAlgorithm0 = new ICSSearchAlgorithm();
      assertNotNull(iCSSearchAlgorithm0);
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      
      Instances instances0 = new Instances(" not supported (LMT)", arrayList0, 2229);
      assertNotNull(instances0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      
      iCSSearchAlgorithm0.search((BayesNet) null, instances0);
      assertEquals("When determining whether an edge exists a search is performed for a set Z that separates the nodes. MaxCardinality determines the maximum size of the set Z. This greatly influences the length of the search. Default value is 2.", iCSSearchAlgorithm0.maxCardinalityTipText());
      assertEquals("This Bayes Network learning algorithm uses conditional independence tests to find a skeleton, finds V-nodes and applies a set of rules to find the directions of the remaining arrows.", iCSSearchAlgorithm0.globalInfo());
      assertEquals("SearchAlgorithm\n", iCSSearchAlgorithm0.toString());
      assertEquals("When set to true (default is false), after a network structure is learned a Markov Blanket correction is applied to the network structure. This ensures that all nodes in the network are part of the Markov blanket of the classifier node.", iCSSearchAlgorithm0.markovBlanketClassifierTipText());
      assertEquals("Set the maximum number of parents a node in the Bayes net can have. When initialized as Naive Bayes, setting this parameter to 1 results in a Naive Bayes classifier. When set to 2, a Tree Augmented Bayes Network (TAN) is learned, and when set >2, a Bayes Net Augmented Bayes Network (BAN) is learned. By setting it to a value much larger than the number of nodes in the network (the default of 100000 pretty much guarantees this), no restriction on the number of parents is enforced", iCSSearchAlgorithm0.maxNrOfParentsTipText());
      assertEquals("When set to true (default), the initial network used for structure learning is a Naive Bayes Network, that is, a network with an arrow from the classifier node to each other node. When set to false, an empty network is used as initial network structure", iCSSearchAlgorithm0.initAsNaiveBayesTipText());
      assertFalse(iCSSearchAlgorithm0.getMarkovBlanketClassifier());
      assertEquals(2, iCSSearchAlgorithm0.getMaxCardinality());
      assertEquals("The score type determines the measure used to judge the quality of a network structure. It can be one of Bayes, BDeu, Minimum Description Length (MDL), Akaike Information Criterion (AIC), and Entropy.", iCSSearchAlgorithm0.scoreTypeTipText());
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      boolean[] booleanArray0 = new boolean[12];
      booleanArray0[0] = true;
      booleanArray0[1] = true;
      booleanArray0[3] = true;
      booleanArray0[11] = true;
      Attribute attribute0 = new Attribute(" not supported (LMT)", instances0);
      assertNotNull(attribute0);
      assertTrue(arrayList0.isEmpty());
      assertEquals(0, arrayList0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(0, instances0.numAttributes());
      assertEquals((-1), attribute0.index());
      assertFalse(attribute0.hasZeropoint());
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertTrue(attribute0.isRelationValued());
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertFalse(attribute0.isRegular());
      assertEquals(4, attribute0.type());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals("", attribute0.getDateFormat());
      assertEquals(0, attribute0.ordering());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertFalse(attribute0.isAveragable());
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(3, Attribute.DATE);
      
      boolean boolean1 = arrayList0.add(attribute0);
      assertTrue(boolean1 == boolean0);
      assertEquals(1, arrayList0.size());
      assertFalse(arrayList0.isEmpty());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals((-1), instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0, instances0.numInstances());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(" not supported (LMT)", instances0.relationName());
      assertEquals(1, instances0.numAttributes());
      assertEquals((-1), attribute0.index());
      assertFalse(attribute0.hasZeropoint());
      assertEquals(0, attribute0.numValues());
      assertFalse(attribute0.lowerNumericBoundIsOpen());
      assertTrue(attribute0.isRelationValued());
      assertEquals(0.0, attribute0.getLowerNumericBound(), 0.01);
      assertEquals(0.0, attribute0.getUpperNumericBound(), 0.01);
      assertFalse(attribute0.isRegular());
      assertEquals(4, attribute0.type());
      assertFalse(attribute0.isString());
      assertFalse(attribute0.isNumeric());
      assertFalse(attribute0.isDate());
      assertFalse(attribute0.isNominal());
      assertFalse(attribute0.upperNumericBoundIsOpen());
      assertEquals("", attribute0.getDateFormat());
      assertEquals(0, attribute0.ordering());
      assertEquals(1.0, attribute0.weight(), 0.01);
      assertFalse(attribute0.isAveragable());
      assertTrue(boolean1);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(3, Attribute.DATE);
      
      Attribute attribute1 = new Attribute((String) null);
      assertNotNull(attribute1);
      assertEquals(0, attribute1.numValues());
      assertTrue(attribute1.isRegular());
      assertFalse(attribute1.isRelationValued());
      assertFalse(attribute1.isDate());
      assertEquals(Double.POSITIVE_INFINITY, attribute1.getUpperNumericBound(), 0.01);
      assertFalse(attribute1.lowerNumericBoundIsOpen());
      assertEquals(Double.NEGATIVE_INFINITY, attribute1.getLowerNumericBound(), 0.01);
      assertEquals(0, attribute1.type());
      assertFalse(attribute1.upperNumericBoundIsOpen());
      assertTrue(attribute1.isNumeric());
      assertFalse(attribute1.isString());
      assertFalse(attribute1.isNominal());
      assertTrue(attribute1.hasZeropoint());
      assertEquals(1.0, attribute1.weight(), 0.01);
      assertEquals(1, attribute1.ordering());
      assertEquals("", attribute1.getDateFormat());
      assertEquals((-1), attribute1.index());
      assertTrue(attribute1.isAveragable());
      assertEquals(0, Attribute.ORDERING_SYMBOLIC);
      assertEquals(1, Attribute.NOMINAL);
      assertEquals(4, Attribute.RELATIONAL);
      assertEquals(2, Attribute.STRING);
      assertEquals(3, Attribute.DATE);
      assertEquals(2, Attribute.ORDERING_MODULO);
      assertEquals(0, Attribute.NUMERIC);
      assertEquals(1, Attribute.ORDERING_ORDERED);
      
      SparseInstance sparseInstance0 = new SparseInstance(0);
      assertNotNull(sparseInstance0);
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(0, sparseInstance0.numValues());
      assertEquals(0, sparseInstance0.numAttributes());
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      boolean[][] booleanArray1 = new boolean[6][6];
      booleanArray1[0] = booleanArray0;
      booleanArray1[1] = booleanArray0;
      booleanArray1[2] = booleanArray0;
      booleanArray1[3] = booleanArray0;
      boolean[] booleanArray2 = new boolean[8];
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      
      booleanArray2[0] = true;
      booleanArray2[1] = true;
      booleanArray2[3] = true;
      booleanArray2[4] = true;
      booleanArray2[5] = true;
      booleanArray2[6] = true;
      booleanArray1[4] = booleanArray2;
      booleanArray1[5] = booleanArray0;
      ICSSearchAlgorithm.SeparationSet[][] iCSSearchAlgorithm_SeparationSetArray0 = new ICSSearchAlgorithm.SeparationSet[3][0];
      ICSSearchAlgorithm.SeparationSet[] iCSSearchAlgorithm_SeparationSetArray1 = new ICSSearchAlgorithm.SeparationSet[0];
      iCSSearchAlgorithm_SeparationSetArray0[0] = iCSSearchAlgorithm_SeparationSetArray1;
      // Undeclared exception!
      try { 
        iCSSearchAlgorithm0.existsSepSet(4, 1, 1, booleanArray1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.bayes.net.search.ci.CISearchAlgorithm", e);
      }
  }
}
