/*
 * This file was automatically generated by EvoSuite
 * Fri Jul 06 16:14:14 GMT 2018
 */

package weka.gui.beans;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.MockitoExtension.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.AWTEvent;
import java.awt.AWTEventMulticaster;
import java.awt.Cursor;
import java.awt.FocusTraversalPolicy;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.GraphicsConfiguration;
import java.awt.HeadlessException;
import java.awt.Insets;
import java.awt.Label;
import java.awt.List;
import java.awt.Point;
import java.awt.event.ComponentListener;
import java.awt.event.InputMethodListener;
import java.awt.event.MouseMotionListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.beans.EventSetDescriptor;
import java.io.IOException;
import java.text.FieldPosition;
import java.text.Format;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Vector;
import javax.swing.JFrame;
import javax.swing.JInternalFrame;
import javax.swing.JToolTip;
import javax.swing.JWindow;
import javax.swing.table.DefaultTableModel;
import javax.swing.text.DefaultCaret;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.time.chrono.MockHijrahDate;
import org.evosuite.runtime.mock.java.time.chrono.MockThaiBuddhistDate;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.util.SystemInUtil;
import org.junit.runner.RunWith;
import sun.awt.HeadlessToolkit;
import weka.classifiers.bayes.BayesNet;
import weka.core.AbstractInstance;
import weka.core.BinarySparseInstance;
import weka.core.Capabilities;
import weka.core.GlobalInfoJavadoc;
import weka.core.Instances;
import weka.core.ListOptions;
import weka.core.ManhattanDistance;
import weka.core.NormalizableDistance;
import weka.core.SparseInstance;
import weka.core.TestInstances;
import weka.core.converters.ArffSaver;
import weka.core.converters.DatabaseLoader;
import weka.core.converters.SVMLightLoader;
import weka.core.converters.TextDirectoryLoader;
import weka.core.tokenizers.WordTokenizer;
import weka.filters.AllFilter;
import weka.filters.MultiFilter;
import weka.filters.supervised.attribute.ClassOrder;
import weka.filters.supervised.attribute.Discretize;
import weka.filters.supervised.attribute.NominalToBinary;
import weka.filters.supervised.instance.SpreadSubsample;
import weka.filters.unsupervised.attribute.Add;
import weka.gui.Logger;
import weka.gui.SysErrLog;
import weka.gui.beans.Appender;
import weka.gui.beans.AttributeSummarizer;
import weka.gui.beans.BeanVisual;
import weka.gui.beans.ClassAssigner;
import weka.gui.beans.ClassValuePicker;
import weka.gui.beans.ClassifierPerformanceEvaluator;
import weka.gui.beans.Clusterer;
import weka.gui.beans.ClustererPerformanceEvaluator;
import weka.gui.beans.ConfigurationListener;
import weka.gui.beans.CrossValidationFoldMaker;
import weka.gui.beans.DataSetEvent;
import weka.gui.beans.DataVisualizer;
import weka.gui.beans.Filter;
import weka.gui.beans.FlowByExpression;
import weka.gui.beans.ImageSaver;
import weka.gui.beans.InstanceEvent;
import weka.gui.beans.InstanceStreamToBatchMaker;
import weka.gui.beans.MetaBean;
import weka.gui.beans.PredictionAppender;
import weka.gui.beans.Saver;
import weka.gui.beans.ScatterPlotMatrix;
import weka.gui.beans.Sorter;
import weka.gui.beans.SubstringLabeler;
import weka.gui.beans.SubstringReplacer;
import weka.gui.beans.TestSetEvent;
import weka.gui.beans.TrainTestSplitMaker;
import weka.gui.beans.TrainingSetEvent;
import weka.gui.beans.TrainingSetListener;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class Filter_ESTest extends Filter_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.useDefaultVisual();
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      filter0.removeConfigurationListener(configurationListener0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Filter filter0 = new Filter();
      boolean boolean0 = filter0.isBusy();
      boolean boolean1 = filter0.eventGeneratable(" V'm(DstQPoj&");
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      Filter filter0 = new Filter();
      Sorter sorter0 = new Sorter();
      filter0.addTestSetListener(sorter0);
      filter0.acceptTrainingSet((TrainingSetEvent) null);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.isFocusable();
      filter0.getBorder();
      filter0.getFocusListeners();
      filter0.getAncestorListeners();
      filter0.getHeight();
      filter0.stop();
      boolean boolean0 = filter0.isBusy();
      MockThaiBuddhistDate mockThaiBuddhistDate0 = new MockThaiBuddhistDate();
      ArffSaver arffSaver0 = new ArffSaver();
      arffSaver0.getInstances();
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(mockThaiBuddhistDate0, (Instances) null, 73, (-242), 0, (-242));
      filter0.acceptTrainingSet(trainingSetEvent0);
      filter0.disconnectionNotification("@relation", arffSaver0);
      boolean boolean1 = filter0.connectionAllowed(" xPjiRc1N+en_\"");
      assertFalse(boolean1 == boolean0);
      
      String string0 = filter0.globalInfo();
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", string0);
      
      DataSetEvent dataSetEvent0 = new DataSetEvent(" xPjiRc1N+en_\"", (Instances) null);
      filter0.acceptDataSet(dataSetEvent0);
      filter0.acceptDataSet(dataSetEvent0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Filter filter0 = new Filter();
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      substringLabeler0.getLocale();
      filter0.addInstanceListener(substringLabeler0);
      FlowByExpression flowByExpression0 = new FlowByExpression();
      InstanceEvent instanceEvent0 = flowByExpression0.m_ie;
      filter0.notifyInstanceListeners(instanceEvent0);
      BeanVisual beanVisual0 = filter0.getVisual();
      assertEquals("weka/gui/beans/icons/DefaultFilter.gif", beanVisual0.getIconPath());
      
      boolean boolean0 = filter0.connectionAllowed(")");
      assertTrue(boolean0);
      
      filter0.stop();
      filter0.connectionNotification("2>)>q", ")");
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Filter filter0 = new Filter();
      // Undeclared exception!
      try { 
        filter0.connectionAllowed((EventSetDescriptor) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      ClassAssigner classAssigner0 = new ClassAssigner();
      BeanVisual beanVisual0 = classAssigner0.m_visual;
      Filter filter0 = new Filter();
      classAssigner0.getConnectedFormat();
      TestSetEvent testSetEvent0 = new TestSetEvent(beanVisual0, (Instances) null, 2, 1);
      filter0.acceptTestSet(testSetEvent0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Filter filter0 = new Filter();
      SpreadSubsample spreadSubsample0 = new SpreadSubsample();
      weka.filters.Filter filter1 = weka.filters.Filter.makeCopy(spreadSubsample0);
      filter0.setFilter(filter1);
      filter0.stop();
      filter0.removeTrainingSetListener((TrainingSetListener) null);
      assertEquals("SpreadSubsample", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Filter filter0 = new Filter();
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getStructure();
      TestSetEvent testSetEvent0 = new TestSetEvent(instances0, instances0, 46, (-40));
      testSetEvent0.m_setNumber = 46;
      filter0.acceptTestSet(testSetEvent0);
      filter0.getGraphicsConfiguration();
      JFrame jFrame0 = null;
      try {
        jFrame0 = new JFrame((GraphicsConfiguration) null);
        fail("Expecting exception: HeadlessException");
      
      } catch(HeadlessException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.awt.GraphicsEnvironment", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.acceptTrainingSet((TrainingSetEvent) null);
      filter0.acceptTrainingSet((TrainingSetEvent) null);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Filter filter0 = new Filter();
      MetaBean metaBean0 = new MetaBean();
      Vector vector0 = metaBean0.m_inputs;
      DefaultTableModel defaultTableModel0 = new DefaultTableModel(vector0, vector0);
      filter0.connectionNotification(".arff", defaultTableModel0);
      filter0.acceptInstance((InstanceEvent) null);
      filter0.getVisual();
      CrossValidationFoldMaker crossValidationFoldMaker0 = new CrossValidationFoldMaker();
      crossValidationFoldMaker0.getStructure("weka/gui/beans/icons/");
      try { 
        Capabilities.forInstances((Instances) null, false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.core.Capabilities", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Filter filter0 = new Filter();
      String string0 = filter0.getCustomName();
      assertEquals("AllFilter", string0);
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      filter0.addConfigurationListener(configurationListener0);
      filter0.requestFocus();
      Saver saver0 = new Saver();
      saver0.removeAll();
      filter0.addInstanceListener(saver0);
      Appender appender0 = new Appender();
      DefaultCaret defaultCaret0 = new DefaultCaret();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      filter0.connectionNotification("i: ", appender0);
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      substringLabeler0.createVolatileImage(12, (-28));
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      PredictionAppender predictionAppender0 = new PredictionAppender();
      PredictionAppender predictionAppender1 = new PredictionAppender();
      InstanceEvent instanceEvent0 = substringLabeler0.m_ie;
      filter0.acceptInstance(instanceEvent0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Filter filter0 = new Filter();
      Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
      FieldPosition fieldPosition0 = new FieldPosition(format_Field0, (-1289));
      Format.Field format_Field1 = fieldPosition0.getFieldAttribute();
      // Undeclared exception!
      try { 
        filter0.setWrappedAlgorithm(format_Field1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // class $java.text.Format$Field$$EnhancerByMockitoWithCGLIB$$2420622f : incorrect type of algorithm (Filter)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Filter filter0 = new Filter();
      Appender appender0 = new Appender();
      InstanceEvent instanceEvent0 = appender0.m_ie;
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      filter0.useDefaultVisual();
      textDirectoryLoader0.getDataSet();
      textDirectoryLoader0.getRevision();
      DefaultCaret defaultCaret0 = new DefaultCaret();
      defaultCaret0.intersects((double) 2, (double) 1, 0.0, 31.631);
      boolean boolean0 = appender0.m_busy;
      DefaultCaret defaultCaret1 = new DefaultCaret();
      defaultCaret1.getMark();
      FileSystemHandling.shouldAllThrowIOExceptions();
      filter0.eventGeneratable(".arff");
      ClassOrder classOrder0 = new ClassOrder();
      FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      InstanceEvent instanceEvent1 = appender0.m_ie;
      instanceEvent0.setStatus(0);
      AttributeSummarizer attributeSummarizer0 = new AttributeSummarizer();
      filter0.connectionNotification("instance", attributeSummarizer0);
      MultiFilter multiFilter0 = new MultiFilter();
      BayesNet bayesNet0 = new BayesNet();
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "\n--- Exception caught ---\n");
      instanceEvent1.setStatus(2);
      filter0.acceptInstance(instanceEvent1);
      WordTokenizer wordTokenizer0 = new WordTokenizer();
      ClassOrder classOrder1 = new ClassOrder();
      // Undeclared exception!
      try { 
        classOrder1.getOutputFormat();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // No output format defined.
         //
         verifyException("weka.filters.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.getCustomName();
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      filter0.addConfigurationListener(configurationListener0);
      filter0.requestFocus();
      Saver saver0 = new Saver();
      saver0.removeAll();
      filter0.addInstanceListener(saver0);
      Appender appender0 = new Appender();
      DefaultCaret defaultCaret0 = new DefaultCaret();
      appender0.removeMouseMotionListener(defaultCaret0);
      defaultCaret0.getMarkBias();
      filter0.getInputMethodListeners();
      Logger logger0 = appender0.m_log;
      ClassOrder classOrder0 = new ClassOrder();
      weka.filters.Filter.makeCopy(classOrder0);
      filter0.setFilter(classOrder0);
      ListOptions listOptions0 = new ListOptions();
      filter0.connectionNotification("$N`5(?.gjM:", listOptions0);
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      substringLabeler0.createVolatileImage((-851), (-682));
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      PredictionAppender predictionAppender0 = new PredictionAppender();
      InstanceEvent instanceEvent0 = substringLabeler0.m_ie;
      filter0.useDefaultVisual();
      filter0.connectionNotification("$N`5(?.gjM:", (Object) null);
      System.setCurrentTimeMillis(2);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      Filter filter0 = new Filter();
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      ClassOrder classOrder0 = new ClassOrder();
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      Appender appender0 = new Appender();
      boolean boolean0 = substringLabeler0.m_busy;
      filter0.getInputMethodListeners();
      appender0.setDebugGraphicsOptions(2);
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      ClustererPerformanceEvaluator clustererPerformanceEvaluator0 = new ClustererPerformanceEvaluator();
      GlobalInfoJavadoc globalInfoJavadoc0 = new GlobalInfoJavadoc();
      DataSetEvent dataSetEvent0 = new DataSetEvent(globalInfoJavadoc0, instances0);
      filter0.acceptDataSet(dataSetEvent0);
      filter0.setCustomName("\tNormalize document length (use in conjunction with -norm and -lnorm)");
      // Undeclared exception!
      try { 
        filter0.performRequest(".bsi");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // .bsi not supported (Filter)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals(2, instances0.numAttributes());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numInstances());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      HashSet<DataSetEvent> hashSet0 = new HashSet<DataSetEvent>();
      assertNotNull(hashSet0);
      assertEquals(0, hashSet0.size());
      assertTrue(hashSet0.isEmpty());
      
      CrossValidationFoldMaker crossValidationFoldMaker0 = new CrossValidationFoldMaker();
      assertNotNull(crossValidationFoldMaker0);
      assertEquals(10, crossValidationFoldMaker0.getFolds());
      assertFalse(crossValidationFoldMaker0.getPreserveOrder());
      assertEquals("Split an incoming data set into cross validation folds. Separate train and test sets are produced for each of the k folds.", crossValidationFoldMaker0.globalInfo());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicyProvider());
      assertEquals("The randomization seed", crossValidationFoldMaker0.seedTipText());
      assertTrue(crossValidationFoldMaker0.getFocusTraversalKeysEnabled());
      assertEquals("The number of train and test splits to produce", crossValidationFoldMaker0.foldsTipText());
      assertFalse(crossValidationFoldMaker0.getIgnoreRepaint());
      assertFalse(crossValidationFoldMaker0.isBusy());
      assertEquals("CrossValidationFoldMaker", crossValidationFoldMaker0.getCustomName());
      assertFalse(crossValidationFoldMaker0.isFocusCycleRoot());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicySet());
      assertEquals(1, crossValidationFoldMaker0.getSeed());
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(crossValidationFoldMaker0, instances0);
      assertNotNull(trainingSetEvent0);
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals(2, instances0.numAttributes());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numInstances());
      assertEquals(10, crossValidationFoldMaker0.getFolds());
      assertFalse(crossValidationFoldMaker0.getPreserveOrder());
      assertEquals("Split an incoming data set into cross validation folds. Separate train and test sets are produced for each of the k folds.", crossValidationFoldMaker0.globalInfo());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicyProvider());
      assertEquals("The randomization seed", crossValidationFoldMaker0.seedTipText());
      assertTrue(crossValidationFoldMaker0.getFocusTraversalKeysEnabled());
      assertEquals("The number of train and test splits to produce", crossValidationFoldMaker0.foldsTipText());
      assertFalse(crossValidationFoldMaker0.getIgnoreRepaint());
      assertFalse(crossValidationFoldMaker0.isBusy());
      assertEquals("CrossValidationFoldMaker", crossValidationFoldMaker0.getCustomName());
      assertFalse(crossValidationFoldMaker0.isFocusCycleRoot());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicySet());
      assertEquals(1, crossValidationFoldMaker0.getSeed());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      
      FileSystemHandling fileSystemHandling1 = new FileSystemHandling();
      assertNotNull(fileSystemHandling1);
      assertFalse(fileSystemHandling1.equals((Object)fileSystemHandling0));
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals(2, instances0.numAttributes());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numInstances());
      assertEquals(10, crossValidationFoldMaker0.getFolds());
      assertFalse(crossValidationFoldMaker0.getPreserveOrder());
      assertEquals("Split an incoming data set into cross validation folds. Separate train and test sets are produced for each of the k folds.", crossValidationFoldMaker0.globalInfo());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicyProvider());
      assertEquals("The randomization seed", crossValidationFoldMaker0.seedTipText());
      assertTrue(crossValidationFoldMaker0.getFocusTraversalKeysEnabled());
      assertEquals("The number of train and test splits to produce", crossValidationFoldMaker0.foldsTipText());
      assertFalse(crossValidationFoldMaker0.getIgnoreRepaint());
      assertFalse(crossValidationFoldMaker0.isBusy());
      assertEquals("CrossValidationFoldMaker", crossValidationFoldMaker0.getCustomName());
      assertFalse(crossValidationFoldMaker0.isFocusCycleRoot());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicySet());
      assertEquals(1, crossValidationFoldMaker0.getSeed());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      assertNotNull(nominalToBinary0);
      assertFalse(nominalToBinary0.getTransformAllValues());
      assertFalse(nominalToBinary0.getBinaryAttributesNominal());
      assertFalse(nominalToBinary0.isOutputFormatDefined());
      assertEquals("Whether resulting binary attributes will be nominal.", nominalToBinary0.binaryAttributesNominalTipText());
      assertFalse(nominalToBinary0.isFirstBatchDone());
      assertEquals("Whether all nominal values are turned into new attributes, not only if there are more than 2.", nominalToBinary0.transformAllValuesTipText());
      assertTrue(nominalToBinary0.isNewBatch());
      assertFalse(nominalToBinary0.mayRemoveInstanceAfterFirstBatchDone());
      
      String string0 = nominalToBinary0.globalInfo();
      assertNotNull(string0);
      assertEquals("Converts all nominal attributes into binary numeric attributes. An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach). Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al. (i.e. taking the average class value associated with each attribute value into account)\n\nFor more information, see:\n\nL. Breiman, J.H. Friedman, R.A. Olshen, C.J. Stone (1984). Classification and Regression Trees. Wadsworth Inc.", string0);
      assertFalse(nominalToBinary0.getTransformAllValues());
      assertFalse(nominalToBinary0.getBinaryAttributesNominal());
      assertFalse(nominalToBinary0.isOutputFormatDefined());
      assertEquals("Whether resulting binary attributes will be nominal.", nominalToBinary0.binaryAttributesNominalTipText());
      assertFalse(nominalToBinary0.isFirstBatchDone());
      assertEquals("Whether all nominal values are turned into new attributes, not only if there are more than 2.", nominalToBinary0.transformAllValuesTipText());
      assertTrue(nominalToBinary0.isNewBatch());
      assertFalse(nominalToBinary0.mayRemoveInstanceAfterFirstBatchDone());
      
      filter0.setFilter(nominalToBinary0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Converts all nominal attributes into binary numeric attributes</font><br><br> An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach).<br>Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al.<br>(i.e.<br>taking the average class value associated with each attribute value into account)<br><br>For more information, see:<br><br>L.<br>Breiman, J.H.<br>Friedman, R.A.<br>Olshen, C.J.<br>Stone (1984).<br>Classification and Regression Trees.<br>Wadsworth Inc.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("NominalToBinary", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(nominalToBinary0.getTransformAllValues());
      assertFalse(nominalToBinary0.getBinaryAttributesNominal());
      assertFalse(nominalToBinary0.isOutputFormatDefined());
      assertEquals("Whether resulting binary attributes will be nominal.", nominalToBinary0.binaryAttributesNominalTipText());
      assertFalse(nominalToBinary0.isFirstBatchDone());
      assertEquals("Whether all nominal values are turned into new attributes, not only if there are more than 2.", nominalToBinary0.transformAllValuesTipText());
      assertTrue(nominalToBinary0.isNewBatch());
      assertFalse(nominalToBinary0.mayRemoveInstanceAfterFirstBatchDone());
      
      Enumeration enumeration0 = nominalToBinary0.listOptions();
      assertNotNull(enumeration0);
      assertFalse(nominalToBinary0.getTransformAllValues());
      assertFalse(nominalToBinary0.getBinaryAttributesNominal());
      assertFalse(nominalToBinary0.isOutputFormatDefined());
      assertEquals("Whether resulting binary attributes will be nominal.", nominalToBinary0.binaryAttributesNominalTipText());
      assertFalse(nominalToBinary0.isFirstBatchDone());
      assertEquals("Whether all nominal values are turned into new attributes, not only if there are more than 2.", nominalToBinary0.transformAllValuesTipText());
      assertTrue(nominalToBinary0.isNewBatch());
      assertFalse(nominalToBinary0.mayRemoveInstanceAfterFirstBatchDone());
      
      BeanVisual beanVisual0 = filter0.getVisual();
      assertNotNull(beanVisual0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Converts all nominal attributes into binary numeric attributes</font><br><br> An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach).<br>Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al.<br>(i.e.<br>taking the average class value associated with each attribute value into account)<br><br>For more information, see:<br><br>L.<br>Breiman, J.H.<br>Friedman, R.A.<br>Olshen, C.J.<br>Stone (1984).<br>Classification and Regression Trees.<br>Wadsworth Inc.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("NominalToBinary", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("weka/gui/beans/icons/filters.supervised.attribute.NominalToBinary.gif", beanVisual0.getIconPath());
      assertFalse(beanVisual0.isFocusCycleRoot());
      assertEquals("weka/gui/beans/icons/filters.supervised.attribute.NominalToBinary_animated.gif", beanVisual0.getAnimatedIconPath());
      assertFalse(beanVisual0.isFocusTraversalPolicyProvider());
      assertEquals("NominalToBinary", beanVisual0.getText());
      assertFalse(beanVisual0.getIgnoreRepaint());
      assertFalse(beanVisual0.isFocusTraversalPolicySet());
      assertTrue(beanVisual0.getFocusTraversalKeysEnabled());
      assertEquals(2, BeanVisual.EAST_CONNECTOR);
      assertEquals(1, BeanVisual.SOUTH_CONNECTOR);
      assertEquals(3, BeanVisual.WEST_CONNECTOR);
      assertEquals(0, BeanVisual.NORTH_CONNECTOR);
      
      filter0.setWrappedAlgorithm(nominalToBinary0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Converts all nominal attributes into binary numeric attributes</font><br><br> An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach).<br>Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al.<br>(i.e.<br>taking the average class value associated with each attribute value into account)<br><br>For more information, see:<br><br>L.<br>Breiman, J.H.<br>Friedman, R.A.<br>Olshen, C.J.<br>Stone (1984).<br>Classification and Regression Trees.<br>Wadsworth Inc.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("NominalToBinary", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(nominalToBinary0.getTransformAllValues());
      assertFalse(nominalToBinary0.getBinaryAttributesNominal());
      assertFalse(nominalToBinary0.isOutputFormatDefined());
      assertEquals("Whether resulting binary attributes will be nominal.", nominalToBinary0.binaryAttributesNominalTipText());
      assertFalse(nominalToBinary0.isFirstBatchDone());
      assertEquals("Whether all nominal values are turned into new attributes, not only if there are more than 2.", nominalToBinary0.transformAllValuesTipText());
      assertTrue(nominalToBinary0.isNewBatch());
      assertFalse(nominalToBinary0.mayRemoveInstanceAfterFirstBatchDone());
      
      String string1 = "measureMax_leaves_visited";
      ManhattanDistance manhattanDistance0 = new ManhattanDistance();
      assertNotNull(manhattanDistance0);
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", manhattanDistance0.attributeIndicesTipText());
      assertEquals("Set attribute selection mode. If false, only selected attributes in the range will be used in the distance calculation; if true, only non-selected attributes will be used for the calculation.", manhattanDistance0.invertSelectionTipText());
      assertEquals("", manhattanDistance0.toString());
      assertEquals("Whether if the normalization of attributes should be turned off for distance calculation (Default: false i.e. attribute values are normalized). ", manhattanDistance0.dontNormalizeTipText());
      assertFalse(manhattanDistance0.getDontNormalize());
      assertFalse(manhattanDistance0.rangesSet());
      assertEquals(1, NormalizableDistance.R_MAX);
      assertEquals(2, NormalizableDistance.R_WIDTH);
      assertEquals(0, NormalizableDistance.R_MIN);
      
      Enumeration enumeration1 = manhattanDistance0.listOptions();
      assertNotSame(enumeration1, enumeration0);
      assertNotNull(enumeration1);
      assertFalse(enumeration1.equals((Object)enumeration0));
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", manhattanDistance0.attributeIndicesTipText());
      assertEquals("Set attribute selection mode. If false, only selected attributes in the range will be used in the distance calculation; if true, only non-selected attributes will be used for the calculation.", manhattanDistance0.invertSelectionTipText());
      assertEquals("", manhattanDistance0.toString());
      assertEquals("Whether if the normalization of attributes should be turned off for distance calculation (Default: false i.e. attribute values are normalized). ", manhattanDistance0.dontNormalizeTipText());
      assertFalse(manhattanDistance0.getDontNormalize());
      assertFalse(manhattanDistance0.rangesSet());
      assertEquals(1, NormalizableDistance.R_MAX);
      assertEquals(2, NormalizableDistance.R_WIDTH);
      assertEquals(0, NormalizableDistance.R_MIN);
      
      filter0.setVisible(false);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Converts all nominal attributes into binary numeric attributes</font><br><br> An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach).<br>Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al.<br>(i.e.<br>taking the average class value associated with each attribute value into account)<br><br>For more information, see:<br><br>L.<br>Breiman, J.H.<br>Friedman, R.A.<br>Olshen, C.J.<br>Stone (1984).<br>Classification and Regression Trees.<br>Wadsworth Inc.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("NominalToBinary", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      try { 
        manhattanDistance0.initializeRanges((int[]) null, (-1404), 76);
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // No instances supplied.
         //
         verifyException("weka.core.NormalizableDistance", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      
      String string0 = filter0.getCustomName();
      assertNotNull(string0);
      assertEquals("AllFilter", string0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      
      Saver saver0 = new Saver();
      assertNotNull(saver0);
      assertEquals("ArffSaver", saver0.getCustomName());
      assertTrue(saver0.getRelationNameForFilename());
      assertTrue(saver0.getFocusTraversalKeysEnabled());
      assertFalse(saver0.isFocusTraversalPolicyProvider());
      assertFalse(saver0.isFocusCycleRoot());
      assertFalse(saver0.isBusy());
      assertFalse(saver0.isFocusTraversalPolicySet());
      assertFalse(saver0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Writes to a destination that is in arff (attribute relation file format) format</font><br><br> The data can be compressed with gzip in order to save space.<br></html>", saver0.globalInfo());
      
      DefaultCaret defaultCaret0 = new DefaultCaret();
      assertNotNull(defaultCaret0);
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertEquals(0, defaultCaret0.width);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.y);
      
      InputMethodListener[] inputMethodListenerArray0 = filter0.getInputMethodListeners();
      assertNotNull(inputMethodListenerArray0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      
      BayesNet bayesNet0 = new BayesNet();
      assertNotNull(bayesNet0);
      assertFalse(bayesNet0.getDebug());
      assertEquals(2, bayesNet0.graphType());
      assertEquals("Bayes Network learning using various search algorithms and quality measures.\nBase class for a Bayes Network classifier. Provides datastructures (network structure, conditional probability distributions, etc.) and facilities common to Bayes Network learning algorithms like K2 and B.\n\nFor more information see:\n\nhttp://www.cs.waikato.ac.nz/~remco/weka.pdf", bayesNet0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", bayesNet0.debugTipText());
      assertFalse(bayesNet0.getUseADTree());
      assertEquals("When ADTree (the data structure for increasing speed on counts, not to be confused with the classifier under the same name) is used learning time goes down typically. However, because ADTrees are memory intensive, memory problems may occur. Switching this option off makes the structure learning algorithms slower, and run with less memory. By default, ADTrees are used.", bayesNet0.useADTreeTipText());
      assertEquals("Select Estimator algorithm for finding the conditional probability tables of the Bayes Network.", bayesNet0.estimatorTipText());
      assertEquals("Set the name of a file in BIF XML format. A Bayes network learned from data can be compared with the Bayes network represented by the BIF file. Statistics calculated are o.a. the number of missing and extra arcs.", bayesNet0.BIFFileTipText());
      assertEquals("Select method used for searching network structures.", bayesNet0.searchAlgorithmTipText());
      
      weka.filters.Filter[] filterArray0 = weka.filters.Filter.makeCopies(multiFilter0, 0);
      assertNotNull(filterArray0);
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      
      DataSetEvent dataSetEvent0 = new DataSetEvent(multiFilter0, (Instances) null);
      assertNotNull(dataSetEvent0);
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(dataSetEvent0.isStructureOnly());
      
      filter0.disconnectionNotification("AllFilter", dataSetEvent0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(dataSetEvent0.isStructureOnly());
      
      filter0.setFilter(multiFilter0);
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "AllFilter");
      assertFalse(boolean0);
      
      MultiFilter multiFilter1 = (MultiFilter)filter0.getFilter();
      assertSame(multiFilter1, multiFilter0);
      assertNotNull(multiFilter1);
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(multiFilter1.getDebug());
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      assertFalse(multiFilter1.isFirstBatchDone());
      assertTrue(multiFilter1.isNewBatch());
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      
      boolean boolean1 = filter0.eventGeneratable("Center");
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      
      InstanceEvent instanceEvent0 = substringLabeler0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      
      String string0 = "h";
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      ClassOrder classOrder0 = new ClassOrder();
      assertNotNull(classOrder0);
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder0.globalInfo());
      assertEquals("Specify the class order after the filtering", classOrder0.classOrderTipText());
      assertEquals(0, classOrder0.getClassOrder());
      assertEquals(1L, classOrder0.getSeed());
      assertFalse(classOrder0.isOutputFormatDefined());
      assertFalse(classOrder0.isFirstBatchDone());
      assertTrue(classOrder0.isNewBatch());
      assertFalse(classOrder0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Specify the seed of randomization of the class order", classOrder0.seedTipText());
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      assertEquals(2, ClassOrder.RANDOM);
      
      DefaultCaret defaultCaret0 = new DefaultCaret();
      assertNotNull(defaultCaret0);
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0, defaultCaret0.y);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.width);
      assertEquals(0, defaultCaret0.x);
      
      MouseMotionListener mouseMotionListener0 = AWTEventMulticaster.add((MouseMotionListener) defaultCaret0, (MouseMotionListener) defaultCaret0);
      assertNotNull(mouseMotionListener0);
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0, defaultCaret0.y);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.width);
      assertEquals(0, defaultCaret0.x);
      
      MouseMotionListener mouseMotionListener1 = AWTEventMulticaster.remove(mouseMotionListener0, mouseMotionListener0);
      assertNull(mouseMotionListener1);
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0, defaultCaret0.y);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.width);
      assertEquals(0, defaultCaret0.x);
      
      int int0 = Font.ITALIC;
      assertEquals(2, int0);
      
      InstanceStreamToBatchMaker instanceStreamToBatchMaker0 = new InstanceStreamToBatchMaker();
      assertNotNull(instanceStreamToBatchMaker0);
      assertTrue(instanceStreamToBatchMaker0.getFocusTraversalKeysEnabled());
      assertEquals("InstanceStreamToBatchMaker", instanceStreamToBatchMaker0.getCustomName());
      assertFalse(instanceStreamToBatchMaker0.getIgnoreRepaint());
      assertFalse(instanceStreamToBatchMaker0.isFocusCycleRoot());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicyProvider());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicySet());
      assertFalse(instanceStreamToBatchMaker0.isBusy());
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      
      filter0.connectionNotification("h", multiFilter0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      
      boolean boolean1 = filter0.eventGeneratable("h");
      assertTrue(boolean1 == boolean0);
      assertTrue(boolean1);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.getNominalBinary());
      
      FlowByExpression flowByExpression0 = new FlowByExpression();
      assertNotNull(flowByExpression0);
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertFalse(flowByExpression0.isBusy());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertEquals("", flowByExpression0.getExpressionString());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      
      ImageSaver imageSaver0 = new ImageSaver();
      assertNotNull(imageSaver0);
      assertFalse(imageSaver0.isFocusTraversalPolicySet());
      assertTrue(imageSaver0.getFocusTraversalKeysEnabled());
      assertNull(imageSaver0.getFilename());
      assertFalse(imageSaver0.isBusy());
      assertFalse(imageSaver0.getIgnoreRepaint());
      assertEquals("ImageSaver", imageSaver0.getCustomName());
      assertFalse(imageSaver0.isFocusCycleRoot());
      assertFalse(imageSaver0.isFocusTraversalPolicyProvider());
      assertEquals("Save static images (such as those produced by ModelPerformanceChart) to a file.", imageSaver0.globalInfo());
      
      Sorter sorter0 = new Sorter();
      assertNotNull(sorter0);
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isFocusCycleRoot());
      assertEquals("10000", sorter0.getBufferSize());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isBusy());
      assertEquals("", sorter0.getTempDirectory());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.getIgnoreRepaint());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorter", sorter0.getCustomName());
      
      Instances instances0 = sorter0.getConnectedFormat();
      assertNull(instances0);
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isFocusCycleRoot());
      assertEquals("10000", sorter0.getBufferSize());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isBusy());
      assertEquals("", sorter0.getTempDirectory());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.getIgnoreRepaint());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorter", sorter0.getCustomName());
      
      filter0.acceptTrainingSet((TrainingSetEvent) null);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      
      TrainingSetEvent trainingSetEvent0 = null;
      try {
        trainingSetEvent0 = new TrainingSetEvent((Object) null, (Instances) null);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // null source
         //
         verifyException("java.util.EventObject", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      
      DefaultCaret defaultCaret0 = new DefaultCaret();
      assertNotNull(defaultCaret0);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.y);
      assertEquals(0, defaultCaret0.width);
      
      defaultCaret0.width = 0;
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      
      boolean boolean0 = defaultCaret0.intersects((double) 0, (double) 0, (double) 0, 31.631);
      assertFalse(boolean0);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.y);
      assertEquals(0, defaultCaret0.width);
      
      boolean boolean1 = filter0.eventGeneratable("configuration");
      assertFalse(boolean1 == boolean0);
      assertTrue(boolean1);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      
      FlowByExpression flowByExpression0 = new FlowByExpression();
      assertNotNull(flowByExpression0);
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertFalse(flowByExpression0.isBusy());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertEquals("", flowByExpression0.getExpressionString());
      assertEquals("", flowByExpression0.getTrueStepName());
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isOutputFormatDefined());
      
      List list0 = null;
      try {
        list0 = new List();
        fail("Expecting exception: HeadlessException");
      
      } catch(HeadlessException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.awt.GraphicsEnvironment", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      
      InstanceEvent instanceEvent0 = substringLabeler0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      SparseInstance sparseInstance0 = new SparseInstance(0);
      assertNotNull(sparseInstance0);
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(0, sparseInstance0.numValues());
      assertEquals(0, sparseInstance0.numAttributes());
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      instanceEvent0.setInstance(sparseInstance0);
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(0, sparseInstance0.numValues());
      assertEquals(0, sparseInstance0.numAttributes());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      
      Enumeration enumeration0 = multiFilter0.listOptions();
      assertNotNull(enumeration0);
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      
      appender0.transferFocusUpCycle();
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      
      filter0.setFilter(multiFilter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      
      instanceEvent0.setStatus(1);
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      instanceEvent0.setInstance(sparseInstance0);
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(0, sparseInstance0.numValues());
      assertEquals(0, sparseInstance0.numAttributes());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      boolean boolean0 = FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, true);
      assertFalse(boolean0);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      Saver saver0 = new Saver();
      assertNotNull(saver0);
      assertEquals("<html><font color=blue>Writes to a destination that is in arff (attribute relation file format) format</font><br><br> The data can be compressed with gzip in order to save space.<br></html>", saver0.globalInfo());
      assertEquals("ArffSaver", saver0.getCustomName());
      assertTrue(saver0.getRelationNameForFilename());
      assertFalse(saver0.getIgnoreRepaint());
      assertTrue(saver0.getFocusTraversalKeysEnabled());
      assertFalse(saver0.isFocusTraversalPolicySet());
      assertFalse(saver0.isBusy());
      assertFalse(saver0.isFocusCycleRoot());
      assertFalse(saver0.isFocusTraversalPolicyProvider());
      
      filter0.addConfigurationListener(configurationListener0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      
      DefaultCaret defaultCaret0 = new DefaultCaret();
      assertNotNull(defaultCaret0);
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0, defaultCaret0.y);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.width);
      
      AffineTransform affineTransform0 = new AffineTransform();
      assertNotNull(affineTransform0);
      assertEquals(0.0, affineTransform0.getTranslateY(), 0.01);
      assertEquals(0.0, affineTransform0.getTranslateX(), 0.01);
      assertEquals(1.0, affineTransform0.getScaleY(), 0.01);
      assertEquals(0.0, affineTransform0.getShearX(), 0.01);
      assertEquals(0.0, affineTransform0.getShearY(), 0.01);
      assertEquals(1.0, affineTransform0.getDeterminant(), 0.01);
      assertEquals(1.0, affineTransform0.getScaleX(), 0.01);
      
      Line2D.Double line2D_Double0 = new Line2D.Double();
      assertNotNull(line2D_Double0);
      assertEquals(0.0, line2D_Double0.x2, 0.01);
      assertEquals(0.0, line2D_Double0.y1, 0.01);
      assertEquals(0.0, line2D_Double0.x1, 0.01);
      assertEquals(0.0, line2D_Double0.y2, 0.01);
      
      Rectangle2D.Double rectangle2D_Double0 = (Rectangle2D.Double)line2D_Double0.getBounds2D();
      assertNotNull(rectangle2D_Double0);
      assertEquals(0.0, rectangle2D_Double0.getMinX(), 0.01);
      assertEquals(0.0, rectangle2D_Double0.getCenterX(), 0.01);
      assertEquals(0.0, rectangle2D_Double0.getMinY(), 0.01);
      assertEquals(0.0, rectangle2D_Double0.getMaxY(), 0.01);
      assertEquals(0.0, rectangle2D_Double0.getMaxX(), 0.01);
      assertEquals(0.0, rectangle2D_Double0.getCenterY(), 0.01);
      assertEquals(0.0, line2D_Double0.x2, 0.01);
      assertEquals(0.0, line2D_Double0.y1, 0.01);
      assertEquals(0.0, line2D_Double0.x1, 0.01);
      assertEquals(0.0, line2D_Double0.y2, 0.01);
      assertEquals(0.0, rectangle2D_Double0.height, 0.01);
      assertEquals(0.0, rectangle2D_Double0.y, 0.01);
      assertEquals(0.0, rectangle2D_Double0.x, 0.01);
      assertEquals(0.0, rectangle2D_Double0.width, 0.01);
      
      Point point0 = new Point();
      assertNotNull(point0);
      assertEquals(0.0, point0.getX(), 0.01);
      assertEquals(0.0, point0.getY(), 0.01);
      assertEquals(0, point0.x);
      assertEquals(0, point0.y);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      
      int int0 = AWTEvent.RESERVED_ID_MAX;
      assertEquals(1999, int0);
      
      InstanceEvent instanceEvent0 = substringLabeler0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      InstanceStreamToBatchMaker instanceStreamToBatchMaker0 = new InstanceStreamToBatchMaker();
      assertNotNull(instanceStreamToBatchMaker0);
      assertEquals("InstanceStreamToBatchMaker", instanceStreamToBatchMaker0.getCustomName());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicyProvider());
      assertFalse(instanceStreamToBatchMaker0.isBusy());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicySet());
      assertFalse(instanceStreamToBatchMaker0.isFocusCycleRoot());
      assertTrue(instanceStreamToBatchMaker0.getFocusTraversalKeysEnabled());
      assertFalse(instanceStreamToBatchMaker0.getIgnoreRepaint());
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      
      instanceEvent0.setStatus(1999);
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertEquals(1999, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      filter0.setFilter(multiFilter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      
      MultiFilter multiFilter1 = new MultiFilter();
      assertNotNull(multiFilter1);
      assertFalse(multiFilter1.equals((Object)multiFilter0));
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      assertTrue(multiFilter1.isNewBatch());
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertFalse(multiFilter1.getDebug());
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      assertFalse(multiFilter1.isFirstBatchDone());
      
      FocusTraversalPolicy focusTraversalPolicy0 = filter0.getFocusTraversalPolicy();
      assertNull(focusTraversalPolicy0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      
      Saver saver0 = new Saver();
      assertNotNull(saver0);
      assertFalse(saver0.getIgnoreRepaint());
      assertFalse(saver0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>Writes to a destination that is in arff (attribute relation file format) format</font><br><br> The data can be compressed with gzip in order to save space.<br></html>", saver0.globalInfo());
      assertFalse(saver0.isFocusTraversalPolicyProvider());
      assertFalse(saver0.isBusy());
      assertTrue(saver0.getRelationNameForFilename());
      assertTrue(saver0.getFocusTraversalKeysEnabled());
      assertEquals("ArffSaver", saver0.getCustomName());
      assertFalse(saver0.isFocusTraversalPolicySet());
      
      BeanVisual beanVisual0 = saver0.m_visual;
      assertNotNull(beanVisual0);
      assertTrue(beanVisual0.getFocusTraversalKeysEnabled());
      assertEquals("ArffSaver", beanVisual0.getText());
      assertFalse(beanVisual0.getIgnoreRepaint());
      assertFalse(beanVisual0.isFocusTraversalPolicySet());
      assertEquals("weka/gui/beans/icons/DefaultDataSink_animated.gif", beanVisual0.getAnimatedIconPath());
      assertFalse(beanVisual0.isFocusCycleRoot());
      assertFalse(beanVisual0.isFocusTraversalPolicyProvider());
      assertEquals("weka/gui/beans/icons/DefaultDataSink.gif", beanVisual0.getIconPath());
      assertEquals(2, BeanVisual.EAST_CONNECTOR);
      assertEquals(3, BeanVisual.WEST_CONNECTOR);
      assertEquals(0, BeanVisual.NORTH_CONNECTOR);
      assertEquals(1, BeanVisual.SOUTH_CONNECTOR);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertEquals(1999, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      CrossValidationFoldMaker crossValidationFoldMaker0 = new CrossValidationFoldMaker();
      assertNotNull(crossValidationFoldMaker0);
      assertEquals("Split an incoming data set into cross validation folds. Separate train and test sets are produced for each of the k folds.", crossValidationFoldMaker0.globalInfo());
      assertEquals(1, crossValidationFoldMaker0.getSeed());
      assertTrue(crossValidationFoldMaker0.getFocusTraversalKeysEnabled());
      assertEquals("CrossValidationFoldMaker", crossValidationFoldMaker0.getCustomName());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicyProvider());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicySet());
      assertFalse(crossValidationFoldMaker0.isFocusCycleRoot());
      assertEquals("The randomization seed", crossValidationFoldMaker0.seedTipText());
      assertFalse(crossValidationFoldMaker0.getIgnoreRepaint());
      assertEquals(10, crossValidationFoldMaker0.getFolds());
      assertFalse(crossValidationFoldMaker0.isBusy());
      assertEquals("The number of train and test splits to produce", crossValidationFoldMaker0.foldsTipText());
      assertFalse(crossValidationFoldMaker0.getPreserveOrder());
      
      ComponentListener[] componentListenerArray0 = crossValidationFoldMaker0.getComponentListeners();
      assertNotNull(componentListenerArray0);
      assertEquals("Split an incoming data set into cross validation folds. Separate train and test sets are produced for each of the k folds.", crossValidationFoldMaker0.globalInfo());
      assertEquals(1, crossValidationFoldMaker0.getSeed());
      assertTrue(crossValidationFoldMaker0.getFocusTraversalKeysEnabled());
      assertEquals("CrossValidationFoldMaker", crossValidationFoldMaker0.getCustomName());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicyProvider());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicySet());
      assertFalse(crossValidationFoldMaker0.isFocusCycleRoot());
      assertEquals("The randomization seed", crossValidationFoldMaker0.seedTipText());
      assertFalse(crossValidationFoldMaker0.getIgnoreRepaint());
      assertEquals(10, crossValidationFoldMaker0.getFolds());
      assertFalse(crossValidationFoldMaker0.isBusy());
      assertEquals("The number of train and test splits to produce", crossValidationFoldMaker0.foldsTipText());
      assertFalse(crossValidationFoldMaker0.getPreserveOrder());
      
      filter0.removeTestSetListener(crossValidationFoldMaker0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("Split an incoming data set into cross validation folds. Separate train and test sets are produced for each of the k folds.", crossValidationFoldMaker0.globalInfo());
      assertEquals(1, crossValidationFoldMaker0.getSeed());
      assertTrue(crossValidationFoldMaker0.getFocusTraversalKeysEnabled());
      assertEquals("CrossValidationFoldMaker", crossValidationFoldMaker0.getCustomName());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicyProvider());
      assertFalse(crossValidationFoldMaker0.isFocusTraversalPolicySet());
      assertFalse(crossValidationFoldMaker0.isFocusCycleRoot());
      assertEquals("The randomization seed", crossValidationFoldMaker0.seedTipText());
      assertFalse(crossValidationFoldMaker0.getIgnoreRepaint());
      assertEquals(10, crossValidationFoldMaker0.getFolds());
      assertFalse(crossValidationFoldMaker0.isBusy());
      assertEquals("The number of train and test splits to produce", crossValidationFoldMaker0.foldsTipText());
      assertFalse(crossValidationFoldMaker0.getPreserveOrder());
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      HeadlessToolkit headlessToolkit0 = (HeadlessToolkit)filter0.getToolkit();
      assertNotNull(headlessToolkit0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      
      // Undeclared exception!
      try { 
        filter0.performRequest("R");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // R not supported (Filter)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      
      SysErrLog sysErrLog0 = new SysErrLog();
      assertNotNull(sysErrLog0);
      
      sysErrLog0.logMessage("NO:");
      filter0.setLog(sysErrLog0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicySet());
      
      ClassOrder classOrder0 = new ClassOrder();
      assertNotNull(classOrder0);
      assertFalse(classOrder0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(classOrder0.isNewBatch());
      assertEquals(1L, classOrder0.getSeed());
      assertEquals("Specify the seed of randomization of the class order", classOrder0.seedTipText());
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder0.globalInfo());
      assertFalse(classOrder0.isOutputFormatDefined());
      assertEquals(0, classOrder0.getClassOrder());
      assertEquals("Specify the class order after the filtering", classOrder0.classOrderTipText());
      assertFalse(classOrder0.isFirstBatchDone());
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      assertEquals(2, ClassOrder.RANDOM);
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      Enumeration enumeration0 = filter0.enumerateRequests();
      assertNotNull(enumeration0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertEquals("", substringLabeler0.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      
      SVMLightLoader sVMLightLoader0 = new SVMLightLoader();
      assertNotNull(sVMLightLoader0);
      assertEquals(".dat", sVMLightLoader0.getFileExtension());
      assertEquals("http://", sVMLightLoader0.retrieveURL());
      assertEquals("Use relative rather than absolute paths", sVMLightLoader0.useRelativePathTipText());
      assertFalse(sVMLightLoader0.getUseRelativePath());
      assertEquals("svm light data files", sVMLightLoader0.getFileDescription());
      assertEquals("Reads a source that is in svm light format.\n\nFor more information about svm light see:\n\nhttp://svmlight.joachims.org/", sVMLightLoader0.globalInfo());
      
      try { 
        sVMLightLoader0.getStructure();
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // No source has been specified
         //
         verifyException("weka.core.converters.SVMLightLoader", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      ClassOrder classOrder0 = new ClassOrder();
      assertNotNull(classOrder0);
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder0.globalInfo());
      assertEquals("Specify the class order after the filtering", classOrder0.classOrderTipText());
      assertEquals(1L, classOrder0.getSeed());
      assertFalse(classOrder0.isFirstBatchDone());
      assertTrue(classOrder0.isNewBatch());
      assertFalse(classOrder0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Specify the seed of randomization of the class order", classOrder0.seedTipText());
      assertFalse(classOrder0.isOutputFormatDefined());
      assertEquals(0, classOrder0.getClassOrder());
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      assertEquals(2, ClassOrder.RANDOM);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      
      DefaultCaret defaultCaret0 = new DefaultCaret();
      assertNotNull(defaultCaret0);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.width);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.y);
      
      MouseMotionListener mouseMotionListener0 = AWTEventMulticaster.add((MouseMotionListener) defaultCaret0, (MouseMotionListener) defaultCaret0);
      assertNotNull(mouseMotionListener0);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.width);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.y);
      
      MouseMotionListener mouseMotionListener1 = AWTEventMulticaster.remove((MouseMotionListener) defaultCaret0, (MouseMotionListener) defaultCaret0);
      assertNull(mouseMotionListener1);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.width);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.y);
      
      substringLabeler0.removeMouseMotionListener(mouseMotionListener0);
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.width);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.y);
      
      int int0 = Font.ITALIC;
      assertEquals(2, int0);
      
      InstanceStreamToBatchMaker instanceStreamToBatchMaker0 = new InstanceStreamToBatchMaker();
      assertNotNull(instanceStreamToBatchMaker0);
      assertTrue(instanceStreamToBatchMaker0.getFocusTraversalKeysEnabled());
      assertEquals("InstanceStreamToBatchMaker", instanceStreamToBatchMaker0.getCustomName());
      assertFalse(instanceStreamToBatchMaker0.isBusy());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicyProvider());
      assertFalse(instanceStreamToBatchMaker0.isFocusCycleRoot());
      assertFalse(instanceStreamToBatchMaker0.getIgnoreRepaint());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicySet());
      
      boolean boolean1 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean1 == boolean0);
      assertFalse(boolean1);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      
      filter0.connectionNotification("=", instanceStreamToBatchMaker0);
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(instanceStreamToBatchMaker0.getFocusTraversalKeysEnabled());
      assertEquals("InstanceStreamToBatchMaker", instanceStreamToBatchMaker0.getCustomName());
      assertFalse(instanceStreamToBatchMaker0.isBusy());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicyProvider());
      assertFalse(instanceStreamToBatchMaker0.isFocusCycleRoot());
      assertFalse(instanceStreamToBatchMaker0.getIgnoreRepaint());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicySet());
      
      SubstringLabeler substringLabeler1 = new SubstringLabeler();
      assertNotNull(substringLabeler1);
      assertFalse(substringLabeler1.equals((Object)substringLabeler0));
      assertTrue(substringLabeler1.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler1.getConsumeNonMatching());
      assertFalse(substringLabeler1.isFocusTraversalPolicySet());
      assertEquals("", substringLabeler1.getMatchDetails());
      assertFalse(substringLabeler1.getNominalBinary());
      assertEquals("SubstringLabeler", substringLabeler1.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler1.globalInfo());
      assertFalse(substringLabeler1.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler1.getIgnoreRepaint());
      assertEquals("Match", substringLabeler1.getMatchAttributeName());
      assertFalse(substringLabeler1.isFocusCycleRoot());
      assertFalse(substringLabeler1.isBusy());
      
      substringLabeler1.removeInstanceListener(filter0);
      assertNotSame(substringLabeler1, substringLabeler0);
      assertFalse(substringLabeler1.equals((Object)substringLabeler0));
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(substringLabeler1.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler1.getConsumeNonMatching());
      assertFalse(substringLabeler1.isFocusTraversalPolicySet());
      assertEquals("", substringLabeler1.getMatchDetails());
      assertFalse(substringLabeler1.getNominalBinary());
      assertEquals("SubstringLabeler", substringLabeler1.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler1.globalInfo());
      assertFalse(substringLabeler1.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler1.getIgnoreRepaint());
      assertEquals("Match", substringLabeler1.getMatchAttributeName());
      assertFalse(substringLabeler1.isFocusCycleRoot());
      assertFalse(substringLabeler1.isBusy());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      
      appender0.transferFocusUpCycle();
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      
      MockHijrahDate mockHijrahDate0 = new MockHijrahDate();
      assertNotNull(mockHijrahDate0);
      
      MultiFilter multiFilter1 = new MultiFilter();
      assertNotNull(multiFilter1);
      assertFalse(multiFilter1.equals((Object)multiFilter0));
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertFalse(multiFilter1.getDebug());
      assertTrue(multiFilter1.isNewBatch());
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      assertFalse(multiFilter1.isFirstBatchDone());
      
      boolean boolean2 = filter0.eventGeneratable("=");
      assertFalse(boolean2 == boolean0);
      assertTrue(boolean2 == boolean1);
      assertFalse(boolean2);
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      
      SubstringLabeler substringLabeler2 = new SubstringLabeler();
      assertNotNull(substringLabeler2);
      assertFalse(substringLabeler2.equals((Object)substringLabeler1));
      assertFalse(substringLabeler2.equals((Object)substringLabeler0));
      assertFalse(substringLabeler2.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler2.isFocusCycleRoot());
      assertEquals("SubstringLabeler", substringLabeler2.getCustomName());
      assertEquals("Match", substringLabeler2.getMatchAttributeName());
      assertFalse(substringLabeler2.getConsumeNonMatching());
      assertTrue(substringLabeler2.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler2.getNominalBinary());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler2.globalInfo());
      assertEquals("", substringLabeler2.getMatchDetails());
      assertFalse(substringLabeler2.isFocusTraversalPolicySet());
      assertFalse(substringLabeler2.isBusy());
      assertFalse(substringLabeler2.getIgnoreRepaint());
      
      Saver saver0 = new Saver();
      assertNotNull(saver0);
      assertTrue(saver0.getRelationNameForFilename());
      assertEquals("<html><font color=blue>Writes to a destination that is in arff (attribute relation file format) format</font><br><br> The data can be compressed with gzip in order to save space.<br></html>", saver0.globalInfo());
      assertEquals("ArffSaver", saver0.getCustomName());
      assertFalse(saver0.isBusy());
      assertFalse(saver0.isFocusCycleRoot());
      assertFalse(saver0.isFocusTraversalPolicyProvider());
      assertFalse(saver0.getIgnoreRepaint());
      assertFalse(saver0.isFocusTraversalPolicySet());
      assertTrue(saver0.getFocusTraversalKeysEnabled());
      
      DatabaseLoader databaseLoader0 = new DatabaseLoader();
      assertNotNull(databaseLoader0);
      assertEquals("The custom properties that the user can use to override the default ones.", databaseLoader0.customPropsFileTipText());
      assertEquals("The URL of the database", databaseLoader0.urlTipText());
      assertEquals("", databaseLoader0.getPassword());
      assertFalse(databaseLoader0.getSparseData());
      assertEquals("The query that should load the instances.\n The query has to be of the form SELECT <column-list>|* FROM <table> [WHERE <conditions>]", databaseLoader0.queryTipText());
      assertEquals("For incremental loading a unique identiefer has to be specified.\nIf the query includes all columns of a table (SELECT *...) a primary key\ncan be detected automatically depending on the JDBC driver. If that is not possible\nspecify the key columns here in a comma separated list.", databaseLoader0.keysTipText());
      assertEquals("Select * from Results0", databaseLoader0.getQuery());
      assertEquals("The user name for the database", databaseLoader0.userTipText());
      assertEquals("Encode data as sparse instances.", databaseLoader0.sparseDataTipText());
      assertEquals("jdbc:idb=experiments.prp", databaseLoader0.getUrl());
      assertEquals("", databaseLoader0.getUser());
      assertEquals("The database password", databaseLoader0.passwordTipText());
      
      filter0.setCustomName((String) null);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertNull(filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      
      filter0.useDefaultVisual();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertNull(filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      
      DatabaseLoader databaseLoader1 = new DatabaseLoader();
      assertNotNull(databaseLoader1);
      assertFalse(databaseLoader1.equals((Object)databaseLoader0));
      assertEquals("The custom properties that the user can use to override the default ones.", databaseLoader1.customPropsFileTipText());
      assertEquals("The URL of the database", databaseLoader1.urlTipText());
      assertEquals("", databaseLoader1.getPassword());
      assertFalse(databaseLoader1.getSparseData());
      assertEquals("", databaseLoader1.getUser());
      assertEquals("The database password", databaseLoader1.passwordTipText());
      assertEquals("The user name for the database", databaseLoader1.userTipText());
      assertEquals("Encode data as sparse instances.", databaseLoader1.sparseDataTipText());
      assertEquals("jdbc:idb=experiments.prp", databaseLoader1.getUrl());
      assertEquals("The query that should load the instances.\n The query has to be of the form SELECT <column-list>|* FROM <table> [WHERE <conditions>]", databaseLoader1.queryTipText());
      assertEquals("For incremental loading a unique identiefer has to be specified.\nIf the query includes all columns of a table (SELECT *...) a primary key\ncan be detected automatically depending on the JDBC driver. If that is not possible\nspecify the key columns here in a comma separated list.", databaseLoader1.keysTipText());
      assertEquals("Select * from Results0", databaseLoader1.getQuery());
      
      Instances instances0 = databaseLoader1.getStructure();
      assertNotSame(databaseLoader1, databaseLoader0);
      assertNull(instances0);
      assertFalse(databaseLoader1.equals((Object)databaseLoader0));
      assertEquals("The custom properties that the user can use to override the default ones.", databaseLoader1.customPropsFileTipText());
      assertEquals("The URL of the database", databaseLoader1.urlTipText());
      assertEquals("", databaseLoader1.getPassword());
      assertFalse(databaseLoader1.getSparseData());
      assertEquals("", databaseLoader1.getUser());
      assertEquals("The database password", databaseLoader1.passwordTipText());
      assertEquals("The user name for the database", databaseLoader1.userTipText());
      assertEquals("Encode data as sparse instances.", databaseLoader1.sparseDataTipText());
      assertEquals("jdbc:idb=experiments.prp", databaseLoader1.getUrl());
      assertEquals("The query that should load the instances.\n The query has to be of the form SELECT <column-list>|* FROM <table> [WHERE <conditions>]", databaseLoader1.queryTipText());
      assertEquals("For incremental loading a unique identiefer has to be specified.\nIf the query includes all columns of a table (SELECT *...) a primary key\ncan be detected automatically depending on the JDBC driver. If that is not possible\nspecify the key columns here in a comma separated list.", databaseLoader1.keysTipText());
      assertEquals("Select * from Results0", databaseLoader1.getQuery());
      
      // Undeclared exception!
      try { 
        multiFilter1.getCapabilities((Instances) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.filters.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      ClassOrder classOrder0 = new ClassOrder();
      assertNotNull(classOrder0);
      assertEquals("Specify the class order after the filtering", classOrder0.classOrderTipText());
      assertEquals(0, classOrder0.getClassOrder());
      assertTrue(classOrder0.isNewBatch());
      assertFalse(classOrder0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals(1L, classOrder0.getSeed());
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder0.globalInfo());
      assertFalse(classOrder0.isOutputFormatDefined());
      assertFalse(classOrder0.isFirstBatchDone());
      assertEquals("Specify the seed of randomization of the class order", classOrder0.seedTipText());
      assertEquals(2, ClassOrder.RANDOM);
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      
      SysErrLog sysErrLog0 = new SysErrLog();
      assertNotNull(sysErrLog0);
      
      filter0.setLog(sysErrLog0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      
      filter0.setFilter(classOrder0);
      assertEquals("ClassOrder", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Changes the order of the classes so that the class values are no longer of in the order specified in the header</font><br><br> The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order.<br>Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier.<br>The value can also be converted back using 'originalValue(double value)' procedure.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Specify the class order after the filtering", classOrder0.classOrderTipText());
      assertEquals(0, classOrder0.getClassOrder());
      assertTrue(classOrder0.isNewBatch());
      assertFalse(classOrder0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals(1L, classOrder0.getSeed());
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder0.globalInfo());
      assertFalse(classOrder0.isOutputFormatDefined());
      assertFalse(classOrder0.isFirstBatchDone());
      assertEquals("Specify the seed of randomization of the class order", classOrder0.seedTipText());
      assertEquals(2, ClassOrder.RANDOM);
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals("ClassOrder", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Changes the order of the classes so that the class values are no longer of in the order specified in the header</font><br><br> The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order.<br>Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier.<br>The value can also be converted back using 'originalValue(double value)' procedure.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      Enumeration enumeration0 = filter0.enumerateRequests();
      assertNotNull(enumeration0);
      assertEquals("ClassOrder", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Changes the order of the classes so that the class values are no longer of in the order specified in the header</font><br><br> The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order.<br>Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier.<br>The value can also be converted back using 'originalValue(double value)' procedure.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      filter0.setFilter(classOrder0);
      assertEquals("ClassOrder", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Changes the order of the classes so that the class values are no longer of in the order specified in the header</font><br><br> The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order.<br>Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier.<br>The value can also be converted back using 'originalValue(double value)' procedure.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Specify the class order after the filtering", classOrder0.classOrderTipText());
      assertEquals(0, classOrder0.getClassOrder());
      assertTrue(classOrder0.isNewBatch());
      assertFalse(classOrder0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals(1L, classOrder0.getSeed());
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder0.globalInfo());
      assertFalse(classOrder0.isOutputFormatDefined());
      assertFalse(classOrder0.isFirstBatchDone());
      assertEquals("Specify the seed of randomization of the class order", classOrder0.seedTipText());
      assertEquals(2, ClassOrder.RANDOM);
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      
      SVMLightLoader sVMLightLoader0 = new SVMLightLoader();
      assertNotNull(sVMLightLoader0);
      assertEquals(".dat", sVMLightLoader0.getFileExtension());
      assertEquals("http://", sVMLightLoader0.retrieveURL());
      assertEquals("svm light data files", sVMLightLoader0.getFileDescription());
      assertEquals("Reads a source that is in svm light format.\n\nFor more information about svm light see:\n\nhttp://svmlight.joachims.org/", sVMLightLoader0.globalInfo());
      assertFalse(sVMLightLoader0.getUseRelativePath());
      assertEquals("Use relative rather than absolute paths", sVMLightLoader0.useRelativePathTipText());
      
      try { 
        sVMLightLoader0.getStructure();
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // No source has been specified
         //
         verifyException("weka.core.converters.SVMLightLoader", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      SystemInUtil.addInputLine((String) null);
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      
      DefaultCaret defaultCaret0 = new DefaultCaret();
      assertNotNull(defaultCaret0);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0, defaultCaret0.y);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.width);
      
      MouseMotionListener mouseMotionListener0 = AWTEventMulticaster.add((MouseMotionListener) defaultCaret0, (MouseMotionListener) defaultCaret0);
      assertNotNull(mouseMotionListener0);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0, defaultCaret0.y);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.width);
      
      DefaultCaret defaultCaret1 = (DefaultCaret)AWTEventMulticaster.remove(mouseMotionListener0, (MouseMotionListener) defaultCaret0);
      assertSame(defaultCaret0, defaultCaret1);
      assertSame(defaultCaret1, defaultCaret0);
      assertNotNull(defaultCaret1);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret1.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret1.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret1.getWidth(), 0.01);
      assertTrue(defaultCaret1.isEmpty());
      assertEquals(0.0, defaultCaret1.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret1.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret1.getY(), 0.01);
      assertEquals(0.0, defaultCaret1.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret1.getX(), 0.01);
      assertEquals(0.0, defaultCaret1.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret1.getCenterY(), 0.01);
      assertEquals(0, defaultCaret0.y);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.width);
      assertEquals(0, defaultCaret1.x);
      assertEquals(0, defaultCaret1.height);
      assertEquals(0, defaultCaret1.y);
      assertEquals(0, defaultCaret1.width);
      
      substringLabeler0.removeMouseMotionListener(defaultCaret1);
      assertSame(defaultCaret0, defaultCaret1);
      assertSame(defaultCaret1, defaultCaret0);
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret1.getHeight(), 0.01);
      assertEquals(0.0, defaultCaret1.getMaxY(), 0.01);
      assertEquals(0.0, defaultCaret1.getWidth(), 0.01);
      assertTrue(defaultCaret1.isEmpty());
      assertEquals(0.0, defaultCaret1.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret1.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret1.getY(), 0.01);
      assertEquals(0.0, defaultCaret1.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret1.getX(), 0.01);
      assertEquals(0.0, defaultCaret1.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret1.getCenterY(), 0.01);
      assertEquals(0, defaultCaret0.y);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.width);
      assertEquals(0, defaultCaret1.x);
      assertEquals(0, defaultCaret1.height);
      assertEquals(0, defaultCaret1.y);
      assertEquals(0, defaultCaret1.width);
      
      int int0 = Font.ITALIC;
      assertEquals(2, int0);
      
      InstanceStreamToBatchMaker instanceStreamToBatchMaker0 = new InstanceStreamToBatchMaker();
      assertNotNull(instanceStreamToBatchMaker0);
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicyProvider());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicySet());
      assertFalse(instanceStreamToBatchMaker0.isBusy());
      assertFalse(instanceStreamToBatchMaker0.getIgnoreRepaint());
      assertFalse(instanceStreamToBatchMaker0.isFocusCycleRoot());
      assertTrue(instanceStreamToBatchMaker0.getFocusTraversalKeysEnabled());
      assertEquals("InstanceStreamToBatchMaker", instanceStreamToBatchMaker0.getCustomName());
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      
      Clusterer clusterer0 = new Clusterer();
      assertNotNull(clusterer0);
      assertFalse(clusterer0.getIgnoreRepaint());
      assertFalse(clusterer0.isFocusTraversalPolicyProvider());
      assertFalse(clusterer0.isBusy());
      assertFalse(clusterer0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>Simple EM (expectation maximisation) class.\n\nEM assigns a probability distribution to each instance which indicates the probability of it belonging to each of the clusters</font><br><br> EM can decide how many clusters to create by cross validation, or you may specify apriori how many clusters to generate.<br><br>The cross validation performed to determine the number of clusters is done in the following steps:<br>1. the number of clusters is set to 1<br>2. the training set is split randomly into 10 folds.<br>3. EM is performed 10 times using the 10 folds the usual CV way.<br>4. the loglikelihood is averaged over all 10 results.<br>5.<br>if loglikelihood has increased the number of clusters is increased by 1 and the program continues at step 2.<br><br><br>The number of folds is fixed to 10, as long as the number of instances in the training set is not smaller 10.<br>If this is the case the number of folds is set equal to the number of instances.<br></html>", clusterer0.globalInfo());
      assertEquals("EM", clusterer0.getCustomName());
      assertFalse(clusterer0.hasIncomingBatchInstances());
      assertFalse(clusterer0.isFocusTraversalPolicySet());
      assertTrue(clusterer0.getFocusTraversalKeysEnabled());
      
      filter0.connectionNotification("EI&_Z>Q`qhx%* d9", clusterer0);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(clusterer0.getIgnoreRepaint());
      assertFalse(clusterer0.isFocusTraversalPolicyProvider());
      assertFalse(clusterer0.isBusy());
      assertFalse(clusterer0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>Simple EM (expectation maximisation) class.\n\nEM assigns a probability distribution to each instance which indicates the probability of it belonging to each of the clusters</font><br><br> EM can decide how many clusters to create by cross validation, or you may specify apriori how many clusters to generate.<br><br>The cross validation performed to determine the number of clusters is done in the following steps:<br>1. the number of clusters is set to 1<br>2. the training set is split randomly into 10 folds.<br>3. EM is performed 10 times using the 10 folds the usual CV way.<br>4. the loglikelihood is averaged over all 10 results.<br>5.<br>if loglikelihood has increased the number of clusters is increased by 1 and the program continues at step 2.<br><br><br>The number of folds is fixed to 10, as long as the number of instances in the training set is not smaller 10.<br>If this is the case the number of folds is set equal to the number of instances.<br></html>", clusterer0.globalInfo());
      assertEquals("EM", clusterer0.getCustomName());
      assertFalse(clusterer0.hasIncomingBatchInstances());
      assertFalse(clusterer0.isFocusTraversalPolicySet());
      assertTrue(clusterer0.getFocusTraversalKeysEnabled());
      
      SubstringLabeler substringLabeler1 = new SubstringLabeler();
      assertNotNull(substringLabeler1);
      assertFalse(substringLabeler1.equals((Object)substringLabeler0));
      assertEquals("", substringLabeler1.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler1.getCustomName());
      assertFalse(substringLabeler1.getIgnoreRepaint());
      assertFalse(substringLabeler1.isBusy());
      assertTrue(substringLabeler1.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler1.getNominalBinary());
      assertFalse(substringLabeler1.isFocusTraversalPolicySet());
      assertFalse(substringLabeler1.isFocusCycleRoot());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler1.globalInfo());
      assertFalse(substringLabeler1.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler1.getMatchAttributeName());
      assertFalse(substringLabeler1.getConsumeNonMatching());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      
      appender0.transferFocusUpCycle();
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      
      MockHijrahDate mockHijrahDate0 = new MockHijrahDate();
      assertNotNull(mockHijrahDate0);
      
      MultiFilter multiFilter1 = new MultiFilter();
      assertNotNull(multiFilter1);
      assertFalse(multiFilter1.equals((Object)multiFilter0));
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      assertFalse(multiFilter1.isFirstBatchDone());
      assertTrue(multiFilter1.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter1.getDebug());
      
      Filter filter1 = new Filter();
      assertNotNull(filter1);
      assertFalse(filter1.equals((Object)filter0));
      assertFalse(filter1.isBusy());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      
      boolean boolean1 = filter0.eventGeneratable("EI&_Z>Q`qhx%* d9");
      assertNotSame(filter0, filter1);
      assertFalse(filter0.equals((Object)filter1));
      assertTrue(boolean1 == boolean0);
      assertTrue(boolean1);
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      boolean boolean2 = filter1.isBusy();
      assertNotSame(filter1, filter0);
      assertFalse(filter1.equals((Object)filter0));
      assertFalse(boolean2 == boolean1);
      assertFalse(boolean2 == boolean0);
      assertFalse(boolean2);
      assertFalse(filter1.isBusy());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      
      Filter filter2 = new Filter();
      assertNotNull(filter2);
      assertFalse(filter2.equals((Object)filter0));
      assertFalse(filter2.equals((Object)filter1));
      assertFalse(filter2.isFocusTraversalPolicyProvider());
      assertFalse(filter2.isFocusCycleRoot());
      assertFalse(filter2.getIgnoreRepaint());
      assertFalse(filter2.isFocusTraversalPolicySet());
      assertFalse(filter2.isBusy());
      assertTrue(filter2.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter2.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter2.globalInfo());
      
      filter0.addDataSourceListener(appender0);
      assertNotSame(filter0, filter2);
      assertNotSame(filter0, filter1);
      assertFalse(filter0.equals((Object)filter2));
      assertFalse(filter0.equals((Object)filter1));
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      
      Enumeration enumeration0 = filter1.enumerateRequests();
      assertNotSame(filter1, filter0);
      assertNotSame(filter1, filter2);
      assertNotNull(enumeration0);
      assertFalse(filter1.equals((Object)filter0));
      assertFalse(filter1.equals((Object)filter2));
      assertFalse(filter1.isBusy());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      
      filter0.useDefaultVisual();
      assertNotSame(filter0, filter2);
      assertNotSame(filter0, filter1);
      assertFalse(filter0.equals((Object)filter2));
      assertFalse(filter0.equals((Object)filter1));
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      filter1.useDefaultVisual();
      assertNotSame(filter1, filter0);
      assertNotSame(filter1, filter2);
      assertFalse(filter1.equals((Object)filter0));
      assertFalse(filter1.equals((Object)filter2));
      assertFalse(filter1.isBusy());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      
      Filter filter3 = new Filter();
      assertNotNull(filter3);
      assertFalse(filter3.equals((Object)filter2));
      assertFalse(filter3.equals((Object)filter1));
      assertFalse(filter3.equals((Object)filter0));
      assertEquals("AllFilter", filter3.getCustomName());
      assertFalse(filter3.isFocusTraversalPolicySet());
      assertTrue(filter3.getFocusTraversalKeysEnabled());
      assertFalse(filter3.getIgnoreRepaint());
      assertFalse(filter3.isFocusCycleRoot());
      assertFalse(filter3.isFocusTraversalPolicyProvider());
      assertFalse(filter3.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter3.globalInfo());
      
      AllFilter allFilter0 = (AllFilter)filter3.getFilter();
      assertNotSame(filter3, filter2);
      assertNotSame(filter3, filter1);
      assertNotSame(filter3, filter0);
      assertNotNull(allFilter0);
      assertFalse(filter3.equals((Object)filter2));
      assertFalse(filter3.equals((Object)filter1));
      assertFalse(filter3.equals((Object)filter0));
      assertEquals("AllFilter", filter3.getCustomName());
      assertFalse(filter3.isFocusTraversalPolicySet());
      assertTrue(filter3.getFocusTraversalKeysEnabled());
      assertFalse(filter3.getIgnoreRepaint());
      assertFalse(filter3.isFocusCycleRoot());
      assertFalse(filter3.isFocusTraversalPolicyProvider());
      assertFalse(filter3.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter3.globalInfo());
      assertEquals("An instance filter that passes all instances through unmodified. Primarily for testing purposes.", allFilter0.globalInfo());
      assertTrue(allFilter0.isNewBatch());
      assertFalse(allFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(allFilter0.isOutputFormatDefined());
      assertFalse(allFilter0.isFirstBatchDone());
      
      filter1.setVisual((BeanVisual) null);
      assertNotSame(filter1, filter0);
      assertNotSame(filter1, filter2);
      assertNotSame(filter1, filter3);
      assertFalse(filter1.equals((Object)filter0));
      assertFalse(filter1.equals((Object)filter2));
      assertFalse(filter1.equals((Object)filter3));
      assertFalse(filter1.isBusy());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("", substringLabeler0.getMatchDetails());
      
      Appender appender1 = new Appender();
      assertNotNull(appender1);
      assertFalse(appender1.equals((Object)appender0));
      assertEquals("Appender", appender1.getCustomName());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusCycleRoot());
      
      InstanceEvent instanceEvent0 = substringLabeler0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      
      Discretize discretize0 = new Discretize();
      assertNotNull(discretize0);
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("Uses a more efficient split point encoding.", discretize0.useBetterEncodingTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseKononenko());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Use Kononenko's MDL criterion. If set to false uses the Fayyad & Irani criterion.", discretize0.useKononenkoTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertFalse(discretize0.getUseBetterEncoding());
      assertFalse(discretize0.isFirstBatchDone());
      
      DataSetEvent dataSetEvent0 = new DataSetEvent(discretize0, instances0);
      assertNotNull(dataSetEvent0);
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertFalse(discretize0.getUseBinNumbers());
      assertEquals("Uses a more efficient split point encoding.", discretize0.useBetterEncodingTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseKononenko());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertEquals("Use Kononenko's MDL criterion. If set to false uses the Fayyad & Irani criterion.", discretize0.useKononenkoTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertFalse(discretize0.getUseBetterEncoding());
      assertFalse(discretize0.isFirstBatchDone());
      assertTrue(dataSetEvent0.isStructureOnly());
      
      instanceEvent0.setStructure(instances0);
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(2);
      assertNotNull(binarySparseInstance0);
      assertEquals(2, binarySparseInstance0.numValues());
      assertEquals(2, binarySparseInstance0.numAttributes());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      instanceEvent0.setInstance(binarySparseInstance0);
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, binarySparseInstance0.numValues());
      assertEquals(2, binarySparseInstance0.numAttributes());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      
      appender0.transferFocusUpCycle();
      assertNotSame(appender0, appender1);
      assertFalse(appender0.equals((Object)appender1));
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      
      filter0.setFilter(multiFilter0);
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      
      Saver saver0 = new Saver();
      assertNotNull(saver0);
      assertFalse(saver0.isFocusTraversalPolicySet());
      assertTrue(saver0.getFocusTraversalKeysEnabled());
      assertTrue(saver0.getRelationNameForFilename());
      assertFalse(saver0.getIgnoreRepaint());
      assertFalse(saver0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Writes to a destination that is in arff (attribute relation file format) format</font><br><br> The data can be compressed with gzip in order to save space.<br></html>", saver0.globalInfo());
      assertEquals("ArffSaver", saver0.getCustomName());
      assertFalse(saver0.isBusy());
      assertFalse(saver0.isFocusCycleRoot());
      
      BeanVisual beanVisual0 = saver0.m_visual;
      assertNotNull(beanVisual0);
      assertEquals("ArffSaver", beanVisual0.getText());
      assertFalse(beanVisual0.isFocusTraversalPolicyProvider());
      assertFalse(beanVisual0.isFocusTraversalPolicySet());
      assertFalse(beanVisual0.isFocusCycleRoot());
      assertFalse(beanVisual0.getIgnoreRepaint());
      assertEquals("weka/gui/beans/icons/DefaultDataSink.gif", beanVisual0.getIconPath());
      assertTrue(beanVisual0.getFocusTraversalKeysEnabled());
      assertEquals("weka/gui/beans/icons/DefaultDataSink_animated.gif", beanVisual0.getAnimatedIconPath());
      assertEquals(1, BeanVisual.SOUTH_CONNECTOR);
      assertEquals(3, BeanVisual.WEST_CONNECTOR);
      assertEquals(0, BeanVisual.NORTH_CONNECTOR);
      assertEquals(2, BeanVisual.EAST_CONNECTOR);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      assertNotNull(trainTestSplitMaker0);
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      
      filter0.removeTestSetListener(substringLabeler0);
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("", substringLabeler0.getMatchDetails());
      
      GraphicsConfiguration graphicsConfiguration0 = filter0.getGraphicsConfiguration();
      assertNull(graphicsConfiguration0);
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      
      JWindow jWindow0 = null;
      try {
        jWindow0 = new JWindow((GraphicsConfiguration) null);
        fail("Expecting exception: HeadlessException");
      
      } catch(HeadlessException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.awt.GraphicsEnvironment", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      
      ClassOrder classOrder0 = new ClassOrder();
      assertNotNull(classOrder0);
      assertEquals("Specify the seed of randomization of the class order", classOrder0.seedTipText());
      assertFalse(classOrder0.isOutputFormatDefined());
      assertTrue(classOrder0.isNewBatch());
      assertFalse(classOrder0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(classOrder0.isFirstBatchDone());
      assertEquals(0, classOrder0.getClassOrder());
      assertEquals("Specify the class order after the filtering", classOrder0.classOrderTipText());
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder0.globalInfo());
      assertEquals(1L, classOrder0.getSeed());
      assertEquals(2, ClassOrder.RANDOM);
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      
      SysErrLog sysErrLog0 = new SysErrLog();
      assertNotNull(sysErrLog0);
      
      sysErrLog0.logMessage("NO:");
      sysErrLog0.logMessage("\"W$A");
      filter0.setLog(sysErrLog0);
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.isBusy());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicySet());
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      instanceEvent0.setStatus((-1232312342));
      assertFalse(appender0.isBusy());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals((-1232312342), instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      filter0.setFilter(classOrder0);
      assertEquals("ClassOrder", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Changes the order of the classes so that the class values are no longer of in the order specified in the header</font><br><br> The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order.<br>Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier.<br>The value can also be converted back using 'originalValue(double value)' procedure.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("Specify the seed of randomization of the class order", classOrder0.seedTipText());
      assertFalse(classOrder0.isOutputFormatDefined());
      assertTrue(classOrder0.isNewBatch());
      assertFalse(classOrder0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(classOrder0.isFirstBatchDone());
      assertEquals(0, classOrder0.getClassOrder());
      assertEquals("Specify the class order after the filtering", classOrder0.classOrderTipText());
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder0.globalInfo());
      assertEquals(1L, classOrder0.getSeed());
      assertEquals(2, ClassOrder.RANDOM);
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      
      ClassOrder classOrder1 = new ClassOrder();
      assertNotNull(classOrder1);
      assertFalse(classOrder1.equals((Object)classOrder0));
      assertEquals("Specify the class order after the filtering", classOrder1.classOrderTipText());
      assertEquals(0, classOrder1.getClassOrder());
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder1.globalInfo());
      assertEquals("Specify the seed of randomization of the class order", classOrder1.seedTipText());
      assertTrue(classOrder1.isNewBatch());
      assertFalse(classOrder1.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(classOrder1.isOutputFormatDefined());
      assertFalse(classOrder1.isFirstBatchDone());
      assertEquals(1L, classOrder1.getSeed());
      assertEquals(2, ClassOrder.RANDOM);
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      
      SparseInstance sparseInstance0 = new SparseInstance(1);
      assertNotNull(sparseInstance0);
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(1, sparseInstance0.numValues());
      assertEquals(1, sparseInstance0.numAttributes());
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      instanceEvent0.setInstance(sparseInstance0);
      assertFalse(appender0.isBusy());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals((-1232312342), instanceEvent0.getStatus());
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(1, sparseInstance0.numValues());
      assertEquals(1, sparseInstance0.numAttributes());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      
      multiFilter0.setDebug(false);
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      
      appender0.transferFocusUpCycle();
      assertFalse(appender0.isBusy());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicySet());
      
      MultiFilter multiFilter1 = new MultiFilter();
      assertNotNull(multiFilter1);
      assertFalse(multiFilter1.equals((Object)multiFilter0));
      assertFalse(multiFilter1.getDebug());
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      assertFalse(multiFilter1.isFirstBatchDone());
      assertTrue(multiFilter1.isNewBatch());
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      
      filter0.setFilter(multiFilter1);
      assertNotSame(multiFilter1, multiFilter0);
      assertFalse(multiFilter1.equals((Object)multiFilter0));
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(multiFilter1.getDebug());
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      assertFalse(multiFilter1.isFirstBatchDone());
      assertTrue(multiFilter1.isNewBatch());
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      
      Saver saver0 = new Saver();
      assertNotNull(saver0);
      assertFalse(saver0.isFocusTraversalPolicySet());
      assertFalse(saver0.isFocusCycleRoot());
      assertTrue(saver0.getFocusTraversalKeysEnabled());
      assertTrue(saver0.getRelationNameForFilename());
      assertFalse(saver0.getIgnoreRepaint());
      assertEquals("ArffSaver", saver0.getCustomName());
      assertFalse(saver0.isFocusTraversalPolicyProvider());
      assertFalse(saver0.isBusy());
      assertEquals("<html><font color=blue>Writes to a destination that is in arff (attribute relation file format) format</font><br><br> The data can be compressed with gzip in order to save space.<br></html>", saver0.globalInfo());
      
      BeanVisual beanVisual0 = saver0.m_visual;
      assertNotNull(beanVisual0);
      assertFalse(beanVisual0.getIgnoreRepaint());
      assertEquals("ArffSaver", beanVisual0.getText());
      assertFalse(beanVisual0.isFocusCycleRoot());
      assertFalse(beanVisual0.isFocusTraversalPolicyProvider());
      assertFalse(beanVisual0.isFocusTraversalPolicySet());
      assertEquals("weka/gui/beans/icons/DefaultDataSink_animated.gif", beanVisual0.getAnimatedIconPath());
      assertEquals("weka/gui/beans/icons/DefaultDataSink.gif", beanVisual0.getIconPath());
      assertTrue(beanVisual0.getFocusTraversalKeysEnabled());
      assertEquals(0, BeanVisual.NORTH_CONNECTOR);
      assertEquals(1, BeanVisual.SOUTH_CONNECTOR);
      assertEquals(3, BeanVisual.WEST_CONNECTOR);
      assertEquals(2, BeanVisual.EAST_CONNECTOR);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(appender0.isBusy());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals((-1232312342), instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      assertNotNull(trainTestSplitMaker0);
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      
      JInternalFrame jInternalFrame0 = new JInternalFrame();
      assertNotNull(jInternalFrame0);
      assertFalse(jInternalFrame0.isFocusTraversalPolicyProvider());
      assertTrue(jInternalFrame0.isFocusTraversalPolicySet());
      assertTrue(jInternalFrame0.getFocusTraversalKeysEnabled());
      assertFalse(jInternalFrame0.getIgnoreRepaint());
      
      Cursor cursor0 = jInternalFrame0.getLastCursor();
      assertNull(cursor0);
      assertFalse(jInternalFrame0.isFocusTraversalPolicyProvider());
      assertTrue(jInternalFrame0.isFocusTraversalPolicySet());
      assertTrue(jInternalFrame0.getFocusTraversalKeysEnabled());
      assertFalse(jInternalFrame0.getIgnoreRepaint());
      
      filter0.setCursor((Cursor) null);
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      
      filter0.removeTestSetListener(saver0);
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(saver0.isFocusTraversalPolicySet());
      assertFalse(saver0.isFocusCycleRoot());
      assertTrue(saver0.getFocusTraversalKeysEnabled());
      assertTrue(saver0.getRelationNameForFilename());
      assertFalse(saver0.getIgnoreRepaint());
      assertEquals("ArffSaver", saver0.getCustomName());
      assertFalse(saver0.isFocusTraversalPolicyProvider());
      assertFalse(saver0.isBusy());
      assertEquals("<html><font color=blue>Writes to a destination that is in arff (attribute relation file format) format</font><br><br> The data can be compressed with gzip in order to save space.<br></html>", saver0.globalInfo());
      
      GraphicsConfiguration graphicsConfiguration0 = filter0.getGraphicsConfiguration();
      assertNull(graphicsConfiguration0);
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      
      JWindow jWindow0 = null;
      try {
        jWindow0 = new JWindow((GraphicsConfiguration) null);
        fail("Expecting exception: HeadlessException");
      
      } catch(HeadlessException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.awt.GraphicsEnvironment", e);
      }
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      
      SparseInstance sparseInstance0 = new SparseInstance(0);
      assertNotNull(sparseInstance0);
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(0, sparseInstance0.numValues());
      assertEquals(0, sparseInstance0.numAttributes());
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      instanceEvent0.setInstance(sparseInstance0);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(0, sparseInstance0.numValues());
      assertEquals(0, sparseInstance0.numAttributes());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      
      Enumeration enumeration0 = multiFilter0.listOptions();
      assertNotNull(enumeration0);
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      
      appender0.transferFocusUpCycle();
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      
      instanceEvent0.setStatus(1);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      Insets insets0 = filter0.getInsets();
      assertNotNull(insets0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals(0, insets0.bottom);
      assertEquals(0, insets0.left);
      assertEquals(0, insets0.top);
      assertEquals(0, insets0.right);
      
      Insets insets1 = filter0.getInsets(insets0);
      assertSame(insets0, insets1);
      assertSame(insets1, insets0);
      assertNotNull(insets1);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals(0, insets0.bottom);
      assertEquals(0, insets0.left);
      assertEquals(0, insets0.top);
      assertEquals(0, insets0.right);
      assertEquals(0, insets1.top);
      assertEquals(0, insets1.right);
      assertEquals(0, insets1.bottom);
      assertEquals(0, insets1.left);
      
      instanceEvent0.setInstance(sparseInstance0);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(0, sparseInstance0.numValues());
      assertEquals(0, sparseInstance0.numAttributes());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      AllFilter allFilter0 = (AllFilter)filter0.getFilter();
      assertNotNull(allFilter0);
      assertFalse(allFilter0.isFirstBatchDone());
      assertFalse(allFilter0.isOutputFormatDefined());
      assertEquals("An instance filter that passes all instances through unmodified. Primarily for testing purposes.", allFilter0.globalInfo());
      assertFalse(allFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(allFilter0.isNewBatch());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      filter0.addConfigurationListener(configurationListener0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      assertNotNull(trainTestSplitMaker0);
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      
      JInternalFrame jInternalFrame0 = new JInternalFrame();
      assertNotNull(jInternalFrame0);
      assertFalse(jInternalFrame0.isFocusTraversalPolicyProvider());
      assertTrue(jInternalFrame0.isFocusTraversalPolicySet());
      assertTrue(jInternalFrame0.getFocusTraversalKeysEnabled());
      assertFalse(jInternalFrame0.getIgnoreRepaint());
      
      Cursor cursor0 = jInternalFrame0.getLastCursor();
      assertNull(cursor0);
      assertFalse(jInternalFrame0.isFocusTraversalPolicyProvider());
      assertTrue(jInternalFrame0.isFocusTraversalPolicySet());
      assertTrue(jInternalFrame0.getFocusTraversalKeysEnabled());
      assertFalse(jInternalFrame0.getIgnoreRepaint());
      
      filter0.setCursor((Cursor) null);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      filter0.removeTestSetListener(substringLabeler0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      
      GraphicsConfiguration graphicsConfiguration0 = filter0.getGraphicsConfiguration();
      assertNull(graphicsConfiguration0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      filter0.performRequest("Stop");
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      DataVisualizer dataVisualizer0 = new DataVisualizer();
      assertNotNull(dataVisualizer0);
      assertEquals("500", dataVisualizer0.getOffscreenWidth());
      assertTrue(dataVisualizer0.getFocusTraversalKeysEnabled());
      assertEquals("Weka Chart Renderer", dataVisualizer0.getOffscreenRendererName());
      assertFalse(dataVisualizer0.isFocusTraversalPolicySet());
      assertFalse(dataVisualizer0.isBusy());
      assertFalse(dataVisualizer0.getIgnoreRepaint());
      assertEquals("400", dataVisualizer0.getOffscreenHeight());
      assertEquals("", dataVisualizer0.getOffscreenYAxis());
      assertEquals("Visualize incoming data/training/test sets in a 2D scatter plot.", dataVisualizer0.globalInfo());
      assertEquals("DataVisualizer", dataVisualizer0.getCustomName());
      assertFalse(dataVisualizer0.isFocusCycleRoot());
      assertEquals("", dataVisualizer0.getOffscreenAdditionalOpts());
      assertFalse(dataVisualizer0.isFocusTraversalPolicyProvider());
      assertEquals("", dataVisualizer0.getOffscreenXAxis());
      
      filter0.performRequest("Stop");
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertNotNull(substringReplacer0);
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      
      Logger logger0 = substringReplacer0.m_log;
      assertNull(logger0);
      
      filter0.setLog((Logger) null);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      filter0.notifyInstanceListeners(instanceEvent0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      String string0 = filter0.getCustomName();
      assertNotNull(string0);
      assertEquals("AllFilter", string0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isBusy());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numInstances());
      assertEquals(1, instances0.classIndex());
      assertEquals(2, instances0.numAttributes());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numClasses());
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      
      WordTokenizer wordTokenizer0 = new WordTokenizer();
      assertNotNull(wordTokenizer0);
      assertEquals("Set of delimiter characters to use in tokenizing (\\r, \\n and \\t can be used for carriage-return, line-feed and tab)", wordTokenizer0.delimitersTipText());
      assertEquals("A simple tokenizer that is using the java.util.StringTokenizer class to tokenize the strings.", wordTokenizer0.globalInfo());
      assertEquals(" \r\n\t.,;:'\"()?!", wordTokenizer0.getDelimiters());
      
      SysErrLog sysErrLog0 = new SysErrLog();
      assertNotNull(sysErrLog0);
      
      sysErrLog0.statusMessage(".bsi");
      sysErrLog0.logMessage("@data");
      sysErrLog0.logMessage(",!)1,r;!! :R");
      filter0.setLog(sysErrLog0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      instanceEvent0.setStatus(0);
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isBusy());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      filter0.setFilter(multiFilter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      
      ClassOrder classOrder0 = new ClassOrder();
      assertNotNull(classOrder0);
      assertEquals(1L, classOrder0.getSeed());
      assertEquals("Specify the seed of randomization of the class order", classOrder0.seedTipText());
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder0.globalInfo());
      assertEquals("Specify the class order after the filtering", classOrder0.classOrderTipText());
      assertFalse(classOrder0.isOutputFormatDefined());
      assertEquals(0, classOrder0.getClassOrder());
      assertFalse(classOrder0.isFirstBatchDone());
      assertTrue(classOrder0.isNewBatch());
      assertFalse(classOrder0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      assertEquals(2, ClassOrder.RANDOM);
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      
      InstanceEvent instanceEvent1 = appender0.m_ie;
      assertSame(instanceEvent1, instanceEvent0);
      assertNotNull(instanceEvent1);
      assertEquals(0, instanceEvent1.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      instanceEvent1.setStatus((-1994091956));
      assertSame(instanceEvent1, instanceEvent0);
      assertEquals((-1994091956), instanceEvent1.getStatus());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isBusy());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      filter0.acceptInstance(instanceEvent0);
      assertSame(instanceEvent0, instanceEvent1);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isBusy());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertEquals((-1994091956), instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      Enumeration enumeration0 = filter0.enumerateRequests();
      assertNotNull(enumeration0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      MultiFilter multiFilter1 = new MultiFilter();
      assertNotNull(multiFilter1);
      assertFalse(multiFilter1.equals((Object)multiFilter0));
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      assertFalse(multiFilter1.isFirstBatchDone());
      assertFalse(multiFilter1.getDebug());
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertTrue(multiFilter1.isNewBatch());
      
      // Undeclared exception!
      try { 
        classOrder0.getOutputFormat();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // No output format defined.
         //
         verifyException("weka.filters.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numClasses());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      
      HashSet<DataSetEvent> hashSet0 = new HashSet<DataSetEvent>();
      assertNotNull(hashSet0);
      assertEquals(0, hashSet0.size());
      assertTrue(hashSet0.isEmpty());
      
      InstanceEvent instanceEvent1 = substringLabeler0.m_ie;
      assertNotSame(instanceEvent1, instanceEvent0);
      assertNotNull(instanceEvent1);
      assertFalse(instanceEvent1.equals((Object)instanceEvent0));
      assertEquals(0, instanceEvent1.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      instanceEvent1.setStructure(instances0);
      assertNotSame(instanceEvent1, instanceEvent0);
      assertFalse(instanceEvent1.equals((Object)instanceEvent0));
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numClasses());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.size());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instanceEvent1.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      SparseInstance sparseInstance0 = new SparseInstance(1);
      assertNotNull(sparseInstance0);
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(1, sparseInstance0.numValues());
      assertEquals(1, sparseInstance0.numAttributes());
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      String[] stringArray0 = new String[4];
      Instances.main(stringArray0);
      instanceEvent1.setInstance(sparseInstance0);
      assertNotSame(instanceEvent1, instanceEvent0);
      assertFalse(instanceEvent1.equals((Object)instanceEvent0));
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertEquals(0, instanceEvent1.getStatus());
      assertEquals(1.0, sparseInstance0.weight(), 0.01);
      assertEquals(1, sparseInstance0.numValues());
      assertEquals(1, sparseInstance0.numAttributes());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      
      MultiFilter multiFilter1 = new MultiFilter();
      assertNotNull(multiFilter1);
      assertFalse(multiFilter1.equals((Object)multiFilter0));
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(multiFilter1.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      assertFalse(multiFilter1.getDebug());
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertFalse(multiFilter1.isFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      
      Enumeration enumeration0 = multiFilter1.listOptions();
      assertNotSame(multiFilter1, multiFilter0);
      assertNotNull(enumeration0);
      assertFalse(multiFilter1.equals((Object)multiFilter0));
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(multiFilter1.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      assertFalse(multiFilter1.getDebug());
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertFalse(multiFilter1.isFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      
      Appender appender1 = new Appender();
      assertNotNull(appender1);
      assertFalse(appender1.equals((Object)appender0));
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.isFocusCycleRoot());
      
      MultiFilter multiFilter2 = new MultiFilter();
      assertNotNull(multiFilter2);
      assertFalse(multiFilter2.equals((Object)multiFilter0));
      assertFalse(multiFilter2.equals((Object)multiFilter1));
      assertFalse(multiFilter2.getDebug());
      assertFalse(multiFilter2.isOutputFormatDefined());
      assertTrue(multiFilter2.isNewBatch());
      assertEquals("Turns on output of debugging information.", multiFilter2.debugTipText());
      assertFalse(multiFilter2.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter2.globalInfo());
      assertEquals("The base filters to be used.", multiFilter2.filtersTipText());
      assertFalse(multiFilter2.isFirstBatchDone());
      
      filter0.setFilter(multiFilter0);
      assertNotSame(multiFilter0, multiFilter1);
      assertNotSame(multiFilter0, multiFilter2);
      assertFalse(multiFilter0.equals((Object)multiFilter1));
      assertFalse(multiFilter0.equals((Object)multiFilter2));
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      
      FlowByExpression flowByExpression0 = new FlowByExpression();
      assertNotNull(flowByExpression0);
      assertEquals("", flowByExpression0.getExpressionString());
      assertFalse(flowByExpression0.isBusy());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      
      InstanceEvent instanceEvent2 = substringLabeler0.m_ie;
      assertSame(instanceEvent2, instanceEvent1);
      assertNotSame(instanceEvent2, instanceEvent0);
      assertNotNull(instanceEvent2);
      assertFalse(instanceEvent2.equals((Object)instanceEvent0));
      assertEquals(0, instanceEvent2.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      instanceEvent2.setStatus(2);
      assertSame(instanceEvent2, instanceEvent1);
      assertNotSame(instanceEvent2, instanceEvent0);
      assertFalse(instanceEvent2.equals((Object)instanceEvent0));
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertEquals(2, instanceEvent2.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      filter0.acceptInstance(instanceEvent1);
      assertNotSame(instanceEvent1, instanceEvent0);
      assertSame(instanceEvent1, instanceEvent2);
      assertFalse(instanceEvent1.equals((Object)instanceEvent0));
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertEquals(2, instanceEvent1.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      Saver saver0 = new Saver();
      assertNotNull(saver0);
      assertFalse(saver0.isFocusTraversalPolicySet());
      assertFalse(saver0.isFocusTraversalPolicyProvider());
      assertFalse(saver0.isFocusCycleRoot());
      assertEquals("ArffSaver", saver0.getCustomName());
      assertEquals("<html><font color=blue>Writes to a destination that is in arff (attribute relation file format) format</font><br><br> The data can be compressed with gzip in order to save space.<br></html>", saver0.globalInfo());
      assertFalse(saver0.isBusy());
      assertFalse(saver0.getIgnoreRepaint());
      assertTrue(saver0.getFocusTraversalKeysEnabled());
      assertTrue(saver0.getRelationNameForFilename());
      
      filter0.disconnectionNotification("!}I5' 0M|5", flowByExpression0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("", flowByExpression0.getExpressionString());
      assertFalse(flowByExpression0.isBusy());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "@data");
      assertFalse(boolean0);
      
      boolean boolean1 = filter0.isBusy();
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      
      filter0.useDefaultVisual();
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/mnt/gaiagpfs/users/homedirs/apanichella/Evosuite_performance/Dataset/gordon_script_sum/projects/9_weka");
      boolean boolean0 = FileSystemHandling.createFolder(evoSuiteFile0);
      assertTrue(boolean0);
      
      Instances instances1 = new Instances(instances0, 2);
      assertNotNull(instances1);
      assertTrue(instances1.equals((Object)instances0));
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances1.checkForStringAttributes());
      assertEquals(1, instances1.classIndex());
      assertEquals(0, instances1.numClasses());
      assertEquals(2, instances1.numAttributes());
      assertEquals(0, instances1.size());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(0, instances1.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances1.relationName());
      
      instanceEvent0.setStructure(instances0);
      assertNotSame(instances0, instances1);
      assertTrue(instances0.equals((Object)instances1));
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(1);
      assertNotNull(binarySparseInstance0);
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(1, binarySparseInstance0.numAttributes());
      assertEquals(1, binarySparseInstance0.numValues());
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      instanceEvent0.setInstance(binarySparseInstance0);
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(1, binarySparseInstance0.numAttributes());
      assertEquals(1, binarySparseInstance0.numValues());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      
      Enumeration enumeration0 = multiFilter0.listOptions();
      assertNotNull(enumeration0);
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      
      appender0.transferFocusUpCycle();
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      
      filter0.setFilter(multiFilter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      
      instanceEvent0.setStatus(1);
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      appender0.grabFocus();
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      
      instanceEvent0.setInstance(binarySparseInstance0);
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(1, binarySparseInstance0.numAttributes());
      assertEquals(1, binarySparseInstance0.numValues());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      filter0.setFilter(multiFilter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(configurationListener0, instances0);
      assertNotNull(trainingSetEvent0);
      assertTrue(instances0.equals((Object)instances1));
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      
      appender0.transferFocusUpCycle();
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertNotSame(instances0, instances1);
      assertTrue(instances0.equals((Object)instances1));
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      
      BayesNet bayesNet0 = new BayesNet();
      assertNotNull(bayesNet0);
      assertEquals("Select Estimator algorithm for finding the conditional probability tables of the Bayes Network.", bayesNet0.estimatorTipText());
      assertFalse(bayesNet0.getDebug());
      assertEquals("If set to true, classifier may output additional info to the console.", bayesNet0.debugTipText());
      assertEquals(2, bayesNet0.graphType());
      assertFalse(bayesNet0.getUseADTree());
      assertEquals("Bayes Network learning using various search algorithms and quality measures.\nBase class for a Bayes Network classifier. Provides datastructures (network structure, conditional probability distributions, etc.) and facilities common to Bayes Network learning algorithms like K2 and B.\n\nFor more information see:\n\nhttp://www.cs.waikato.ac.nz/~remco/weka.pdf", bayesNet0.globalInfo());
      assertEquals("Select method used for searching network structures.", bayesNet0.searchAlgorithmTipText());
      assertEquals("When ADTree (the data structure for increasing speed on counts, not to be confused with the classifier under the same name) is used learning time goes down typically. However, because ADTrees are memory intensive, memory problems may occur. Switching this option off makes the structure learning algorithms slower, and run with less memory. By default, ADTrees are used.", bayesNet0.useADTreeTipText());
      assertEquals("Set the name of a file in BIF XML format. A Bayes network learned from data can be compared with the Bayes network represented by the BIF file. Statistics calculated are o.a. the number of missing and extra arcs.", bayesNet0.BIFFileTipText());
      
      boolean boolean1 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "|a^)u:4{X@8Fp]");
      assertFalse(boolean1 == boolean0);
      assertFalse(boolean1);
      
      instanceEvent0.setStatus(0);
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      WordTokenizer wordTokenizer0 = new WordTokenizer();
      assertNotNull(wordTokenizer0);
      assertEquals("Set of delimiter characters to use in tokenizing (\\r, \\n and \\t can be used for carriage-return, line-feed and tab)", wordTokenizer0.delimitersTipText());
      assertEquals(" \r\n\t.,;:'\"()?!", wordTokenizer0.getDelimiters());
      assertEquals("A simple tokenizer that is using the java.util.StringTokenizer class to tokenize the strings.", wordTokenizer0.globalInfo());
      
      MultiFilter multiFilter1 = new MultiFilter();
      assertNotNull(multiFilter1);
      assertFalse(multiFilter1.equals((Object)multiFilter0));
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      assertFalse(multiFilter1.isFirstBatchDone());
      assertTrue(multiFilter1.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter1.getDebug());
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      
      ClassOrder classOrder0 = new ClassOrder();
      assertNotNull(classOrder0);
      assertFalse(classOrder0.isOutputFormatDefined());
      assertEquals(1L, classOrder0.getSeed());
      assertFalse(classOrder0.isFirstBatchDone());
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder0.globalInfo());
      assertEquals(0, classOrder0.getClassOrder());
      assertEquals("Specify the class order after the filtering", classOrder0.classOrderTipText());
      assertTrue(classOrder0.isNewBatch());
      assertFalse(classOrder0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Specify the seed of randomization of the class order", classOrder0.seedTipText());
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      assertEquals(2, ClassOrder.RANDOM);
      
      // Undeclared exception!
      try { 
        classOrder0.getOutputFormat();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // No output format defined.
         //
         verifyException("weka.filters.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      
      filter0.useDefaultVisual();
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      
      Instances instances1 = textDirectoryLoader0.getDataSet();
      assertSame(instances1, instances0);
      assertNotNull(instances1);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(0, instances1.size());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      assertTrue(instances1.checkForStringAttributes());
      assertEquals(0, instances1.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances1.relationName());
      assertEquals(1, instances1.classIndex());
      assertEquals(0, instances1.numClasses());
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      
      Enumeration enumeration0 = multiFilter0.listOptions();
      assertNotNull(enumeration0);
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      
      filter0.setFilter(multiFilter0);
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      
      filter0.setFilter(multiFilter0);
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(multiFilter0, instances0);
      assertNotNull(trainingSetEvent0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertSame(instances0, instances1);
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertTrue(multiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertTrue(multiFilter0.isOutputFormatDefined());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      
      BayesNet bayesNet0 = new BayesNet();
      assertNotNull(bayesNet0);
      assertEquals(2, bayesNet0.graphType());
      assertFalse(bayesNet0.getUseADTree());
      assertEquals("Bayes Network learning using various search algorithms and quality measures.\nBase class for a Bayes Network classifier. Provides datastructures (network structure, conditional probability distributions, etc.) and facilities common to Bayes Network learning algorithms like K2 and B.\n\nFor more information see:\n\nhttp://www.cs.waikato.ac.nz/~remco/weka.pdf", bayesNet0.globalInfo());
      assertEquals("Select method used for searching network structures.", bayesNet0.searchAlgorithmTipText());
      assertEquals("When ADTree (the data structure for increasing speed on counts, not to be confused with the classifier under the same name) is used learning time goes down typically. However, because ADTrees are memory intensive, memory problems may occur. Switching this option off makes the structure learning algorithms slower, and run with less memory. By default, ADTrees are used.", bayesNet0.useADTreeTipText());
      assertFalse(bayesNet0.getDebug());
      assertEquals("If set to true, classifier may output additional info to the console.", bayesNet0.debugTipText());
      assertEquals("Select Estimator algorithm for finding the conditional probability tables of the Bayes Network.", bayesNet0.estimatorTipText());
      assertEquals("Set the name of a file in BIF XML format. A Bayes network learned from data can be compared with the Bayes network represented by the BIF file. Statistics calculated are o.a. the number of missing and extra arcs.", bayesNet0.BIFFileTipText());
      
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "&+ybR7L/A=/:*@");
      assertFalse(boolean0);
      
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      assertNotNull(trainTestSplitMaker0);
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      
      TestSetEvent testSetEvent0 = new TestSetEvent(trainTestSplitMaker0, instances1);
      assertNotNull(testSetEvent0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(0, instances1.size());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      assertTrue(instances1.checkForStringAttributes());
      assertEquals(0, instances1.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances1.relationName());
      assertEquals(1, instances1.classIndex());
      assertEquals(0, instances1.numClasses());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertTrue(testSetEvent0.isStructureOnly());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertEquals(0, testSetEvent0.getMaxSetNumber());
      assertEquals(1, testSetEvent0.getRunNumber());
      assertEquals(0, testSetEvent0.getSetNumber());
      
      filter0.acceptTestSet(testSetEvent0);
      assertSame(instances1, instances0);
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(0, instances1.size());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      assertTrue(instances1.checkForStringAttributes());
      assertEquals(0, instances1.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances1.relationName());
      assertEquals(1, instances1.classIndex());
      assertEquals(0, instances1.numClasses());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertTrue(testSetEvent0.isStructureOnly());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertEquals(0, testSetEvent0.getMaxSetNumber());
      assertEquals(1, testSetEvent0.getRunNumber());
      assertEquals(0, testSetEvent0.getSetNumber());
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      
      filter0.useDefaultVisual();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(2, instances0.numAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      
      Instances instances1 = textDirectoryLoader0.getDataSet();
      assertSame(instances1, instances0);
      assertNotNull(instances1);
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(2, instances1.numAttributes());
      assertEquals(0, instances1.size());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(0, instances1.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances1.relationName());
      assertTrue(instances1.checkForStringAttributes());
      assertEquals(1, instances1.classIndex());
      assertEquals(0, instances1.numClasses());
      
      instanceEvent0.setStructure(instances0);
      assertSame(instances0, instances1);
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(2, instances0.numAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertFalse(multiFilter0.getDebug());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      
      Enumeration enumeration0 = multiFilter0.listOptions();
      assertNotNull(enumeration0);
      assertFalse(multiFilter0.getDebug());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      
      appender0.transferFocusUpCycle();
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      
      instanceEvent0.setStatus(1);
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      appender0.grabFocus();
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      filter0.setFilter(multiFilter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(multiFilter0.getDebug());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(multiFilter0, instances0);
      assertNotNull(trainingSetEvent0);
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(2, instances0.numAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertFalse(multiFilter0.getDebug());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      
      appender0.transferFocusUpCycle();
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertSame(instances0, instances1);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(2, instances0.numAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertTrue(multiFilter0.isOutputFormatDefined());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      
      BayesNet bayesNet0 = new BayesNet();
      assertNotNull(bayesNet0);
      assertFalse(bayesNet0.getUseADTree());
      assertEquals("When ADTree (the data structure for increasing speed on counts, not to be confused with the classifier under the same name) is used learning time goes down typically. However, because ADTrees are memory intensive, memory problems may occur. Switching this option off makes the structure learning algorithms slower, and run with less memory. By default, ADTrees are used.", bayesNet0.useADTreeTipText());
      assertEquals(2, bayesNet0.graphType());
      assertEquals("Bayes Network learning using various search algorithms and quality measures.\nBase class for a Bayes Network classifier. Provides datastructures (network structure, conditional probability distributions, etc.) and facilities common to Bayes Network learning algorithms like K2 and B.\n\nFor more information see:\n\nhttp://www.cs.waikato.ac.nz/~remco/weka.pdf", bayesNet0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", bayesNet0.debugTipText());
      assertEquals("Set the name of a file in BIF XML format. A Bayes network learned from data can be compared with the Bayes network represented by the BIF file. Statistics calculated are o.a. the number of missing and extra arcs.", bayesNet0.BIFFileTipText());
      assertFalse(bayesNet0.getDebug());
      assertEquals("Select method used for searching network structures.", bayesNet0.searchAlgorithmTipText());
      assertEquals("Select Estimator algorithm for finding the conditional probability tables of the Bayes Network.", bayesNet0.estimatorTipText());
      
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, " not supported (Filter)");
      assertFalse(boolean0);
      
      instanceEvent0.setStatus((-1060));
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertEquals((-1060), instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertEquals((-1060), instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      WordTokenizer wordTokenizer0 = new WordTokenizer();
      assertNotNull(wordTokenizer0);
      assertEquals(" \r\n\t.,;:'\"()?!", wordTokenizer0.getDelimiters());
      assertEquals("Set of delimiter characters to use in tokenizing (\\r, \\n and \\t can be used for carriage-return, line-feed and tab)", wordTokenizer0.delimitersTipText());
      assertEquals("A simple tokenizer that is using the java.util.StringTokenizer class to tokenize the strings.", wordTokenizer0.globalInfo());
      
      ClassOrder classOrder0 = new ClassOrder();
      assertNotNull(classOrder0);
      assertTrue(classOrder0.isNewBatch());
      assertFalse(classOrder0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Specify the class order after the filtering", classOrder0.classOrderTipText());
      assertFalse(classOrder0.isFirstBatchDone());
      assertEquals(0, classOrder0.getClassOrder());
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder0.globalInfo());
      assertEquals(1L, classOrder0.getSeed());
      assertFalse(classOrder0.isOutputFormatDefined());
      assertEquals("Specify the seed of randomization of the class order", classOrder0.seedTipText());
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      assertEquals(2, ClassOrder.RANDOM);
      
      // Undeclared exception!
      try { 
        classOrder0.getOutputFormat();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // No output format defined.
         //
         verifyException("weka.filters.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      
      filter0.useDefaultVisual();
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      
      instanceEvent0.setStructure(instances0);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(0);
      assertNotNull(binarySparseInstance0);
      assertEquals(0, binarySparseInstance0.numAttributes());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(0, binarySparseInstance0.numValues());
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      instanceEvent0.setInstance(binarySparseInstance0);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, binarySparseInstance0.numAttributes());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(0, binarySparseInstance0.numValues());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      
      Enumeration enumeration0 = multiFilter0.listOptions();
      assertNotNull(enumeration0);
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      
      filter0.setFilter(multiFilter0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      
      instanceEvent0.setStatus(1);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      appender0.grabFocus();
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      
      instanceEvent0.setInstance(binarySparseInstance0);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(0, binarySparseInstance0.numAttributes());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(0, binarySparseInstance0.numValues());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      filter0.setFilter(multiFilter0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(multiFilter0, instances0);
      assertNotNull(trainingSetEvent0);
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      
      binarySparseInstance0.s_numericAfterDecimalPoint = 0;
      assertEquals(0, binarySparseInstance0.numAttributes());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(0, binarySparseInstance0.numValues());
      
      appender0.transferFocusUpCycle();
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numInstances());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertTrue(multiFilter0.isFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      assertTrue(multiFilter0.isOutputFormatDefined());
      
      BayesNet bayesNet0 = new BayesNet();
      assertNotNull(bayesNet0);
      assertEquals("Bayes Network learning using various search algorithms and quality measures.\nBase class for a Bayes Network classifier. Provides datastructures (network structure, conditional probability distributions, etc.) and facilities common to Bayes Network learning algorithms like K2 and B.\n\nFor more information see:\n\nhttp://www.cs.waikato.ac.nz/~remco/weka.pdf", bayesNet0.globalInfo());
      assertEquals("Select method used for searching network structures.", bayesNet0.searchAlgorithmTipText());
      assertEquals("Select Estimator algorithm for finding the conditional probability tables of the Bayes Network.", bayesNet0.estimatorTipText());
      assertFalse(bayesNet0.getUseADTree());
      assertEquals("If set to true, classifier may output additional info to the console.", bayesNet0.debugTipText());
      assertEquals("Set the name of a file in BIF XML format. A Bayes network learned from data can be compared with the Bayes network represented by the BIF file. Statistics calculated are o.a. the number of missing and extra arcs.", bayesNet0.BIFFileTipText());
      assertEquals("When ADTree (the data structure for increasing speed on counts, not to be confused with the classifier under the same name) is used learning time goes down typically. However, because ADTrees are memory intensive, memory problems may occur. Switching this option off makes the structure learning algorithms slower, and run with less memory. By default, ADTrees are used.", bayesNet0.useADTreeTipText());
      assertFalse(bayesNet0.getDebug());
      assertEquals(2, bayesNet0.graphType());
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      WordTokenizer wordTokenizer0 = new WordTokenizer();
      assertNotNull(wordTokenizer0);
      assertEquals("A simple tokenizer that is using the java.util.StringTokenizer class to tokenize the strings.", wordTokenizer0.globalInfo());
      assertEquals("Set of delimiter characters to use in tokenizing (\\r, \\n and \\t can be used for carriage-return, line-feed and tab)", wordTokenizer0.delimitersTipText());
      assertEquals(" \r\n\t.,;:'\"()?!", wordTokenizer0.getDelimiters());
      
      MultiFilter multiFilter1 = new MultiFilter();
      assertNotNull(multiFilter1);
      assertFalse(multiFilter1.equals((Object)multiFilter0));
      assertTrue(multiFilter1.isNewBatch());
      assertFalse(multiFilter1.isFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertFalse(multiFilter1.getDebug());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      
      ClassOrder classOrder0 = new ClassOrder();
      assertNotNull(classOrder0);
      assertFalse(classOrder0.isFirstBatchDone());
      assertTrue(classOrder0.isNewBatch());
      assertFalse(classOrder0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Specify the class order after the filtering", classOrder0.classOrderTipText());
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder0.globalInfo());
      assertEquals(1L, classOrder0.getSeed());
      assertFalse(classOrder0.isOutputFormatDefined());
      assertEquals(0, classOrder0.getClassOrder());
      assertEquals("Specify the seed of randomization of the class order", classOrder0.seedTipText());
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      assertEquals(2, ClassOrder.RANDOM);
      
      // Undeclared exception!
      try { 
        classOrder0.getOutputFormat();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // No output format defined.
         //
         verifyException("weka.filters.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      
      filter0.useDefaultVisual();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      
      Instances instances1 = textDirectoryLoader0.getDataSet();
      assertSame(instances1, instances0);
      assertNotNull(instances1);
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals(0, instances1.numInstances());
      assertEquals(0, instances1.size());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      assertTrue(instances1.checkForStringAttributes());
      assertEquals(1, instances1.classIndex());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances1.relationName());
      assertEquals(0, instances1.numClasses());
      
      instanceEvent0.setStructure(instances0);
      assertSame(instances0, instances1);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      
      Enumeration enumeration0 = multiFilter0.listOptions();
      assertNotNull(enumeration0);
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      
      appender0.transferFocusUpCycle();
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      
      filter0.setFilter(multiFilter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      
      instanceEvent0.setStatus(1);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      appender0.grabFocus();
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals(1, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      filter0.removeDataSourceListener(appender0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      
      filter0.removeInstanceListener(appender0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      
      filter0.addTrainingSetListener(appender0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      
      Instances instances2 = textDirectoryLoader0.getStructure();
      assertSame(instances2, instances0);
      assertSame(instances2, instances1);
      assertNotNull(instances2);
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances2.relationName());
      assertEquals(0, instances2.size());
      assertEquals(0, instances2.numInstances());
      assertTrue(instances2.checkForStringAttributes());
      assertEquals(0.0, instances2.sumOfWeights(), 0.01);
      assertEquals(2, instances2.numAttributes());
      assertEquals(0, instances2.numClasses());
      assertEquals(1, instances2.classIndex());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      
      MultiFilter multiFilter1 = (MultiFilter)filter0.getWrappedAlgorithm();
      assertSame(multiFilter1, multiFilter0);
      assertNotNull(multiFilter1);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      assertTrue(multiFilter1.isNewBatch());
      assertFalse(multiFilter1.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertFalse(multiFilter1.getDebug());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(instances1, instances0);
      assertNotNull(trainingSetEvent0);
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances1.numInstances());
      assertEquals(0, instances1.size());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      assertTrue(instances1.checkForStringAttributes());
      assertEquals(1, instances1.classIndex());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances1.relationName());
      assertEquals(0, instances1.numClasses());
      
      appender0.transferFocusUpCycle();
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      
      filter0.addConfigurationListener((ConfigurationListener) null);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertSame(instances0, instances2);
      assertSame(instances0, instances1);
      assertSame(instances1, instances2);
      assertSame(instances1, instances0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances1.numInstances());
      assertEquals(0, instances1.size());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      assertTrue(instances1.checkForStringAttributes());
      assertEquals(1, instances1.classIndex());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances1.relationName());
      assertEquals(0, instances1.numClasses());
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertEquals("Appender", appender0.getCustomName());
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      
      filter0.useDefaultVisual();
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      
      textDirectoryLoader0.reset();
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      
      Instances instances1 = textDirectoryLoader0.getDataSet();
      assertNotSame(instances1, instances0);
      assertNotNull(instances1);
      assertTrue(instances1.equals((Object)instances0));
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals(0, instances1.numInstances());
      assertEquals(0, instances1.size());
      assertTrue(instances1.checkForStringAttributes());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      assertEquals(1, instances1.classIndex());
      assertEquals(0, instances1.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances1.relationName());
      
      instanceEvent0.setStructure(instances0);
      assertNotSame(instances0, instances1);
      assertTrue(instances0.equals((Object)instances1));
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertEquals("Appender", appender0.getCustomName());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(0);
      assertNotNull(binarySparseInstance0);
      assertEquals(0, binarySparseInstance0.numValues());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(0, binarySparseInstance0.numAttributes());
      assertEquals(0, AbstractInstance.s_numericAfterDecimalPoint);
      
      instanceEvent0.setInstance(binarySparseInstance0);
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertEquals("Appender", appender0.getCustomName());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, binarySparseInstance0.numValues());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(0, binarySparseInstance0.numAttributes());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, AbstractInstance.s_numericAfterDecimalPoint);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      
      Enumeration enumeration0 = multiFilter0.listOptions();
      assertNotNull(enumeration0);
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      
      appender0.transferFocusUpCycle();
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertEquals("Appender", appender0.getCustomName());
      
      instanceEvent0.setInstance(binarySparseInstance0);
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertEquals("Appender", appender0.getCustomName());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, binarySparseInstance0.numValues());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(0, binarySparseInstance0.numAttributes());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, AbstractInstance.s_numericAfterDecimalPoint);
      
      MultiFilter multiFilter1 = new MultiFilter();
      assertNotNull(multiFilter1);
      assertFalse(multiFilter1.equals((Object)multiFilter0));
      assertFalse(multiFilter1.getDebug());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      assertFalse(multiFilter1.isFirstBatchDone());
      assertTrue(multiFilter1.isNewBatch());
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      
      Enumeration enumeration1 = multiFilter1.listOptions();
      assertNotSame(multiFilter1, multiFilter0);
      assertNotSame(enumeration1, enumeration0);
      assertNotNull(enumeration1);
      assertFalse(multiFilter1.equals((Object)multiFilter0));
      assertFalse(enumeration1.equals((Object)enumeration0));
      assertFalse(multiFilter1.getDebug());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      assertFalse(multiFilter1.isFirstBatchDone());
      assertTrue(multiFilter1.isNewBatch());
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      
      InstanceEvent instanceEvent1 = appender0.m_ie;
      assertSame(instanceEvent1, instanceEvent0);
      assertNotNull(instanceEvent1);
      assertEquals(0, instanceEvent1.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      instanceEvent1.setStatus(2);
      assertSame(instanceEvent1, instanceEvent0);
      assertEquals(2, instanceEvent1.getStatus());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertEquals("Appender", appender0.getCustomName());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      Appender appender1 = new Appender();
      assertNotNull(appender1);
      assertFalse(appender1.equals((Object)appender0));
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.isFocusCycleRoot());
      
      appender1.grabFocus();
      assertNotSame(appender1, appender0);
      assertFalse(appender1.equals((Object)appender0));
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.isFocusCycleRoot());
      
      filter0.acceptInstance(instanceEvent0);
      assertNotSame(appender0, appender1);
      assertSame(instanceEvent0, instanceEvent1);
      assertFalse(appender0.equals((Object)appender1));
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertEquals("Appender", appender0.getCustomName());
      assertEquals(2, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      filter0.setFilter(multiFilter0);
      assertNotSame(multiFilter0, multiFilter1);
      assertFalse(multiFilter0.equals((Object)multiFilter1));
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(appender1, instances0);
      assertNotNull(trainingSetEvent0);
      assertFalse(appender1.equals((Object)appender0));
      assertTrue(instances0.equals((Object)instances1));
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.isFocusCycleRoot());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      
      appender1.transferFocusUpCycle();
      assertNotSame(appender1, appender0);
      assertFalse(appender1.equals((Object)appender0));
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.isFocusCycleRoot());
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertNotSame(appender1, appender0);
      assertNotSame(instances0, instances1);
      assertFalse(appender1.equals((Object)appender0));
      assertTrue(instances0.equals((Object)instances1));
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.isFocusCycleRoot());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      
      BayesNet bayesNet0 = new BayesNet();
      assertNotNull(bayesNet0);
      assertEquals("Set the name of a file in BIF XML format. A Bayes network learned from data can be compared with the Bayes network represented by the BIF file. Statistics calculated are o.a. the number of missing and extra arcs.", bayesNet0.BIFFileTipText());
      assertFalse(bayesNet0.getUseADTree());
      assertEquals("If set to true, classifier may output additional info to the console.", bayesNet0.debugTipText());
      assertEquals("When ADTree (the data structure for increasing speed on counts, not to be confused with the classifier under the same name) is used learning time goes down typically. However, because ADTrees are memory intensive, memory problems may occur. Switching this option off makes the structure learning algorithms slower, and run with less memory. By default, ADTrees are used.", bayesNet0.useADTreeTipText());
      assertEquals("Bayes Network learning using various search algorithms and quality measures.\nBase class for a Bayes Network classifier. Provides datastructures (network structure, conditional probability distributions, etc.) and facilities common to Bayes Network learning algorithms like K2 and B.\n\nFor more information see:\n\nhttp://www.cs.waikato.ac.nz/~remco/weka.pdf", bayesNet0.globalInfo());
      assertEquals(2, bayesNet0.graphType());
      assertFalse(bayesNet0.getDebug());
      assertEquals("Select method used for searching network structures.", bayesNet0.searchAlgorithmTipText());
      assertEquals("Select Estimator algorithm for finding the conditional probability tables of the Bayes Network.", bayesNet0.estimatorTipText());
      
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "@relation");
      assertFalse(boolean0);
      
      instanceEvent1.setStatus(3202);
      assertSame(instanceEvent1, instanceEvent0);
      assertNotSame(appender0, appender1);
      assertFalse(appender0.equals((Object)appender1));
      assertEquals(3202, instanceEvent1.getStatus());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertEquals("Appender", appender0.getCustomName());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      filter0.acceptInstance(instanceEvent1);
      assertSame(instanceEvent1, instanceEvent0);
      assertNotSame(appender0, appender1);
      assertFalse(appender0.equals((Object)appender1));
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals(3202, instanceEvent1.getStatus());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertEquals("Appender", appender0.getCustomName());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      WordTokenizer wordTokenizer0 = new WordTokenizer();
      assertNotNull(wordTokenizer0);
      assertEquals(" \r\n\t.,;:'\"()?!", wordTokenizer0.getDelimiters());
      assertEquals("A simple tokenizer that is using the java.util.StringTokenizer class to tokenize the strings.", wordTokenizer0.globalInfo());
      assertEquals("Set of delimiter characters to use in tokenizing (\\r, \\n and \\t can be used for carriage-return, line-feed and tab)", wordTokenizer0.delimitersTipText());
      
      MultiFilter multiFilter2 = new MultiFilter();
      assertNotNull(multiFilter2);
      assertFalse(multiFilter2.equals((Object)multiFilter0));
      assertFalse(multiFilter2.equals((Object)multiFilter1));
      assertTrue(multiFilter2.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter2.globalInfo());
      assertFalse(multiFilter2.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter2.getDebug());
      assertFalse(multiFilter2.isOutputFormatDefined());
      assertFalse(multiFilter2.isFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter2.filtersTipText());
      assertEquals("Turns on output of debugging information.", multiFilter2.debugTipText());
      
      ClassOrder classOrder0 = new ClassOrder();
      assertNotNull(classOrder0);
      assertEquals(1L, classOrder0.getSeed());
      assertEquals("Specify the seed of randomization of the class order", classOrder0.seedTipText());
      assertFalse(classOrder0.isOutputFormatDefined());
      assertEquals(0, classOrder0.getClassOrder());
      assertFalse(classOrder0.isFirstBatchDone());
      assertTrue(classOrder0.isNewBatch());
      assertFalse(classOrder0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Specify the class order after the filtering", classOrder0.classOrderTipText());
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder0.globalInfo());
      assertEquals(2, ClassOrder.RANDOM);
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      
      boolean boolean1 = filter0.connectionAllowed("b;:y");
      assertFalse(boolean1 == boolean0);
      assertTrue(boolean1);
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      
      filter0.acceptInstance(instanceEvent0);
      assertNotSame(appender0, appender1);
      assertSame(instanceEvent0, instanceEvent1);
      assertFalse(appender0.equals((Object)appender1));
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertEquals("Appender", appender0.getCustomName());
      assertEquals(3202, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      InstanceEvent instanceEvent1 = appender0.m_ie;
      assertSame(instanceEvent1, instanceEvent0);
      assertNotNull(instanceEvent1);
      assertEquals(0, instanceEvent1.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      
      filter0.useDefaultVisual();
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numClasses());
      
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(2);
      assertNotNull(binarySparseInstance0);
      assertEquals(2, binarySparseInstance0.numValues());
      assertEquals(2, binarySparseInstance0.numAttributes());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(0, AbstractInstance.s_numericAfterDecimalPoint);
      
      boolean boolean0 = appender0.isFocusOwner();
      assertFalse(boolean0);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      
      instanceEvent1.setInstance(binarySparseInstance0);
      assertSame(instanceEvent1, instanceEvent0);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals(0, instanceEvent1.getStatus());
      assertEquals(2, binarySparseInstance0.numValues());
      assertEquals(2, binarySparseInstance0.numAttributes());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, AbstractInstance.s_numericAfterDecimalPoint);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      
      Enumeration enumeration0 = multiFilter0.listOptions();
      assertNotNull(enumeration0);
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      
      filter0.setFilter(multiFilter0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      instanceEvent1.setStatus(2);
      assertSame(instanceEvent1, instanceEvent0);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals(2, instanceEvent1.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      appender0.grabFocus();
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      
      instanceEvent0.setInstance(binarySparseInstance0);
      assertSame(instanceEvent0, instanceEvent1);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals(2, instanceEvent0.getStatus());
      assertEquals(2, binarySparseInstance0.numValues());
      assertEquals(2, binarySparseInstance0.numAttributes());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, AbstractInstance.s_numericAfterDecimalPoint);
      
      filter0.acceptInstance(instanceEvent1);
      assertSame(instanceEvent1, instanceEvent0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals(2, instanceEvent1.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      Filter filter1 = new Filter();
      assertNotNull(filter1);
      assertFalse(filter1.equals((Object)filter0));
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.getIgnoreRepaint());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(instanceEvent1, instances0);
      assertNotNull(trainingSetEvent0);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals(2, instanceEvent1.getStatus());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      appender0.transferFocusUpCycle();
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertNotSame(filter0, filter1);
      assertSame(instanceEvent1, instanceEvent0);
      assertFalse(filter0.equals((Object)filter1));
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals(2, instanceEvent1.getStatus());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(0, instances0.size());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      BayesNet bayesNet0 = new BayesNet();
      assertNotNull(bayesNet0);
      assertFalse(bayesNet0.getDebug());
      assertEquals("Select method used for searching network structures.", bayesNet0.searchAlgorithmTipText());
      assertEquals("Select Estimator algorithm for finding the conditional probability tables of the Bayes Network.", bayesNet0.estimatorTipText());
      assertFalse(bayesNet0.getUseADTree());
      assertEquals("When ADTree (the data structure for increasing speed on counts, not to be confused with the classifier under the same name) is used learning time goes down typically. However, because ADTrees are memory intensive, memory problems may occur. Switching this option off makes the structure learning algorithms slower, and run with less memory. By default, ADTrees are used.", bayesNet0.useADTreeTipText());
      assertEquals("Bayes Network learning using various search algorithms and quality measures.\nBase class for a Bayes Network classifier. Provides datastructures (network structure, conditional probability distributions, etc.) and facilities common to Bayes Network learning algorithms like K2 and B.\n\nFor more information see:\n\nhttp://www.cs.waikato.ac.nz/~remco/weka.pdf", bayesNet0.globalInfo());
      assertEquals(2, bayesNet0.graphType());
      assertEquals("If set to true, classifier may output additional info to the console.", bayesNet0.debugTipText());
      assertEquals("Set the name of a file in BIF XML format. A Bayes network learned from data can be compared with the Bayes network represented by the BIF file. Statistics calculated are o.a. the number of missing and extra arcs.", bayesNet0.BIFFileTipText());
      
      filter0.acceptInstance(instanceEvent1);
      assertNotSame(filter0, filter1);
      assertSame(instanceEvent1, instanceEvent0);
      assertFalse(filter0.equals((Object)filter1));
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals(2, instanceEvent1.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      WordTokenizer wordTokenizer0 = new WordTokenizer();
      assertNotNull(wordTokenizer0);
      assertEquals(" \r\n\t.,;:'\"()?!", wordTokenizer0.getDelimiters());
      assertEquals("Set of delimiter characters to use in tokenizing (\\r, \\n and \\t can be used for carriage-return, line-feed and tab)", wordTokenizer0.delimitersTipText());
      assertEquals("A simple tokenizer that is using the java.util.StringTokenizer class to tokenize the strings.", wordTokenizer0.globalInfo());
      
      MultiFilter multiFilter1 = new MultiFilter();
      assertNotNull(multiFilter1);
      assertFalse(multiFilter1.equals((Object)multiFilter0));
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter1.getDebug());
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      assertFalse(multiFilter1.isFirstBatchDone());
      assertTrue(multiFilter1.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      
      ClassOrder classOrder0 = new ClassOrder();
      assertNotNull(classOrder0);
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder0.globalInfo());
      assertEquals(0, classOrder0.getClassOrder());
      assertTrue(classOrder0.isNewBatch());
      assertFalse(classOrder0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Specify the seed of randomization of the class order", classOrder0.seedTipText());
      assertFalse(classOrder0.isOutputFormatDefined());
      assertEquals(1L, classOrder0.getSeed());
      assertEquals("Specify the class order after the filtering", classOrder0.classOrderTipText());
      assertFalse(classOrder0.isFirstBatchDone());
      assertEquals(2, ClassOrder.RANDOM);
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      
      classOrder0.setSeed((-236L));
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder0.globalInfo());
      assertEquals(0, classOrder0.getClassOrder());
      assertTrue(classOrder0.isNewBatch());
      assertFalse(classOrder0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Specify the seed of randomization of the class order", classOrder0.seedTipText());
      assertEquals((-236L), classOrder0.getSeed());
      assertFalse(classOrder0.isOutputFormatDefined());
      assertEquals("Specify the class order after the filtering", classOrder0.classOrderTipText());
      assertFalse(classOrder0.isFirstBatchDone());
      assertEquals(2, ClassOrder.RANDOM);
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      
      // Undeclared exception!
      try { 
        classOrder0.getOutputFormat();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // No output format defined.
         //
         verifyException("weka.filters.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      
      InstanceEvent instanceEvent0 = appender0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      
      filter0.useDefaultVisual();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      
      textDirectoryLoader0.reset();
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      
      Instances instances1 = textDirectoryLoader0.getDataSet();
      assertNotSame(instances1, instances0);
      assertNotNull(instances1);
      assertTrue(instances1.equals((Object)instances0));
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals(0, instances1.numInstances());
      assertEquals(0, instances1.numClasses());
      assertEquals(1, instances1.classIndex());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances1.relationName());
      assertEquals(0, instances1.size());
      assertTrue(instances1.checkForStringAttributes());
      assertEquals(0.0, instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      
      instanceEvent0.setStructure(instances0);
      assertNotSame(instances0, instances1);
      assertTrue(instances0.equals((Object)instances1));
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(0);
      assertNotNull(binarySparseInstance0);
      assertEquals(0, binarySparseInstance0.numValues());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(0, binarySparseInstance0.numAttributes());
      assertEquals(0, AbstractInstance.s_numericAfterDecimalPoint);
      
      instanceEvent0.setInstance(binarySparseInstance0);
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, binarySparseInstance0.numValues());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(0, binarySparseInstance0.numAttributes());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, AbstractInstance.s_numericAfterDecimalPoint);
      
      SysErrLog sysErrLog0 = new SysErrLog();
      assertNotNull(sysErrLog0);
      
      sysErrLog0.logMessage("&/[Y~e");
      filter0.setLog(sysErrLog0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      Appender appender1 = new Appender();
      assertNotNull(appender1);
      assertFalse(appender1.equals((Object)appender0));
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isBusy());
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      
      JToolTip jToolTip0 = filter0.createToolTip();
      assertNotNull(jToolTip0);
      assertFalse(jToolTip0.isFocusCycleRoot());
      assertFalse(jToolTip0.isFocusTraversalPolicySet());
      assertFalse(jToolTip0.isFocusTraversalPolicyProvider());
      assertFalse(jToolTip0.getIgnoreRepaint());
      assertTrue(jToolTip0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      Add add0 = new Add();
      assertNotNull(add0);
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("unnamed", add0.getAttributeName());
      
      filter0.setFilter(add0);
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("unnamed", add0.getAttributeName());
      
      ClassOrder classOrder0 = new ClassOrder();
      assertNotNull(classOrder0);
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder0.globalInfo());
      assertEquals(0, classOrder0.getClassOrder());
      assertTrue(classOrder0.isNewBatch());
      assertFalse(classOrder0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Specify the seed of randomization of the class order", classOrder0.seedTipText());
      assertFalse(classOrder0.isOutputFormatDefined());
      assertEquals(1L, classOrder0.getSeed());
      assertEquals("Specify the class order after the filtering", classOrder0.classOrderTipText());
      assertFalse(classOrder0.isFirstBatchDone());
      assertEquals(2, ClassOrder.RANDOM);
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      
      InstanceEvent instanceEvent1 = appender1.m_ie;
      assertNotSame(instanceEvent1, instanceEvent0);
      assertNotNull(instanceEvent1);
      assertFalse(instanceEvent1.equals((Object)instanceEvent0));
      assertEquals(0, instanceEvent1.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      filter0.acceptInstance(instanceEvent0);
      assertNotSame(appender0, appender1);
      assertNotSame(instanceEvent0, instanceEvent1);
      assertFalse(appender0.equals((Object)appender1));
      assertFalse(instanceEvent0.equals((Object)instanceEvent1));
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusCycleRoot());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      Enumeration enumeration0 = filter0.enumerateRequests();
      assertNotNull(enumeration0);
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      filter0.setFilter(classOrder0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>Changes the order of the classes so that the class values are no longer of in the order specified in the header</font><br><br> The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order.<br>Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier.<br>The value can also be converted back using 'originalValue(double value)' procedure.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("ClassOrder", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", classOrder0.globalInfo());
      assertEquals(0, classOrder0.getClassOrder());
      assertTrue(classOrder0.isNewBatch());
      assertFalse(classOrder0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Specify the seed of randomization of the class order", classOrder0.seedTipText());
      assertFalse(classOrder0.isOutputFormatDefined());
      assertEquals(1L, classOrder0.getSeed());
      assertEquals("Specify the class order after the filtering", classOrder0.classOrderTipText());
      assertFalse(classOrder0.isFirstBatchDone());
      assertEquals(2, ClassOrder.RANDOM);
      assertEquals(1, ClassOrder.FREQ_DESCEND);
      assertEquals(0, ClassOrder.FREQ_ASCEND);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertNotNull(substringLabeler0);
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      
      SVMLightLoader sVMLightLoader0 = new SVMLightLoader();
      assertNotNull(sVMLightLoader0);
      assertFalse(sVMLightLoader0.getUseRelativePath());
      assertEquals(".dat", sVMLightLoader0.getFileExtension());
      assertEquals("Reads a source that is in svm light format.\n\nFor more information about svm light see:\n\nhttp://svmlight.joachims.org/", sVMLightLoader0.globalInfo());
      assertEquals("http://", sVMLightLoader0.retrieveURL());
      assertEquals("Use relative rather than absolute paths", sVMLightLoader0.useRelativePathTipText());
      assertEquals("svm light data files", sVMLightLoader0.getFileDescription());
      
      try { 
        sVMLightLoader0.getStructure();
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // No source has been specified
         //
         verifyException("weka.core.converters.SVMLightLoader", e);
      }
  }
}
