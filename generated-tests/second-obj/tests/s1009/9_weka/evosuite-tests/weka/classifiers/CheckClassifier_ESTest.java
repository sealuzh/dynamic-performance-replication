/*
 * This file was automatically generated by EvoSuite
 * Fri Jul 06 22:29:38 GMT 2018
 */

package weka.classifiers;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.Locale;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;
import weka.classifiers.AbstractClassifier;
import weka.classifiers.CheckClassifier;
import weka.classifiers.Classifier;
import weka.classifiers.bayes.NaiveBayesMultinomialText;
import weka.classifiers.bayes.NaiveBayesMultinomialUpdateable;
import weka.classifiers.functions.LinearRegression;
import weka.classifiers.functions.MultilayerPerceptron;
import weka.classifiers.meta.FilteredClassifier;
import weka.classifiers.meta.MultiClassClassifier;
import weka.classifiers.rules.ZeroR;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class CheckClassifier_ESTest extends CheckClassifier_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.setNumString(50);
      checkClassifier0.declaresSerialVersionUID();
      boolean boolean0 = false;
      boolean boolean1 = false;
      LinearRegression linearRegression0 = new LinearRegression();
      checkClassifier0.m_Classifier = (Classifier) linearRegression0;
      int int0 = 10;
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleOnlyClass(true, true, true, false, false, 10);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '10' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(false, false, false, false, false, false, (-23));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-23' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      boolean boolean0 = true;
      boolean boolean1 = false;
      boolean boolean2 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleNClasses(true, true, true, false, true, true, (-1750));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: / by zero
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      boolean boolean0 = false;
      boolean boolean1 = false;
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleClassAsNthAttribute(false, false, false, false, false, false, 137, 137);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '137' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(true, true, true, true, true, true, 2662);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '2662' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.declaresSerialVersionUID();
      try { 
        checkClassifier0.setOptions((String[]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.core.Utils", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(false, false, false, false, false, false, 5);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '5' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      String[] stringArray0 = new String[4];
      stringArray0[0] = "";
      stringArray0[1] = "I5";
      stringArray0[2] = "}2m%g8X*.";
      stringArray0[3] = "Artificial Intelligence";
      CheckClassifier.main(stringArray0);
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.multiInstanceHandler();
      checkClassifier0.getRevision();
      checkClassifier0.canPredict(true, false, true, true, false, false, 4);
      checkClassifier0.setNumString(0);
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(false, false, true, false, true, true, 71, false, true);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '71' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      boolean[] booleanArray0 = checkClassifier0.canHandleOnlyClass(true, true, false, true, true, 0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      
      boolean[] booleanArray0 = checkClassifier0.multiInstanceHandler();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      
      String string0 = checkClassifier0.getWords();
      assertNotNull(string0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals("The,quick,brown,fox,jumps,over,the,lazy,dog", string0);
      
      boolean[] booleanArray1 = checkClassifier0.canPredict(false, false, true, true, false, false, 4);
      assertNotNull(booleanArray1);
      assertTrue(Arrays.equals(new boolean[] {false, true}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      checkClassifier0.setNumString(4);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(4, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumRelational());
      
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(false, false, false, true, false, true, 71, false, true);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '71' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean boolean0 = true;
      boolean boolean1 = false;
      boolean boolean2 = false;
      boolean[] booleanArray0 = checkClassifier0.canHandleMissing(true, false, true, false, false, false, 0, false, false, 21);
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean[] booleanArray1 = checkClassifier0.testToString();
      assertNotNull(booleanArray1);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      String[] stringArray0 = checkClassifier0.getOptions();
      assertNotNull(stringArray0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      String[] stringArray1 = new String[7];
      assertFalse(stringArray1.equals((Object)stringArray0));
      
      stringArray1[0] = "R";
      stringArray1[1] = "$~S&IWn.w($pC-'P*g";
      stringArray1[2] = "";
      stringArray1[3] = "";
      stringArray1[4] = "";
      stringArray1[5] = "1-2";
      stringArray1[6] = "";
      checkClassifier0.setOptions(stringArray1);
      assertNotSame(stringArray1, stringArray0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(stringArray1.equals((Object)stringArray0));
      
      try { 
        checkClassifier0.makeTestDataset(0, 21, 21, 0, 0, (-1693), 0, (-529), (-1693), true);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Illegal Capacity: -1671
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      checkClassifier0.setNumInstances((-497));
      assertEquals((-497), checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      FilteredClassifier filteredClassifier0 = new FilteredClassifier();
      assertNotNull(filteredClassifier0);
      assertEquals("The filter to be used.", filteredClassifier0.filterTipText());
      assertEquals("The base classifier to be used.", filteredClassifier0.classifierTipText());
      assertEquals("Class for running an arbitrary classifier on data that has been passed through an arbitrary filter. Like the classifier, the structure of the filter is based exclusively on the training data and test instances will be processed by the filter without changing their structure.", filteredClassifier0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", filteredClassifier0.debugTipText());
      assertEquals(1, filteredClassifier0.graphType());
      assertFalse(filteredClassifier0.getDebug());
      
      checkClassifier0.m_Classifier = (Classifier) filteredClassifier0;
      assertEquals((-497), checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals("The filter to be used.", filteredClassifier0.filterTipText());
      assertEquals("The base classifier to be used.", filteredClassifier0.classifierTipText());
      assertEquals("Class for running an arbitrary classifier on data that has been passed through an arbitrary filter. Like the classifier, the structure of the filter is based exclusively on the training data and test instances will be processed by the filter without changing their structure.", filteredClassifier0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", filteredClassifier0.debugTipText());
      assertEquals(1, filteredClassifier0.graphType());
      assertFalse(filteredClassifier0.getDebug());
      
      String[] stringArray0 = checkClassifier0.getOptions();
      assertNotNull(stringArray0);
      assertEquals((-497), checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      boolean[] booleanArray0 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertEquals((-497), checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(false, true, false, false, true, true, 65);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '65' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean[] booleanArray0 = checkClassifier0.weightedInstancesHandler();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      String[] stringArray0 = checkClassifier0.getOptions();
      assertNotNull(stringArray0);
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean[] booleanArray1 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray1);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(false, true, false, true, false, true, 65);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '65' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      
      boolean[] booleanArray0 = checkClassifier0.weightedInstancesHandler();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      
      boolean boolean0 = FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      assertFalse(boolean0);
      
      // Undeclared exception!
      try { 
        checkClassifier0.testsPerClassType((-1), true, true, true);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      
      checkClassifier0.setSilent(false);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      
      int int0 = 0;
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(false, false, true, false, true, true, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      
      boolean boolean0 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleMissing(true, false, true, false, true, false, (-16), true, false, 21);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-16' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      
      int int0 = (-6);
      int int1 = 0;
      int int2 = 1415;
      int int3 = (-1355);
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleMissing(false, false, false, false, false, false, (-1355), false, true, 3085);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1355' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      String string0 = checkClassifier0.getWords();
      assertNotNull(string0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals("The,quick,brown,fox,jumps,over,the,lazy,dog", string0);
      
      NaiveBayesMultinomialUpdateable naiveBayesMultinomialUpdateable0 = new NaiveBayesMultinomialUpdateable();
      assertNotNull(naiveBayesMultinomialUpdateable0);
      assertFalse(naiveBayesMultinomialUpdateable0.getDebug());
      assertEquals("If set to true, classifier may output additional info to the console.", naiveBayesMultinomialUpdateable0.debugTipText());
      
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(false, true, false, false, false, false, 2875);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '2875' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      boolean[] booleanArray0 = checkClassifier0.multiInstanceHandler();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      String string0 = checkClassifier0.getWords();
      assertNotNull(string0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals("The,quick,brown,fox,jumps,over,the,lazy,dog", string0);
      
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertNotNull(checkClassifier1);
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(true, true, true, false, true, true, 87);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '87' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      
      checkClassifier0.setSilent(false);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      
      ZeroR zeroR0 = (ZeroR)checkClassifier0.getClassifier();
      assertNotNull(zeroR0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals("If set to true, classifier may output additional info to the console.", zeroR0.debugTipText());
      assertFalse(zeroR0.getDebug());
      assertEquals("Class for building and using a 0-R classifier. Predicts the mean (for a numeric class) or the mode (for a nominal class).", zeroR0.globalInfo());
      
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertNotNull(checkClassifier1);
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(1, checkClassifier1.getNumString());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertEquals(1, checkClassifier1.getNumDate());
      assertFalse(checkClassifier1.getDebug());
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      
      NaiveBayesMultinomialText naiveBayesMultinomialText0 = new NaiveBayesMultinomialText();
      assertNotNull(naiveBayesMultinomialText0);
      assertEquals("If true then document length is normalized according to the settings for norm and lnorm", naiveBayesMultinomialText0.normalizeDocLengthTipText());
      assertEquals(2.0, naiveBayesMultinomialText0.getLNorm(), 0.01);
      assertEquals(0, naiveBayesMultinomialText0.getPeriodicPruning());
      assertFalse(naiveBayesMultinomialText0.getNormalizeDocLength());
      assertEquals("The tokenizing algorithm to use on the strings.", naiveBayesMultinomialText0.tokenizerTipText());
      assertEquals("Ignore any words that don't occur at least min frequency times in the training data. If periodic pruning is turned on, then the dictionary is pruned according to this value", naiveBayesMultinomialText0.minWordFrequencyTipText());
      assertEquals("Use word frequencies rather than binary bag of words representation", naiveBayesMultinomialText0.useWordFrequenciesTipText());
      assertEquals(3.0, naiveBayesMultinomialText0.getMinWordFrequency(), 0.01);
      assertEquals("If true, ignores all words that are on the stoplist.", naiveBayesMultinomialText0.useStopListTipText());
      assertEquals("The stemming algorithm to use on the words.", naiveBayesMultinomialText0.stemmerTipText());
      assertFalse(naiveBayesMultinomialText0.getLowercaseTokens());
      assertEquals("The LNorm to use for document length normalization.", naiveBayesMultinomialText0.LNormTipText());
      assertEquals("The file containing the stopwords (if this is a directory then the default ones are used).", naiveBayesMultinomialText0.stopwordsTipText());
      assertEquals("The norm of the instances after normalization.", naiveBayesMultinomialText0.normTipText());
      assertFalse(naiveBayesMultinomialText0.getUseWordFrequencies());
      assertEquals("Multinomial naive bayes for text data. Operates directly (and only) on String attributes. Other types of input attributes are accepted but ignored during training and classification", naiveBayesMultinomialText0.globalInfo());
      assertEquals("How often (number of instances) to prune the dictionary of low frequency terms. 0 means don't prune. Setting a positive integer n means prune after every n instances", naiveBayesMultinomialText0.periodicPruningTipText());
      assertFalse(naiveBayesMultinomialText0.getUseStopList());
      assertFalse(naiveBayesMultinomialText0.getDebug());
      assertEquals("Whether to convert all tokens to lowercase", naiveBayesMultinomialText0.lowercaseTokensTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", naiveBayesMultinomialText0.debugTipText());
      assertEquals(1.0, naiveBayesMultinomialText0.getNorm(), 0.01);
      
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(false, false, false, false, false, false, 82);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '82' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean[] booleanArray0 = checkClassifier0.weightedInstancesHandler();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean boolean0 = true;
      boolean boolean1 = false;
      boolean boolean2 = FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      assertFalse(boolean2);
      assertFalse(boolean2 == boolean0);
      assertTrue(boolean2 == boolean1);
      
      checkClassifier0.setNumString((-1));
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals((-1), checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean boolean3 = true;
      boolean boolean4 = false;
      boolean boolean5 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(true, false, true, true, true, true, 200003);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '200003' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      boolean boolean0 = false;
      boolean boolean1 = false;
      int int0 = 0;
      boolean boolean2 = true;
      boolean boolean3 = true;
      int int1 = (-1725);
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(false, true, false, false, true, true, (-1725));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1725' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean[] booleanArray0 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      checkClassifier0.setNumNumeric((-2469));
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals((-2469), checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      int int0 = 0;
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertNotNull(checkClassifier1);
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(1, checkClassifier1.getNumDate());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertFalse(checkClassifier1.getSilent());
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(false, false, true, false, true, true, 2);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      boolean[] booleanArray0 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertNotNull(checkClassifier1);
      assertFalse(checkClassifier1.getSilent());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumDate());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      
      boolean[] booleanArray1 = checkClassifier1.correctBuildInitialisation(false, false, false, false, false, true, 0);
      assertNotNull(booleanArray1);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(checkClassifier1, checkClassifier0);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(checkClassifier1.getSilent());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumDate());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      checkClassifier1.setNumNominal(1082);
      assertNotSame(checkClassifier1, checkClassifier0);
      assertFalse(checkClassifier1.getSilent());
      assertEquals(1082, checkClassifier1.getNumNominal());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumDate());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      
      NaiveBayesMultinomialText naiveBayesMultinomialText0 = new NaiveBayesMultinomialText();
      assertNotNull(naiveBayesMultinomialText0);
      assertEquals("The norm of the instances after normalization.", naiveBayesMultinomialText0.normTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", naiveBayesMultinomialText0.debugTipText());
      assertEquals("The stemming algorithm to use on the words.", naiveBayesMultinomialText0.stemmerTipText());
      assertEquals("The file containing the stopwords (if this is a directory then the default ones are used).", naiveBayesMultinomialText0.stopwordsTipText());
      assertEquals(1.0, naiveBayesMultinomialText0.getNorm(), 0.01);
      assertEquals("How often (number of instances) to prune the dictionary of low frequency terms. 0 means don't prune. Setting a positive integer n means prune after every n instances", naiveBayesMultinomialText0.periodicPruningTipText());
      assertEquals("Ignore any words that don't occur at least min frequency times in the training data. If periodic pruning is turned on, then the dictionary is pruned according to this value", naiveBayesMultinomialText0.minWordFrequencyTipText());
      assertEquals("The tokenizing algorithm to use on the strings.", naiveBayesMultinomialText0.tokenizerTipText());
      assertEquals("If true then document length is normalized according to the settings for norm and lnorm", naiveBayesMultinomialText0.normalizeDocLengthTipText());
      assertFalse(naiveBayesMultinomialText0.getUseWordFrequencies());
      assertEquals("Multinomial naive bayes for text data. Operates directly (and only) on String attributes. Other types of input attributes are accepted but ignored during training and classification", naiveBayesMultinomialText0.globalInfo());
      assertEquals("Whether to convert all tokens to lowercase", naiveBayesMultinomialText0.lowercaseTokensTipText());
      assertFalse(naiveBayesMultinomialText0.getDebug());
      assertFalse(naiveBayesMultinomialText0.getNormalizeDocLength());
      assertEquals("If true, ignores all words that are on the stoplist.", naiveBayesMultinomialText0.useStopListTipText());
      assertEquals(2.0, naiveBayesMultinomialText0.getLNorm(), 0.01);
      assertEquals(3.0, naiveBayesMultinomialText0.getMinWordFrequency(), 0.01);
      assertFalse(naiveBayesMultinomialText0.getUseStopList());
      assertFalse(naiveBayesMultinomialText0.getLowercaseTokens());
      assertEquals("The LNorm to use for document length normalization.", naiveBayesMultinomialText0.LNormTipText());
      assertEquals(0, naiveBayesMultinomialText0.getPeriodicPruning());
      assertEquals("Use word frequencies rather than binary bag of words representation", naiveBayesMultinomialText0.useWordFrequenciesTipText());
      
      AbstractClassifier.runClassifier(naiveBayesMultinomialText0, (String[]) null);
      assertEquals("The norm of the instances after normalization.", naiveBayesMultinomialText0.normTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", naiveBayesMultinomialText0.debugTipText());
      assertEquals("The stemming algorithm to use on the words.", naiveBayesMultinomialText0.stemmerTipText());
      assertEquals("The file containing the stopwords (if this is a directory then the default ones are used).", naiveBayesMultinomialText0.stopwordsTipText());
      assertEquals(1.0, naiveBayesMultinomialText0.getNorm(), 0.01);
      assertEquals("How often (number of instances) to prune the dictionary of low frequency terms. 0 means don't prune. Setting a positive integer n means prune after every n instances", naiveBayesMultinomialText0.periodicPruningTipText());
      assertEquals("Ignore any words that don't occur at least min frequency times in the training data. If periodic pruning is turned on, then the dictionary is pruned according to this value", naiveBayesMultinomialText0.minWordFrequencyTipText());
      assertEquals("The tokenizing algorithm to use on the strings.", naiveBayesMultinomialText0.tokenizerTipText());
      assertEquals("If true then document length is normalized according to the settings for norm and lnorm", naiveBayesMultinomialText0.normalizeDocLengthTipText());
      assertFalse(naiveBayesMultinomialText0.getUseWordFrequencies());
      assertEquals("Multinomial naive bayes for text data. Operates directly (and only) on String attributes. Other types of input attributes are accepted but ignored during training and classification", naiveBayesMultinomialText0.globalInfo());
      assertEquals("Whether to convert all tokens to lowercase", naiveBayesMultinomialText0.lowercaseTokensTipText());
      assertFalse(naiveBayesMultinomialText0.getDebug());
      assertFalse(naiveBayesMultinomialText0.getNormalizeDocLength());
      assertEquals("If true, ignores all words that are on the stoplist.", naiveBayesMultinomialText0.useStopListTipText());
      assertEquals(2.0, naiveBayesMultinomialText0.getLNorm(), 0.01);
      assertEquals(3.0, naiveBayesMultinomialText0.getMinWordFrequency(), 0.01);
      assertFalse(naiveBayesMultinomialText0.getUseStopList());
      assertFalse(naiveBayesMultinomialText0.getLowercaseTokens());
      assertEquals("The LNorm to use for document length normalization.", naiveBayesMultinomialText0.LNormTipText());
      assertEquals(0, naiveBayesMultinomialText0.getPeriodicPruning());
      assertEquals("Use word frequencies rather than binary bag of words representation", naiveBayesMultinomialText0.useWordFrequenciesTipText());
      
      CheckClassifier checkClassifier2 = new CheckClassifier();
      assertNotNull(checkClassifier2);
      assertEquals(1, checkClassifier2.getNumNumeric());
      assertEquals(20, checkClassifier2.getNumInstances());
      assertEquals(1, checkClassifier2.getNumRelational());
      assertEquals(" ", checkClassifier2.getWordSeparators());
      assertEquals(2, checkClassifier2.getNumNominal());
      assertEquals(1, checkClassifier2.getNumDate());
      assertFalse(checkClassifier2.getDebug());
      assertEquals(1, checkClassifier2.getNumString());
      assertFalse(checkClassifier2.hasClasspathProblems());
      assertEquals(10, checkClassifier2.getNumInstancesRelational());
      assertFalse(checkClassifier2.getSilent());
      assertFalse(checkClassifier2.equals((Object)checkClassifier1));
      assertFalse(checkClassifier2.equals((Object)checkClassifier0));
      
      MultilayerPerceptron multilayerPerceptron0 = new MultilayerPerceptron();
      assertNotNull(multilayerPerceptron0);
      assertEquals("A Classifier that uses backpropagation to classify instances.\nThis network can be built by hand, created by an algorithm or both. The network can also be monitored and modified during training time. The nodes in this network are all sigmoid (except for when the class is numeric in which case the the output nodes become unthresholded linear units).", multilayerPerceptron0.globalInfo());
      assertTrue(multilayerPerceptron0.getNormalizeAttributes());
      assertEquals("The number of epochs to train through. If the validation set is non-zero then it can terminate the network early", multilayerPerceptron0.trainingTimeTipText());
      assertEquals(0.2, multilayerPerceptron0.getMomentum(), 0.01);
      assertFalse(multilayerPerceptron0.getGUI());
      assertFalse(multilayerPerceptron0.getDecay());
      assertEquals("Seed used to initialise the random number generator.Random numbers are used for setting the initial weights of the connections betweem nodes, and also for shuffling the training data.", multilayerPerceptron0.seedTipText());
      assertEquals("This defines the hidden layers of the neural network. This is a list of positive whole numbers. 1 for each hidden layer. Comma seperated. To have no hidden layers put a single 0 here. This will only be used if autobuild is set. There are also wildcard values 'a' = (attribs + classes) / 2, 'i' = attribs, 'o' = classes , 't' = attribs + classes.", multilayerPerceptron0.hiddenLayersTipText());
      assertEquals(0, multilayerPerceptron0.getSeed());
      assertEquals("This will cause the learning rate to decrease. This will divide the starting learning rate by the epoch number, to determine what the current learning rate should be. This may help to stop the network from diverging from the target output, as well as improve general performance. Note that the decaying learning rate will not be shown in the gui, only the original learning rate. If the learning rate is changed in the gui, this is treated as the starting learning rate.", multilayerPerceptron0.decayTipText());
      assertEquals("The percentage size of the validation set.(The training will continue until it is observed that the error on the validation set has been consistently getting worse, or if the training time is reached).\nIf This is set to zero no validation set will be used and instead the network will train for the specified number of epochs.", multilayerPerceptron0.validationSetSizeTipText());
      assertTrue(multilayerPerceptron0.getAutoBuild());
      assertEquals(500, multilayerPerceptron0.getTrainingTime());
      assertEquals(0.3, multilayerPerceptron0.getLearningRate(), 0.01);
      assertTrue(multilayerPerceptron0.getNormalizeNumericClass());
      assertEquals(0, multilayerPerceptron0.getValidationSetSize());
      assertEquals("The amount the weights are updated.", multilayerPerceptron0.learningRateTipText());
      assertTrue(multilayerPerceptron0.getReset());
      assertTrue(multilayerPerceptron0.getNominalToBinaryFilter());
      assertEquals("a", multilayerPerceptron0.getHiddenLayers());
      assertEquals(20, multilayerPerceptron0.getValidationThreshold());
      assertEquals("This will preprocess the instances with the filter. This could help improve performance if there are nominal attributes in the data.", multilayerPerceptron0.nominalToBinaryFilterTipText());
      assertEquals("This will normalize the attributes. This could help improve performance of the network. This is not reliant on the class being numeric. This will also normalize nominal attributes as well (after they have been run through the nominal to binary filter if that is in use) so that the nominal values are between -1 and 1", multilayerPerceptron0.normalizeAttributesTipText());
      assertEquals("Used to terminate validation testing.The value here dictates how many times in a row the validation set error can get worse before training is terminated.", multilayerPerceptron0.validationThresholdTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", multilayerPerceptron0.debugTipText());
      assertFalse(multilayerPerceptron0.getDebug());
      assertEquals("This will allow the network to reset with a lower learning rate. If the network diverges from the answer this will automatically reset the network with a lower learning rate and begin training again. This option is only available if the gui is not set. Note that if the network diverges but isn't allowed to reset it will fail the training process and return an error message.", multilayerPerceptron0.resetTipText());
      assertEquals("Adds and connects up hidden layers in the network.", multilayerPerceptron0.autoBuildTipText());
      assertEquals("Momentum applied to the weights during updating.", multilayerPerceptron0.momentumTipText());
      assertEquals("This will normalize the class if it's numeric. This could help improve performance of the network, It normalizes the class to be between -1 and 1. Note that this is only internally, the output will be scaled back to the original range.", multilayerPerceptron0.normalizeNumericClassTipText());
      
      checkClassifier2.setClassifier(multilayerPerceptron0);
      assertNotSame(checkClassifier2, checkClassifier1);
      assertNotSame(checkClassifier2, checkClassifier0);
      assertEquals(1, checkClassifier2.getNumNumeric());
      assertEquals(20, checkClassifier2.getNumInstances());
      assertEquals(1, checkClassifier2.getNumRelational());
      assertEquals(" ", checkClassifier2.getWordSeparators());
      assertEquals(2, checkClassifier2.getNumNominal());
      assertEquals(1, checkClassifier2.getNumDate());
      assertFalse(checkClassifier2.getDebug());
      assertEquals(1, checkClassifier2.getNumString());
      assertFalse(checkClassifier2.hasClasspathProblems());
      assertEquals(10, checkClassifier2.getNumInstancesRelational());
      assertFalse(checkClassifier2.getSilent());
      assertEquals("A Classifier that uses backpropagation to classify instances.\nThis network can be built by hand, created by an algorithm or both. The network can also be monitored and modified during training time. The nodes in this network are all sigmoid (except for when the class is numeric in which case the the output nodes become unthresholded linear units).", multilayerPerceptron0.globalInfo());
      assertTrue(multilayerPerceptron0.getNormalizeAttributes());
      assertEquals("The number of epochs to train through. If the validation set is non-zero then it can terminate the network early", multilayerPerceptron0.trainingTimeTipText());
      assertEquals(0.2, multilayerPerceptron0.getMomentum(), 0.01);
      assertFalse(multilayerPerceptron0.getGUI());
      assertFalse(multilayerPerceptron0.getDecay());
      assertEquals("Seed used to initialise the random number generator.Random numbers are used for setting the initial weights of the connections betweem nodes, and also for shuffling the training data.", multilayerPerceptron0.seedTipText());
      assertEquals("This defines the hidden layers of the neural network. This is a list of positive whole numbers. 1 for each hidden layer. Comma seperated. To have no hidden layers put a single 0 here. This will only be used if autobuild is set. There are also wildcard values 'a' = (attribs + classes) / 2, 'i' = attribs, 'o' = classes , 't' = attribs + classes.", multilayerPerceptron0.hiddenLayersTipText());
      assertEquals(0, multilayerPerceptron0.getSeed());
      assertEquals("This will cause the learning rate to decrease. This will divide the starting learning rate by the epoch number, to determine what the current learning rate should be. This may help to stop the network from diverging from the target output, as well as improve general performance. Note that the decaying learning rate will not be shown in the gui, only the original learning rate. If the learning rate is changed in the gui, this is treated as the starting learning rate.", multilayerPerceptron0.decayTipText());
      assertEquals("The percentage size of the validation set.(The training will continue until it is observed that the error on the validation set has been consistently getting worse, or if the training time is reached).\nIf This is set to zero no validation set will be used and instead the network will train for the specified number of epochs.", multilayerPerceptron0.validationSetSizeTipText());
      assertTrue(multilayerPerceptron0.getAutoBuild());
      assertEquals(500, multilayerPerceptron0.getTrainingTime());
      assertEquals(0.3, multilayerPerceptron0.getLearningRate(), 0.01);
      assertTrue(multilayerPerceptron0.getNormalizeNumericClass());
      assertEquals(0, multilayerPerceptron0.getValidationSetSize());
      assertEquals("The amount the weights are updated.", multilayerPerceptron0.learningRateTipText());
      assertTrue(multilayerPerceptron0.getReset());
      assertTrue(multilayerPerceptron0.getNominalToBinaryFilter());
      assertEquals("a", multilayerPerceptron0.getHiddenLayers());
      assertEquals(20, multilayerPerceptron0.getValidationThreshold());
      assertEquals("This will preprocess the instances with the filter. This could help improve performance if there are nominal attributes in the data.", multilayerPerceptron0.nominalToBinaryFilterTipText());
      assertEquals("This will normalize the attributes. This could help improve performance of the network. This is not reliant on the class being numeric. This will also normalize nominal attributes as well (after they have been run through the nominal to binary filter if that is in use) so that the nominal values are between -1 and 1", multilayerPerceptron0.normalizeAttributesTipText());
      assertEquals("Used to terminate validation testing.The value here dictates how many times in a row the validation set error can get worse before training is terminated.", multilayerPerceptron0.validationThresholdTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", multilayerPerceptron0.debugTipText());
      assertFalse(multilayerPerceptron0.getDebug());
      assertEquals("This will allow the network to reset with a lower learning rate. If the network diverges from the answer this will automatically reset the network with a lower learning rate and begin training again. This option is only available if the gui is not set. Note that if the network diverges but isn't allowed to reset it will fail the training process and return an error message.", multilayerPerceptron0.resetTipText());
      assertEquals("Adds and connects up hidden layers in the network.", multilayerPerceptron0.autoBuildTipText());
      assertEquals("Momentum applied to the weights during updating.", multilayerPerceptron0.momentumTipText());
      assertEquals("This will normalize the class if it's numeric. This could help improve performance of the network, It normalizes the class to be between -1 and 1. Note that this is only internally, the output will be scaled back to the original range.", multilayerPerceptron0.normalizeNumericClassTipText());
      assertFalse(checkClassifier2.equals((Object)checkClassifier1));
      assertFalse(checkClassifier2.equals((Object)checkClassifier0));
      
      Enumeration enumeration0 = checkClassifier1.listOptions();
      assertNotNull(enumeration0);
      assertNotSame(checkClassifier1, checkClassifier0);
      assertNotSame(checkClassifier1, checkClassifier2);
      assertFalse(checkClassifier1.getSilent());
      assertEquals(1082, checkClassifier1.getNumNominal());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumDate());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertFalse(checkClassifier1.equals((Object)checkClassifier2));
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean[] booleanArray0 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      int int0 = (-2469);
      checkClassifier0.setNumNumeric((-2469));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals((-2469), checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean boolean0 = false;
      boolean boolean1 = false;
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertNotNull(checkClassifier1);
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      
      boolean boolean2 = true;
      boolean boolean3 = false;
      // Undeclared exception!
      try { 
        checkClassifier1.correctBuildInitialisation(false, true, true, true, false, true, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean[] booleanArray0 = checkClassifier0.multiInstanceHandler();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean[] booleanArray1 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray1);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      String string0 = checkClassifier0.getWords();
      assertNotNull(string0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals("The,quick,brown,fox,jumps,over,the,lazy,dog", string0);
      
      checkClassifier0.setNumString(0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(0, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean[] booleanArray2 = checkClassifier0.correctBuildInitialisation(false, false, true, true, false, false, 4);
      assertNotNull(booleanArray2);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray2));
      assertNotSame(booleanArray2, booleanArray1);
      assertNotSame(booleanArray2, booleanArray0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(0, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      
      NaiveBayesMultinomialText naiveBayesMultinomialText0 = new NaiveBayesMultinomialText();
      assertNotNull(naiveBayesMultinomialText0);
      assertFalse(naiveBayesMultinomialText0.getUseStopList());
      assertFalse(naiveBayesMultinomialText0.getDebug());
      assertEquals(1.0, naiveBayesMultinomialText0.getNorm(), 0.01);
      assertFalse(naiveBayesMultinomialText0.getLowercaseTokens());
      assertEquals(0, naiveBayesMultinomialText0.getPeriodicPruning());
      assertEquals("Use word frequencies rather than binary bag of words representation", naiveBayesMultinomialText0.useWordFrequenciesTipText());
      assertFalse(naiveBayesMultinomialText0.getUseWordFrequencies());
      assertEquals("Multinomial naive bayes for text data. Operates directly (and only) on String attributes. Other types of input attributes are accepted but ignored during training and classification", naiveBayesMultinomialText0.globalInfo());
      assertEquals("The file containing the stopwords (if this is a directory then the default ones are used).", naiveBayesMultinomialText0.stopwordsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", naiveBayesMultinomialText0.debugTipText());
      assertEquals(2.0, naiveBayesMultinomialText0.getLNorm(), 0.01);
      assertEquals("Whether to convert all tokens to lowercase", naiveBayesMultinomialText0.lowercaseTokensTipText());
      assertEquals("Ignore any words that don't occur at least min frequency times in the training data. If periodic pruning is turned on, then the dictionary is pruned according to this value", naiveBayesMultinomialText0.minWordFrequencyTipText());
      assertEquals("The LNorm to use for document length normalization.", naiveBayesMultinomialText0.LNormTipText());
      assertEquals("The stemming algorithm to use on the words.", naiveBayesMultinomialText0.stemmerTipText());
      assertEquals("The norm of the instances after normalization.", naiveBayesMultinomialText0.normTipText());
      assertEquals("If true then document length is normalized according to the settings for norm and lnorm", naiveBayesMultinomialText0.normalizeDocLengthTipText());
      assertFalse(naiveBayesMultinomialText0.getNormalizeDocLength());
      assertEquals("If true, ignores all words that are on the stoplist.", naiveBayesMultinomialText0.useStopListTipText());
      assertEquals("The tokenizing algorithm to use on the strings.", naiveBayesMultinomialText0.tokenizerTipText());
      assertEquals("How often (number of instances) to prune the dictionary of low frequency terms. 0 means don't prune. Setting a positive integer n means prune after every n instances", naiveBayesMultinomialText0.periodicPruningTipText());
      assertEquals(3.0, naiveBayesMultinomialText0.getMinWordFrequency(), 0.01);
      
      String[] stringArray0 = new String[7];
      stringArray0[0] = "The,quick,brown,fox,jumps,over,the,lazy,dog";
      stringArray0[1] = "The,quick,brown,fox,jumps,over,the,lazy,dog";
      stringArray0[2] = "The,quick,brown,fox,jumps,over,the,lazy,dog";
      stringArray0[3] = "The,quick,brown,fox,jumps,over,the,lazy,dog";
      stringArray0[4] = "The,quick,brown,fox,jumps,over,the,lazy,dog";
      stringArray0[5] = "<-DskbMaXZ";
      stringArray0[6] = "The,quick,brown,fox,jumps,over,the,lazy,dog";
      AbstractClassifier.runClassifier(naiveBayesMultinomialText0, stringArray0);
      assertFalse(naiveBayesMultinomialText0.getUseStopList());
      assertFalse(naiveBayesMultinomialText0.getDebug());
      assertEquals(1.0, naiveBayesMultinomialText0.getNorm(), 0.01);
      assertFalse(naiveBayesMultinomialText0.getLowercaseTokens());
      assertEquals(0, naiveBayesMultinomialText0.getPeriodicPruning());
      assertEquals("Use word frequencies rather than binary bag of words representation", naiveBayesMultinomialText0.useWordFrequenciesTipText());
      assertFalse(naiveBayesMultinomialText0.getUseWordFrequencies());
      assertEquals("Multinomial naive bayes for text data. Operates directly (and only) on String attributes. Other types of input attributes are accepted but ignored during training and classification", naiveBayesMultinomialText0.globalInfo());
      assertEquals("The file containing the stopwords (if this is a directory then the default ones are used).", naiveBayesMultinomialText0.stopwordsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", naiveBayesMultinomialText0.debugTipText());
      assertEquals(2.0, naiveBayesMultinomialText0.getLNorm(), 0.01);
      assertEquals("Whether to convert all tokens to lowercase", naiveBayesMultinomialText0.lowercaseTokensTipText());
      assertEquals("Ignore any words that don't occur at least min frequency times in the training data. If periodic pruning is turned on, then the dictionary is pruned according to this value", naiveBayesMultinomialText0.minWordFrequencyTipText());
      assertEquals("The LNorm to use for document length normalization.", naiveBayesMultinomialText0.LNormTipText());
      assertEquals("The stemming algorithm to use on the words.", naiveBayesMultinomialText0.stemmerTipText());
      assertEquals("The norm of the instances after normalization.", naiveBayesMultinomialText0.normTipText());
      assertEquals("If true then document length is normalized according to the settings for norm and lnorm", naiveBayesMultinomialText0.normalizeDocLengthTipText());
      assertFalse(naiveBayesMultinomialText0.getNormalizeDocLength());
      assertEquals("If true, ignores all words that are on the stoplist.", naiveBayesMultinomialText0.useStopListTipText());
      assertEquals("The tokenizing algorithm to use on the strings.", naiveBayesMultinomialText0.tokenizerTipText());
      assertEquals("How often (number of instances) to prune the dictionary of low frequency terms. 0 means don't prune. Setting a positive integer n means prune after every n instances", naiveBayesMultinomialText0.periodicPruningTipText());
      assertEquals(3.0, naiveBayesMultinomialText0.getMinWordFrequency(), 0.01);
      
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertNotNull(checkClassifier1);
      assertEquals(2, checkClassifier1.getNumNominal());
      assertEquals(1, checkClassifier1.getNumDate());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      
      MultilayerPerceptron multilayerPerceptron0 = new MultilayerPerceptron();
      assertNotNull(multilayerPerceptron0);
      assertTrue(multilayerPerceptron0.getNominalToBinaryFilter());
      assertEquals("This will allow the network to reset with a lower learning rate. If the network diverges from the answer this will automatically reset the network with a lower learning rate and begin training again. This option is only available if the gui is not set. Note that if the network diverges but isn't allowed to reset it will fail the training process and return an error message.", multilayerPerceptron0.resetTipText());
      assertTrue(multilayerPerceptron0.getReset());
      assertEquals("The amount the weights are updated.", multilayerPerceptron0.learningRateTipText());
      assertEquals(0.2, multilayerPerceptron0.getMomentum(), 0.01);
      assertTrue(multilayerPerceptron0.getAutoBuild());
      assertEquals(0, multilayerPerceptron0.getSeed());
      assertEquals("This will preprocess the instances with the filter. This could help improve performance if there are nominal attributes in the data.", multilayerPerceptron0.nominalToBinaryFilterTipText());
      assertFalse(multilayerPerceptron0.getDecay());
      assertEquals("a", multilayerPerceptron0.getHiddenLayers());
      assertEquals("This defines the hidden layers of the neural network. This is a list of positive whole numbers. 1 for each hidden layer. Comma seperated. To have no hidden layers put a single 0 here. This will only be used if autobuild is set. There are also wildcard values 'a' = (attribs + classes) / 2, 'i' = attribs, 'o' = classes , 't' = attribs + classes.", multilayerPerceptron0.hiddenLayersTipText());
      assertEquals("The percentage size of the validation set.(The training will continue until it is observed that the error on the validation set has been consistently getting worse, or if the training time is reached).\nIf This is set to zero no validation set will be used and instead the network will train for the specified number of epochs.", multilayerPerceptron0.validationSetSizeTipText());
      assertEquals("This will cause the learning rate to decrease. This will divide the starting learning rate by the epoch number, to determine what the current learning rate should be. This may help to stop the network from diverging from the target output, as well as improve general performance. Note that the decaying learning rate will not be shown in the gui, only the original learning rate. If the learning rate is changed in the gui, this is treated as the starting learning rate.", multilayerPerceptron0.decayTipText());
      assertFalse(multilayerPerceptron0.getDebug());
      assertEquals("This will normalize the attributes. This could help improve performance of the network. This is not reliant on the class being numeric. This will also normalize nominal attributes as well (after they have been run through the nominal to binary filter if that is in use) so that the nominal values are between -1 and 1", multilayerPerceptron0.normalizeAttributesTipText());
      assertEquals("Used to terminate validation testing.The value here dictates how many times in a row the validation set error can get worse before training is terminated.", multilayerPerceptron0.validationThresholdTipText());
      assertFalse(multilayerPerceptron0.getGUI());
      assertEquals("The number of epochs to train through. If the validation set is non-zero then it can terminate the network early", multilayerPerceptron0.trainingTimeTipText());
      assertEquals("Seed used to initialise the random number generator.Random numbers are used for setting the initial weights of the connections betweem nodes, and also for shuffling the training data.", multilayerPerceptron0.seedTipText());
      assertEquals("A Classifier that uses backpropagation to classify instances.\nThis network can be built by hand, created by an algorithm or both. The network can also be monitored and modified during training time. The nodes in this network are all sigmoid (except for when the class is numeric in which case the the output nodes become unthresholded linear units).", multilayerPerceptron0.globalInfo());
      assertTrue(multilayerPerceptron0.getNormalizeAttributes());
      assertEquals("Momentum applied to the weights during updating.", multilayerPerceptron0.momentumTipText());
      assertEquals("This will normalize the class if it's numeric. This could help improve performance of the network, It normalizes the class to be between -1 and 1. Note that this is only internally, the output will be scaled back to the original range.", multilayerPerceptron0.normalizeNumericClassTipText());
      assertEquals(20, multilayerPerceptron0.getValidationThreshold());
      assertEquals("Adds and connects up hidden layers in the network.", multilayerPerceptron0.autoBuildTipText());
      assertEquals(0.3, multilayerPerceptron0.getLearningRate(), 0.01);
      assertEquals(0, multilayerPerceptron0.getValidationSetSize());
      assertEquals("If set to true, classifier may output additional info to the console.", multilayerPerceptron0.debugTipText());
      assertEquals(500, multilayerPerceptron0.getTrainingTime());
      assertTrue(multilayerPerceptron0.getNormalizeNumericClass());
      
      checkClassifier0.setClassifier(multilayerPerceptron0);
      assertNotSame(checkClassifier0, checkClassifier1);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(0, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(multilayerPerceptron0.getNominalToBinaryFilter());
      assertEquals("This will allow the network to reset with a lower learning rate. If the network diverges from the answer this will automatically reset the network with a lower learning rate and begin training again. This option is only available if the gui is not set. Note that if the network diverges but isn't allowed to reset it will fail the training process and return an error message.", multilayerPerceptron0.resetTipText());
      assertTrue(multilayerPerceptron0.getReset());
      assertEquals("The amount the weights are updated.", multilayerPerceptron0.learningRateTipText());
      assertEquals(0.2, multilayerPerceptron0.getMomentum(), 0.01);
      assertTrue(multilayerPerceptron0.getAutoBuild());
      assertEquals(0, multilayerPerceptron0.getSeed());
      assertEquals("This will preprocess the instances with the filter. This could help improve performance if there are nominal attributes in the data.", multilayerPerceptron0.nominalToBinaryFilterTipText());
      assertFalse(multilayerPerceptron0.getDecay());
      assertEquals("a", multilayerPerceptron0.getHiddenLayers());
      assertEquals("This defines the hidden layers of the neural network. This is a list of positive whole numbers. 1 for each hidden layer. Comma seperated. To have no hidden layers put a single 0 here. This will only be used if autobuild is set. There are also wildcard values 'a' = (attribs + classes) / 2, 'i' = attribs, 'o' = classes , 't' = attribs + classes.", multilayerPerceptron0.hiddenLayersTipText());
      assertEquals("The percentage size of the validation set.(The training will continue until it is observed that the error on the validation set has been consistently getting worse, or if the training time is reached).\nIf This is set to zero no validation set will be used and instead the network will train for the specified number of epochs.", multilayerPerceptron0.validationSetSizeTipText());
      assertEquals("This will cause the learning rate to decrease. This will divide the starting learning rate by the epoch number, to determine what the current learning rate should be. This may help to stop the network from diverging from the target output, as well as improve general performance. Note that the decaying learning rate will not be shown in the gui, only the original learning rate. If the learning rate is changed in the gui, this is treated as the starting learning rate.", multilayerPerceptron0.decayTipText());
      assertFalse(multilayerPerceptron0.getDebug());
      assertEquals("This will normalize the attributes. This could help improve performance of the network. This is not reliant on the class being numeric. This will also normalize nominal attributes as well (after they have been run through the nominal to binary filter if that is in use) so that the nominal values are between -1 and 1", multilayerPerceptron0.normalizeAttributesTipText());
      assertEquals("Used to terminate validation testing.The value here dictates how many times in a row the validation set error can get worse before training is terminated.", multilayerPerceptron0.validationThresholdTipText());
      assertFalse(multilayerPerceptron0.getGUI());
      assertEquals("The number of epochs to train through. If the validation set is non-zero then it can terminate the network early", multilayerPerceptron0.trainingTimeTipText());
      assertEquals("Seed used to initialise the random number generator.Random numbers are used for setting the initial weights of the connections betweem nodes, and also for shuffling the training data.", multilayerPerceptron0.seedTipText());
      assertEquals("A Classifier that uses backpropagation to classify instances.\nThis network can be built by hand, created by an algorithm or both. The network can also be monitored and modified during training time. The nodes in this network are all sigmoid (except for when the class is numeric in which case the the output nodes become unthresholded linear units).", multilayerPerceptron0.globalInfo());
      assertTrue(multilayerPerceptron0.getNormalizeAttributes());
      assertEquals("Momentum applied to the weights during updating.", multilayerPerceptron0.momentumTipText());
      assertEquals("This will normalize the class if it's numeric. This could help improve performance of the network, It normalizes the class to be between -1 and 1. Note that this is only internally, the output will be scaled back to the original range.", multilayerPerceptron0.normalizeNumericClassTipText());
      assertEquals(20, multilayerPerceptron0.getValidationThreshold());
      assertEquals("Adds and connects up hidden layers in the network.", multilayerPerceptron0.autoBuildTipText());
      assertEquals(0.3, multilayerPerceptron0.getLearningRate(), 0.01);
      assertEquals(0, multilayerPerceptron0.getValidationSetSize());
      assertEquals("If set to true, classifier may output additional info to the console.", multilayerPerceptron0.debugTipText());
      assertEquals(500, multilayerPerceptron0.getTrainingTime());
      assertTrue(multilayerPerceptron0.getNormalizeNumericClass());
      assertFalse(checkClassifier0.equals((Object)checkClassifier1));
      
      Enumeration enumeration0 = checkClassifier0.listOptions();
      assertNotNull(enumeration0);
      assertNotSame(checkClassifier0, checkClassifier1);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(0, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.equals((Object)checkClassifier1));
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      boolean[] booleanArray0 = checkClassifier0.testToString();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      boolean[] booleanArray1 = checkClassifier0.correctBuildInitialisation(false, false, false, true, true, false, 0);
      assertNotNull(booleanArray1);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      checkClassifier0.setNumRelational(0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(0, checkClassifier0.getNumRelational());
      
      String[] stringArray0 = new String[2];
      stringArray0[0] = "+\"ca&6{\"-u:{y";
      stringArray0[1] = "";
      checkClassifier0.setOptions(stringArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      checkClassifier0.makeTestDataset(0, 30, (-1002), 591, 6, 15000, 15000, 2449, 4, true);
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean[] booleanArray0 = checkClassifier0.multiInstanceHandler();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      String string0 = checkClassifier0.getWords();
      assertNotNull(string0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals("The,quick,brown,fox,jumps,over,the,lazy,dog", string0);
      
      boolean boolean0 = true;
      boolean boolean1 = false;
      boolean boolean2 = true;
      boolean boolean3 = false;
      boolean boolean4 = true;
      LinearRegression linearRegression0 = new LinearRegression();
      assertEquals(0, LinearRegression.SELECTION_M5);
      assertEquals(2, LinearRegression.SELECTION_GREEDY);
      assertEquals(1, LinearRegression.SELECTION_NONE);
      assertNotNull(linearRegression0);
      assertEquals("Class for using linear regression for prediction. Uses the Akaike criterion for model selection, and is able to deal with weighted instances.", linearRegression0.globalInfo());
      assertFalse(linearRegression0.getMinimal());
      assertEquals("Eliminate colinear attributes.", linearRegression0.eliminateColinearAttributesTipText());
      assertEquals(1.0E-8, linearRegression0.getRidge(), 0.01);
      assertFalse(linearRegression0.getDebug());
      assertTrue(linearRegression0.getEliminateColinearAttributes());
      assertEquals("If enabled, dataset header, means and stdevs get discarded to conserve memory; also, the model cannot be printed out.", linearRegression0.minimalTipText());
      assertEquals("Set the method used to select attributes for use in the linear regression. Available methods are: no attribute selection, attribute selection using M5's method (step through the attributes removing the one with the smallest standardised coefficient until no improvement is observed in the estimate of the error given by the Akaike information criterion), and a greedy selection using the Akaike information metric.", linearRegression0.attributeSelectionMethodTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", linearRegression0.debugTipText());
      assertEquals("The value of the Ridge parameter.", linearRegression0.ridgeTipText());
      
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(false, false, false, true, true, false, 84);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '84' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(false, false, false, false, true, false, (-1752), true, true);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1752' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean[] booleanArray0 = checkClassifier0.multiInstanceHandler();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      String string0 = checkClassifier0.getWords();
      assertNotNull(string0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals("The,quick,brown,fox,jumps,over,the,lazy,dog", string0);
      
      LinearRegression linearRegression0 = new LinearRegression();
      assertEquals(1, LinearRegression.SELECTION_NONE);
      assertEquals(0, LinearRegression.SELECTION_M5);
      assertEquals(2, LinearRegression.SELECTION_GREEDY);
      assertNotNull(linearRegression0);
      assertEquals("Set the method used to select attributes for use in the linear regression. Available methods are: no attribute selection, attribute selection using M5's method (step through the attributes removing the one with the smallest standardised coefficient until no improvement is observed in the estimate of the error given by the Akaike information criterion), and a greedy selection using the Akaike information metric.", linearRegression0.attributeSelectionMethodTipText());
      assertEquals("Eliminate colinear attributes.", linearRegression0.eliminateColinearAttributesTipText());
      assertEquals("The value of the Ridge parameter.", linearRegression0.ridgeTipText());
      assertEquals("If enabled, dataset header, means and stdevs get discarded to conserve memory; also, the model cannot be printed out.", linearRegression0.minimalTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", linearRegression0.debugTipText());
      assertEquals("Class for using linear regression for prediction. Uses the Akaike criterion for model selection, and is able to deal with weighted instances.", linearRegression0.globalInfo());
      assertFalse(linearRegression0.getMinimal());
      assertEquals(1.0E-8, linearRegression0.getRidge(), 0.01);
      assertFalse(linearRegression0.getDebug());
      assertTrue(linearRegression0.getEliminateColinearAttributes());
      
      linearRegression0.setEliminateColinearAttributes(true);
      assertEquals(1, LinearRegression.SELECTION_NONE);
      assertEquals(0, LinearRegression.SELECTION_M5);
      assertEquals(2, LinearRegression.SELECTION_GREEDY);
      assertEquals("Set the method used to select attributes for use in the linear regression. Available methods are: no attribute selection, attribute selection using M5's method (step through the attributes removing the one with the smallest standardised coefficient until no improvement is observed in the estimate of the error given by the Akaike information criterion), and a greedy selection using the Akaike information metric.", linearRegression0.attributeSelectionMethodTipText());
      assertEquals("Eliminate colinear attributes.", linearRegression0.eliminateColinearAttributesTipText());
      assertEquals("The value of the Ridge parameter.", linearRegression0.ridgeTipText());
      assertEquals("If enabled, dataset header, means and stdevs get discarded to conserve memory; also, the model cannot be printed out.", linearRegression0.minimalTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", linearRegression0.debugTipText());
      assertEquals("Class for using linear regression for prediction. Uses the Akaike criterion for model selection, and is able to deal with weighted instances.", linearRegression0.globalInfo());
      assertFalse(linearRegression0.getMinimal());
      assertEquals(1.0E-8, linearRegression0.getRidge(), 0.01);
      assertFalse(linearRegression0.getDebug());
      assertTrue(linearRegression0.getEliminateColinearAttributes());
      
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(true, true, true, false, true, true, 2, true, true);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      boolean boolean0 = true;
      boolean boolean1 = false;
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(true, true, true, true, false, false, (-3247));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-3247' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      checkClassifier0.setSilent(false);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      boolean[] booleanArray0 = checkClassifier0.doesntUseTestClassVal(false, false, false, false, false, false, 0);
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      checkClassifier0.setNumDate(0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(0, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      checkClassifier0.setClassifier((Classifier) null);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(0, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      Classifier classifier0 = checkClassifier0.getClassifier();
      assertNull(classifier0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(0, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      LinearRegression linearRegression0 = new LinearRegression();
      assertEquals(2, LinearRegression.SELECTION_GREEDY);
      assertEquals(1, LinearRegression.SELECTION_NONE);
      assertEquals(0, LinearRegression.SELECTION_M5);
      assertNotNull(linearRegression0);
      assertFalse(linearRegression0.getDebug());
      assertEquals("If set to true, classifier may output additional info to the console.", linearRegression0.debugTipText());
      assertEquals("Set the method used to select attributes for use in the linear regression. Available methods are: no attribute selection, attribute selection using M5's method (step through the attributes removing the one with the smallest standardised coefficient until no improvement is observed in the estimate of the error given by the Akaike information criterion), and a greedy selection using the Akaike information metric.", linearRegression0.attributeSelectionMethodTipText());
      assertEquals(1.0E-8, linearRegression0.getRidge(), 0.01);
      assertTrue(linearRegression0.getEliminateColinearAttributes());
      assertEquals("Class for using linear regression for prediction. Uses the Akaike criterion for model selection, and is able to deal with weighted instances.", linearRegression0.globalInfo());
      assertEquals("If enabled, dataset header, means and stdevs get discarded to conserve memory; also, the model cannot be printed out.", linearRegression0.minimalTipText());
      assertEquals("Eliminate colinear attributes.", linearRegression0.eliminateColinearAttributesTipText());
      assertEquals("The value of the Ridge parameter.", linearRegression0.ridgeTipText());
      assertFalse(linearRegression0.getMinimal());
      
      linearRegression0.setEliminateColinearAttributes(false);
      assertEquals(2, LinearRegression.SELECTION_GREEDY);
      assertEquals(1, LinearRegression.SELECTION_NONE);
      assertEquals(0, LinearRegression.SELECTION_M5);
      assertFalse(linearRegression0.getDebug());
      assertEquals("If set to true, classifier may output additional info to the console.", linearRegression0.debugTipText());
      assertEquals("Set the method used to select attributes for use in the linear regression. Available methods are: no attribute selection, attribute selection using M5's method (step through the attributes removing the one with the smallest standardised coefficient until no improvement is observed in the estimate of the error given by the Akaike information criterion), and a greedy selection using the Akaike information metric.", linearRegression0.attributeSelectionMethodTipText());
      assertEquals(1.0E-8, linearRegression0.getRidge(), 0.01);
      assertEquals("Class for using linear regression for prediction. Uses the Akaike criterion for model selection, and is able to deal with weighted instances.", linearRegression0.globalInfo());
      assertEquals("If enabled, dataset header, means and stdevs get discarded to conserve memory; also, the model cannot be printed out.", linearRegression0.minimalTipText());
      assertEquals("Eliminate colinear attributes.", linearRegression0.eliminateColinearAttributesTipText());
      assertEquals("The value of the Ridge parameter.", linearRegression0.ridgeTipText());
      assertFalse(linearRegression0.getMinimal());
      assertFalse(linearRegression0.getEliminateColinearAttributes());
      
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(false, false, false, false, false, false, 2995, false, false);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '2995' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      assertFalse(boolean0);
      
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      String string0 = checkClassifier0.getRevision();
      assertNotNull(string0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals("8034", string0);
      
      boolean[] booleanArray0 = checkClassifier0.weightedInstancesHandler();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(true, false, true, true, true, false, 15, false, false);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '15' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      checkClassifier0.setSilent(false);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      LinearRegression linearRegression0 = new LinearRegression();
      assertEquals(1, LinearRegression.SELECTION_NONE);
      assertEquals(2, LinearRegression.SELECTION_GREEDY);
      assertEquals(0, LinearRegression.SELECTION_M5);
      assertNotNull(linearRegression0);
      assertEquals("If set to true, classifier may output additional info to the console.", linearRegression0.debugTipText());
      assertEquals("The value of the Ridge parameter.", linearRegression0.ridgeTipText());
      assertEquals("If enabled, dataset header, means and stdevs get discarded to conserve memory; also, the model cannot be printed out.", linearRegression0.minimalTipText());
      assertTrue(linearRegression0.getEliminateColinearAttributes());
      assertEquals("Set the method used to select attributes for use in the linear regression. Available methods are: no attribute selection, attribute selection using M5's method (step through the attributes removing the one with the smallest standardised coefficient until no improvement is observed in the estimate of the error given by the Akaike information criterion), and a greedy selection using the Akaike information metric.", linearRegression0.attributeSelectionMethodTipText());
      assertFalse(linearRegression0.getMinimal());
      assertEquals(1.0E-8, linearRegression0.getRidge(), 0.01);
      assertFalse(linearRegression0.getDebug());
      assertEquals("Class for using linear regression for prediction. Uses the Akaike criterion for model selection, and is able to deal with weighted instances.", linearRegression0.globalInfo());
      assertEquals("Eliminate colinear attributes.", linearRegression0.eliminateColinearAttributesTipText());
      
      ZeroR zeroR0 = (ZeroR)checkClassifier0.getClassifier();
      assertNotNull(zeroR0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals("If set to true, classifier may output additional info to the console.", zeroR0.debugTipText());
      assertEquals("Class for building and using a 0-R classifier. Predicts the mean (for a numeric class) or the mode (for a nominal class).", zeroR0.globalInfo());
      assertFalse(zeroR0.getDebug());
      
      System.setCurrentTimeMillis(10);
      linearRegression0.setEliminateColinearAttributes(false);
      assertEquals(1, LinearRegression.SELECTION_NONE);
      assertEquals(2, LinearRegression.SELECTION_GREEDY);
      assertEquals(0, LinearRegression.SELECTION_M5);
      assertEquals("If set to true, classifier may output additional info to the console.", linearRegression0.debugTipText());
      assertEquals("The value of the Ridge parameter.", linearRegression0.ridgeTipText());
      assertEquals("If enabled, dataset header, means and stdevs get discarded to conserve memory; also, the model cannot be printed out.", linearRegression0.minimalTipText());
      assertEquals("Set the method used to select attributes for use in the linear regression. Available methods are: no attribute selection, attribute selection using M5's method (step through the attributes removing the one with the smallest standardised coefficient until no improvement is observed in the estimate of the error given by the Akaike information criterion), and a greedy selection using the Akaike information metric.", linearRegression0.attributeSelectionMethodTipText());
      assertFalse(linearRegression0.getMinimal());
      assertEquals(1.0E-8, linearRegression0.getRidge(), 0.01);
      assertFalse(linearRegression0.getDebug());
      assertFalse(linearRegression0.getEliminateColinearAttributes());
      assertEquals("Class for using linear regression for prediction. Uses the Akaike criterion for model selection, and is able to deal with weighted instances.", linearRegression0.globalInfo());
      assertEquals("Eliminate colinear attributes.", linearRegression0.eliminateColinearAttributesTipText());
      
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertNotNull(checkClassifier1);
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      
      boolean[] booleanArray0 = checkClassifier1.datasetIntegrity(false, false, false, false, false, true, 3, false, true);
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertNotSame(checkClassifier1, checkClassifier0);
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      
      ZeroR zeroR1 = (ZeroR)checkClassifier0.getClassifier();
      assertNotNull(zeroR1);
      assertNotSame(checkClassifier0, checkClassifier1);
      assertSame(zeroR1, zeroR0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(zeroR1.getDebug());
      assertEquals("Class for building and using a 0-R classifier. Predicts the mean (for a numeric class) or the mode (for a nominal class).", zeroR1.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", zeroR1.debugTipText());
      assertFalse(checkClassifier0.equals((Object)checkClassifier1));
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/mnt/gaiagpfs/users/homedirs/apanichella/Evosuite_performance/Dataset/gordon_script_sum/projects/9_weka/Capabilities.props");
      boolean boolean0 = FileSystemHandling.setPermissions(evoSuiteFile0, false, false, false);
      assertFalse(boolean0);
      
      boolean boolean1 = true;
      boolean boolean2 = true;
      int int0 = 0;
      boolean boolean3 = true;
      checkClassifier0.datasetIntegrity(true, false, false, false, true, true, 0, false, true);
      boolean boolean4 = true;
      CheckClassifier checkClassifier1 = new CheckClassifier();
      boolean boolean5 = false;
      boolean boolean6 = false;
      boolean boolean7 = true;
      checkClassifier0.canHandleClassAsNthAttribute(boolean3, boolean6, boolean7, boolean7, boolean5, boolean3, int0, int0);
      boolean boolean8 = true;
      boolean boolean9 = false;
      boolean boolean10 = false;
      int int1 = (-671);
      checkClassifier0.canHandleNClasses(boolean4, boolean8, boolean9, boolean10, boolean1, boolean2, int1);
      boolean boolean11 = false;
      boolean boolean12 = true;
      boolean boolean13 = false;
      int int2 = (-1365);
      checkClassifier0.correctBuildInitialisation(boolean9, boolean11, boolean2, boolean5, boolean12, boolean13, int2);
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      boolean boolean0 = true;
      boolean[] booleanArray0 = checkClassifier0.datasetIntegrity(false, false, false, true, false, true, 0, true, false);
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleClassAsNthAttribute(true, true, true, true, true, true, 42, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '42' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      checkClassifier0.setNumString(50);
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(50, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean[] booleanArray0 = checkClassifier0.declaresSerialVersionUID();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(50, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean boolean0 = false;
      LinearRegression linearRegression0 = new LinearRegression();
      assertEquals(0, LinearRegression.SELECTION_M5);
      assertEquals(2, LinearRegression.SELECTION_GREEDY);
      assertEquals(1, LinearRegression.SELECTION_NONE);
      assertNotNull(linearRegression0);
      assertFalse(linearRegression0.getMinimal());
      assertEquals("Class for using linear regression for prediction. Uses the Akaike criterion for model selection, and is able to deal with weighted instances.", linearRegression0.globalInfo());
      assertEquals("Eliminate colinear attributes.", linearRegression0.eliminateColinearAttributesTipText());
      assertFalse(linearRegression0.getDebug());
      assertEquals(1.0E-8, linearRegression0.getRidge(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", linearRegression0.debugTipText());
      assertTrue(linearRegression0.getEliminateColinearAttributes());
      assertEquals("The value of the Ridge parameter.", linearRegression0.ridgeTipText());
      assertEquals("Set the method used to select attributes for use in the linear regression. Available methods are: no attribute selection, attribute selection using M5's method (step through the attributes removing the one with the smallest standardised coefficient until no improvement is observed in the estimate of the error given by the Akaike information criterion), and a greedy selection using the Akaike information metric.", linearRegression0.attributeSelectionMethodTipText());
      assertEquals("If enabled, dataset header, means and stdevs get discarded to conserve memory; also, the model cannot be printed out.", linearRegression0.minimalTipText());
      
      checkClassifier0.m_Classifier = (Classifier) linearRegression0;
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(50, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(linearRegression0.getMinimal());
      assertEquals("Class for using linear regression for prediction. Uses the Akaike criterion for model selection, and is able to deal with weighted instances.", linearRegression0.globalInfo());
      assertEquals("Eliminate colinear attributes.", linearRegression0.eliminateColinearAttributesTipText());
      assertFalse(linearRegression0.getDebug());
      assertEquals(1.0E-8, linearRegression0.getRidge(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", linearRegression0.debugTipText());
      assertTrue(linearRegression0.getEliminateColinearAttributes());
      assertEquals("The value of the Ridge parameter.", linearRegression0.ridgeTipText());
      assertEquals("Set the method used to select attributes for use in the linear regression. Available methods are: no attribute selection, attribute selection using M5's method (step through the attributes removing the one with the smallest standardised coefficient until no improvement is observed in the estimate of the error given by the Akaike information criterion), and a greedy selection using the Akaike information metric.", linearRegression0.attributeSelectionMethodTipText());
      assertEquals("If enabled, dataset header, means and stdevs get discarded to conserve memory; also, the model cannot be printed out.", linearRegression0.minimalTipText());
      
      boolean boolean1 = false;
      boolean boolean2 = true;
      boolean boolean3 = false;
      boolean boolean4 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleClassAsNthAttribute(false, true, false, true, false, true, (-984), (-3731));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-984' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean boolean1 = true;
      boolean boolean2 = false;
      boolean boolean3 = true;
      boolean boolean4 = true;
      boolean boolean5 = true;
      int int0 = 14;
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleZeroTraining(true, true, false, false, false, false, 14);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '14' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean boolean0 = true;
      boolean[] booleanArray0 = checkClassifier0.datasetIntegrity(false, false, false, true, false, true, 0, true, false);
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleClassAsNthAttribute(true, true, true, true, true, true, 0, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      checkClassifier0.setNumInstances((-497));
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals((-497), checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      FilteredClassifier filteredClassifier0 = new FilteredClassifier();
      assertNotNull(filteredClassifier0);
      assertEquals("If set to true, classifier may output additional info to the console.", filteredClassifier0.debugTipText());
      assertFalse(filteredClassifier0.getDebug());
      assertEquals("The base classifier to be used.", filteredClassifier0.classifierTipText());
      assertEquals("Class for running an arbitrary classifier on data that has been passed through an arbitrary filter. Like the classifier, the structure of the filter is based exclusively on the training data and test instances will be processed by the filter without changing their structure.", filteredClassifier0.globalInfo());
      assertEquals(1, filteredClassifier0.graphType());
      assertEquals("The filter to be used.", filteredClassifier0.filterTipText());
      
      checkClassifier0.m_Classifier = (Classifier) filteredClassifier0;
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals((-497), checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals("If set to true, classifier may output additional info to the console.", filteredClassifier0.debugTipText());
      assertFalse(filteredClassifier0.getDebug());
      assertEquals("The base classifier to be used.", filteredClassifier0.classifierTipText());
      assertEquals("Class for running an arbitrary classifier on data that has been passed through an arbitrary filter. Like the classifier, the structure of the filter is based exclusively on the training data and test instances will be processed by the filter without changing their structure.", filteredClassifier0.globalInfo());
      assertEquals(1, filteredClassifier0.graphType());
      assertEquals("The filter to be used.", filteredClassifier0.filterTipText());
      
      boolean[] booleanArray0 = checkClassifier0.weightedInstancesHandler();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals((-497), checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      String[] stringArray0 = checkClassifier0.getOptions();
      assertNotNull(stringArray0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals((-497), checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean[] booleanArray1 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray1);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals((-497), checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(false, false, true, true, false, false, (-497));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-497' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      boolean[] booleanArray0 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      boolean boolean0 = FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      assertFalse(boolean0);
      
      // Undeclared exception!
      try { 
        checkClassifier0.testsPerClassType((-1), false, false, false);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      
      boolean boolean0 = true;
      boolean boolean1 = true;
      boolean boolean2 = true;
      boolean boolean3 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(true, true, true, true, true, true, 4);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      boolean[] booleanArray0 = checkClassifier0.multiInstanceHandler();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      String string0 = checkClassifier0.getWords();
      assertNotNull(string0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals("The,quick,brown,fox,jumps,over,the,lazy,dog", string0);
      
      int int0 = 0;
      boolean boolean0 = false;
      int int1 = 33;
      int int2 = (-2268);
      int int3 = 596;
      int int4 = (-760);
      int int5 = 71;
      int int6 = 4817;
      int int7 = 1540;
      int int8 = (-735);
      boolean boolean1 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(false, true, true, false, false, true, (-760));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-760' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean[] booleanArray0 = checkClassifier0.multiInstanceHandler();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      String string0 = checkClassifier0.getWords();
      assertNotNull(string0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals("The,quick,brown,fox,jumps,over,the,lazy,dog", string0);
      
      LinearRegression linearRegression0 = new LinearRegression();
      assertEquals(0, LinearRegression.SELECTION_M5);
      assertEquals(1, LinearRegression.SELECTION_NONE);
      assertEquals(2, LinearRegression.SELECTION_GREEDY);
      assertNotNull(linearRegression0);
      assertEquals(1.0E-8, linearRegression0.getRidge(), 0.01);
      assertTrue(linearRegression0.getEliminateColinearAttributes());
      assertFalse(linearRegression0.getMinimal());
      assertEquals("Set the method used to select attributes for use in the linear regression. Available methods are: no attribute selection, attribute selection using M5's method (step through the attributes removing the one with the smallest standardised coefficient until no improvement is observed in the estimate of the error given by the Akaike information criterion), and a greedy selection using the Akaike information metric.", linearRegression0.attributeSelectionMethodTipText());
      assertEquals("Eliminate colinear attributes.", linearRegression0.eliminateColinearAttributesTipText());
      assertEquals("The value of the Ridge parameter.", linearRegression0.ridgeTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", linearRegression0.debugTipText());
      assertEquals("Class for using linear regression for prediction. Uses the Akaike criterion for model selection, and is able to deal with weighted instances.", linearRegression0.globalInfo());
      assertEquals("If enabled, dataset header, means and stdevs get discarded to conserve memory; also, the model cannot be printed out.", linearRegression0.minimalTipText());
      assertFalse(linearRegression0.getDebug());
      
      boolean boolean0 = true;
      int int0 = (-1598);
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(true, true, true, true, false, false, (-1598));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1598' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean boolean0 = true;
      checkClassifier0.setNumString(50);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(50, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean[] booleanArray0 = checkClassifier0.declaresSerialVersionUID();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(50, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean boolean1 = false;
      boolean boolean2 = false;
      int int0 = 0;
      checkClassifier0.setNumString((-310));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals((-310), checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean boolean3 = true;
      boolean boolean4 = false;
      boolean boolean5 = false;
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(false, false, true, false, false, true, (-310));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Illegal Capacity: -309
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      checkClassifier0.setNumString(50);
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(50, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean[] booleanArray0 = checkClassifier0.declaresSerialVersionUID();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(50, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean boolean0 = false;
      boolean boolean1 = true;
      LinearRegression linearRegression0 = new LinearRegression();
      assertEquals(1, LinearRegression.SELECTION_NONE);
      assertEquals(0, LinearRegression.SELECTION_M5);
      assertEquals(2, LinearRegression.SELECTION_GREEDY);
      assertNotNull(linearRegression0);
      assertEquals("The value of the Ridge parameter.", linearRegression0.ridgeTipText());
      assertEquals("Set the method used to select attributes for use in the linear regression. Available methods are: no attribute selection, attribute selection using M5's method (step through the attributes removing the one with the smallest standardised coefficient until no improvement is observed in the estimate of the error given by the Akaike information criterion), and a greedy selection using the Akaike information metric.", linearRegression0.attributeSelectionMethodTipText());
      assertEquals("Eliminate colinear attributes.", linearRegression0.eliminateColinearAttributesTipText());
      assertEquals("Class for using linear regression for prediction. Uses the Akaike criterion for model selection, and is able to deal with weighted instances.", linearRegression0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", linearRegression0.debugTipText());
      assertEquals("If enabled, dataset header, means and stdevs get discarded to conserve memory; also, the model cannot be printed out.", linearRegression0.minimalTipText());
      assertFalse(linearRegression0.getMinimal());
      assertEquals(1.0E-8, linearRegression0.getRidge(), 0.01);
      assertTrue(linearRegression0.getEliminateColinearAttributes());
      assertFalse(linearRegression0.getDebug());
      
      checkClassifier0.m_Classifier = (Classifier) linearRegression0;
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(50, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals("The value of the Ridge parameter.", linearRegression0.ridgeTipText());
      assertEquals("Set the method used to select attributes for use in the linear regression. Available methods are: no attribute selection, attribute selection using M5's method (step through the attributes removing the one with the smallest standardised coefficient until no improvement is observed in the estimate of the error given by the Akaike information criterion), and a greedy selection using the Akaike information metric.", linearRegression0.attributeSelectionMethodTipText());
      assertEquals("Eliminate colinear attributes.", linearRegression0.eliminateColinearAttributesTipText());
      assertEquals("Class for using linear regression for prediction. Uses the Akaike criterion for model selection, and is able to deal with weighted instances.", linearRegression0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", linearRegression0.debugTipText());
      assertEquals("If enabled, dataset header, means and stdevs get discarded to conserve memory; also, the model cannot be printed out.", linearRegression0.minimalTipText());
      assertFalse(linearRegression0.getMinimal());
      assertEquals(1.0E-8, linearRegression0.getRidge(), 0.01);
      assertTrue(linearRegression0.getEliminateColinearAttributes());
      assertFalse(linearRegression0.getDebug());
      
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(true, true, false, true, true, false, 1);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: weka.classifiers.functions.LinearRegression: Cannot handle relational attributes!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean boolean0 = true;
      boolean boolean1 = false;
      boolean boolean2 = true;
      boolean boolean3 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(true, true, true, true, true, true, 14);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '14' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test49()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      checkClassifier0.setSilent(false);
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      ZeroR zeroR0 = (ZeroR)checkClassifier0.getClassifier();
      assertNotNull(zeroR0);
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(zeroR0.getDebug());
      assertEquals("If set to true, classifier may output additional info to the console.", zeroR0.debugTipText());
      assertEquals("Class for building and using a 0-R classifier. Predicts the mean (for a numeric class) or the mode (for a nominal class).", zeroR0.globalInfo());
      
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertNotNull(checkClassifier1);
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumString());
      assertFalse(checkClassifier1.getSilent());
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      
      NaiveBayesMultinomialText naiveBayesMultinomialText0 = new NaiveBayesMultinomialText();
      assertNotNull(naiveBayesMultinomialText0);
      assertEquals(1.0, naiveBayesMultinomialText0.getNorm(), 0.01);
      assertEquals("Use word frequencies rather than binary bag of words representation", naiveBayesMultinomialText0.useWordFrequenciesTipText());
      assertFalse(naiveBayesMultinomialText0.getLowercaseTokens());
      assertFalse(naiveBayesMultinomialText0.getDebug());
      assertEquals(0, naiveBayesMultinomialText0.getPeriodicPruning());
      assertEquals("If true, ignores all words that are on the stoplist.", naiveBayesMultinomialText0.useStopListTipText());
      assertFalse(naiveBayesMultinomialText0.getNormalizeDocLength());
      assertEquals(2.0, naiveBayesMultinomialText0.getLNorm(), 0.01);
      assertEquals("How often (number of instances) to prune the dictionary of low frequency terms. 0 means don't prune. Setting a positive integer n means prune after every n instances", naiveBayesMultinomialText0.periodicPruningTipText());
      assertFalse(naiveBayesMultinomialText0.getUseStopList());
      assertEquals("If true then document length is normalized according to the settings for norm and lnorm", naiveBayesMultinomialText0.normalizeDocLengthTipText());
      assertFalse(naiveBayesMultinomialText0.getUseWordFrequencies());
      assertEquals("Multinomial naive bayes for text data. Operates directly (and only) on String attributes. Other types of input attributes are accepted but ignored during training and classification", naiveBayesMultinomialText0.globalInfo());
      assertEquals("The tokenizing algorithm to use on the strings.", naiveBayesMultinomialText0.tokenizerTipText());
      assertEquals("The file containing the stopwords (if this is a directory then the default ones are used).", naiveBayesMultinomialText0.stopwordsTipText());
      assertEquals("The norm of the instances after normalization.", naiveBayesMultinomialText0.normTipText());
      assertEquals("Whether to convert all tokens to lowercase", naiveBayesMultinomialText0.lowercaseTokensTipText());
      assertEquals("The stemming algorithm to use on the words.", naiveBayesMultinomialText0.stemmerTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", naiveBayesMultinomialText0.debugTipText());
      assertEquals("Ignore any words that don't occur at least min frequency times in the training data. If periodic pruning is turned on, then the dictionary is pruned according to this value", naiveBayesMultinomialText0.minWordFrequencyTipText());
      assertEquals(3.0, naiveBayesMultinomialText0.getMinWordFrequency(), 0.01);
      assertEquals("The LNorm to use for document length normalization.", naiveBayesMultinomialText0.LNormTipText());
      
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(false, false, false, false, true, true, 82);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '82' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test50()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      checkClassifier0.setSilent(false);
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      int int0 = 0;
      boolean[] booleanArray0 = checkClassifier0.doesntUseTestClassVal(true, false, false, true, true, false, 0);
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      checkClassifier0.setNumDate(0);
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(0, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      ZeroR zeroR0 = (ZeroR)checkClassifier0.getClassifier();
      assertNotNull(zeroR0);
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(0, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(zeroR0.getDebug());
      assertEquals("If set to true, classifier may output additional info to the console.", zeroR0.debugTipText());
      assertEquals("Class for building and using a 0-R classifier. Predicts the mean (for a numeric class) or the mode (for a nominal class).", zeroR0.globalInfo());
      
      boolean boolean0 = false;
      int int1 = 25;
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(true, false, false, false, false, false, 25);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '25' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test51()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.testToString();
      checkClassifier0.getWords();
      boolean boolean0 = true;
      boolean boolean1 = true;
      boolean boolean2 = false;
      checkClassifier0.setNumString(0);
      boolean boolean3 = false;
      checkClassifier0.correctBuildInitialisation(false, false, true, false, false, false, 4);
      boolean boolean4 = false;
      boolean boolean5 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(false, false, false, false, false, true, (-2933));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-2933' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test52()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.canTakeOptions();
      CheckClassifier checkClassifier1 = new CheckClassifier();
      checkClassifier1.declaresSerialVersionUID();
      boolean boolean0 = true;
      boolean boolean1 = false;
      LinearRegression linearRegression0 = new LinearRegression();
      boolean boolean2 = true;
      boolean boolean3 = true;
      boolean boolean4 = false;
      boolean boolean5 = false;
      checkClassifier0.instanceWeights(false, true, true, false, false, true, 0);
      boolean boolean6 = false;
      LinearRegression linearRegression1 = new LinearRegression();
      linearRegression1.setEliminateColinearAttributes(boolean4);
      boolean boolean7 = true;
      boolean boolean8 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(boolean0, boolean7, boolean1, boolean2, boolean8, boolean3, linearRegression0.SELECTION_GREEDY, boolean5, boolean6);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test53()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.declaresSerialVersionUID();
      boolean boolean0 = false;
      LinearRegression linearRegression0 = new LinearRegression();
      CheckClassifier checkClassifier1 = new CheckClassifier();
      boolean boolean1 = true;
      // Undeclared exception!
      try { 
        checkClassifier1.instanceWeights(true, false, false, true, false, false, 2);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: weka.classifiers.rules.ZeroR: Cannot handle string class!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test54()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      boolean boolean0 = true;
      boolean boolean1 = true;
      checkClassifier0.testToString();
      String[] stringArray0 = checkClassifier0.getOptions();
      checkClassifier0.setOptions(stringArray0);
      try { 
        checkClassifier0.makeTestDataset(16, (-1040), (-805), 18, (-1693), 3, 17, (-16), 16, (-16), false);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Illegal Capacity: -2459
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void test55()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.setSilent(false);
      int int0 = 0;
      boolean boolean0 = false;
      checkClassifier0.instanceWeights(false, false, false, false, false, false, 0);
      checkClassifier0.setNumDate(0);
      checkClassifier0.getClassifier();
      CheckClassifier checkClassifier1 = new CheckClassifier();
      int int1 = (-3475);
      int int2 = 596;
      int int3 = (-760);
      try { 
        checkClassifier1.makeTestDataset(0, 0, (-1169), (-3475), 33, 0, (-2268), 1416, 596, (-760), false);
        fail("Expecting exception: NegativeArraySizeException");
      
      } catch(NegativeArraySizeException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.core.TestInstances", e);
      }
  }

  @Test(timeout = 4000)
  public void test56()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.multiInstanceHandler();
      checkClassifier0.getWords();
      boolean boolean0 = false;
      // Undeclared exception!
      try { 
        checkClassifier0.testsPerClassType(0, true, true, false);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Problem determining ZeroR performance: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test57()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/mnt/gaiagpfs/users/homedirs/apanichella/Evosuite_performance/Dataset/gordon_script_sum/projects/9_weka/Capabilities.props");
      FileSystemHandling.setPermissions(evoSuiteFile0, false, false, false);
      checkClassifier0.datasetIntegrity(false, true, false, true, false, false, 0, true, false);
      CheckClassifier checkClassifier1 = new CheckClassifier();
      checkClassifier0.canHandleClassAsNthAttribute(true, false, false, true, false, true, 0, 0);
      // Undeclared exception!
      try { 
        checkClassifier1.canHandleNClasses(false, true, true, true, true, true, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: / by zero
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test58()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.testToString();
      checkClassifier0.correctBuildInitialisation(false, false, false, true, true, false, 0);
      checkClassifier0.setNumRelational(0);
      checkClassifier0.correctBuildInitialisation(false, true, false, false, true, false, 0);
      checkClassifier0.setNumNominal((-2906));
      CheckClassifier checkClassifier1 = new CheckClassifier();
      MultilayerPerceptron multilayerPerceptron0 = new MultilayerPerceptron();
  }
}
