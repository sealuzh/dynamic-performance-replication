/*
 * This file was automatically generated by EvoSuite
 * Fri Jul 06 18:52:43 GMT 2018
 */

package weka.classifiers;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.Arrays;
import java.util.Locale;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;
import weka.classifiers.AbstractClassifier;
import weka.classifiers.CheckClassifier;
import weka.classifiers.Classifier;
import weka.classifiers.bayes.NaiveBayesMultinomialText;
import weka.classifiers.functions.SGD;
import weka.classifiers.meta.AdditiveRegression;
import weka.classifiers.rules.DecisionTable;
import weka.core.SelectedTag;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class CheckClassifier_ESTest extends CheckClassifier_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(true, true, false, false, true, true, 87);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '87' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.getOptions();
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(true, true, true, true, false, true, 14);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '14' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.instanceWeights(false, false, false, false, false, true, 0);
      checkClassifier0.canTakeOptions();
      checkClassifier0.getRevision();
      String[] stringArray0 = new String[1];
      stringArray0[0] = "8034";
      CheckClassifier.main(stringArray0);
      checkClassifier0.weightedInstancesHandler();
      checkClassifier0.setNumDate(0);
      // Undeclared exception!
      try { 
        checkClassifier0.doTests();
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(true, false, false, true, true, true, 0, false, false);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.getOptions();
      CheckClassifier checkClassifier1 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier1.correctBuildInitialisation(true, false, true, true, false, false, 78);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '78' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.printAttributeSummary(false, false, false, false, false, false, 0);
      checkClassifier0.testToString();
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(false, false, false, false, false, false, (-1107));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1107' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      SGD sGD0 = new SGD();
      AdditiveRegression additiveRegression0 = new AdditiveRegression(sGD0);
      checkClassifier0.setClassifier(additiveRegression0);
      String[] stringArray0 = checkClassifier0.getOptions();
      checkClassifier0.setOptions(stringArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      boolean boolean0 = false;
      boolean boolean1 = true;
      boolean boolean2 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(false, false, false, false, true, true, (-3148));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-3148' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      DecisionTable decisionTable0 = new DecisionTable();
      decisionTable0.getEvaluationMeasure();
      AbstractClassifier.makeCopy(decisionTable0);
      checkClassifier0.updatingEquality(false, false, false, true, false, false, 3);
      String[] stringArray0 = new String[1];
      stringArray0[0] = "=v*=#+?2CpW,O0";
      CheckClassifier.main(stringArray0);
      CheckClassifier.main(stringArray0);
      checkClassifier0.weightedInstancesHandler();
      checkClassifier0.setNumDate(4);
      assertEquals(1, checkClassifier0.getNumRelational());
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean[] booleanArray0 = checkClassifier0.instanceWeights(false, false, false, false, false, true, 0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertNotNull(booleanArray0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean[] booleanArray1 = checkClassifier0.canTakeOptions();
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertNotNull(booleanArray1);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertNotSame(booleanArray1, booleanArray0);
      
      String string0 = checkClassifier0.getRevision();
      assertNotNull(string0);
      assertEquals("8034", string0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertNotNull(checkClassifier1);
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      
      String[] stringArray0 = checkClassifier1.getOptions();
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertNotNull(stringArray0);
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertNotSame(checkClassifier1, checkClassifier0);
      
      boolean[] booleanArray2 = checkClassifier1.updateableClassifier();
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray2));
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      assertNotNull(booleanArray2);
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertNotSame(checkClassifier1, checkClassifier0);
      assertNotSame(booleanArray2, booleanArray1);
      assertNotSame(booleanArray2, booleanArray0);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      checkClassifier0.setWordSeparators("\tFull name of meta classifier, followed by options.\n\t(default: \"weka.classifiers.rules.Zero\")");
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals("\tFull name of meta classifier, followed by options.\n\t(default: \"weka.classifiers.rules.Zero\")", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      String[] stringArray0 = checkClassifier0.getOptions();
      assertNotNull(stringArray0);
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals("\tFull name of meta classifier, followed by options.\n\t(default: \"weka.classifiers.rules.Zero\")", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(true, false, true, false, false, false, (-1107));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1107' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      boolean boolean0 = true;
      int int0 = 0;
      boolean boolean1 = false;
      boolean boolean2 = true;
      boolean[] booleanArray0 = checkClassifier0.instanceWeights(false, false, false, false, false, true, 0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertNotNull(booleanArray0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(true, true, true, false, true, true, 0, false, false);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      boolean[] booleanArray0 = checkClassifier0.testToString();
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertNotNull(booleanArray0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleMissing(true, true, true, true, true, true, 100, true, true, (-1799));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '100' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      String[] stringArray0 = new String[9];
      boolean boolean0 = true;
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      boolean boolean1 = true;
      boolean boolean2 = false;
      int int0 = 110;
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(true, false, true, false, true, true, 110);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '110' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      
      boolean boolean0 = true;
      boolean boolean1 = false;
      checkClassifier0.printAttributeSummary(false, false, false, false, false, false, 0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      
      boolean boolean2 = false;
      boolean[] booleanArray0 = checkClassifier0.datasetIntegrity(false, false, false, true, false, true, 0, true, true);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertNotNull(booleanArray0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(true, true, false, true, false, false, (-1423));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1423' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      
      boolean boolean0 = false;
      boolean boolean1 = false;
      boolean boolean2 = true;
      boolean boolean3 = true;
      int int0 = 110;
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(false, false, false, true, true, true, 110);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '110' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      
      checkClassifier0.printAttributeSummary(false, false, false, true, true, true, 0);
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      
      checkClassifier0.setNumNominal(0);
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(0, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      
      boolean[] booleanArray0 = checkClassifier0.datasetIntegrity(true, true, true, false, false, false, 0, false, false);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertNotNull(booleanArray0);
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(0, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      
      boolean[] booleanArray1 = checkClassifier0.instanceWeights(true, false, false, true, false, true, 0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertNotNull(booleanArray1);
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(0, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertNotSame(booleanArray1, booleanArray0);
      
      boolean[] booleanArray2 = checkClassifier0.testToString();
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray2));
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      assertNotNull(booleanArray2);
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(0, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertNotSame(booleanArray2, booleanArray1);
      assertNotSame(booleanArray2, booleanArray0);
      
      checkClassifier0.printAttributeSummary(true, false, true, false, false, true, 0);
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(0, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(true, true, true, true, false, true, (-1423));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1423' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      DecisionTable decisionTable0 = new DecisionTable();
      assertEquals(2, DecisionTable.EVAL_ACCURACY);
      assertEquals(5, DecisionTable.EVAL_AUC);
      assertEquals(1, DecisionTable.EVAL_DEFAULT);
      assertEquals(4, DecisionTable.EVAL_MAE);
      assertEquals(3, DecisionTable.EVAL_RMSE);
      assertNotNull(decisionTable0);
      assertFalse(decisionTable0.getDebug());
      assertEquals("Sets whether rules are to be printed.", decisionTable0.displayRulesTipText());
      assertFalse(decisionTable0.getDisplayRules());
      assertEquals(1, decisionTable0.getCrossVal());
      assertEquals("If set to true, classifier may output additional info to the console.", decisionTable0.debugTipText());
      assertFalse(decisionTable0.getUseIBk());
      assertEquals("Sets whether IBk should be used instead of the majority class.", decisionTable0.useIBkTipText());
      assertEquals("The search method used to find good attribute combinations for the decision table.", decisionTable0.searchTipText());
      assertEquals("Sets the number of folds for cross validation (1 = leave one out).", decisionTable0.crossValTipText());
      assertEquals("The measure used to evaluate the performance of attribute combinations used in the decision table.", decisionTable0.evaluationMeasureTipText());
      
      SelectedTag selectedTag0 = decisionTable0.getEvaluationMeasure();
      assertEquals(2, DecisionTable.EVAL_ACCURACY);
      assertEquals(5, DecisionTable.EVAL_AUC);
      assertEquals(1, DecisionTable.EVAL_DEFAULT);
      assertEquals(4, DecisionTable.EVAL_MAE);
      assertEquals(3, DecisionTable.EVAL_RMSE);
      assertNotNull(selectedTag0);
      assertFalse(decisionTable0.getDebug());
      assertEquals("Sets whether rules are to be printed.", decisionTable0.displayRulesTipText());
      assertFalse(decisionTable0.getDisplayRules());
      assertEquals(1, decisionTable0.getCrossVal());
      assertEquals("If set to true, classifier may output additional info to the console.", decisionTable0.debugTipText());
      assertFalse(decisionTable0.getUseIBk());
      assertEquals("Sets whether IBk should be used instead of the majority class.", decisionTable0.useIBkTipText());
      assertEquals("The search method used to find good attribute combinations for the decision table.", decisionTable0.searchTipText());
      assertEquals("Sets the number of folds for cross validation (1 = leave one out).", decisionTable0.crossValTipText());
      assertEquals("The measure used to evaluate the performance of attribute combinations used in the decision table.", decisionTable0.evaluationMeasureTipText());
      assertEquals("1", selectedTag0.toString());
      
      DecisionTable decisionTable1 = (DecisionTable)AbstractClassifier.makeCopy(decisionTable0);
      assertEquals(2, DecisionTable.EVAL_ACCURACY);
      assertEquals(5, DecisionTable.EVAL_AUC);
      assertEquals(1, DecisionTable.EVAL_DEFAULT);
      assertEquals(4, DecisionTable.EVAL_MAE);
      assertEquals(3, DecisionTable.EVAL_RMSE);
      assertEquals(4, DecisionTable.EVAL_MAE);
      assertEquals(5, DecisionTable.EVAL_AUC);
      assertEquals(3, DecisionTable.EVAL_RMSE);
      assertEquals(2, DecisionTable.EVAL_ACCURACY);
      assertEquals(1, DecisionTable.EVAL_DEFAULT);
      assertFalse(decisionTable1.equals((Object)decisionTable0));
      assertNotNull(decisionTable1);
      assertFalse(decisionTable0.getDebug());
      assertEquals("Sets whether rules are to be printed.", decisionTable0.displayRulesTipText());
      assertFalse(decisionTable0.getDisplayRules());
      assertEquals(1, decisionTable0.getCrossVal());
      assertEquals("If set to true, classifier may output additional info to the console.", decisionTable0.debugTipText());
      assertFalse(decisionTable0.getUseIBk());
      assertEquals("Sets whether IBk should be used instead of the majority class.", decisionTable0.useIBkTipText());
      assertEquals("The search method used to find good attribute combinations for the decision table.", decisionTable0.searchTipText());
      assertEquals("Sets the number of folds for cross validation (1 = leave one out).", decisionTable0.crossValTipText());
      assertEquals("The measure used to evaluate the performance of attribute combinations used in the decision table.", decisionTable0.evaluationMeasureTipText());
      assertFalse(decisionTable1.getDebug());
      assertEquals("The measure used to evaluate the performance of attribute combinations used in the decision table.", decisionTable1.evaluationMeasureTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", decisionTable1.debugTipText());
      assertEquals("Sets whether rules are to be printed.", decisionTable1.displayRulesTipText());
      assertFalse(decisionTable1.getUseIBk());
      assertEquals("Sets whether IBk should be used instead of the majority class.", decisionTable1.useIBkTipText());
      assertEquals("The search method used to find good attribute combinations for the decision table.", decisionTable1.searchTipText());
      assertEquals("Sets the number of folds for cross validation (1 = leave one out).", decisionTable1.crossValTipText());
      assertFalse(decisionTable1.getDisplayRules());
      assertEquals(1, decisionTable1.getCrossVal());
      assertNotSame(decisionTable0, decisionTable1);
      assertNotSame(decisionTable1, decisionTable0);
      
      NaiveBayesMultinomialText naiveBayesMultinomialText0 = new NaiveBayesMultinomialText();
      assertNotNull(naiveBayesMultinomialText0);
      assertEquals("Use word frequencies rather than binary bag of words representation", naiveBayesMultinomialText0.useWordFrequenciesTipText());
      assertEquals(0, naiveBayesMultinomialText0.getPeriodicPruning());
      assertEquals(1.0, naiveBayesMultinomialText0.getNorm(), 0.01);
      assertFalse(naiveBayesMultinomialText0.getLowercaseTokens());
      assertFalse(naiveBayesMultinomialText0.getNormalizeDocLength());
      assertEquals("If true, ignores all words that are on the stoplist.", naiveBayesMultinomialText0.useStopListTipText());
      assertFalse(naiveBayesMultinomialText0.getDebug());
      assertEquals("If true then document length is normalized according to the settings for norm and lnorm", naiveBayesMultinomialText0.normalizeDocLengthTipText());
      assertEquals("How often (number of instances) to prune the dictionary of low frequency terms. 0 means don't prune. Setting a positive integer n means prune after every n instances", naiveBayesMultinomialText0.periodicPruningTipText());
      assertEquals("The tokenizing algorithm to use on the strings.", naiveBayesMultinomialText0.tokenizerTipText());
      assertEquals(3.0, naiveBayesMultinomialText0.getMinWordFrequency(), 0.01);
      assertEquals("The LNorm to use for document length normalization.", naiveBayesMultinomialText0.LNormTipText());
      assertEquals("Ignore any words that don't occur at least min frequency times in the training data. If periodic pruning is turned on, then the dictionary is pruned according to this value", naiveBayesMultinomialText0.minWordFrequencyTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", naiveBayesMultinomialText0.debugTipText());
      assertEquals("The stemming algorithm to use on the words.", naiveBayesMultinomialText0.stemmerTipText());
      assertEquals("Whether to convert all tokens to lowercase", naiveBayesMultinomialText0.lowercaseTokensTipText());
      assertFalse(naiveBayesMultinomialText0.getUseWordFrequencies());
      assertEquals("Multinomial naive bayes for text data. Operates directly (and only) on String attributes. Other types of input attributes are accepted but ignored during training and classification", naiveBayesMultinomialText0.globalInfo());
      assertEquals("The norm of the instances after normalization.", naiveBayesMultinomialText0.normTipText());
      assertEquals("The file containing the stopwords (if this is a directory then the default ones are used).", naiveBayesMultinomialText0.stopwordsTipText());
      assertFalse(naiveBayesMultinomialText0.getUseStopList());
      assertEquals(2.0, naiveBayesMultinomialText0.getLNorm(), 0.01);
      
      boolean[] booleanArray0 = checkClassifier0.updatingEquality(false, false, false, true, true, false, 3);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertNotNull(booleanArray0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      String[] stringArray0 = new String[1];
      stringArray0[0] = "=v*=#+?2CpW,O0";
      CheckClassifier.main(stringArray0);
      CheckClassifier.main(stringArray0);
      boolean[] booleanArray1 = checkClassifier0.weightedInstancesHandler();
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertNotNull(booleanArray1);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertNotSame(booleanArray1, booleanArray0);
      
      checkClassifier0.setNumDate(4);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(4, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      checkClassifier0.doTests();
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      
      String string0 = checkClassifier0.getRevision();
      assertNotNull(string0);
      assertEquals("8034", string0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      
      checkClassifier0.setNumInstances(0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      
      boolean[] booleanArray0 = checkClassifier0.correctBuildInitialisation(true, true, true, false, false, true, 0);
      assertTrue(Arrays.equals(new boolean[] {true, true}, booleanArray0));
      assertNotNull(booleanArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertNotNull(checkClassifier1);
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(1, checkClassifier1.getNumString());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(1, checkClassifier1.getNumNumeric());
      
      boolean boolean0 = FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, true);
      assertFalse(boolean0);
      
      boolean[] booleanArray1 = checkClassifier1.updatingEquality(true, false, true, true, false, true, 0);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray1));
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertNotNull(booleanArray1);
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(1, checkClassifier1.getNumString());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertNotSame(checkClassifier1, checkClassifier0);
      assertNotSame(booleanArray1, booleanArray0);
      
      String[] stringArray0 = new String[1];
      stringArray0[0] = "8034";
      CheckClassifier.main(stringArray0);
      CheckClassifier.main(stringArray0);
      boolean[] booleanArray2 = checkClassifier0.weightedInstancesHandler();
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray2));
      assertFalse(checkClassifier0.equals((Object)checkClassifier1));
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      assertNotNull(booleanArray2);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertNotSame(checkClassifier0, checkClassifier1);
      assertNotSame(booleanArray2, booleanArray0);
      assertNotSame(booleanArray2, booleanArray1);
      
      checkClassifier0.setNumDate(0);
      assertFalse(checkClassifier0.equals((Object)checkClassifier1));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(0, checkClassifier0.getNumDate());
      assertNotSame(checkClassifier0, checkClassifier1);
      
      checkClassifier1.doTests();
      checkClassifier1.getClassifier();
      checkClassifier1.weightedInstancesHandler();
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      String[] stringArray0 = Locale.getISOCountries();
      assertNotNull(stringArray0);
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertNotNull(booleanArray0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(true, true, true, true, true, true, 100000);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '100000' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      DecisionTable decisionTable0 = new DecisionTable();
      assertEquals(1, DecisionTable.EVAL_DEFAULT);
      assertEquals(3, DecisionTable.EVAL_RMSE);
      assertEquals(4, DecisionTable.EVAL_MAE);
      assertEquals(5, DecisionTable.EVAL_AUC);
      assertEquals(2, DecisionTable.EVAL_ACCURACY);
      assertNotNull(decisionTable0);
      assertFalse(decisionTable0.getUseIBk());
      assertEquals("Sets whether IBk should be used instead of the majority class.", decisionTable0.useIBkTipText());
      assertEquals("The search method used to find good attribute combinations for the decision table.", decisionTable0.searchTipText());
      assertEquals("Sets the number of folds for cross validation (1 = leave one out).", decisionTable0.crossValTipText());
      assertEquals("The measure used to evaluate the performance of attribute combinations used in the decision table.", decisionTable0.evaluationMeasureTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", decisionTable0.debugTipText());
      assertEquals("Sets whether rules are to be printed.", decisionTable0.displayRulesTipText());
      assertFalse(decisionTable0.getDisplayRules());
      assertEquals(1, decisionTable0.getCrossVal());
      assertFalse(decisionTable0.getDebug());
      
      SelectedTag selectedTag0 = decisionTable0.getEvaluationMeasure();
      assertEquals(1, DecisionTable.EVAL_DEFAULT);
      assertEquals(3, DecisionTable.EVAL_RMSE);
      assertEquals(4, DecisionTable.EVAL_MAE);
      assertEquals(5, DecisionTable.EVAL_AUC);
      assertEquals(2, DecisionTable.EVAL_ACCURACY);
      assertNotNull(selectedTag0);
      assertFalse(decisionTable0.getUseIBk());
      assertEquals("Sets whether IBk should be used instead of the majority class.", decisionTable0.useIBkTipText());
      assertEquals("The search method used to find good attribute combinations for the decision table.", decisionTable0.searchTipText());
      assertEquals("Sets the number of folds for cross validation (1 = leave one out).", decisionTable0.crossValTipText());
      assertEquals("The measure used to evaluate the performance of attribute combinations used in the decision table.", decisionTable0.evaluationMeasureTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", decisionTable0.debugTipText());
      assertEquals("Sets whether rules are to be printed.", decisionTable0.displayRulesTipText());
      assertFalse(decisionTable0.getDisplayRules());
      assertEquals(1, decisionTable0.getCrossVal());
      assertFalse(decisionTable0.getDebug());
      assertEquals("1", selectedTag0.toString());
      
      DecisionTable decisionTable1 = (DecisionTable)AbstractClassifier.makeCopy(decisionTable0);
      assertEquals(1, DecisionTable.EVAL_DEFAULT);
      assertEquals(3, DecisionTable.EVAL_RMSE);
      assertEquals(4, DecisionTable.EVAL_MAE);
      assertEquals(5, DecisionTable.EVAL_AUC);
      assertEquals(2, DecisionTable.EVAL_ACCURACY);
      assertEquals(1, DecisionTable.EVAL_DEFAULT);
      assertEquals(3, DecisionTable.EVAL_RMSE);
      assertEquals(4, DecisionTable.EVAL_MAE);
      assertEquals(5, DecisionTable.EVAL_AUC);
      assertEquals(2, DecisionTable.EVAL_ACCURACY);
      assertFalse(decisionTable1.equals((Object)decisionTable0));
      assertNotNull(decisionTable1);
      assertFalse(decisionTable0.getUseIBk());
      assertEquals("Sets whether IBk should be used instead of the majority class.", decisionTable0.useIBkTipText());
      assertEquals("The search method used to find good attribute combinations for the decision table.", decisionTable0.searchTipText());
      assertEquals("Sets the number of folds for cross validation (1 = leave one out).", decisionTable0.crossValTipText());
      assertEquals("The measure used to evaluate the performance of attribute combinations used in the decision table.", decisionTable0.evaluationMeasureTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", decisionTable0.debugTipText());
      assertEquals("Sets whether rules are to be printed.", decisionTable0.displayRulesTipText());
      assertFalse(decisionTable0.getDisplayRules());
      assertEquals(1, decisionTable0.getCrossVal());
      assertFalse(decisionTable0.getDebug());
      assertFalse(decisionTable1.getUseIBk());
      assertEquals("The search method used to find good attribute combinations for the decision table.", decisionTable1.searchTipText());
      assertEquals("Sets whether rules are to be printed.", decisionTable1.displayRulesTipText());
      assertEquals("The measure used to evaluate the performance of attribute combinations used in the decision table.", decisionTable1.evaluationMeasureTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", decisionTable1.debugTipText());
      assertEquals("Sets whether IBk should be used instead of the majority class.", decisionTable1.useIBkTipText());
      assertEquals(1, decisionTable1.getCrossVal());
      assertFalse(decisionTable1.getDisplayRules());
      assertEquals("Sets the number of folds for cross validation (1 = leave one out).", decisionTable1.crossValTipText());
      assertFalse(decisionTable1.getDebug());
      assertNotSame(decisionTable0, decisionTable1);
      assertNotSame(decisionTable1, decisionTable0);
      
      NaiveBayesMultinomialText naiveBayesMultinomialText0 = new NaiveBayesMultinomialText();
      assertNotNull(naiveBayesMultinomialText0);
      assertFalse(naiveBayesMultinomialText0.getUseStopList());
      assertFalse(naiveBayesMultinomialText0.getDebug());
      assertEquals(1.0, naiveBayesMultinomialText0.getNorm(), 0.01);
      assertFalse(naiveBayesMultinomialText0.getLowercaseTokens());
      assertEquals("If true, ignores all words that are on the stoplist.", naiveBayesMultinomialText0.useStopListTipText());
      assertEquals("Use word frequencies rather than binary bag of words representation", naiveBayesMultinomialText0.useWordFrequenciesTipText());
      assertEquals(0, naiveBayesMultinomialText0.getPeriodicPruning());
      assertFalse(naiveBayesMultinomialText0.getUseWordFrequencies());
      assertEquals("Multinomial naive bayes for text data. Operates directly (and only) on String attributes. Other types of input attributes are accepted but ignored during training and classification", naiveBayesMultinomialText0.globalInfo());
      assertEquals("The file containing the stopwords (if this is a directory then the default ones are used).", naiveBayesMultinomialText0.stopwordsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", naiveBayesMultinomialText0.debugTipText());
      assertEquals(2.0, naiveBayesMultinomialText0.getLNorm(), 0.01);
      assertEquals("Ignore any words that don't occur at least min frequency times in the training data. If periodic pruning is turned on, then the dictionary is pruned according to this value", naiveBayesMultinomialText0.minWordFrequencyTipText());
      assertEquals("Whether to convert all tokens to lowercase", naiveBayesMultinomialText0.lowercaseTokensTipText());
      assertEquals("The LNorm to use for document length normalization.", naiveBayesMultinomialText0.LNormTipText());
      assertEquals("The stemming algorithm to use on the words.", naiveBayesMultinomialText0.stemmerTipText());
      assertEquals("If true then document length is normalized according to the settings for norm and lnorm", naiveBayesMultinomialText0.normalizeDocLengthTipText());
      assertEquals("The norm of the instances after normalization.", naiveBayesMultinomialText0.normTipText());
      assertFalse(naiveBayesMultinomialText0.getNormalizeDocLength());
      assertEquals("The tokenizing algorithm to use on the strings.", naiveBayesMultinomialText0.tokenizerTipText());
      assertEquals("How often (number of instances) to prune the dictionary of low frequency terms. 0 means don't prune. Setting a positive integer n means prune after every n instances", naiveBayesMultinomialText0.periodicPruningTipText());
      assertEquals(3.0, naiveBayesMultinomialText0.getMinWordFrequency(), 0.01);
      
      checkClassifier0.setClassifier(naiveBayesMultinomialText0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(naiveBayesMultinomialText0.getUseStopList());
      assertFalse(naiveBayesMultinomialText0.getDebug());
      assertEquals(1.0, naiveBayesMultinomialText0.getNorm(), 0.01);
      assertFalse(naiveBayesMultinomialText0.getLowercaseTokens());
      assertEquals("If true, ignores all words that are on the stoplist.", naiveBayesMultinomialText0.useStopListTipText());
      assertEquals("Use word frequencies rather than binary bag of words representation", naiveBayesMultinomialText0.useWordFrequenciesTipText());
      assertEquals(0, naiveBayesMultinomialText0.getPeriodicPruning());
      assertFalse(naiveBayesMultinomialText0.getUseWordFrequencies());
      assertEquals("Multinomial naive bayes for text data. Operates directly (and only) on String attributes. Other types of input attributes are accepted but ignored during training and classification", naiveBayesMultinomialText0.globalInfo());
      assertEquals("The file containing the stopwords (if this is a directory then the default ones are used).", naiveBayesMultinomialText0.stopwordsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", naiveBayesMultinomialText0.debugTipText());
      assertEquals(2.0, naiveBayesMultinomialText0.getLNorm(), 0.01);
      assertEquals("Ignore any words that don't occur at least min frequency times in the training data. If periodic pruning is turned on, then the dictionary is pruned according to this value", naiveBayesMultinomialText0.minWordFrequencyTipText());
      assertEquals("Whether to convert all tokens to lowercase", naiveBayesMultinomialText0.lowercaseTokensTipText());
      assertEquals("The LNorm to use for document length normalization.", naiveBayesMultinomialText0.LNormTipText());
      assertEquals("The stemming algorithm to use on the words.", naiveBayesMultinomialText0.stemmerTipText());
      assertEquals("If true then document length is normalized according to the settings for norm and lnorm", naiveBayesMultinomialText0.normalizeDocLengthTipText());
      assertEquals("The norm of the instances after normalization.", naiveBayesMultinomialText0.normTipText());
      assertFalse(naiveBayesMultinomialText0.getNormalizeDocLength());
      assertEquals("The tokenizing algorithm to use on the strings.", naiveBayesMultinomialText0.tokenizerTipText());
      assertEquals("How often (number of instances) to prune the dictionary of low frequency terms. 0 means don't prune. Setting a positive integer n means prune after every n instances", naiveBayesMultinomialText0.periodicPruningTipText());
      assertEquals(3.0, naiveBayesMultinomialText0.getMinWordFrequency(), 0.01);
      
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(false, false, true, true, true, false, 3);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: weka.classifiers.bayes.NaiveBayesMultinomialText: Cannot handle relational attributes!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertNotNull(checkClassifier1);
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertFalse(checkClassifier1.getSilent());
      
      boolean[] booleanArray0 = checkClassifier1.instanceWeights(false, false, false, false, false, false, 0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertNotNull(booleanArray0);
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertFalse(checkClassifier1.getSilent());
      assertNotSame(checkClassifier1, checkClassifier0);
      
      boolean[] booleanArray1 = checkClassifier0.canTakeOptions();
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertFalse(checkClassifier0.equals((Object)checkClassifier1));
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertNotNull(booleanArray1);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertNotSame(checkClassifier0, checkClassifier1);
      assertNotSame(booleanArray1, booleanArray0);
      
      String string0 = checkClassifier0.getRevision();
      assertFalse(checkClassifier0.equals((Object)checkClassifier1));
      assertNotNull(string0);
      assertEquals("8034", string0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertNotSame(checkClassifier0, checkClassifier1);
      
      boolean[] booleanArray2 = checkClassifier0.doesntUseTestClassVal(true, true, true, true, true, false, 0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray2));
      assertFalse(checkClassifier0.equals((Object)checkClassifier1));
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      assertNotNull(booleanArray2);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertNotSame(checkClassifier0, checkClassifier1);
      assertNotSame(booleanArray2, booleanArray1);
      assertNotSame(booleanArray2, booleanArray0);
      
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleOnlyClass(true, true, false, true, false, 8);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '8' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      DecisionTable decisionTable0 = new DecisionTable();
      assertEquals(1, DecisionTable.EVAL_DEFAULT);
      assertEquals(4, DecisionTable.EVAL_MAE);
      assertEquals(5, DecisionTable.EVAL_AUC);
      assertEquals(3, DecisionTable.EVAL_RMSE);
      assertEquals(2, DecisionTable.EVAL_ACCURACY);
      assertNotNull(decisionTable0);
      assertEquals("Sets whether rules are to be printed.", decisionTable0.displayRulesTipText());
      assertFalse(decisionTable0.getDisplayRules());
      assertEquals("If set to true, classifier may output additional info to the console.", decisionTable0.debugTipText());
      assertFalse(decisionTable0.getDebug());
      assertFalse(decisionTable0.getUseIBk());
      assertEquals("The measure used to evaluate the performance of attribute combinations used in the decision table.", decisionTable0.evaluationMeasureTipText());
      assertEquals("Sets whether IBk should be used instead of the majority class.", decisionTable0.useIBkTipText());
      assertEquals("Sets the number of folds for cross validation (1 = leave one out).", decisionTable0.crossValTipText());
      assertEquals("The search method used to find good attribute combinations for the decision table.", decisionTable0.searchTipText());
      assertEquals(1, decisionTable0.getCrossVal());
      
      SelectedTag selectedTag0 = decisionTable0.getEvaluationMeasure();
      assertEquals(1, DecisionTable.EVAL_DEFAULT);
      assertEquals(4, DecisionTable.EVAL_MAE);
      assertEquals(5, DecisionTable.EVAL_AUC);
      assertEquals(3, DecisionTable.EVAL_RMSE);
      assertEquals(2, DecisionTable.EVAL_ACCURACY);
      assertNotNull(selectedTag0);
      assertEquals("Sets whether rules are to be printed.", decisionTable0.displayRulesTipText());
      assertFalse(decisionTable0.getDisplayRules());
      assertEquals("If set to true, classifier may output additional info to the console.", decisionTable0.debugTipText());
      assertFalse(decisionTable0.getDebug());
      assertFalse(decisionTable0.getUseIBk());
      assertEquals("The measure used to evaluate the performance of attribute combinations used in the decision table.", decisionTable0.evaluationMeasureTipText());
      assertEquals("Sets whether IBk should be used instead of the majority class.", decisionTable0.useIBkTipText());
      assertEquals("Sets the number of folds for cross validation (1 = leave one out).", decisionTable0.crossValTipText());
      assertEquals("The search method used to find good attribute combinations for the decision table.", decisionTable0.searchTipText());
      assertEquals(1, decisionTable0.getCrossVal());
      assertEquals("1", selectedTag0.toString());
      
      DecisionTable decisionTable1 = (DecisionTable)AbstractClassifier.makeCopy(decisionTable0);
      assertEquals(1, DecisionTable.EVAL_DEFAULT);
      assertEquals(4, DecisionTable.EVAL_MAE);
      assertEquals(5, DecisionTable.EVAL_AUC);
      assertEquals(3, DecisionTable.EVAL_RMSE);
      assertEquals(2, DecisionTable.EVAL_ACCURACY);
      assertEquals(5, DecisionTable.EVAL_AUC);
      assertEquals(1, DecisionTable.EVAL_DEFAULT);
      assertEquals(3, DecisionTable.EVAL_RMSE);
      assertEquals(4, DecisionTable.EVAL_MAE);
      assertEquals(2, DecisionTable.EVAL_ACCURACY);
      assertFalse(decisionTable1.equals((Object)decisionTable0));
      assertNotNull(decisionTable1);
      assertEquals("Sets whether rules are to be printed.", decisionTable0.displayRulesTipText());
      assertFalse(decisionTable0.getDisplayRules());
      assertEquals("If set to true, classifier may output additional info to the console.", decisionTable0.debugTipText());
      assertFalse(decisionTable0.getDebug());
      assertFalse(decisionTable0.getUseIBk());
      assertEquals("The measure used to evaluate the performance of attribute combinations used in the decision table.", decisionTable0.evaluationMeasureTipText());
      assertEquals("Sets whether IBk should be used instead of the majority class.", decisionTable0.useIBkTipText());
      assertEquals("Sets the number of folds for cross validation (1 = leave one out).", decisionTable0.crossValTipText());
      assertEquals("The search method used to find good attribute combinations for the decision table.", decisionTable0.searchTipText());
      assertEquals(1, decisionTable0.getCrossVal());
      assertEquals("The measure used to evaluate the performance of attribute combinations used in the decision table.", decisionTable1.evaluationMeasureTipText());
      assertFalse(decisionTable1.getUseIBk());
      assertEquals("Sets the number of folds for cross validation (1 = leave one out).", decisionTable1.crossValTipText());
      assertEquals("Sets whether rules are to be printed.", decisionTable1.displayRulesTipText());
      assertFalse(decisionTable1.getDisplayRules());
      assertEquals(1, decisionTable1.getCrossVal());
      assertEquals("If set to true, classifier may output additional info to the console.", decisionTable1.debugTipText());
      assertFalse(decisionTable1.getDebug());
      assertEquals("Sets whether IBk should be used instead of the majority class.", decisionTable1.useIBkTipText());
      assertEquals("The search method used to find good attribute combinations for the decision table.", decisionTable1.searchTipText());
      assertNotSame(decisionTable0, decisionTable1);
      assertNotSame(decisionTable1, decisionTable0);
      
      NaiveBayesMultinomialText naiveBayesMultinomialText0 = new NaiveBayesMultinomialText();
      assertNotNull(naiveBayesMultinomialText0);
      assertEquals("If true then document length is normalized according to the settings for norm and lnorm", naiveBayesMultinomialText0.normalizeDocLengthTipText());
      assertEquals("Whether to convert all tokens to lowercase", naiveBayesMultinomialText0.lowercaseTokensTipText());
      assertEquals(3.0, naiveBayesMultinomialText0.getMinWordFrequency(), 0.01);
      assertFalse(naiveBayesMultinomialText0.getNormalizeDocLength());
      assertEquals("Ignore any words that don't occur at least min frequency times in the training data. If periodic pruning is turned on, then the dictionary is pruned according to this value", naiveBayesMultinomialText0.minWordFrequencyTipText());
      assertEquals("The tokenizing algorithm to use on the strings.", naiveBayesMultinomialText0.tokenizerTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", naiveBayesMultinomialText0.debugTipText());
      assertEquals(2.0, naiveBayesMultinomialText0.getLNorm(), 0.01);
      assertFalse(naiveBayesMultinomialText0.getDebug());
      assertEquals("The norm of the instances after normalization.", naiveBayesMultinomialText0.normTipText());
      assertEquals("The file containing the stopwords (if this is a directory then the default ones are used).", naiveBayesMultinomialText0.stopwordsTipText());
      assertEquals(1.0, naiveBayesMultinomialText0.getNorm(), 0.01);
      assertFalse(naiveBayesMultinomialText0.getUseWordFrequencies());
      assertEquals("Multinomial naive bayes for text data. Operates directly (and only) on String attributes. Other types of input attributes are accepted but ignored during training and classification", naiveBayesMultinomialText0.globalInfo());
      assertFalse(naiveBayesMultinomialText0.getUseStopList());
      assertEquals("How often (number of instances) to prune the dictionary of low frequency terms. 0 means don't prune. Setting a positive integer n means prune after every n instances", naiveBayesMultinomialText0.periodicPruningTipText());
      assertEquals("Use word frequencies rather than binary bag of words representation", naiveBayesMultinomialText0.useWordFrequenciesTipText());
      assertEquals(0, naiveBayesMultinomialText0.getPeriodicPruning());
      assertEquals("The stemming algorithm to use on the words.", naiveBayesMultinomialText0.stemmerTipText());
      assertEquals("If true, ignores all words that are on the stoplist.", naiveBayesMultinomialText0.useStopListTipText());
      assertFalse(naiveBayesMultinomialText0.getLowercaseTokens());
      assertEquals("The LNorm to use for document length normalization.", naiveBayesMultinomialText0.LNormTipText());
      
      boolean[] booleanArray0 = checkClassifier0.updatingEquality(false, false, false, true, true, false, 3);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertNotNull(booleanArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      String[] stringArray0 = new String[1];
      stringArray0[0] = "=v*=#+?2CpW,O0";
      CheckClassifier.main(stringArray0);
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertNotNull(checkClassifier1);
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(1, checkClassifier1.getNumString());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(20, checkClassifier1.getNumInstances());
      
      DecisionTable.main(stringArray0);
      // Undeclared exception!
      try { 
        checkClassifier1.doesntUseTestClassVal(true, false, false, true, false, false, 2);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: weka.classifiers.rules.ZeroR: Cannot handle string class!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      DecisionTable decisionTable0 = new DecisionTable();
      decisionTable0.getEvaluationMeasure();
      Classifier classifier0 = AbstractClassifier.makeCopy(decisionTable0);
      AbstractClassifier.makeCopy(classifier0);
      checkClassifier0.updatingEquality(false, false, false, true, false, false, 3);
      String[] stringArray0 = new String[1];
      boolean boolean0 = false;
      boolean boolean1 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(true, false, true, true, false, false, 2);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: weka.classifiers.rules.ZeroR: Cannot handle string class!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      int int0 = 0;
      checkClassifier0.instanceWeights(false, false, false, false, false, true, 0);
      checkClassifier0.canTakeOptions();
      checkClassifier0.getRevision();
      checkClassifier0.doesntUseTestClassVal(false, false, true, true, true, false, 0);
      boolean boolean0 = false;
      checkClassifier0.canHandleOnlyClass(true, false, false, false, false, 0);
      String[] stringArray0 = new String[1];
      stringArray0[0] = "8034";
      checkClassifier0.setOptions(stringArray0);
      checkClassifier0.doTests();
      boolean boolean1 = false;
      boolean boolean2 = false;
      boolean boolean3 = true;
      boolean boolean4 = true;
      boolean boolean5 = false;
      checkClassifier0.correctBuildInitialisation(boolean1, boolean0, boolean2, boolean3, boolean4, boolean5, int0);
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      DecisionTable decisionTable0 = new DecisionTable();
      decisionTable0.getEvaluationMeasure();
      AbstractClassifier.makeCopy(decisionTable0);
      checkClassifier0.setClassifier(decisionTable0);
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(false, false, false, false, false, true, 2);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: weka.classifiers.rules.DecisionTable: Cannot handle relational attributes!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      DecisionTable decisionTable0 = new DecisionTable();
      decisionTable0.getEvaluationMeasure();
      AbstractClassifier.makeCopy(decisionTable0);
      NaiveBayesMultinomialText naiveBayesMultinomialText0 = new NaiveBayesMultinomialText();
      checkClassifier0.updatingEquality(false, false, false, true, true, false, 3);
      String[] stringArray0 = new String[1];
      stringArray0[0] = "=v*=#+?2CpW,O0";
      CheckClassifier.main(stringArray0);
      CheckClassifier.main(stringArray0);
      checkClassifier0.weightedInstancesHandler();
      checkClassifier0.setNumDate(4);
      checkClassifier0.printAttributeSummary(false, true, false, false, false, true, 4);
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.getRevision();
      checkClassifier0.setNumInstances(0);
      checkClassifier0.setNumString(0);
      checkClassifier0.instanceWeights(true, true, false, true, false, false, 0);
      checkClassifier0.canTakeOptions();
      CheckClassifier checkClassifier1 = new CheckClassifier();
      checkClassifier1.getRevision();
      String[] stringArray0 = new String[2];
      stringArray0[0] = "8034";
      stringArray0[1] = "8034";
      CheckClassifier.main(stringArray0);
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.getRevision();
      checkClassifier0.setNumInstances(0);
      boolean boolean0 = false;
      int int0 = 0;
      checkClassifier0.setNumString(0);
      checkClassifier0.instanceWeights(true, true, false, true, false, false, 0);
      checkClassifier0.canTakeOptions();
      CheckClassifier checkClassifier1 = new CheckClassifier();
      checkClassifier1.getRevision();
      boolean boolean1 = false;
      // Undeclared exception!
      try { 
        checkClassifier1.doesntUseTestClassVal(false, false, true, false, false, true, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.instanceWeights(false, false, false, false, false, true, 0);
      checkClassifier0.canTakeOptions();
      checkClassifier0.getRevision();
      checkClassifier0.doesntUseTestClassVal(false, false, true, true, true, false, 0);
      checkClassifier0.weightedInstancesHandler();
      String[] stringArray0 = new String[7];
      stringArray0[0] = "8034";
      stringArray0[1] = "8034";
      stringArray0[2] = "8034";
      stringArray0[3] = "8034";
      stringArray0[4] = "8034";
      stringArray0[5] = "8034";
      stringArray0[6] = "8034";
      checkClassifier0.setOptions(stringArray0);
      checkClassifier0.datasetIntegrity(false, false, false, false, true, false, 0, true, true);
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      int int0 = 0;
      checkClassifier0.getRevision();
      checkClassifier0.setNumInstances(0);
      boolean boolean0 = true;
      checkClassifier0.correctBuildInitialisation(true, false, false, true, true, false, 0);
      CheckClassifier checkClassifier1 = new CheckClassifier();
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(true, false, true, false, false, true, 2);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: weka.classifiers.rules.ZeroR: Cannot handle string class!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.getRevision();
      checkClassifier0.setNumInstances(0);
      NaiveBayesMultinomialText naiveBayesMultinomialText0 = new NaiveBayesMultinomialText();
      checkClassifier0.updatingEquality(true, false, true, true, true, true, 0);
      String[] stringArray0 = new String[6];
      stringArray0[0] = "=v*=#+?2CpW,O0";
      stringArray0[1] = "=v*=#+?2CpW,O0";
      stringArray0[2] = "8034";
      stringArray0[3] = "8034";
      stringArray0[4] = "8034";
      stringArray0[5] = "=v*=#+?2CpW,O0";
      CheckClassifier.main(stringArray0);
      CheckClassifier.main(stringArray0);
      checkClassifier0.weightedInstancesHandler();
      CheckClassifier checkClassifier1 = new CheckClassifier();
      checkClassifier1.weightedInstancesHandler();
      checkClassifier1.setClassifier(naiveBayesMultinomialText0);
      checkClassifier1.setNumDate((-2164));
      checkClassifier0.doTests();
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(false, false, false, true, false, true, 16);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '16' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }
}
