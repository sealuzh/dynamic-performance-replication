/*
 * This file was automatically generated by EvoSuite
 * Fri Jul 06 16:04:38 GMT 2018
 */

package weka.classifiers;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.Arrays;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;
import weka.classifiers.CheckClassifier;
import weka.classifiers.Classifier;
import weka.classifiers.functions.SMO;
import weka.classifiers.functions.SimpleLogistic;
import weka.classifiers.meta.MultiClassClassifier;
import weka.classifiers.meta.Stacking;
import weka.classifiers.rules.PART;
import weka.core.Capabilities;
import weka.core.CheckScheme;
import weka.core.TestInstances;
import weka.core.Utils;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class CheckClassifier_ESTest extends CheckClassifier_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.getOptions();
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(true, true, true, false, true, true, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, true);
      CheckClassifier checkClassifier0 = new CheckClassifier();
      CheckScheme.PostProcessor checkScheme_PostProcessor0 = new CheckScheme.PostProcessor();
      checkClassifier0.setPostProcessor(checkScheme_PostProcessor0);
      Utils.SMALL = (-1751.63);
      checkClassifier0.testToString();
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleZeroTraining(false, false, false, true, false, true, 2742);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '2742' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(true, true, true, true, false, false, (-3172));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-3172' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      Utils.SMALL = 0.0;
      checkClassifier0.setNumNominal(3);
      // Undeclared exception!
      try { 
        checkClassifier0.testsPerClassType(17, false, false, false);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '17' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      Stacking stacking0 = new Stacking();
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/home/users/apanichella/PackageManager.props");
      FileSystemHandling.appendLineToFile(evoSuiteFile0, "The filter to be used.");
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleMissing(true, true, true, false, true, true, 10, true, true, (-1224));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '10' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(true, false, true, false, true, true, 2);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      boolean[] booleanArray0 = checkClassifier0.weightedInstancesHandler();
      assertNotNull(booleanArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      boolean[] booleanArray1 = checkClassifier0.multiInstanceHandler();
      assertNotNull(booleanArray1);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray1));
      
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(false, false, false, true, false, true, 387);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '387' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      boolean[] booleanArray0 = checkClassifier0.weightedInstancesHandler();
      assertNotNull(booleanArray0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      Stacking stacking0 = new Stacking();
      assertNotNull(stacking0);
      assertFalse(stacking0.getDebug());
      assertEquals(10, stacking0.getNumFolds());
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      assertEquals(1, stacking0.getSeed());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      assertEquals(1, stacking0.getNumExecutionSlots());
      
      stacking0.setNumFolds(69);
      assertFalse(stacking0.getDebug());
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      assertEquals(69, stacking0.getNumFolds());
      assertEquals(1, stacking0.getSeed());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      assertEquals(1, stacking0.getNumExecutionSlots());
      
      String[] stringArray0 = new String[1];
      stringArray0[0] = "e";
      CheckClassifier.main(stringArray0);
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertNotNull(checkClassifier1);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertFalse(checkClassifier1.getSilent());
      
      boolean[] booleanArray1 = checkClassifier1.testToString();
      assertNotNull(booleanArray1);
      assertNotSame(checkClassifier1, checkClassifier0);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertFalse(checkClassifier1.getSilent());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      
      CheckClassifier checkClassifier2 = new CheckClassifier();
      assertNotNull(checkClassifier2);
      assertFalse(checkClassifier2.equals((Object)checkClassifier0));
      assertFalse(checkClassifier2.equals((Object)checkClassifier1));
      assertEquals(2, checkClassifier2.getNumNominal());
      assertFalse(checkClassifier2.getDebug());
      assertEquals(20, checkClassifier2.getNumInstances());
      assertEquals(1, checkClassifier2.getNumNumeric());
      assertEquals(10, checkClassifier2.getNumInstancesRelational());
      assertFalse(checkClassifier2.getSilent());
      assertEquals(1, checkClassifier2.getNumString());
      assertEquals(1, checkClassifier2.getNumDate());
      assertEquals(1, checkClassifier2.getNumRelational());
      assertEquals(" ", checkClassifier2.getWordSeparators());
      assertFalse(checkClassifier2.hasClasspathProblems());
      
      boolean[] booleanArray2 = checkClassifier2.declaresSerialVersionUID();
      assertNotNull(booleanArray2);
      assertNotSame(checkClassifier2, checkClassifier0);
      assertNotSame(checkClassifier2, checkClassifier1);
      assertNotSame(booleanArray2, booleanArray1);
      assertNotSame(booleanArray2, booleanArray0);
      assertFalse(checkClassifier2.equals((Object)checkClassifier0));
      assertFalse(checkClassifier2.equals((Object)checkClassifier1));
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      assertEquals(2, checkClassifier2.getNumNominal());
      assertFalse(checkClassifier2.getDebug());
      assertEquals(20, checkClassifier2.getNumInstances());
      assertEquals(1, checkClassifier2.getNumNumeric());
      assertEquals(10, checkClassifier2.getNumInstancesRelational());
      assertFalse(checkClassifier2.getSilent());
      assertEquals(1, checkClassifier2.getNumString());
      assertEquals(1, checkClassifier2.getNumDate());
      assertEquals(1, checkClassifier2.getNumRelational());
      assertEquals(" ", checkClassifier2.getWordSeparators());
      assertFalse(checkClassifier2.hasClasspathProblems());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray2));
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "");
      assertFalse(boolean0);
      
      PART pART0 = new PART();
      assertNotNull(pART0);
      assertEquals(2, pART0.getMinNumObj());
      assertEquals(0.25F, pART0.getConfidenceFactor(), 0.01F);
      assertEquals("Whether to use binary splits on nominal attributes when building the partial trees.", pART0.binarySplitsTipText());
      assertFalse(pART0.getDebug());
      assertFalse(pART0.getBinarySplits());
      assertFalse(pART0.getUnpruned());
      assertEquals("The confidence factor used for pruning (smaller values incur more pruning).", pART0.confidenceFactorTipText());
      assertEquals("Whether reduced-error pruning is used instead of C.4.5 pruning.", pART0.reducedErrorPruningTipText());
      assertEquals("Whether pruning is performed.", pART0.unprunedTipText());
      assertEquals("The minimum number of instances per rule.", pART0.minNumObjTipText());
      assertEquals("Whether MDL correction is used when finding splits on numeric attributes.", pART0.useMDLcorrectionTipText());
      assertEquals("Determines the amount of data used for reduced-error pruning.  One fold is used for pruning, the rest for growing the rules.", pART0.numFoldsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", pART0.debugTipText());
      assertEquals("The seed used for randomizing the data when reduced-error pruning is used.", pART0.seedTipText());
      assertFalse(pART0.getReducedErrorPruning());
      assertEquals(1, pART0.getSeed());
      assertTrue(pART0.getUseMDLcorrection());
      assertEquals(3, pART0.getNumFolds());
      
      checkClassifier0.setClassifier(pART0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(2, pART0.getMinNumObj());
      assertEquals(0.25F, pART0.getConfidenceFactor(), 0.01F);
      assertEquals("Whether to use binary splits on nominal attributes when building the partial trees.", pART0.binarySplitsTipText());
      assertFalse(pART0.getDebug());
      assertFalse(pART0.getBinarySplits());
      assertFalse(pART0.getUnpruned());
      assertEquals("The confidence factor used for pruning (smaller values incur more pruning).", pART0.confidenceFactorTipText());
      assertEquals("Whether reduced-error pruning is used instead of C.4.5 pruning.", pART0.reducedErrorPruningTipText());
      assertEquals("Whether pruning is performed.", pART0.unprunedTipText());
      assertEquals("The minimum number of instances per rule.", pART0.minNumObjTipText());
      assertEquals("Whether MDL correction is used when finding splits on numeric attributes.", pART0.useMDLcorrectionTipText());
      assertEquals("Determines the amount of data used for reduced-error pruning.  One fold is used for pruning, the rest for growing the rules.", pART0.numFoldsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", pART0.debugTipText());
      assertEquals("The seed used for randomizing the data when reduced-error pruning is used.", pART0.seedTipText());
      assertFalse(pART0.getReducedErrorPruning());
      assertEquals(1, pART0.getSeed());
      assertTrue(pART0.getUseMDLcorrection());
      assertEquals(3, pART0.getNumFolds());
      
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleMissing(false, false, false, true, true, false, (-1398), false, true, (-1398));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1398' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      boolean[] booleanArray0 = checkClassifier0.canHandleZeroTraining(true, false, true, false, true, false, 0);
      assertNotNull(booleanArray0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(true, false, false, false, true, true, 110);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '110' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      
      boolean boolean0 = false;
      boolean boolean1 = true;
      int int0 = 266;
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleOnlyClass(false, true, false, true, false, 266);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '266' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      String[] stringArray0 = checkClassifier0.getOptions();
      assertNotNull(stringArray0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(true, false, true, true, true, true, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      boolean boolean0 = true;
      int int0 = 20;
      SimpleLogistic simpleLogistic0 = new SimpleLogistic(20, true, true);
      assertNotNull(simpleLogistic0);
      assertTrue(simpleLogistic0.getErrorOnProbabilities());
      assertEquals(20, simpleLogistic0.getNumBoostingIterations());
      assertFalse(simpleLogistic0.getDebug());
      assertEquals("If set to true, classifier may output additional info to the console.", simpleLogistic0.debugTipText());
      assertEquals("The AIC is used to determine when to stop LogitBoost iterations (instead of cross-validation or training error).", simpleLogistic0.useAICTipText());
      assertEquals(0.0, simpleLogistic0.getWeightTrimBeta(), 0.01);
      assertTrue(simpleLogistic0.getUseCrossValidation());
      assertEquals(500, simpleLogistic0.getMaxBoostingIterations());
      assertEquals("Sets whether the number of LogitBoost iterations is to be cross-validated or the stopping criterion on the training set should be used. If not set (and no fixed number of iterations was given), the number of LogitBoost iterations is used that minimizes the error on the training set (misclassification error or error on probabilities depending on errorOnProbabilities).", simpleLogistic0.useCrossValidationTipText());
      assertEquals("If heuristicStop > 0, the heuristic for greedy stopping while cross-validating the number of LogitBoost iterations is enabled. This means LogitBoost is stopped if no new error minimum has been reached in the last heuristicStop iterations. It is recommended to use this heuristic, it gives a large speed-up especially on small datasets. The default value is 50.", simpleLogistic0.heuristicStopTipText());
      assertEquals("Set the beta value used for weight trimming in LogitBoost. Only instances carrying (1 - beta)% of the weight from previous iteration are used in the next iteration. Set to 0 for no weight trimming. The default value is 0.", simpleLogistic0.weightTrimBetaTipText());
      assertEquals("Set fixed number of iterations for LogitBoost. If >= 0, this sets the number of LogitBoost iterations to perform. If < 0, the number is cross-validated or a stopping criterion on the training set is used (depending on the value of useCrossValidation).", simpleLogistic0.numBoostingIterationsTipText());
      assertEquals("Sets the maximum number of iterations for LogitBoost. Default value is 500, for very small/large datasets a lower/higher value might be preferable.", simpleLogistic0.maxBoostingIterationsTipText());
      assertEquals(50, simpleLogistic0.getHeuristicStop());
      assertFalse(simpleLogistic0.getUseAIC());
      assertEquals("Use error on the probabilties as error measure when determining the best number of LogitBoost iterations. If set, the number of LogitBoost iterations is chosen that minimizes the root mean squared error (either on the training set or in the cross-validation, depending on useCrossValidation).", simpleLogistic0.errorOnProbabilitiesTipText());
      
      checkClassifier0.m_Classifier = (Classifier) simpleLogistic0;
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertTrue(simpleLogistic0.getErrorOnProbabilities());
      assertEquals(20, simpleLogistic0.getNumBoostingIterations());
      assertFalse(simpleLogistic0.getDebug());
      assertEquals("If set to true, classifier may output additional info to the console.", simpleLogistic0.debugTipText());
      assertEquals("The AIC is used to determine when to stop LogitBoost iterations (instead of cross-validation or training error).", simpleLogistic0.useAICTipText());
      assertEquals(0.0, simpleLogistic0.getWeightTrimBeta(), 0.01);
      assertTrue(simpleLogistic0.getUseCrossValidation());
      assertEquals(500, simpleLogistic0.getMaxBoostingIterations());
      assertEquals("Sets whether the number of LogitBoost iterations is to be cross-validated or the stopping criterion on the training set should be used. If not set (and no fixed number of iterations was given), the number of LogitBoost iterations is used that minimizes the error on the training set (misclassification error or error on probabilities depending on errorOnProbabilities).", simpleLogistic0.useCrossValidationTipText());
      assertEquals("If heuristicStop > 0, the heuristic for greedy stopping while cross-validating the number of LogitBoost iterations is enabled. This means LogitBoost is stopped if no new error minimum has been reached in the last heuristicStop iterations. It is recommended to use this heuristic, it gives a large speed-up especially on small datasets. The default value is 50.", simpleLogistic0.heuristicStopTipText());
      assertEquals("Set the beta value used for weight trimming in LogitBoost. Only instances carrying (1 - beta)% of the weight from previous iteration are used in the next iteration. Set to 0 for no weight trimming. The default value is 0.", simpleLogistic0.weightTrimBetaTipText());
      assertEquals("Set fixed number of iterations for LogitBoost. If >= 0, this sets the number of LogitBoost iterations to perform. If < 0, the number is cross-validated or a stopping criterion on the training set is used (depending on the value of useCrossValidation).", simpleLogistic0.numBoostingIterationsTipText());
      assertEquals("Sets the maximum number of iterations for LogitBoost. Default value is 500, for very small/large datasets a lower/higher value might be preferable.", simpleLogistic0.maxBoostingIterationsTipText());
      assertEquals(50, simpleLogistic0.getHeuristicStop());
      assertFalse(simpleLogistic0.getUseAIC());
      assertEquals("Use error on the probabilties as error measure when determining the best number of LogitBoost iterations. If set, the number of LogitBoost iterations is chosen that minimizes the root mean squared error (either on the training set or in the cross-validation, depending on useCrossValidation).", simpleLogistic0.errorOnProbabilitiesTipText());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      
      boolean boolean1 = true;
      boolean boolean2 = false;
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleClassAsNthAttribute(true, true, false, false, false, false, (-83), 20);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-83' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/home/users/apanichella/PackageManager.props");
      boolean boolean0 = FileSystemHandling.appendLineToFile(evoSuiteFile0, "[H");
      assertTrue(boolean0);
      
      boolean[] booleanArray1 = checkClassifier0.canHandleMissing(false, true, false, false, false, false, 0, false, true, 34);
      assertNotNull(booleanArray1);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      
      boolean[] booleanArray2 = checkClassifier0.declaresSerialVersionUID();
      assertNotNull(booleanArray2);
      assertNotSame(booleanArray2, booleanArray0);
      assertNotSame(booleanArray2, booleanArray1);
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray2));
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/home/users/apanichella/PackageManager.props");
      boolean boolean0 = FileSystemHandling.appendLineToFile(evoSuiteFile0, "rP:{RXzvnK;4VYB");
      assertTrue(boolean0);
      
      boolean[] booleanArray0 = checkClassifier0.canHandleMissing(true, false, false, true, true, false, 2, true, false, 387);
      assertNotNull(booleanArray0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, (String) null);
      assertFalse(boolean0);
      
      boolean[] booleanArray1 = checkClassifier0.multiInstanceHandler();
      assertNotNull(booleanArray1);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray1));
      
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(false, true, true, false, true, false, 387);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '387' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      
      Stacking stacking0 = new Stacking();
      assertNotNull(stacking0);
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals(10, stacking0.getNumFolds());
      assertFalse(stacking0.getDebug());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      assertEquals(1, stacking0.getNumExecutionSlots());
      assertEquals(1, stacking0.getSeed());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      
      stacking0.setNumFolds(270);
      assertEquals(270, stacking0.getNumFolds());
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertFalse(stacking0.getDebug());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      assertEquals(1, stacking0.getNumExecutionSlots());
      assertEquals(1, stacking0.getSeed());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(false, false, true, false, false, true, 270, true, false);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '270' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      Stacking stacking0 = new Stacking();
      assertNotNull(stacking0);
      assertEquals(1, stacking0.getSeed());
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      assertFalse(stacking0.getDebug());
      assertEquals(10, stacking0.getNumFolds());
      assertEquals(1, stacking0.getNumExecutionSlots());
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      
      stacking0.setNumFolds(270);
      assertEquals(1, stacking0.getSeed());
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      assertEquals(270, stacking0.getNumFolds());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      assertFalse(stacking0.getDebug());
      assertEquals(1, stacking0.getNumExecutionSlots());
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleMissing(false, false, false, false, true, true, 4, false, true, 100);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean boolean0 = false;
      boolean boolean1 = true;
      boolean boolean2 = false;
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleMissing(false, true, true, false, true, false, (-1799), true, false, (-3949));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1799' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      boolean[] booleanArray0 = checkClassifier0.weightedInstancesHandler();
      assertNotNull(booleanArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, (String) null);
      assertFalse(boolean0);
      
      boolean[] booleanArray1 = checkClassifier0.multiInstanceHandler();
      assertNotNull(booleanArray1);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray1));
      
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(false, false, false, true, true, false, (-1135));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1135' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean[] booleanArray0 = checkClassifier0.declaresSerialVersionUID();
      assertNotNull(booleanArray0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      boolean boolean0 = true;
      MultiClassClassifier multiClassClassifier0 = new MultiClassClassifier();
      assertNotNull(multiClassClassifier0);
      assertEquals(2.0, multiClassClassifier0.getRandomWidthFactor(), 0.01);
      assertEquals("Sets the method to use for transforming the multi-class problem into several 2-class ones.", multiClassClassifier0.methodTipText());
      assertEquals("Sets the width multiplier when using random codes. The number of codes generated will be thus number multiplied by the number of classes.", multiClassClassifier0.randomWidthFactorTipText());
      assertEquals("A metaclassifier for handling multi-class datasets with 2-class classifiers. This classifier is also capable of applying error correcting output codes for increased accuracy.", multiClassClassifier0.globalInfo());
      assertFalse(multiClassClassifier0.getUsePairwiseCoupling());
      assertFalse(multiClassClassifier0.getDebug());
      assertEquals("If set to true, classifier may output additional info to the console.", multiClassClassifier0.debugTipText());
      assertEquals("The random number seed to be used.", multiClassClassifier0.seedTipText());
      assertEquals(1, multiClassClassifier0.getSeed());
      assertEquals("The base classifier to be used.", multiClassClassifier0.classifierTipText());
      assertEquals("Use pairwise coupling (only has an effect for 1-against-1).", multiClassClassifier0.usePairwiseCouplingTipText());
      assertEquals(2, MultiClassClassifier.METHOD_ERROR_EXHAUSTIVE);
      assertEquals(1, MultiClassClassifier.METHOD_ERROR_RANDOM);
      assertEquals(3, MultiClassClassifier.METHOD_1_AGAINST_1);
      assertEquals(0, MultiClassClassifier.METHOD_1_AGAINST_ALL);
      
      checkClassifier0.m_Classifier = (Classifier) multiClassClassifier0;
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(2.0, multiClassClassifier0.getRandomWidthFactor(), 0.01);
      assertEquals("Sets the method to use for transforming the multi-class problem into several 2-class ones.", multiClassClassifier0.methodTipText());
      assertEquals("Sets the width multiplier when using random codes. The number of codes generated will be thus number multiplied by the number of classes.", multiClassClassifier0.randomWidthFactorTipText());
      assertEquals("A metaclassifier for handling multi-class datasets with 2-class classifiers. This classifier is also capable of applying error correcting output codes for increased accuracy.", multiClassClassifier0.globalInfo());
      assertFalse(multiClassClassifier0.getUsePairwiseCoupling());
      assertFalse(multiClassClassifier0.getDebug());
      assertEquals("If set to true, classifier may output additional info to the console.", multiClassClassifier0.debugTipText());
      assertEquals("The random number seed to be used.", multiClassClassifier0.seedTipText());
      assertEquals(1, multiClassClassifier0.getSeed());
      assertEquals("The base classifier to be used.", multiClassClassifier0.classifierTipText());
      assertEquals("Use pairwise coupling (only has an effect for 1-against-1).", multiClassClassifier0.usePairwiseCouplingTipText());
      
      checkClassifier0.setNumInstancesRelational(3);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(3, checkClassifier0.getNumInstancesRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean boolean1 = false;
      boolean boolean2 = false;
      String[] stringArray0 = checkClassifier0.getOptions();
      assertNotNull(stringArray0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(3, checkClassifier0.getNumInstancesRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      int int0 = 34;
      Capabilities capabilities0 = multiClassClassifier0.getCapabilities();
      assertNotNull(capabilities0);
      assertEquals(2.0, multiClassClassifier0.getRandomWidthFactor(), 0.01);
      assertEquals("Sets the method to use for transforming the multi-class problem into several 2-class ones.", multiClassClassifier0.methodTipText());
      assertEquals("Sets the width multiplier when using random codes. The number of codes generated will be thus number multiplied by the number of classes.", multiClassClassifier0.randomWidthFactorTipText());
      assertEquals("A metaclassifier for handling multi-class datasets with 2-class classifiers. This classifier is also capable of applying error correcting output codes for increased accuracy.", multiClassClassifier0.globalInfo());
      assertFalse(multiClassClassifier0.getUsePairwiseCoupling());
      assertFalse(multiClassClassifier0.getDebug());
      assertEquals("If set to true, classifier may output additional info to the console.", multiClassClassifier0.debugTipText());
      assertEquals("The random number seed to be used.", multiClassClassifier0.seedTipText());
      assertEquals(1, multiClassClassifier0.getSeed());
      assertEquals("The base classifier to be used.", multiClassClassifier0.classifierTipText());
      assertEquals("Use pairwise coupling (only has an effect for 1-against-1).", multiClassClassifier0.usePairwiseCouplingTipText());
      assertTrue(capabilities0.hasDependencies());
      assertEquals(1, capabilities0.getMinimumNumberInstances());
      assertEquals(2, MultiClassClassifier.METHOD_ERROR_EXHAUSTIVE);
      assertEquals(1, MultiClassClassifier.METHOD_ERROR_RANDOM);
      assertEquals(3, MultiClassClassifier.METHOD_1_AGAINST_1);
      assertEquals(0, MultiClassClassifier.METHOD_1_AGAINST_ALL);
      
      checkClassifier0.setNumRelational(0);
      assertEquals(0, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(3, checkClassifier0.getNumInstancesRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      int int1 = 0;
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleClassAsNthAttribute(false, false, false, false, true, false, 3, 3);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Index: 3, Size: 0
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      
      Stacking stacking0 = new Stacking();
      assertNotNull(stacking0);
      assertEquals(1, stacking0.getNumExecutionSlots());
      assertFalse(stacking0.getDebug());
      assertEquals(10, stacking0.getNumFolds());
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      assertEquals(1, stacking0.getSeed());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      
      boolean boolean0 = true;
      boolean boolean1 = true;
      boolean boolean2 = false;
      boolean boolean3 = true;
      boolean boolean4 = false;
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(true, false, false, true, true, true, 3);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      String string0 = checkClassifier0.getRevision();
      assertNotNull(string0);
      assertEquals("8034", string0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      int int0 = (-2975);
      boolean boolean0 = true;
      String string1 = "Problem determining ZeroR performance: ";
      checkClassifier0.setWordSeparators("Problem determining ZeroR performance: ");
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals("Problem determining ZeroR performance: ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      boolean boolean1 = false;
      Utils.SMALL = (double) (-2975);
      boolean boolean2 = false;
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleOnlyClass(false, false, false, false, false, (-2975));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-2975' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      
      int int0 = 1060;
      boolean boolean0 = false;
      boolean boolean1 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(true, true, false, true, true, true, 1060);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '1060' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      
      boolean boolean0 = true;
      int int0 = 243;
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(true, true, true, true, true, true, 243);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '243' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      boolean[] booleanArray0 = checkClassifier0.weightedInstancesHandler();
      assertNotNull(booleanArray0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      Stacking stacking0 = new Stacking();
      assertNotNull(stacking0);
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      assertFalse(stacking0.getDebug());
      assertEquals(1, stacking0.getNumExecutionSlots());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      assertEquals(10, stacking0.getNumFolds());
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals(1, stacking0.getSeed());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      
      stacking0.setNumFolds(69);
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      assertFalse(stacking0.getDebug());
      assertEquals(1, stacking0.getNumExecutionSlots());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      assertEquals(69, stacking0.getNumFolds());
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals(1, stacking0.getSeed());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(true, true, false, true, false, true, 4, false, true);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      
      Stacking stacking0 = new Stacking();
      assertNotNull(stacking0);
      assertEquals(1, stacking0.getSeed());
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      assertFalse(stacking0.getDebug());
      assertEquals(10, stacking0.getNumFolds());
      assertEquals(1, stacking0.getNumExecutionSlots());
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      
      stacking0.setNumFolds(270);
      assertEquals(1, stacking0.getSeed());
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      assertFalse(stacking0.getDebug());
      assertEquals(1, stacking0.getNumExecutionSlots());
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      assertEquals(270, stacking0.getNumFolds());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(false, true, false, false, false, false, 270, true, false);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '270' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, " is not assignable from ");
      assertFalse(boolean0);
      
      Stacking stacking0 = new Stacking();
      assertNotNull(stacking0);
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals(1, stacking0.getSeed());
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      assertFalse(stacking0.getDebug());
      assertEquals(10, stacking0.getNumFolds());
      assertEquals(1, stacking0.getNumExecutionSlots());
      
      stacking0.setNumFolds(1715);
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals(1, stacking0.getSeed());
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals(1715, stacking0.getNumFolds());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      assertFalse(stacking0.getDebug());
      assertEquals(1, stacking0.getNumExecutionSlots());
      
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(true, true, false, false, true, false, (-1792), false, true);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1792' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean boolean0 = false;
      boolean boolean1 = true;
      boolean boolean2 = true;
      boolean boolean3 = false;
      int int0 = (-806);
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(false, true, true, false, false, true, (-285));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-285' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      
      int int0 = 1079;
      boolean boolean0 = true;
      int int1 = 10;
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(false, false, true, true, true, true, 10);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '10' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      boolean boolean0 = true;
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/home/users/apanichella/PackageManager.props");
      boolean boolean1 = FileSystemHandling.appendLineToFile(evoSuiteFile0, "]AbD");
      assertTrue(boolean1);
      assertTrue(boolean1 == boolean0);
      
      boolean boolean2 = false;
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(true, true, true, false, true, true, 1497);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '1497' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      
      boolean boolean0 = false;
      boolean boolean1 = false;
      boolean boolean2 = true;
      int int0 = 0;
      // Undeclared exception!
      try { 
        checkClassifier0.testsPerClassType(0, true, false, true);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Problem determining ZeroR performance: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      
      Stacking stacking0 = new Stacking();
      assertNotNull(stacking0);
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      assertFalse(stacking0.getDebug());
      assertEquals(1, stacking0.getNumExecutionSlots());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      assertEquals(10, stacking0.getNumFolds());
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals(1, stacking0.getSeed());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      
      stacking0.setNumFolds(270);
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      assertFalse(stacking0.getDebug());
      assertEquals(1, stacking0.getNumExecutionSlots());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals(1, stacking0.getSeed());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      assertEquals(270, stacking0.getNumFolds());
      
      boolean[] booleanArray1 = checkClassifier0.weightedInstancesHandler();
      assertNotNull(booleanArray1);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      
      String[] stringArray0 = new String[3];
      stringArray0[0] = "r~S";
      stringArray0[1] = "";
      stringArray0[2] = "OMxs ";
      checkClassifier0.setOptions(stringArray0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      boolean boolean0 = true;
      boolean boolean1 = false;
      boolean boolean2 = false;
      int int0 = 2036;
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(true, true, false, false, false, true, 2036);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '2036' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      
      String[] stringArray0 = checkClassifier0.getOptions();
      assertNotNull(stringArray0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      
      boolean[] booleanArray0 = checkClassifier0.instanceWeights(true, true, true, false, false, false, 0);
      assertNotNull(booleanArray0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      boolean[] booleanArray1 = checkClassifier0.testToString();
      assertNotNull(booleanArray1);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      
      boolean[] booleanArray2 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray2);
      assertNotSame(booleanArray2, booleanArray1);
      assertNotSame(booleanArray2, booleanArray0);
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray2));
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      
      SMO sMO0 = new SMO();
      assertNotNull(sMO0);
      assertEquals("The complexity parameter C.", sMO0.cTipText());
      assertFalse(sMO0.getBuildLogisticModels());
      assertEquals("Random number seed for the cross-validation.", sMO0.randomSeedTipText());
      assertEquals("The kernel to use.", sMO0.kernelTipText());
      assertEquals("Determines how/if the data will be transformed.", sMO0.filterTypeTipText());
      assertEquals(0.001, sMO0.getToleranceParameter(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", sMO0.debugTipText());
      assertEquals("The tolerance parameter (shouldn't be changed).", sMO0.toleranceParameterTipText());
      assertEquals((-1), sMO0.getNumFolds());
      assertEquals("Turns time-consuming checks off - use with caution.", sMO0.checksTurnedOffTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", sMO0.epsilonTipText());
      assertFalse(sMO0.getChecksTurnedOff());
      assertFalse(sMO0.getDebug());
      assertEquals("The number of folds for cross-validation used to generate training data for logistic models (-1 means use training data).", sMO0.numFoldsTipText());
      assertEquals("Whether to fit logistic models to the outputs (for proper probability estimates).", sMO0.buildLogisticModelsTipText());
      assertEquals(1.0, sMO0.getC(), 0.01);
      assertEquals(1, sMO0.getRandomSeed());
      assertEquals(1.0E-12, sMO0.getEpsilon(), 0.01);
      assertEquals(1, SMO.FILTER_STANDARDIZE);
      assertEquals(2, SMO.FILTER_NONE);
      assertEquals(0, SMO.FILTER_NORMALIZE);
      
      checkClassifier0.m_Classifier = (Classifier) sMO0;
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals("The complexity parameter C.", sMO0.cTipText());
      assertFalse(sMO0.getBuildLogisticModels());
      assertEquals("Random number seed for the cross-validation.", sMO0.randomSeedTipText());
      assertEquals("The kernel to use.", sMO0.kernelTipText());
      assertEquals("Determines how/if the data will be transformed.", sMO0.filterTypeTipText());
      assertEquals(0.001, sMO0.getToleranceParameter(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", sMO0.debugTipText());
      assertEquals("The tolerance parameter (shouldn't be changed).", sMO0.toleranceParameterTipText());
      assertEquals((-1), sMO0.getNumFolds());
      assertEquals("Turns time-consuming checks off - use with caution.", sMO0.checksTurnedOffTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", sMO0.epsilonTipText());
      assertFalse(sMO0.getChecksTurnedOff());
      assertFalse(sMO0.getDebug());
      assertEquals("The number of folds for cross-validation used to generate training data for logistic models (-1 means use training data).", sMO0.numFoldsTipText());
      assertEquals("Whether to fit logistic models to the outputs (for proper probability estimates).", sMO0.buildLogisticModelsTipText());
      assertEquals(1.0, sMO0.getC(), 0.01);
      assertEquals(1, sMO0.getRandomSeed());
      assertEquals(1.0E-12, sMO0.getEpsilon(), 0.01);
      
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "]AbD");
      assertFalse(boolean0);
      
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(false, false, true, false, false, false, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: weka.classifiers.functions.SMO: Cannot handle string attributes!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      String string0 = "]AbD";
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "]AbD");
      assertFalse(boolean0);
      
      boolean[] booleanArray0 = checkClassifier0.canHandleMissing(true, true, true, false, true, false, 0, false, true, 11);
      assertNotNull(booleanArray0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      String[] stringArray0 = new String[0];
      CheckClassifier.main(stringArray0);
      checkClassifier0.declaresSerialVersionUID();
      String[] stringArray1 = new String[3];
      stringArray1[0] = string0;
      stringArray1[1] = string0;
      stringArray1[2] = string0;
      checkClassifier0.setOptions(stringArray1);
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      SimpleLogistic simpleLogistic0 = new SimpleLogistic(20, true, true);
      assertNotNull(simpleLogistic0);
      assertEquals(500, simpleLogistic0.getMaxBoostingIterations());
      assertEquals("If heuristicStop > 0, the heuristic for greedy stopping while cross-validating the number of LogitBoost iterations is enabled. This means LogitBoost is stopped if no new error minimum has been reached in the last heuristicStop iterations. It is recommended to use this heuristic, it gives a large speed-up especially on small datasets. The default value is 50.", simpleLogistic0.heuristicStopTipText());
      assertEquals("Set the beta value used for weight trimming in LogitBoost. Only instances carrying (1 - beta)% of the weight from previous iteration are used in the next iteration. Set to 0 for no weight trimming. The default value is 0.", simpleLogistic0.weightTrimBetaTipText());
      assertEquals("Use error on the probabilties as error measure when determining the best number of LogitBoost iterations. If set, the number of LogitBoost iterations is chosen that minimizes the root mean squared error (either on the training set or in the cross-validation, depending on useCrossValidation).", simpleLogistic0.errorOnProbabilitiesTipText());
      assertEquals(20, simpleLogistic0.getNumBoostingIterations());
      assertFalse(simpleLogistic0.getUseAIC());
      assertEquals("Sets the maximum number of iterations for LogitBoost. Default value is 500, for very small/large datasets a lower/higher value might be preferable.", simpleLogistic0.maxBoostingIterationsTipText());
      assertEquals("Sets whether the number of LogitBoost iterations is to be cross-validated or the stopping criterion on the training set should be used. If not set (and no fixed number of iterations was given), the number of LogitBoost iterations is used that minimizes the error on the training set (misclassification error or error on probabilities depending on errorOnProbabilities).", simpleLogistic0.useCrossValidationTipText());
      assertEquals(50, simpleLogistic0.getHeuristicStop());
      assertTrue(simpleLogistic0.getUseCrossValidation());
      assertEquals("If set to true, classifier may output additional info to the console.", simpleLogistic0.debugTipText());
      assertEquals("The AIC is used to determine when to stop LogitBoost iterations (instead of cross-validation or training error).", simpleLogistic0.useAICTipText());
      assertEquals(0.0, simpleLogistic0.getWeightTrimBeta(), 0.01);
      assertFalse(simpleLogistic0.getDebug());
      assertEquals("Set fixed number of iterations for LogitBoost. If >= 0, this sets the number of LogitBoost iterations to perform. If < 0, the number is cross-validated or a stopping criterion on the training set is used (depending on the value of useCrossValidation).", simpleLogistic0.numBoostingIterationsTipText());
      assertTrue(simpleLogistic0.getErrorOnProbabilities());
      
      checkClassifier0.m_Classifier = (Classifier) simpleLogistic0;
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(500, simpleLogistic0.getMaxBoostingIterations());
      assertEquals("If heuristicStop > 0, the heuristic for greedy stopping while cross-validating the number of LogitBoost iterations is enabled. This means LogitBoost is stopped if no new error minimum has been reached in the last heuristicStop iterations. It is recommended to use this heuristic, it gives a large speed-up especially on small datasets. The default value is 50.", simpleLogistic0.heuristicStopTipText());
      assertEquals("Set the beta value used for weight trimming in LogitBoost. Only instances carrying (1 - beta)% of the weight from previous iteration are used in the next iteration. Set to 0 for no weight trimming. The default value is 0.", simpleLogistic0.weightTrimBetaTipText());
      assertEquals("Use error on the probabilties as error measure when determining the best number of LogitBoost iterations. If set, the number of LogitBoost iterations is chosen that minimizes the root mean squared error (either on the training set or in the cross-validation, depending on useCrossValidation).", simpleLogistic0.errorOnProbabilitiesTipText());
      assertEquals(20, simpleLogistic0.getNumBoostingIterations());
      assertFalse(simpleLogistic0.getUseAIC());
      assertEquals("Sets the maximum number of iterations for LogitBoost. Default value is 500, for very small/large datasets a lower/higher value might be preferable.", simpleLogistic0.maxBoostingIterationsTipText());
      assertEquals("Sets whether the number of LogitBoost iterations is to be cross-validated or the stopping criterion on the training set should be used. If not set (and no fixed number of iterations was given), the number of LogitBoost iterations is used that minimizes the error on the training set (misclassification error or error on probabilities depending on errorOnProbabilities).", simpleLogistic0.useCrossValidationTipText());
      assertEquals(50, simpleLogistic0.getHeuristicStop());
      assertTrue(simpleLogistic0.getUseCrossValidation());
      assertEquals("If set to true, classifier may output additional info to the console.", simpleLogistic0.debugTipText());
      assertEquals("The AIC is used to determine when to stop LogitBoost iterations (instead of cross-validation or training error).", simpleLogistic0.useAICTipText());
      assertEquals(0.0, simpleLogistic0.getWeightTrimBeta(), 0.01);
      assertFalse(simpleLogistic0.getDebug());
      assertEquals("Set fixed number of iterations for LogitBoost. If >= 0, this sets the number of LogitBoost iterations to perform. If < 0, the number is cross-validated or a stopping criterion on the training set is used (depending on the value of useCrossValidation).", simpleLogistic0.numBoostingIterationsTipText());
      assertTrue(simpleLogistic0.getErrorOnProbabilities());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      
      boolean[] booleanArray1 = checkClassifier0.canHandleClassAsNthAttribute(false, true, true, true, false, false, 0, 0);
      assertNotNull(booleanArray1);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray1));
      
      String[] stringArray0 = new String[6];
      stringArray0[1] = "";
      stringArray0[2] = "";
      stringArray0[3] = " values";
      boolean[] booleanArray2 = checkClassifier0.correctBuildInitialisation(false, true, false, true, false, true, 0);
      assertNotNull(booleanArray2);
      assertNotSame(booleanArray2, booleanArray0);
      assertNotSame(booleanArray2, booleanArray1);
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray2));
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      boolean boolean0 = false;
      boolean boolean1 = FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, true);
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
      
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      
      boolean boolean2 = true;
      boolean boolean3 = true;
      boolean boolean4 = false;
      int int0 = 13;
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(false, true, false, true, true, false, 13);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '13' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      boolean[] booleanArray0 = checkClassifier0.weightedInstancesHandler();
      assertNotNull(booleanArray0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      Stacking stacking0 = new Stacking();
      assertNotNull(stacking0);
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals(1, stacking0.getNumExecutionSlots());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      assertEquals(10, stacking0.getNumFolds());
      assertEquals(1, stacking0.getSeed());
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      assertFalse(stacking0.getDebug());
      
      stacking0.setNumFolds(69);
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals(1, stacking0.getNumExecutionSlots());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      assertEquals(1, stacking0.getSeed());
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      assertEquals(69, stacking0.getNumFolds());
      assertFalse(stacking0.getDebug());
      
      boolean[] booleanArray1 = checkClassifier0.datasetIntegrity(false, true, true, false, false, true, 2, false, false);
      assertNotNull(booleanArray1);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray1));
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      
      String[] stringArray0 = TestInstances.DEFAULT_WORDS;
      assertNotNull(stringArray0);
      
      Stacking stacking0 = new Stacking();
      assertNotNull(stacking0);
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals(1, stacking0.getSeed());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals(1, stacking0.getNumExecutionSlots());
      assertFalse(stacking0.getDebug());
      assertEquals(10, stacking0.getNumFolds());
      
      stacking0.setNumFolds(13);
      assertEquals("The base classifiers to be used.", stacking0.classifiersTipText());
      assertEquals(13, stacking0.getNumFolds());
      assertEquals(1, stacking0.getSeed());
      assertEquals("The meta classifiers to be used.", stacking0.metaClassifierTipText());
      assertEquals("The number of folds used for cross-validation.", stacking0.numFoldsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", stacking0.debugTipText());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", stacking0.numExecutionSlotsTipText());
      assertEquals("The random number seed to be used.", stacking0.seedTipText());
      assertEquals(1, stacking0.getNumExecutionSlots());
      assertFalse(stacking0.getDebug());
      
      boolean[] booleanArray0 = checkClassifier0.datasetIntegrity(true, true, true, true, true, false, 2, true, false);
      assertNotNull(booleanArray0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.updateableClassifier();
      checkClassifier0.canHandleClassAsNthAttribute(false, true, true, true, false, false, 0, 0);
      String[] stringArray0 = new String[6];
      stringArray0[1] = "";
      stringArray0[2] = "";
      stringArray0[3] = " values";
      checkClassifier0.doesntUseTestClassVal(true, true, true, true, false, true, 0);
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      SimpleLogistic simpleLogistic0 = new SimpleLogistic(20, true, true);
      checkClassifier0.m_Classifier = (Classifier) simpleLogistic0;
      checkClassifier0.updateableClassifier();
      checkClassifier0.canHandleClassAsNthAttribute(false, true, true, true, false, true, 0, 0);
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/mnt/gaiagpfs/users/homedirs/apanichella/Evosuite_performance/Dataset/gordon_script_sum/projects/9_weka/Capabilities.props");
      FileSystemHandling.shouldThrowIOException(evoSuiteFile0);
      checkClassifier0.correctBuildInitialisation(false, false, true, true, true, false, 0);
      checkClassifier0.canPredict(false, false, false, false, true, false, 0);
      checkClassifier0.weightedInstancesHandler();
  }
}
