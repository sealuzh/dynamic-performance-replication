/*
 * This file was automatically generated by EvoSuite
 * Sat Jul 07 13:47:52 GMT 2018
 */

package weka.classifiers;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.Arrays;
import java.util.Enumeration;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.System;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;
import weka.classifiers.AbstractClassifier;
import weka.classifiers.CheckClassifier;
import weka.classifiers.Classifier;
import weka.classifiers.functions.MultilayerPerceptron;
import weka.classifiers.functions.SGD;
import weka.classifiers.misc.SerializedClassifier;
import weka.classifiers.rules.ZeroR;
import weka.classifiers.trees.RandomForest;
import weka.core.CheckScheme;
import weka.core.Utils;
import weka.core.tokenizers.WordTokenizer;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class CheckClassifier_ESTest extends CheckClassifier_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.getClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.testsPerClassType((-553), true, false, true);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-553' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleClassAsNthAttribute(false, false, false, false, false, false, 2306, 112);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '2306' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleMissing(true, true, true, true, true, true, 37, true, true, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '37' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      boolean boolean0 = true;
      int int0 = (-1471);
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(false, false, true, false, true, true, (-1471), true, false);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1471' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.weightedInstancesHandler();
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleMissing(true, true, true, true, false, true, (-199), true, false, 935);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-199' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.weightedInstancesHandler();
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleMissing(false, true, false, false, true, false, (-174), false, false, 935);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-174' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      boolean boolean0 = true;
      boolean boolean1 = true;
      boolean boolean2 = true;
      int int0 = 119;
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleZeroTraining(true, true, true, true, true, true, 119);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '119' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.getClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(false, false, false, false, true, false, (-2245));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-2245' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.getPostProcessor();
      checkClassifier0.setPostProcessor((CheckScheme.PostProcessor) null);
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleOnlyClass(true, false, false, false, true, 34);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '34' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(true, true, true, true, true, true, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleClassAsNthAttribute(false, false, false, true, false, true, 87, 87);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '87' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(true, true, true, true, true, true, (-16));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-16' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.weightedInstancesHandler();
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(false, false, false, false, false, true, 28);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '28' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.canTakeOptions();
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(false, true, true, true, false, false, 1016);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '1016' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(true, false, true, true, true, true, 34);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '34' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.weightedInstancesHandler();
      checkClassifier0.setNumString(3);
      boolean boolean0 = false;
      boolean boolean1 = true;
      MultilayerPerceptron multilayerPerceptron0 = new MultilayerPerceptron();
      checkClassifier0.setClassifier(multilayerPerceptron0);
      checkClassifier0.testToString();
      boolean boolean2 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(true, true, true, true, false, true, 103);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '103' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.setNumInstances(0);
      boolean[] booleanArray0 = checkClassifier0.canHandleNClasses(true, true, true, false, false, false, 500);
      assertTrue(Arrays.equals(new boolean[] {true, true}, booleanArray0));
      
      checkClassifier0.listOptions();
      checkClassifier0.getClassifier();
      boolean[] booleanArray1 = checkClassifier0.canTakeOptions();
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      
      checkClassifier0.getOptions();
      boolean[] booleanArray2 = checkClassifier0.declaresSerialVersionUID();
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray2));
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      CheckClassifier.main((String[]) null);
      SGD sGD0 = new SGD();
      assertNotNull(sGD0);
      assertEquals(0, SGD.HINGE);
      assertEquals(2, SGD.SQUAREDLOSS);
      assertEquals(1, SGD.LOGLOSS);
      assertEquals(500, sGD0.getEpochs());
      assertEquals(0.01, sGD0.getLearningRate(), 0.01);
      assertFalse(sGD0.getDontNormalize());
      assertEquals("If set to true, classifier may output additional info to the console.", sGD0.debugTipText());
      assertEquals("Turn off global replacement of missing values", sGD0.dontReplaceMissingTipText());
      assertFalse(sGD0.getDebug());
      assertEquals("The regularization constant. (default = 0.0001)", sGD0.lambdaTipText());
      assertEquals("Turn normalization off", sGD0.dontNormalizeTipText());
      assertEquals("The random number seed to be used.", sGD0.seedTipText());
      assertEquals(1.0E-4, sGD0.getLambda(), 0.01);
      assertEquals("The number of epochs to perform (batch learning). The total number of iterations is epochs * num instances.", sGD0.epochsTipText());
      assertEquals("The learning rate. If normalization is turned off (as it is automatically for streaming data), thenthe default learning rate will need to be reduced (try 0.0001).", sGD0.learningRateTipText());
      assertEquals("The loss function to use. Hinge loss (SVM), log loss (logistic regression) or squared loss (regression).", sGD0.lossFunctionTipText());
      assertFalse(sGD0.getDontReplaceMissing());
      assertEquals("Implements stochastic gradient descent for learning various linear models (binary class SVM, binary class logistic regression and linear regression). Globally replaces all missing values and transforms nominal attributes into binary ones. It also normalizes all attributes, so the coefficients in the output are based on the normalized data.\nFor numeric class attributes, the squared loss function (2) must be used.", sGD0.globalInfo());
      assertEquals(1, sGD0.getSeed());
      
      sGD0.setLearningRate(0.0);
      assertEquals(0, SGD.HINGE);
      assertEquals(2, SGD.SQUAREDLOSS);
      assertEquals(1, SGD.LOGLOSS);
      assertEquals(500, sGD0.getEpochs());
      assertFalse(sGD0.getDontNormalize());
      assertEquals("If set to true, classifier may output additional info to the console.", sGD0.debugTipText());
      assertEquals("Turn off global replacement of missing values", sGD0.dontReplaceMissingTipText());
      assertFalse(sGD0.getDebug());
      assertEquals(0.0, sGD0.getLearningRate(), 0.01);
      assertEquals("The regularization constant. (default = 0.0001)", sGD0.lambdaTipText());
      assertEquals("Turn normalization off", sGD0.dontNormalizeTipText());
      assertEquals("The random number seed to be used.", sGD0.seedTipText());
      assertEquals(1.0E-4, sGD0.getLambda(), 0.01);
      assertEquals("The number of epochs to perform (batch learning). The total number of iterations is epochs * num instances.", sGD0.epochsTipText());
      assertEquals("The learning rate. If normalization is turned off (as it is automatically for streaming data), thenthe default learning rate will need to be reduced (try 0.0001).", sGD0.learningRateTipText());
      assertEquals("The loss function to use. Hinge loss (SVM), log loss (logistic regression) or squared loss (regression).", sGD0.lossFunctionTipText());
      assertFalse(sGD0.getDontReplaceMissing());
      assertEquals("Implements stochastic gradient descent for learning various linear models (binary class SVM, binary class logistic regression and linear regression). Globally replaces all missing values and transforms nominal attributes into binary ones. It also normalizes all attributes, so the coefficients in the output are based on the normalized data.\nFor numeric class attributes, the squared loss function (2) must be used.", sGD0.globalInfo());
      assertEquals(1, sGD0.getSeed());
      
      Classifier[] classifierArray0 = AbstractClassifier.makeCopies(sGD0, 1);
      assertNotNull(classifierArray0);
      assertEquals(0, SGD.HINGE);
      assertEquals(2, SGD.SQUAREDLOSS);
      assertEquals(1, SGD.LOGLOSS);
      assertEquals(500, sGD0.getEpochs());
      assertFalse(sGD0.getDontNormalize());
      assertEquals("If set to true, classifier may output additional info to the console.", sGD0.debugTipText());
      assertEquals("Turn off global replacement of missing values", sGD0.dontReplaceMissingTipText());
      assertFalse(sGD0.getDebug());
      assertEquals(0.0, sGD0.getLearningRate(), 0.01);
      assertEquals("The regularization constant. (default = 0.0001)", sGD0.lambdaTipText());
      assertEquals("Turn normalization off", sGD0.dontNormalizeTipText());
      assertEquals("The random number seed to be used.", sGD0.seedTipText());
      assertEquals(1.0E-4, sGD0.getLambda(), 0.01);
      assertEquals("The number of epochs to perform (batch learning). The total number of iterations is epochs * num instances.", sGD0.epochsTipText());
      assertEquals("The learning rate. If normalization is turned off (as it is automatically for streaming data), thenthe default learning rate will need to be reduced (try 0.0001).", sGD0.learningRateTipText());
      assertEquals("The loss function to use. Hinge loss (SVM), log loss (logistic regression) or squared loss (regression).", sGD0.lossFunctionTipText());
      assertFalse(sGD0.getDontReplaceMissing());
      assertEquals("Implements stochastic gradient descent for learning various linear models (binary class SVM, binary class logistic regression and linear regression). Globally replaces all missing values and transforms nominal attributes into binary ones. It also normalizes all attributes, so the coefficients in the output are based on the normalized data.\nFor numeric class attributes, the squared loss function (2) must be used.", sGD0.globalInfo());
      assertEquals(1, sGD0.getSeed());
      
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertNotNull(checkClassifier1);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(1, checkClassifier1.getNumString());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertFalse(checkClassifier1.hasClasspathProblems());
      
      boolean[] booleanArray1 = checkClassifier0.canPredict(true, true, true, true, false, true, 2);
      assertNotNull(booleanArray1);
      assertNotSame(checkClassifier0, checkClassifier1);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(checkClassifier0.equals((Object)checkClassifier1));
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertTrue(Arrays.equals(new boolean[] {false, true}, booleanArray1));
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      String string0 = checkClassifier0.getWords();
      assertEquals("The,quick,brown,fox,jumps,over,the,lazy,dog", string0);
      assertNotNull(string0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean boolean0 = false;
      int int0 = (-1774);
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(true, true, false, false, false, true, (-1774), true, true);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1774' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      String[] stringArray0 = checkClassifier0.getOptions();
      assertNotNull(stringArray0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      String string0 = checkClassifier0.getRevision();
      assertEquals("8034", string0);
      assertNotNull(string0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      String string0 = checkClassifier0.getRevision();
      assertEquals("8034", string0);
      assertNotNull(string0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      Enumeration enumeration0 = checkClassifier0.listOptions();
      assertNotNull(enumeration0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      checkClassifier0.setClassifier((Classifier) null);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      Enumeration enumeration1 = checkClassifier0.listOptions();
      assertNotNull(enumeration1);
      assertNotSame(enumeration1, enumeration0);
      assertFalse(enumeration1.equals((Object)enumeration0));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      boolean boolean0 = false;
      // Undeclared exception!
      try { 
        checkClassifier0.testsPerClassType(0, false, false, false);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: No model classifier set
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      
      CheckScheme.PostProcessor checkScheme_PostProcessor0 = new CheckScheme.PostProcessor();
      assertNotNull(checkScheme_PostProcessor0);
      
      checkClassifier0.setPostProcessor(checkScheme_PostProcessor0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      
      boolean boolean0 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(false, false, false, false, true, false, 1126);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '1126' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean[] booleanArray0 = checkClassifier0.testToString();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean boolean0 = false;
      Utils.SMALL = 0.5;
      int int0 = 0;
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(true, false, false, false, true, true, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      int int0 = 3291;
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(true, false, false, false, false, false, 3291);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '3291' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      String string0 = checkClassifier0.getWords();
      assertEquals("The,quick,brown,fox,jumps,over,the,lazy,dog", string0);
      assertNotNull(string0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      boolean boolean0 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(false, true, false, true, true, false, (-1774));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1774' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      
      String string0 = checkClassifier0.getWords();
      assertEquals("The,quick,brown,fox,jumps,over,the,lazy,dog", string0);
      assertNotNull(string0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(true, false, false, true, true, true, (-2184));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-2184' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(true, true, false, true, false, false, 869);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '869' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      checkClassifier0.setNumRelational(2500);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2500, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(true, false, false, true, false, false, (-2081), false, true);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-2081' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean[] booleanArray0 = checkClassifier0.multiInstanceHandler();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean[] booleanArray1 = checkClassifier0.doesntUseTestClassVal(false, false, true, false, false, false, 3);
      assertNotNull(booleanArray1);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      
      boolean[] booleanArray0 = checkClassifier0.doesntUseTestClassVal(true, true, true, true, true, false, 0);
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      CheckClassifier.main((String[]) null);
      SGD sGD0 = new SGD();
      assertNotNull(sGD0);
      assertEquals(0, SGD.HINGE);
      assertEquals(1, SGD.LOGLOSS);
      assertEquals(2, SGD.SQUAREDLOSS);
      assertFalse(sGD0.getDontReplaceMissing());
      assertEquals(500, sGD0.getEpochs());
      assertEquals("Implements stochastic gradient descent for learning various linear models (binary class SVM, binary class logistic regression and linear regression). Globally replaces all missing values and transforms nominal attributes into binary ones. It also normalizes all attributes, so the coefficients in the output are based on the normalized data.\nFor numeric class attributes, the squared loss function (2) must be used.", sGD0.globalInfo());
      assertEquals("Turn normalization off", sGD0.dontNormalizeTipText());
      assertEquals("The random number seed to be used.", sGD0.seedTipText());
      assertEquals("The number of epochs to perform (batch learning). The total number of iterations is epochs * num instances.", sGD0.epochsTipText());
      assertEquals("Turn off global replacement of missing values", sGD0.dontReplaceMissingTipText());
      assertFalse(sGD0.getDontNormalize());
      assertEquals("The learning rate. If normalization is turned off (as it is automatically for streaming data), thenthe default learning rate will need to be reduced (try 0.0001).", sGD0.learningRateTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sGD0.debugTipText());
      assertEquals("The regularization constant. (default = 0.0001)", sGD0.lambdaTipText());
      assertEquals(1, sGD0.getSeed());
      assertEquals(1.0E-4, sGD0.getLambda(), 0.01);
      assertEquals("The loss function to use. Hinge loss (SVM), log loss (logistic regression) or squared loss (regression).", sGD0.lossFunctionTipText());
      assertFalse(sGD0.getDebug());
      assertEquals(0.01, sGD0.getLearningRate(), 0.01);
      
      sGD0.setLearningRate(0.0);
      assertEquals(0, SGD.HINGE);
      assertEquals(1, SGD.LOGLOSS);
      assertEquals(2, SGD.SQUAREDLOSS);
      assertFalse(sGD0.getDontReplaceMissing());
      assertEquals(500, sGD0.getEpochs());
      assertEquals("Implements stochastic gradient descent for learning various linear models (binary class SVM, binary class logistic regression and linear regression). Globally replaces all missing values and transforms nominal attributes into binary ones. It also normalizes all attributes, so the coefficients in the output are based on the normalized data.\nFor numeric class attributes, the squared loss function (2) must be used.", sGD0.globalInfo());
      assertEquals("Turn normalization off", sGD0.dontNormalizeTipText());
      assertEquals("The random number seed to be used.", sGD0.seedTipText());
      assertEquals(0.0, sGD0.getLearningRate(), 0.01);
      assertEquals("The number of epochs to perform (batch learning). The total number of iterations is epochs * num instances.", sGD0.epochsTipText());
      assertEquals("Turn off global replacement of missing values", sGD0.dontReplaceMissingTipText());
      assertFalse(sGD0.getDontNormalize());
      assertEquals("The learning rate. If normalization is turned off (as it is automatically for streaming data), thenthe default learning rate will need to be reduced (try 0.0001).", sGD0.learningRateTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sGD0.debugTipText());
      assertEquals("The regularization constant. (default = 0.0001)", sGD0.lambdaTipText());
      assertEquals(1, sGD0.getSeed());
      assertEquals(1.0E-4, sGD0.getLambda(), 0.01);
      assertEquals("The loss function to use. Hinge loss (SVM), log loss (logistic regression) or squared loss (regression).", sGD0.lossFunctionTipText());
      assertFalse(sGD0.getDebug());
      
      boolean[] booleanArray1 = checkClassifier0.doesntUseTestClassVal(false, false, false, false, false, false, 1);
      assertNotNull(booleanArray1);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      
      boolean[] booleanArray0 = checkClassifier0.weightedInstancesHandler();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      
      boolean boolean0 = false;
      boolean boolean1 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(false, true, false, true, true, true, 3);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      boolean[] booleanArray0 = checkClassifier0.weightedInstancesHandler();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      boolean[] booleanArray1 = checkClassifier0.testToString();
      assertNotNull(booleanArray1);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(true, true, true, false, true, true, (-389));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-389' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      Enumeration enumeration0 = checkClassifier0.listOptions();
      assertNotNull(enumeration0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      RandomForest randomForest0 = new RandomForest();
      assertNotNull(randomForest0);
      assertEquals(1, randomForest0.getNumExecutionSlots());
      assertFalse(randomForest0.getDebug());
      assertEquals(1, randomForest0.getSeed());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", randomForest0.numExecutionSlotsTipText());
      assertEquals("The maximum depth of the trees, 0 for unlimited.", randomForest0.maxDepthTipText());
      assertEquals(0, randomForest0.getNumFeatures());
      assertEquals("The number of trees to be generated.", randomForest0.numTreesTipText());
      assertFalse(randomForest0.getPrintTrees());
      assertEquals(0, randomForest0.getMaxDepth());
      assertEquals("If set to true, classifier may output additional info to the console.", randomForest0.debugTipText());
      assertEquals("The number of attributes to be used in random selection (see RandomTree).", randomForest0.numFeaturesTipText());
      assertEquals("Print the individual trees in the output", randomForest0.printTreesTipText());
      assertEquals("The random number seed to be used.", randomForest0.seedTipText());
      assertEquals(10, randomForest0.getNumTrees());
      assertEquals(Double.NaN, randomForest0.measureOutOfBagError(), 0.01);
      
      boolean[] booleanArray0 = checkClassifier0.correctBuildInitialisation(false, false, true, true, true, false, 2);
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      String[] stringArray0 = checkClassifier0.getOptions();
      assertNotNull(stringArray0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertNotNull(checkClassifier1);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      
      boolean[] booleanArray1 = checkClassifier1.declaresSerialVersionUID();
      assertNotNull(booleanArray1);
      assertNotSame(checkClassifier1, checkClassifier0);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(" ", checkClassifier1.getWordSeparators());
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      boolean[] booleanArray0 = checkClassifier0.correctBuildInitialisation(false, true, false, true, false, false, 2);
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      System.setCurrentTimeMillis((-1485L));
      checkClassifier0.printAttributeSummary(false, false, false, false, true, true, 348);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.createFolder((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      checkClassifier0.setNumInstances(0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean[] booleanArray0 = checkClassifier0.canHandleNClasses(true, true, true, true, true, true, 0);
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, true}, booleanArray0));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      Enumeration enumeration0 = checkClassifier0.listOptions();
      assertNotNull(enumeration0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      RandomForest randomForest0 = new RandomForest();
      assertNotNull(randomForest0);
      assertFalse(randomForest0.getDebug());
      assertEquals(1, randomForest0.getSeed());
      assertEquals("The maximum depth of the trees, 0 for unlimited.", randomForest0.maxDepthTipText());
      assertEquals(10, randomForest0.getNumTrees());
      assertEquals(0, randomForest0.getMaxDepth());
      assertEquals(1, randomForest0.getNumExecutionSlots());
      assertEquals(Double.NaN, randomForest0.measureOutOfBagError(), 0.01);
      assertFalse(randomForest0.getPrintTrees());
      assertEquals("Print the individual trees in the output", randomForest0.printTreesTipText());
      assertEquals("The number of attributes to be used in random selection (see RandomTree).", randomForest0.numFeaturesTipText());
      assertEquals("The random number seed to be used.", randomForest0.seedTipText());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", randomForest0.numExecutionSlotsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", randomForest0.debugTipText());
      assertEquals("The number of trees to be generated.", randomForest0.numTreesTipText());
      assertEquals(0, randomForest0.getNumFeatures());
      
      checkClassifier0.m_Classifier = (Classifier) randomForest0;
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(randomForest0.getDebug());
      assertEquals(1, randomForest0.getSeed());
      assertEquals("The maximum depth of the trees, 0 for unlimited.", randomForest0.maxDepthTipText());
      assertEquals(10, randomForest0.getNumTrees());
      assertEquals(0, randomForest0.getMaxDepth());
      assertEquals(1, randomForest0.getNumExecutionSlots());
      assertEquals(Double.NaN, randomForest0.measureOutOfBagError(), 0.01);
      assertFalse(randomForest0.getPrintTrees());
      assertEquals("Print the individual trees in the output", randomForest0.printTreesTipText());
      assertEquals("The number of attributes to be used in random selection (see RandomTree).", randomForest0.numFeaturesTipText());
      assertEquals("The random number seed to be used.", randomForest0.seedTipText());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", randomForest0.numExecutionSlotsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", randomForest0.debugTipText());
      assertEquals("The number of trees to be generated.", randomForest0.numTreesTipText());
      assertEquals(0, randomForest0.getNumFeatures());
      
      boolean[] booleanArray1 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray1);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      String[] stringArray0 = checkClassifier0.getOptions();
      assertNotNull(stringArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean[] booleanArray2 = checkClassifier0.declaresSerialVersionUID();
      assertNotNull(booleanArray2);
      assertNotSame(booleanArray2, booleanArray0);
      assertNotSame(booleanArray2, booleanArray1);
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray2));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean[] booleanArray3 = checkClassifier0.canHandleNClasses(false, false, true, false, false, true, (-1250));
      assertNotNull(booleanArray3);
      assertNotSame(booleanArray3, booleanArray2);
      assertNotSame(booleanArray3, booleanArray1);
      assertNotSame(booleanArray3, booleanArray0);
      assertFalse(booleanArray3.equals((Object)booleanArray2));
      assertFalse(booleanArray3.equals((Object)booleanArray1));
      assertFalse(booleanArray3.equals((Object)booleanArray0));
      assertTrue(Arrays.equals(new boolean[] {false, true}, booleanArray3));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      String[] stringArray1 = checkClassifier0.getOptions();
      assertNotNull(stringArray1);
      assertNotSame(stringArray1, stringArray0);
      assertFalse(stringArray1.equals((Object)stringArray0));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      checkClassifier0.setNumRelational(824);
      assertEquals(824, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(false, true, true, false, false, true, (-2705));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-2705' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      checkClassifier0.setNumInstances(0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      boolean[] booleanArray0 = checkClassifier0.canHandleNClasses(true, true, true, true, false, true, 0);
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, true}, booleanArray0));
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      Enumeration enumeration0 = checkClassifier0.listOptions();
      assertNotNull(enumeration0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      RandomForest randomForest0 = new RandomForest();
      assertNotNull(randomForest0);
      assertEquals(1, randomForest0.getNumExecutionSlots());
      assertEquals(1, randomForest0.getSeed());
      assertFalse(randomForest0.getDebug());
      assertEquals(Double.NaN, randomForest0.measureOutOfBagError(), 0.01);
      assertEquals(10, randomForest0.getNumTrees());
      assertEquals("The maximum depth of the trees, 0 for unlimited.", randomForest0.maxDepthTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", randomForest0.debugTipText());
      assertEquals(0, randomForest0.getMaxDepth());
      assertEquals("The number of trees to be generated.", randomForest0.numTreesTipText());
      assertEquals("The number of attributes to be used in random selection (see RandomTree).", randomForest0.numFeaturesTipText());
      assertFalse(randomForest0.getPrintTrees());
      assertEquals("The random number seed to be used.", randomForest0.seedTipText());
      assertEquals(0, randomForest0.getNumFeatures());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", randomForest0.numExecutionSlotsTipText());
      assertEquals("Print the individual trees in the output", randomForest0.printTreesTipText());
      
      checkClassifier0.m_Classifier = (Classifier) randomForest0;
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, randomForest0.getNumExecutionSlots());
      assertEquals(1, randomForest0.getSeed());
      assertFalse(randomForest0.getDebug());
      assertEquals(Double.NaN, randomForest0.measureOutOfBagError(), 0.01);
      assertEquals(10, randomForest0.getNumTrees());
      assertEquals("The maximum depth of the trees, 0 for unlimited.", randomForest0.maxDepthTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", randomForest0.debugTipText());
      assertEquals(0, randomForest0.getMaxDepth());
      assertEquals("The number of trees to be generated.", randomForest0.numTreesTipText());
      assertEquals("The number of attributes to be used in random selection (see RandomTree).", randomForest0.numFeaturesTipText());
      assertFalse(randomForest0.getPrintTrees());
      assertEquals("The random number seed to be used.", randomForest0.seedTipText());
      assertEquals(0, randomForest0.getNumFeatures());
      assertEquals("The number of execution slots (threads) to use for constructing the ensemble.", randomForest0.numExecutionSlotsTipText());
      assertEquals("Print the individual trees in the output", randomForest0.printTreesTipText());
      
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(true, false, true, false, true, false, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: weka.classifiers.trees.RandomTree: Cannot handle string attributes!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      
      CheckScheme.PostProcessor checkScheme_PostProcessor0 = new CheckScheme.PostProcessor();
      assertNotNull(checkScheme_PostProcessor0);
      
      checkClassifier0.setPostProcessor(checkScheme_PostProcessor0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      boolean boolean1 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(false, false, false, true, true, true, 1126);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '1126' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean boolean0 = false;
      checkClassifier0.setNumInstances(0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean boolean1 = true;
      boolean[] booleanArray0 = checkClassifier0.canHandleNClasses(false, true, true, true, true, true, 0);
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, true}, booleanArray0));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      WordTokenizer wordTokenizer0 = new WordTokenizer();
      assertNotNull(wordTokenizer0);
      assertEquals(" \r\n\t.,;:'\"()?!", wordTokenizer0.getDelimiters());
      assertEquals("Set of delimiter characters to use in tokenizing (\\r, \\n and \\t can be used for carriage-return, line-feed and tab)", wordTokenizer0.delimitersTipText());
      assertEquals("A simple tokenizer that is using the java.util.StringTokenizer class to tokenize the strings.", wordTokenizer0.globalInfo());
      
      boolean boolean2 = true;
      boolean boolean3 = false;
      boolean[] booleanArray1 = checkClassifier0.canHandleMissing(false, true, false, true, true, true, 0, false, false, 2416);
      assertNotNull(booleanArray1);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertTrue(Arrays.equals(new boolean[] {true, true}, booleanArray1));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean boolean4 = false;
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertNotNull(checkClassifier1);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertEquals(1, checkClassifier1.getNumString());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertEquals(1, checkClassifier1.getNumDate());
      assertFalse(checkClassifier1.getDebug());
      
      boolean boolean5 = false;
      boolean[] booleanArray2 = checkClassifier0.testToString();
      assertNotNull(booleanArray2);
      assertNotSame(checkClassifier0, checkClassifier1);
      assertNotSame(booleanArray2, booleanArray1);
      assertNotSame(booleanArray2, booleanArray0);
      assertFalse(checkClassifier0.equals((Object)checkClassifier1));
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray2));
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean[] booleanArray3 = checkClassifier1.instanceWeights(false, true, true, false, false, true, 0);
      assertNotNull(booleanArray3);
      assertNotSame(checkClassifier1, checkClassifier0);
      assertNotSame(booleanArray3, booleanArray1);
      assertNotSame(booleanArray3, booleanArray2);
      assertNotSame(booleanArray3, booleanArray0);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertFalse(booleanArray3.equals((Object)booleanArray1));
      assertFalse(booleanArray3.equals((Object)booleanArray2));
      assertFalse(booleanArray3.equals((Object)booleanArray0));
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray3));
      assertEquals(1, checkClassifier1.getNumString());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertEquals(1, checkClassifier1.getNumDate());
      assertFalse(checkClassifier1.getDebug());
      
      boolean[] booleanArray4 = checkClassifier1.canTakeOptions();
      assertNotNull(booleanArray4);
      assertNotSame(checkClassifier1, checkClassifier0);
      assertNotSame(booleanArray4, booleanArray2);
      assertNotSame(booleanArray4, booleanArray0);
      assertNotSame(booleanArray4, booleanArray1);
      assertNotSame(booleanArray4, booleanArray3);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertFalse(booleanArray4.equals((Object)booleanArray2));
      assertFalse(booleanArray4.equals((Object)booleanArray0));
      assertFalse(booleanArray4.equals((Object)booleanArray1));
      assertFalse(booleanArray4.equals((Object)booleanArray3));
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray4));
      assertEquals(1, checkClassifier1.getNumString());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertEquals(1, checkClassifier1.getNumDate());
      assertFalse(checkClassifier1.getDebug());
      
      int int0 = 723;
      // Undeclared exception!
      try { 
        checkClassifier1.datasetIntegrity(boolean1, boolean4, boolean2, boolean3, boolean0, boolean5, int0, boolean5, boolean0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '723' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      checkClassifier0.setNumInstances(0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      boolean[] booleanArray0 = checkClassifier0.canHandleNClasses(true, true, true, true, true, true, 0);
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, true}, booleanArray0));
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      Enumeration enumeration0 = checkClassifier0.listOptions();
      assertNotNull(enumeration0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      boolean[] booleanArray1 = checkClassifier0.instanceWeights(true, false, true, true, true, true, 0);
      assertNotNull(booleanArray1);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray1));
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      String[] stringArray0 = checkClassifier0.getOptions();
      assertNotNull(stringArray0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      boolean[] booleanArray2 = checkClassifier0.declaresSerialVersionUID();
      assertNotNull(booleanArray2);
      assertNotSame(booleanArray2, booleanArray1);
      assertNotSame(booleanArray2, booleanArray0);
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray2));
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean boolean0 = true;
      boolean boolean1 = false;
      int int0 = 0;
      checkClassifier0.setNumInstances(0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean[] booleanArray0 = checkClassifier0.canHandleNClasses(true, true, true, false, false, false, 0);
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, true}, booleanArray0));
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      
      ZeroR zeroR0 = (ZeroR)checkClassifier0.getClassifier();
      assertNotNull(zeroR0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(zeroR0.getDebug());
      assertEquals("Class for building and using a 0-R classifier. Predicts the mean (for a numeric class) or the mode (for a nominal class).", zeroR0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", zeroR0.debugTipText());
      
      boolean boolean2 = false;
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertNotNull(checkClassifier1);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      
      boolean boolean3 = false;
      checkClassifier1.setNumString(10);
      assertNotSame(checkClassifier1, checkClassifier0);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(10, checkClassifier1.getNumString());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      
      checkClassifier1.setDebug(false);
      assertNotSame(checkClassifier1, checkClassifier0);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(10, checkClassifier1.getNumString());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      
      boolean boolean4 = true;
      boolean[] booleanArray1 = checkClassifier1.instanceWeights(false, false, true, false, false, false, 0);
      assertNotNull(booleanArray1);
      assertNotSame(checkClassifier1, checkClassifier0);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(10, checkClassifier1.getNumString());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      
      // Undeclared exception!
      try { 
        checkClassifier1.setWords("&1:/4N}K1co9\u0006uv");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // At least 2 words must be provided!
         //
         verifyException("weka.core.CheckScheme", e);
      }
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean[] booleanArray0 = checkClassifier0.declaresSerialVersionUID();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      String[] stringArray0 = new String[1];
      stringArray0[0] = "ioS2O)bk";
      boolean[] booleanArray1 = checkClassifier0.testToString();
      assertNotNull(booleanArray1);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      checkClassifier0.setOptions(stringArray0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      checkClassifier0.testsPerClassType(2, false, false, false);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(true, false, false, true, true, false, 2);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: weka.classifiers.rules.ZeroR: Cannot handle string class!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      CheckClassifier.main((String[]) null);
      SGD sGD0 = new SGD();
      assertNotNull(sGD0);
      assertEquals(1, SGD.LOGLOSS);
      assertEquals(0, SGD.HINGE);
      assertEquals(2, SGD.SQUAREDLOSS);
      assertEquals("The learning rate. If normalization is turned off (as it is automatically for streaming data), thenthe default learning rate will need to be reduced (try 0.0001).", sGD0.learningRateTipText());
      assertEquals(1, sGD0.getSeed());
      assertEquals("The regularization constant. (default = 0.0001)", sGD0.lambdaTipText());
      assertEquals(0.01, sGD0.getLearningRate(), 0.01);
      assertEquals("Implements stochastic gradient descent for learning various linear models (binary class SVM, binary class logistic regression and linear regression). Globally replaces all missing values and transforms nominal attributes into binary ones. It also normalizes all attributes, so the coefficients in the output are based on the normalized data.\nFor numeric class attributes, the squared loss function (2) must be used.", sGD0.globalInfo());
      assertEquals("The loss function to use. Hinge loss (SVM), log loss (logistic regression) or squared loss (regression).", sGD0.lossFunctionTipText());
      assertFalse(sGD0.getDontReplaceMissing());
      assertFalse(sGD0.getDontNormalize());
      assertEquals("The random number seed to be used.", sGD0.seedTipText());
      assertEquals("Turn normalization off", sGD0.dontNormalizeTipText());
      assertEquals(500, sGD0.getEpochs());
      assertFalse(sGD0.getDebug());
      assertEquals(1.0E-4, sGD0.getLambda(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", sGD0.debugTipText());
      assertEquals("Turn off global replacement of missing values", sGD0.dontReplaceMissingTipText());
      assertEquals("The number of epochs to perform (batch learning). The total number of iterations is epochs * num instances.", sGD0.epochsTipText());
      
      sGD0.setLearningRate(0.0);
      assertEquals(1, SGD.LOGLOSS);
      assertEquals(0, SGD.HINGE);
      assertEquals(2, SGD.SQUAREDLOSS);
      assertEquals("The learning rate. If normalization is turned off (as it is automatically for streaming data), thenthe default learning rate will need to be reduced (try 0.0001).", sGD0.learningRateTipText());
      assertEquals(1, sGD0.getSeed());
      assertEquals("The regularization constant. (default = 0.0001)", sGD0.lambdaTipText());
      assertEquals("Implements stochastic gradient descent for learning various linear models (binary class SVM, binary class logistic regression and linear regression). Globally replaces all missing values and transforms nominal attributes into binary ones. It also normalizes all attributes, so the coefficients in the output are based on the normalized data.\nFor numeric class attributes, the squared loss function (2) must be used.", sGD0.globalInfo());
      assertEquals("The loss function to use. Hinge loss (SVM), log loss (logistic regression) or squared loss (regression).", sGD0.lossFunctionTipText());
      assertFalse(sGD0.getDontReplaceMissing());
      assertFalse(sGD0.getDontNormalize());
      assertEquals("The random number seed to be used.", sGD0.seedTipText());
      assertEquals("Turn normalization off", sGD0.dontNormalizeTipText());
      assertEquals(500, sGD0.getEpochs());
      assertFalse(sGD0.getDebug());
      assertEquals(0.0, sGD0.getLearningRate(), 0.01);
      assertEquals(1.0E-4, sGD0.getLambda(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", sGD0.debugTipText());
      assertEquals("Turn off global replacement of missing values", sGD0.dontReplaceMissingTipText());
      assertEquals("The number of epochs to perform (batch learning). The total number of iterations is epochs * num instances.", sGD0.epochsTipText());
      
      Classifier[] classifierArray0 = AbstractClassifier.makeCopies(sGD0, 1);
      assertNotNull(classifierArray0);
      assertEquals(1, SGD.LOGLOSS);
      assertEquals(0, SGD.HINGE);
      assertEquals(2, SGD.SQUAREDLOSS);
      assertEquals("The learning rate. If normalization is turned off (as it is automatically for streaming data), thenthe default learning rate will need to be reduced (try 0.0001).", sGD0.learningRateTipText());
      assertEquals(1, sGD0.getSeed());
      assertEquals("The regularization constant. (default = 0.0001)", sGD0.lambdaTipText());
      assertEquals("Implements stochastic gradient descent for learning various linear models (binary class SVM, binary class logistic regression and linear regression). Globally replaces all missing values and transforms nominal attributes into binary ones. It also normalizes all attributes, so the coefficients in the output are based on the normalized data.\nFor numeric class attributes, the squared loss function (2) must be used.", sGD0.globalInfo());
      assertEquals("The loss function to use. Hinge loss (SVM), log loss (logistic regression) or squared loss (regression).", sGD0.lossFunctionTipText());
      assertFalse(sGD0.getDontReplaceMissing());
      assertFalse(sGD0.getDontNormalize());
      assertEquals("The random number seed to be used.", sGD0.seedTipText());
      assertEquals("Turn normalization off", sGD0.dontNormalizeTipText());
      assertEquals(500, sGD0.getEpochs());
      assertFalse(sGD0.getDebug());
      assertEquals(0.0, sGD0.getLearningRate(), 0.01);
      assertEquals(1.0E-4, sGD0.getLambda(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", sGD0.debugTipText());
      assertEquals("Turn off global replacement of missing values", sGD0.dontReplaceMissingTipText());
      assertEquals("The number of epochs to perform (batch learning). The total number of iterations is epochs * num instances.", sGD0.epochsTipText());
      
      boolean boolean0 = true;
      boolean boolean1 = false;
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertNotNull(checkClassifier1);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumString());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumDate());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(1, checkClassifier1.getNumRelational());
      
      String string0 = sGD0.toString();
      assertEquals("SGD: No model built yet.\n", string0);
      assertNotNull(string0);
      assertEquals(1, SGD.LOGLOSS);
      assertEquals(0, SGD.HINGE);
      assertEquals(2, SGD.SQUAREDLOSS);
      assertEquals("The learning rate. If normalization is turned off (as it is automatically for streaming data), thenthe default learning rate will need to be reduced (try 0.0001).", sGD0.learningRateTipText());
      assertEquals(1, sGD0.getSeed());
      assertEquals("The regularization constant. (default = 0.0001)", sGD0.lambdaTipText());
      assertEquals("Implements stochastic gradient descent for learning various linear models (binary class SVM, binary class logistic regression and linear regression). Globally replaces all missing values and transforms nominal attributes into binary ones. It also normalizes all attributes, so the coefficients in the output are based on the normalized data.\nFor numeric class attributes, the squared loss function (2) must be used.", sGD0.globalInfo());
      assertEquals("The loss function to use. Hinge loss (SVM), log loss (logistic regression) or squared loss (regression).", sGD0.lossFunctionTipText());
      assertFalse(sGD0.getDontReplaceMissing());
      assertFalse(sGD0.getDontNormalize());
      assertEquals("The random number seed to be used.", sGD0.seedTipText());
      assertEquals("Turn normalization off", sGD0.dontNormalizeTipText());
      assertEquals(500, sGD0.getEpochs());
      assertFalse(sGD0.getDebug());
      assertEquals(0.0, sGD0.getLearningRate(), 0.01);
      assertEquals(1.0E-4, sGD0.getLambda(), 0.01);
      assertEquals("If set to true, classifier may output additional info to the console.", sGD0.debugTipText());
      assertEquals("Turn off global replacement of missing values", sGD0.dontReplaceMissingTipText());
      assertEquals("The number of epochs to perform (batch learning). The total number of iterations is epochs * num instances.", sGD0.epochsTipText());
      
      // Undeclared exception!
      try { 
        checkClassifier0.testsPerClassType(0, true, true, false);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Problem determining ZeroR performance: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      boolean boolean0 = false;
      checkClassifier0.setNumInstances(0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      boolean[] booleanArray0 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray0);
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      ZeroR zeroR0 = (ZeroR)checkClassifier0.getClassifier();
      assertNotNull(zeroR0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(0, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(zeroR0.getDebug());
      assertEquals("Class for building and using a 0-R classifier. Predicts the mean (for a numeric class) or the mode (for a nominal class).", zeroR0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", zeroR0.debugTipText());
      
      boolean boolean1 = false;
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertNotNull(checkClassifier1);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(1, checkClassifier1.getNumDate());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      
      boolean boolean2 = false;
      checkClassifier1.setDebug(false);
      assertNotSame(checkClassifier1, checkClassifier0);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(1, checkClassifier1.getNumDate());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      
      boolean[] booleanArray1 = checkClassifier1.canHandleMissing(false, false, false, false, false, false, 0, false, true, 0);
      assertNotNull(booleanArray1);
      assertNotSame(checkClassifier1, checkClassifier0);
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(1, checkClassifier1.getNumDate());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      
      boolean[] booleanArray2 = checkClassifier1.instanceWeights(false, false, true, false, false, false, 0);
      assertNotNull(booleanArray2);
      assertNotSame(checkClassifier1, checkClassifier0);
      assertNotSame(booleanArray2, booleanArray0);
      assertNotSame(booleanArray2, booleanArray1);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray2));
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(1, checkClassifier1.getNumDate());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      
      CheckClassifier checkClassifier2 = new CheckClassifier();
      assertNotNull(checkClassifier2);
      assertFalse(checkClassifier2.equals((Object)checkClassifier0));
      assertFalse(checkClassifier2.equals((Object)checkClassifier1));
      assertEquals(1, checkClassifier2.getNumString());
      assertFalse(checkClassifier2.hasClasspathProblems());
      assertEquals(1, checkClassifier2.getNumDate());
      assertFalse(checkClassifier2.getDebug());
      assertEquals(1, checkClassifier2.getNumNumeric());
      assertEquals(1, checkClassifier2.getNumRelational());
      assertEquals(2, checkClassifier2.getNumNominal());
      assertEquals(" ", checkClassifier2.getWordSeparators());
      assertEquals(20, checkClassifier2.getNumInstances());
      assertFalse(checkClassifier2.getSilent());
      assertEquals(10, checkClassifier2.getNumInstancesRelational());
      
      // Undeclared exception!
      try { 
        checkClassifier1.doTests();
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.setNumInstances(0);
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleMissing(true, true, false, false, true, false, (-1113), false, false, 100);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1113' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      String[] stringArray0 = new String[7];
      stringArray0[0] = "";
      stringArray0[1] = "k|";
      stringArray0[2] = "";
      SGD sGD0 = new SGD();
      sGD0.setLearningRate(1.1000000022351741);
      AbstractClassifier.makeCopies(sGD0, 1);
      CheckClassifier checkClassifier1 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier1.updatingEquality(true, true, true, false, true, true, 2315);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '2315' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.updateableClassifier();
      CheckClassifier.main((String[]) null);
      SGD sGD0 = new SGD();
      sGD0.setLearningRate(0.0);
      AbstractClassifier.makeCopies(sGD0, 1);
      CheckClassifier checkClassifier1 = new CheckClassifier();
      checkClassifier1.updatingEquality(true, true, true, true, false, true, 0);
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.updateableClassifier();
      CheckClassifier.main((String[]) null);
      SGD sGD0 = new SGD();
      CheckClassifier.main((String[]) null);
      SGD sGD1 = new SGD();
      sGD0.setLearningRate(2);
      SerializedClassifier serializedClassifier0 = new SerializedClassifier();
      AbstractClassifier.makeCopies(serializedClassifier0, 973);
      CheckClassifier checkClassifier1 = new CheckClassifier();
      sGD1.toString();
      checkClassifier1.correctBuildInitialisation(true, false, false, true, false, false, 2);
      CheckClassifier checkClassifier2 = new CheckClassifier();
      checkClassifier2.getOptions();
      CheckClassifier checkClassifier3 = new CheckClassifier();
      checkClassifier3.declaresSerialVersionUID();
      System.setCurrentTimeMillis(1);
  }

  @Test(timeout = 4000)
  public void test49()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.updateableClassifier();
      CheckClassifier.main((String[]) null);
      SGD sGD0 = new SGD();
      sGD0.setLearningRate(0.0);
      AbstractClassifier.makeCopies(sGD0, 1);
      CheckClassifier checkClassifier1 = new CheckClassifier();
      int int0 = 2;
      checkClassifier0.correctBuildInitialisation(false, false, false, false, false, false, 2);
      boolean boolean0 = false;
      int int1 = 3136;
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(false, false, false, false, false, false, 3136);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '3136' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test50()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      String[] stringArray0 = new String[7];
      stringArray0[0] = "";
      stringArray0[1] = "";
      stringArray0[2] = "";
      stringArray0[3] = "hA6fcWa{g";
      stringArray0[4] = "<o)EqMMa7rp";
      stringArray0[5] = "";
      stringArray0[6] = "\n=== Check on Classifier: ";
      CheckClassifier.main(stringArray0);
      SGD sGD0 = new SGD();
      sGD0.setLearningRate(0.0);
      AbstractClassifier.makeCopies(sGD0, 0);
      CheckClassifier checkClassifier1 = new CheckClassifier();
      sGD0.toString();
      checkClassifier0.correctBuildInitialisation(false, true, true, true, true, false, 1);
      CheckClassifier checkClassifier2 = new CheckClassifier();
      checkClassifier2.getOptions();
      checkClassifier0.declaresSerialVersionUID();
      System.setCurrentTimeMillis((-764));
  }

  @Test(timeout = 4000)
  public void test51()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.multiInstanceHandler();
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, (byte[]) null);
      boolean boolean0 = false;
      int int0 = 4;
      boolean boolean1 = true;
      boolean boolean2 = false;
      boolean boolean3 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleClassAsNthAttribute(false, false, true, false, false, true, 4, (-2705));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Index: -2705, Size: 1
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test52()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      boolean boolean0 = true;
      boolean boolean1 = true;
      boolean boolean2 = false;
      int int0 = 50;
      checkClassifier0.setNumInstances(50);
      checkClassifier0.canHandleNClasses(true, false, false, false, true, false, 500);
      checkClassifier0.getClassifier();
      CheckClassifier checkClassifier1 = new CheckClassifier();
      boolean boolean3 = false;
      checkClassifier0.setDebug(true);
      boolean boolean4 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(false, false, false, true, false, true, 50);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '50' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test53()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.multiInstanceHandler();
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/home/users/apanichella/wekafiles");
      FileSystemHandling.setPermissions(evoSuiteFile0, false, false, true);
      checkClassifier0.correctBuildInitialisation(false, true, false, false, true, false, 0);
      checkClassifier0.correctBuildInitialisation(false, true, true, true, false, false, 3);
      System.setCurrentTimeMillis(0);
      checkClassifier0.doTests();
  }

  @Test(timeout = 4000)
  public void test54()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.canHandleOnlyClass(true, true, true, true, false, 0);
      checkClassifier0.testToString();
      RandomForest randomForest0 = new RandomForest();
      CheckClassifier checkClassifier1 = new CheckClassifier();
      checkClassifier1.correctBuildInitialisation(false, false, false, false, false, false, 0);
      checkClassifier1.correctBuildInitialisation(true, false, false, false, false, false, 2);
      System.setCurrentTimeMillis(2);
      checkClassifier0.doTests();
  }

  @Test(timeout = 4000)
  public void test55()  throws Throwable  {
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "");
      CheckClassifier checkClassifier0 = new CheckClassifier();
      String[] stringArray0 = new String[8];
      stringArray0[0] = "";
      stringArray0[1] = "<o)EqMMa7rp";
      stringArray0[2] = "hA6fcWa{g";
      stringArray0[3] = "";
      stringArray0[4] = "";
      stringArray0[5] = "";
      stringArray0[6] = "\n=== Check on Classifier: ";
      stringArray0[7] = "";
      CheckClassifier.main(stringArray0);
      SGD sGD0 = new SGD();
      SGD sGD1 = new SGD();
      sGD1.setLearningRate(1.1000000022351741);
      AbstractClassifier.makeCopies(sGD1, 1);
      CheckClassifier checkClassifier1 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier1.updatingEquality(false, false, false, true, true, true, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test56()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      boolean boolean0 = true;
      boolean boolean1 = true;
      boolean boolean2 = false;
      checkClassifier0.canHandleOnlyClass(true, true, true, true, false, 0);
      checkClassifier0.testToString();
      checkClassifier0.datasetIntegrity(true, false, false, false, true, true, 0, false, false);
      boolean boolean3 = false;
      boolean boolean4 = true;
      boolean boolean5 = true;
      boolean boolean6 = false;
      int int0 = (-1300);
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(boolean3, boolean4, boolean2, boolean0, boolean5, boolean6, int0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1300' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test57()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.canHandleOnlyClass(true, true, true, true, false, 0);
      checkClassifier0.datasetIntegrity(false, true, false, false, false, false, 0, false, false);
      checkClassifier0.updatingEquality(false, true, false, false, true, false, 1);
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(false, true, false, false, true, false, (-823));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-823' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }
}
