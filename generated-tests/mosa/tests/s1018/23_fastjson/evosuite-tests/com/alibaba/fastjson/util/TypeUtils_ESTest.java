/*
 * This file was automatically generated by EvoSuite
 * Sat Jul 07 09:17:10 GMT 2018
 */

package com.alibaba.fastjson.util;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.MockitoExtension.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.PropertyNamingStrategy;
import com.alibaba.fastjson.TypeReference;
import com.alibaba.fastjson.annotation.JSONType;
import com.alibaba.fastjson.parser.ParserConfig;
import com.alibaba.fastjson.parser.deserializer.ASMDeserializerFactory;
import com.alibaba.fastjson.parser.deserializer.EnumDeserializer;
import com.alibaba.fastjson.parser.deserializer.JSONPDeserializer;
import com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer;
import com.alibaba.fastjson.parser.deserializer.JavaObjectDeserializer;
import com.alibaba.fastjson.parser.deserializer.Jdk8DateCodec;
import com.alibaba.fastjson.parser.deserializer.NumberDeserializer;
import com.alibaba.fastjson.parser.deserializer.ObjectDeserializer;
import com.alibaba.fastjson.parser.deserializer.SqlDateDeserializer;
import com.alibaba.fastjson.parser.deserializer.StackTraceElementDeserializer;
import com.alibaba.fastjson.parser.deserializer.ThrowableDeserializer;
import com.alibaba.fastjson.parser.deserializer.TimeDeserializer;
import com.alibaba.fastjson.serializer.JavaBeanSerializer;
import com.alibaba.fastjson.serializer.ObjectArrayCodec;
import com.alibaba.fastjson.serializer.SerializeBeanInfo;
import com.alibaba.fastjson.util.ASMClassLoader;
import com.alibaba.fastjson.util.FieldInfo;
import com.alibaba.fastjson.util.JavaBeanInfo;
import com.alibaba.fastjson.util.ParameterizedTypeImpl;
import com.alibaba.fastjson.util.TypeUtils;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.JobAttributes;
import java.awt.Point;
import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.HttpCookie;
import java.sql.BatchUpdateException;
import java.sql.DataTruncation;
import java.sql.Date;
import java.sql.SQLClientInfoException;
import java.sql.SQLDataException;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLIntegrityConstraintViolationException;
import java.sql.SQLInvalidAuthorizationSpecException;
import java.sql.SQLNonTransientConnectionException;
import java.sql.SQLNonTransientException;
import java.sql.SQLRecoverableException;
import java.sql.SQLSyntaxErrorException;
import java.sql.SQLTransactionRollbackException;
import java.sql.SQLTransientConnectionException;
import java.sql.SQLTransientException;
import java.sql.SQLWarning;
import java.sql.Time;
import java.sql.Timestamp;
import java.text.BreakIterator;
import java.text.ChoiceFormat;
import java.text.Collator;
import java.text.DateFormatSymbols;
import java.text.DecimalFormatSymbols;
import java.text.MessageFormat;
import java.text.RuleBasedCollator;
import java.text.SimpleDateFormat;
import java.text.StringCharacterIterator;
import java.time.ZoneId;
import java.time.chrono.ChronoLocalDate;
import java.util.Collection;
import java.util.Comparator;
import java.util.Currency;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.NavigableSet;
import java.util.Properties;
import java.util.SortedMap;
import java.util.TimeZone;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.WeakHashMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.LongBinaryOperator;
import java.util.function.LongUnaryOperator;
import java.util.function.ToDoubleFunction;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.lang.MockIllegalArgumentException;
import org.evosuite.runtime.mock.java.lang.MockThread;
import org.evosuite.runtime.mock.java.text.MockSimpleDateFormat;
import org.evosuite.runtime.mock.java.time.chrono.MockHijrahDate;
import org.evosuite.runtime.mock.java.time.chrono.MockJapaneseDate;
import org.evosuite.runtime.mock.java.time.chrono.MockThaiBuddhistDate;
import org.evosuite.runtime.mock.java.util.MockDate;
import org.evosuite.runtime.mock.java.util.MockGregorianCalendar;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class TypeUtils_ESTest extends TypeUtils_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test000()  throws Throwable  {
      Class<SQLNonTransientConnectionException> class0 = SQLNonTransientConnectionException.class;
      LinkedHashMap<String, Object> linkedHashMap0 = new LinkedHashMap<String, Object>();
      Class<SimpleDateFormat> class1 = SimpleDateFormat.class;
      ParserConfig parserConfig0 = new ParserConfig();
      // Undeclared exception!
      try { 
        TypeUtils.castToJavaBean((Map<String, Object>) linkedHashMap0, class1, parserConfig0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not get javaBeanDeserializer. java.text.SimpleDateFormat
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test001()  throws Throwable  {
      Class<InstantiationException> class0 = InstantiationException.class;
      TypeUtils.getSerializeFeatures(class0);
      TypeUtils.getGenericParamType(class0);
      MockJapaneseDate mockJapaneseDate0 = new MockJapaneseDate();
      Class<SqlDateDeserializer> class1 = SqlDateDeserializer.class;
      // Undeclared exception!
      try { 
        TypeUtils.castToJavaBean((Object) mockJapaneseDate0, class1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to : com.alibaba.fastjson.parser.deserializer.SqlDateDeserializer
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test002()  throws Throwable  {
      Class<EnumDeserializer> class0 = EnumDeserializer.class;
      TypeUtils typeUtils0 = new TypeUtils();
      TypeUtils.isGenericParamType(class0);
      TypeUtils.getCollectionItemType(class0);
      VerifyError verifyError0 = new VerifyError();
      Float float0 = new Float(0.0F);
      Integer integer0 = TypeUtils.castToInt(float0);
      assertEquals(0, (int)integer0);
  }

  @Test(timeout = 4000)
  public void test003()  throws Throwable  {
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "getiterator");
      StackOverflowError stackOverflowError0 = new StackOverflowError("getiterator");
      Class<Float> class0 = Float.TYPE;
      TypeUtils.isGenericParamType(class0);
      TypeUtils.getCollectionItemType(class0);
      VerifyError verifyError0 = new VerifyError();
      Float float0 = new Float((-1597.1003F));
      WeakHashMap<PropertyNamingStrategy, EnumDeserializer> weakHashMap0 = new WeakHashMap<PropertyNamingStrategy, EnumDeserializer>();
      // Undeclared exception!
      try { 
        TypeUtils.castToInt(weakHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to int, value : {}
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test004()  throws Throwable  {
      Class<?> class0 = TypeUtils.loadClass("Lorg.springframework.util.LinkedMultiValueMap");
      assertNull(class0);
  }

  @Test(timeout = 4000)
  public void test005()  throws Throwable  {
      TypeUtils.loadClass("timeInMillis", (ClassLoader) null, false);
      Type type0 = TypeUtils.unwrapOptional((Type) null);
      assertNull(type0);
  }

  @Test(timeout = 4000)
  public void test006()  throws Throwable  {
      DecimalFormatSymbols decimalFormatSymbols0 = DecimalFormatSymbols.getInstance();
      Currency currency0 = decimalFormatSymbols0.getCurrency();
      // Undeclared exception!
      try { 
        TypeUtils.castToShort(currency0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to short, value : XXX
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test007()  throws Throwable  {
      Class<SQLNonTransientConnectionException> class0 = SQLNonTransientConnectionException.class;
      List<FieldInfo> list0 = TypeUtils.computeGetters(class0, (Map<String, String>) null, true);
      assertEquals(7, list0.size());
  }

  @Test(timeout = 4000)
  public void test008()  throws Throwable  {
      Class<Jdk8DateCodec> class0 = Jdk8DateCodec.class;
      Map<String, String> map0 = new LinkedHashMap<String, String>();
      TypeUtils typeUtils0 = new TypeUtils();
      MockDate mockDate0 = new MockDate();
      List<FieldInfo> list0 = TypeUtils.computeGetters(class0, map0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test009()  throws Throwable  {
      TreeMap<String, Object> treeMap0 = new TreeMap<String, Object>();
      Class<Throwable> class0 = Throwable.class;
      TypeUtils.isPath(class0);
      TypeUtils.castToBigDecimal(treeMap0);
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.SnakeCase;
      JavaBeanInfo javaBeanInfo0 = JavaBeanInfo.build((Class<?>) class0, (Type) class0, propertyNamingStrategy0, false, false);
      ParserConfig.getGlobalInstance();
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      TypeUtils.loadClass("", classLoader0, false);
      TypeUtils.getClass((Type) javaBeanInfo0.clazz);
      Class<SqlDateDeserializer> class1 = SqlDateDeserializer.class;
      TypeUtils.isPath(class1);
      TypeUtils.getGenericParamType((Type) null);
      Class<Dimension> class2 = Dimension.class;
      // Undeclared exception!
      try { 
        TypeUtils.castToJavaBean((Object) classLoader0, class2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to : java.awt.Dimension
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test010()  throws Throwable  {
      Class<Jdk8DateCodec> class0 = Jdk8DateCodec.class;
      TypeUtils.isPath(class0);
      TypeUtils.castToBigDecimal((Object) null);
      LinkedHashMap<OutOfMemoryError, SQLWarning> linkedHashMap0 = new LinkedHashMap<OutOfMemoryError, SQLWarning>();
      OutOfMemoryError outOfMemoryError0 = new OutOfMemoryError("clazz is null");
      outOfMemoryError0.fillInStackTrace();
      SQLRecoverableException sQLRecoverableException0 = new SQLRecoverableException();
      SQLNonTransientConnectionException sQLNonTransientConnectionException0 = new SQLNonTransientConnectionException();
      // Undeclared exception!
      try { 
        TypeUtils.castToSqlDate(sQLNonTransientConnectionException0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to Date, value : java.sql.SQLNonTransientConnectionException
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test011()  throws Throwable  {
      Class<EnumDeserializer> class0 = EnumDeserializer.class;
      TypeUtils typeUtils0 = new TypeUtils();
      // Undeclared exception!
      try { 
        TypeUtils.castToDate(class0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to Date, value : class com.alibaba.fastjson.parser.deserializer.EnumDeserializer
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test012()  throws Throwable  {
      TypeUtils.isNumber("fil");
      Class<SQLNonTransientException> class0 = SQLNonTransientException.class;
      JSONType jSONType0 = mock(JSONType.class, new ViolatedAssumptionAnswer());
      Map<String, String> map0 = ZoneId.SHORT_IDS;
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.CamelCase;
      // Undeclared exception!
      try { 
        TypeUtils.computeGetters(class0, jSONType0, map0, (Map<String, Field>) null, false, propertyNamingStrategy0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
      }
  }

  @Test(timeout = 4000)
  public void test013()  throws Throwable  {
      TypeUtils.castToByte((Object) null);
      boolean boolean0 = TypeUtils.isNumber("Ljava.awt.Point");
      TypeUtils typeUtils0 = new TypeUtils();
      ParserConfig parserConfig0 = ParserConfig.global;
      parserConfig0.setAutoTypeSupport(true);
      parserConfig0.clearDeserializers();
      ParserConfig.getGlobalInstance();
      Class<OutOfMemoryError> class0 = OutOfMemoryError.class;
      boolean boolean1 = TypeUtils.isProxy(class0);
      assertTrue(boolean1 == boolean0);
      
      TypeUtils.loadClass("fastjson.parser.autoTypeSupport");
      TypeUtils.isPath(class0);
      Class<IllegalMonitorStateException> class1 = IllegalMonitorStateException.class;
      int int0 = TypeUtils.getParserFeatures(class1);
      assertEquals(0, int0);
      
      Class<Byte> class2 = Byte.class;
      List<FieldInfo> list0 = TypeUtils.computeGetters(class2, (Map<String, String>) null, false);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test014()  throws Throwable  {
      TypeUtils typeUtils0 = new TypeUtils();
      VerifyError verifyError0 = new VerifyError();
      SQLTransientException sQLTransientException0 = new SQLTransientException();
      verifyError0.initCause(sQLTransientException0);
      // Undeclared exception!
      try { 
        TypeUtils.castToSqlTime(verifyError0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to Date, value : java.lang.VerifyError
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test015()  throws Throwable  {
      Insets insets0 = new Insets((-4063), 8192, (-4063), (-4063));
      // Undeclared exception!
      try { 
        TypeUtils.castToLong(insets0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to long, value : java.awt.Insets[top=-4063,left=8192,bottom=-4063,right=-4063]
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test016()  throws Throwable  {
      Class<Object> class0 = Object.class;
      TypeUtils.computeGetters(class0, (Map<String, String>) null, false);
      Class<SQLNonTransientConnectionException> class1 = SQLNonTransientConnectionException.class;
      TypeUtils.isProxy(class1);
      TypeUtils.isPath(class0);
      String string0 = "Q;ZC2XLk";
      TypeUtils.loadClass("Q;ZC2XLk");
      TypeUtils.getParserFeatures(class0);
      // Undeclared exception!
      try { 
        TypeUtils.castToByte("Q;ZC2XLk");
        fail("Expecting exception: NumberFormatException");
      
      } catch(NumberFormatException e) {
         //
         // For input string: \"Q;ZC2XLk\"
         //
         verifyException("java.lang.NumberFormatException", e);
      }
  }

  @Test(timeout = 4000)
  public void test017()  throws Throwable  {
      JavaObjectDeserializer javaObjectDeserializer0 = new JavaObjectDeserializer();
      Class<BreakIterator> class0 = BreakIterator.class;
      TypeUtils.getParserFeatures(class0);
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.KebabCase;
      List<FieldInfo> list0 = TypeUtils.computeGettersWithFieldBase(class0, weakHashMap0, false, propertyNamingStrategy0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test018()  throws Throwable  {
      Class<BreakIterator> class0 = BreakIterator.class;
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      Class<ClassLoader> class1 = ClassLoader.class;
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.PascalCase;
      TypeUtils.computeGettersWithFieldBase(class1, weakHashMap0, false, propertyNamingStrategy0);
      StringCharacterIterator stringCharacterIterator0 = new StringCharacterIterator("!X\"NFaL$Xqp#*'");
      TreeSet<ChronoLocalDate> treeSet0 = new TreeSet<ChronoLocalDate>();
      // Undeclared exception!
      try { 
        TypeUtils.castToDouble(treeSet0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to double, value : []
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test019()  throws Throwable  {
      TreeMap<String, Object> treeMap0 = new TreeMap<String, Object>();
      TypeUtils.castToBigDecimal(treeMap0);
      LinkedHashMap<OutOfMemoryError, SQLWarning> linkedHashMap0 = new LinkedHashMap<OutOfMemoryError, SQLWarning>();
      // Undeclared exception!
      try { 
        TypeUtils.castToByte(linkedHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to byte, value : {}
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test020()  throws Throwable  {
      Class<MockJapaneseDate> class0 = MockJapaneseDate.class;
      TypeUtils.isPath(class0);
      Class<SecurityException> class1 = SecurityException.class;
      Class<?> class2 = TypeUtils.getClass((Type) class1);
      Class<TimeZone> class3 = TimeZone.class;
      TypeUtils.isPath(class3);
      TypeUtils.getGenericParamType(class2);
      // Undeclared exception!
      try { 
        TypeUtils.createCollection(class0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // create instance error, class org.evosuite.runtime.mock.java.time.chrono.MockJapaneseDate
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test021()  throws Throwable  {
      Class<MockJapaneseDate> class0 = MockJapaneseDate.class;
      // Undeclared exception!
      try { 
        TypeUtils.castToBigDecimal(class0);
        fail("Expecting exception: NumberFormatException");
      
      } catch(NumberFormatException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.math.BigDecimal", e);
      }
  }

  @Test(timeout = 4000)
  public void test022()  throws Throwable  {
      TypeUtils.fnv1a_64_lower("CYG$.");
      // Undeclared exception!
      try { 
        TypeUtils.castToShort("CYG$.");
        fail("Expecting exception: NumberFormatException");
      
      } catch(NumberFormatException e) {
         //
         // For input string: \"CYG$.\"
         //
         verifyException("java.lang.NumberFormatException", e);
      }
  }

  @Test(timeout = 4000)
  public void test023()  throws Throwable  {
      Class<IndexOutOfBoundsException> class0 = IndexOutOfBoundsException.class;
      TypeUtils.isPath(class0);
      String string0 = "4=~<ub)>4/(1Bx2[<YT";
      TypeUtils.fnv1a_64_lower("4=~<ub)>4/(1Bx2[<YT");
      Class<SQLNonTransientConnectionException> class1 = SQLNonTransientConnectionException.class;
      TypeUtils.isProxy(class1);
      TypeUtils.loadClass(";ZC2XLk");
      // Undeclared exception!
      try { 
        TypeUtils.isPath((Class<?>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.lang.Class", e);
      }
  }

  @Test(timeout = 4000)
  public void test024()  throws Throwable  {
      MockThread mockThread0 = new MockThread((ThreadGroup) null, (Runnable) null);
      MockThread mockThread1 = new MockThread(mockThread0, "Ljava.awt.Rectangle");
      ClassLoader classLoader0 = mockThread1.getContextClassLoader();
      TypeUtils.loadClass("I", classLoader0);
      long long0 = TypeUtils.fnv1a_64("I");
      assertEquals((-5808512892688781180L), long0);
  }

  @Test(timeout = 4000)
  public void test025()  throws Throwable  {
      Class<String> class0 = String.class;
      boolean boolean0 = TypeUtils.compatibleWithFieldName;
      TypeUtils.unwrapOptional(class0);
      TreeMap<String, TimeDeserializer> treeMap0 = new TreeMap<String, TimeDeserializer>();
      TreeMap<String, Object> treeMap1 = new TreeMap<String, Object>((SortedMap<String, ?>) treeMap0);
      ParserConfig parserConfig0 = ParserConfig.getGlobalInstance();
      Class<GridBagConstraints> class1 = GridBagConstraints.class;
      // Undeclared exception!
      try { 
        TypeUtils.castToEnum((Object) treeMap1, class1, parserConfig0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to : java.awt.GridBagConstraints
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test026()  throws Throwable  {
      Class<MockThaiBuddhistDate> class0 = MockThaiBuddhistDate.class;
      TypeUtils.getSerializeFeatures(class0);
      TypeUtils.getGenericParamType(class0);
      MockJapaneseDate mockJapaneseDate0 = new MockJapaneseDate();
      NoSuchMethodException noSuchMethodException0 = new NoSuchMethodException();
      // Undeclared exception!
      try { 
        TypeUtils.castToChar(noSuchMethodException0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to char, value : java.lang.NoSuchMethodException
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test027()  throws Throwable  {
      Class<MockJapaneseDate> class0 = MockJapaneseDate.class;
      GenericArrayType genericArrayType0 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(genericArrayType0).toString();
      doReturn((Type) null).when(genericArrayType0).getGenericComponentType();
      TypeUtils.checkPrimitiveArray(genericArrayType0);
      TypeUtils.getClass((Type) class0);
      SQLSyntaxErrorException sQLSyntaxErrorException0 = new SQLSyntaxErrorException("Hai/nt#!5P'", ">wny4Y$n[2");
      SQLNonTransientConnectionException sQLNonTransientConnectionException0 = new SQLNonTransientConnectionException("@Ej[[=d`", "ord", (-3604));
      sQLNonTransientConnectionException0.getSuppressed();
      SecurityException securityException0 = new SecurityException("@Ej[[=d`", sQLNonTransientConnectionException0);
      StackOverflowError stackOverflowError0 = new StackOverflowError("ord");
      GenericArrayType genericArrayType1 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(genericArrayType1).toString();
      doReturn((Type) null).when(genericArrayType1).getGenericComponentType();
      TypeUtils.checkPrimitiveArray(genericArrayType1);
      ParserConfig parserConfig0 = new ParserConfig(true);
      WeakHashMap<MockSimpleDateFormat, Dimension> weakHashMap0 = new WeakHashMap<MockSimpleDateFormat, Dimension>();
      String string0 = TypeUtils.castToString(weakHashMap0);
      assertNotNull(string0);
  }

  @Test(timeout = 4000)
  public void test028()  throws Throwable  {
      Class<Byte> class0 = Byte.TYPE;
      TypeUtils.getCollectionItemClass(class0);
      TypeUtils typeUtils0 = new TypeUtils();
      System.setCurrentTimeMillis(2664L);
  }

  @Test(timeout = 4000)
  public void test029()  throws Throwable  {
      Class<MockJapaneseDate> class0 = MockJapaneseDate.class;
      TypeUtils.isProxy(class0);
      LinkedList<FieldInfo> linkedList0 = new LinkedList<FieldInfo>();
      linkedList0.add((FieldInfo) null);
      VerifyError verifyError0 = new VerifyError("");
      IndexOutOfBoundsException indexOutOfBoundsException0 = new IndexOutOfBoundsException("");
      SQLRecoverableException sQLRecoverableException0 = new SQLRecoverableException();
      ParserConfig parserConfig0 = new ParserConfig(false);
      // Undeclared exception!
      try { 
        TypeUtils.cast((Object) linkedList0, (Type) class0, parserConfig0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to : org.evosuite.runtime.mock.java.time.chrono.MockJapaneseDate
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test030()  throws Throwable  {
      TimeDeserializer timeDeserializer0 = TimeDeserializer.instance;
      Class<Byte> class0 = Byte.TYPE;
      Class<?> class1 = TypeUtils.getClass((Type) class0);
      Class<?> class2 = TypeUtils.getCollectionItemClass(class1);
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      ASMDeserializerFactory aSMDeserializerFactory0 = new ASMDeserializerFactory(classLoader0);
      ParserConfig parserConfig0 = new ParserConfig(aSMDeserializerFactory0);
      TypeUtils.cast((Object) timeDeserializer0, (Type) class2, parserConfig0);
      String string0 = "/**/";
      IllegalThreadStateException illegalThreadStateException0 = new IllegalThreadStateException("/**/");
      TypeUtils.castToString(illegalThreadStateException0);
      TypeUtils.castToString(class2);
      GenericArrayType genericArrayType0 = null;
      // Undeclared exception!
      try { 
        TypeUtils.checkPrimitiveArray((GenericArrayType) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test031()  throws Throwable  {
      TreeMap<String, String> treeMap0 = new TreeMap<String, String>();
      Class<IllegalStateException> class0 = IllegalStateException.class;
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.PascalCase;
      TypeUtils.computeGettersWithFieldBase(class0, treeMap0, true, propertyNamingStrategy0);
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      // Undeclared exception!
      try { 
        TypeUtils.loadClass("[h>n*p;", classLoader0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.lang.reflect.Array", e);
      }
  }

  @Test(timeout = 4000)
  public void test032()  throws Throwable  {
      Class<MockThaiBuddhistDate> class0 = MockThaiBuddhistDate.class;
      TypeUtils.getSerializeFeatures(class0);
      TypeUtils.getGenericParamType(class0);
      MockJapaneseDate mockJapaneseDate0 = new MockJapaneseDate();
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      WeakHashMap<String, String> weakHashMap1 = new WeakHashMap<String, String>();
      weakHashMap1.put("1b/A}EsW\"j-3)", "Ox^/[6n");
      Short short0 = new Short((short)1464);
      OutOfMemoryError outOfMemoryError0 = new OutOfMemoryError();
      // Undeclared exception!
      try { 
        TypeUtils.castToInt(outOfMemoryError0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to int, value : java.lang.OutOfMemoryError
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test033()  throws Throwable  {
      TypeUtils.fnv1a_64("timezoneOffset");
      TypeUtils.loadClass("q4uUv1H]?\"f;", (ClassLoader) null, false);
      ParserConfig parserConfig0 = new ParserConfig((ClassLoader) null);
      HashMap<String, Field> hashMap0 = new HashMap<String, Field>();
      ParserConfig.getFieldFromCache("fastjson.parser.autoTypeAccept", hashMap0);
      parserConfig0.setAsmEnable(false);
      TypeUtils.cast((Object) null, (Type) null, parserConfig0);
      TypeUtils.decapitalize("{[1,d4lvKhtFH~");
      StringIndexOutOfBoundsException stringIndexOutOfBoundsException0 = new StringIndexOutOfBoundsException("Ljava.util.concurrent.ConcurrentSkipListMap");
      // Undeclared exception!
      try { 
        TypeUtils.castToBytes(stringIndexOutOfBoundsException0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to int, value : java.lang.StringIndexOutOfBoundsException: Ljava.util.concurrent.ConcurrentSkipListMap
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test034()  throws Throwable  {
      TypeUtils typeUtils0 = new TypeUtils();
      JSON.DEFFAULT_DATE_FORMAT = "BrowserCompatible";
      GenericArrayType genericArrayType0 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(genericArrayType0).toString();
      doReturn((Type) null).when(genericArrayType0).getGenericComponentType();
      TypeUtils.checkPrimitiveArray(genericArrayType0);
      // Undeclared exception!
      try { 
        TypeUtils.castToBytes(typeUtils0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to int, value : com.alibaba.fastjson.util.TypeUtils@1
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test035()  throws Throwable  {
      Class<SQLRecoverableException> class0 = SQLRecoverableException.class;
      TypeUtils.getKoltinConstructorParameters(class0);
      Class<SQLNonTransientConnectionException> class1 = SQLNonTransientConnectionException.class;
      TypeUtils.getKoltinConstructorParameters(class1);
      boolean boolean0 = TypeUtils.isHibernateInitialized(class1);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test036()  throws Throwable  {
      Class<Point> class0 = Point.class;
      Hashtable<String, String> hashtable0 = new Hashtable<String, String>();
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.SnakeCase;
      TypeUtils.buildBeanInfo((Class<?>) class0, (Map<String, String>) hashtable0, propertyNamingStrategy0, false);
      // Undeclared exception!
      try { 
        TypeUtils.castToSqlTime(hashtable0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to Date, value : {}
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test037()  throws Throwable  {
      Class<InstantiationException> class0 = InstantiationException.class;
      TypeUtils.getSerializeFeatures(class0);
      MockJapaneseDate mockJapaneseDate0 = new MockJapaneseDate();
      NoSuchMethodException noSuchMethodException0 = new NoSuchMethodException(", class ");
      java.util.IdentityHashMap<String, String> identityHashMap0 = new java.util.IdentityHashMap<String, String>();
      identityHashMap0.put(", class ", ", class ");
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.PascalCase;
      SerializeBeanInfo serializeBeanInfo0 = TypeUtils.buildBeanInfo((Class<?>) class0, (Map<String, String>) identityHashMap0, propertyNamingStrategy0);
      assertNotNull(serializeBeanInfo0);
  }

  @Test(timeout = 4000)
  public void test038()  throws Throwable  {
      TypeUtils.isAnnotationPresentManyToMany((Method) null);
      TypeUtils.loadClass("");
      TreeMap<String, Field> treeMap0 = new TreeMap<String, Field>((Comparator<? super String>) null);
      HashMap<String, Field> hashMap0 = new HashMap<String, Field>();
      TypeUtils.loadClass("}&UEBH~$%KyCGOg7Uwk", (ClassLoader) null);
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      TypeUtils.castToDate("");
      TypeUtils.castToInt((Object) null);
      Class class0 = (Class)TypeUtils.getCollectionItemType((Type) null);
      assertEquals("class java.lang.Object", class0.toString());
  }

  @Test(timeout = 4000)
  public void test039()  throws Throwable  {
      Class<DateFormatSymbols> class0 = DateFormatSymbols.class;
      TypeUtils.isPath(class0);
      TypeUtils.fnv1a_64_lower("Qj");
      ParserConfig parserConfig0 = ParserConfig.global;
      parserConfig0.setAutoTypeSupport(false);
      parserConfig0.clearDeserializers();
      parserConfig0.addDeny("4=~<ub)>4/(1Bx2[<YT");
      Properties properties0 = new Properties();
      parserConfig0.configFromPropety(properties0);
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.SnakeCase;
      propertyNamingStrategy0.translate("KqZ");
      Class<String> class1 = String.class;
      TypeUtils.cast((Object) null, class1, parserConfig0);
      TreeMap<StackTraceElement, SQLException> treeMap0 = new TreeMap<StackTraceElement, SQLException>();
      Class<Time> class2 = Time.class;
      // Undeclared exception!
      try { 
        TypeUtils.castToEnum((Object) treeMap0, class2, parserConfig0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to : java.sql.Time
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test040()  throws Throwable  {
      Class<PropertyNamingStrategy> class0 = PropertyNamingStrategy.class;
      TypeUtils.getKoltinConstructorParameters(class0);
      Class<Boolean> class1 = Boolean.class;
      TypeUtils.isProxy(class1);
      TypeUtils.getClassFromMapping("");
      TypeUtils.isGenericParamType(class0);
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      ParserConfig parserConfig0 = ParserConfig.global;
      TypeUtils.loadClass("fastjson.parser.autoTypeSupport", classLoader0);
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      OutOfMemoryError outOfMemoryError0 = new OutOfMemoryError("");
      outOfMemoryError0.fillInStackTrace();
      SQLRecoverableException sQLRecoverableException0 = new SQLRecoverableException();
      Date date0 = TypeUtils.castToSqlDate((Object) null);
      assertNull(date0);
  }

  @Test(timeout = 4000)
  public void test041()  throws Throwable  {
      Class<IndexOutOfBoundsException> class0 = IndexOutOfBoundsException.class;
      TypeUtils.isPath(class0);
      TypeUtils.fnv1a_64_lower("4=~<ub)>4/(1Bx2[<YT");
      Class<Time> class1 = Time.class;
      ParserConfig parserConfig0 = ParserConfig.global;
      parserConfig0.setAutoTypeSupport(false);
      parserConfig0.clearDeserializers();
      parserConfig0.addDeny(";wO*rqyzb[bUbLj+");
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.KebabCase;
      parserConfig0.propertyNamingStrategy = propertyNamingStrategy0;
      ConcurrentHashMap<String, Field> concurrentHashMap0 = new ConcurrentHashMap<String, Field>();
      ParserConfig.getFieldFromCache(";wO*rqyzb[bUbLj+", concurrentHashMap0);
      ParserConfig parserConfig1 = ParserConfig.getGlobalInstance();
      parserConfig1.setAsmEnable(true);
      MockHijrahDate mockHijrahDate0 = new MockHijrahDate();
      BreakIterator breakIterator0 = BreakIterator.getCharacterInstance();
      // Undeclared exception!
      try { 
        TypeUtils.cast((Object) breakIterator0, (Type) class1, parserConfig1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to Date, value : [checksum=0x480651ac]
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test042()  throws Throwable  {
      TreeMap<String, Object> treeMap0 = new TreeMap<String, Object>();
      Class<Throwable> class0 = Throwable.class;
      TypeUtils.isPath(class0);
      TypeUtils.castToBigDecimal(treeMap0);
      LinkedHashMap<OutOfMemoryError, SQLWarning> linkedHashMap0 = new LinkedHashMap<OutOfMemoryError, SQLWarning>();
      HashMap<String, Field> hashMap0 = new HashMap<String, Field>();
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      TypeUtils.castToDate((Object) null);
      Time time0 = TypeUtils.castToSqlTime((Object) null);
      assertNull(time0);
  }

  @Test(timeout = 4000)
  public void test043()  throws Throwable  {
      Class<Byte> class0 = Byte.TYPE;
      Class<MockSimpleDateFormat> class1 = MockSimpleDateFormat.class;
      TypeUtils.isProxy(class1);
      TypeUtils.castToInt((Object) null);
      // Undeclared exception!
      try { 
        TypeUtils.createCollection(class0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // create instance error, class byte
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test044()  throws Throwable  {
      AtomicLong atomicLong0 = new AtomicLong(0L);
      Class<ChronoLocalDate> class0 = ChronoLocalDate.class;
      ParserConfig parserConfig0 = ParserConfig.global;
      LongUnaryOperator longUnaryOperator0 = mock(LongUnaryOperator.class, new ViolatedAssumptionAnswer());
      doReturn(0L).when(longUnaryOperator0).applyAsLong(anyLong());
      atomicLong0.getAndUpdate(longUnaryOperator0);
      Hashtable<String, Field> hashtable0 = new Hashtable<String, Field>();
      LongUnaryOperator longUnaryOperator1 = mock(LongUnaryOperator.class, new ViolatedAssumptionAnswer());
      doReturn(0L).when(longUnaryOperator1).applyAsLong(anyLong());
      LongBinaryOperator longBinaryOperator0 = mock(LongBinaryOperator.class, new ViolatedAssumptionAnswer());
      doReturn(0L).when(longBinaryOperator0).applyAsLong(anyLong() , anyLong());
      atomicLong0.accumulateAndGet(0L, longBinaryOperator0);
      atomicLong0.getAndUpdate(longUnaryOperator1);
      parserConfig0.addAccept("has");
      atomicLong0.set(0L);
      atomicLong0.weakCompareAndSet(0L, 0L);
      ParserConfig.getFieldFromCache("fastjson.parser.deny", hashtable0);
      ParserConfig.parserAllFieldToCache(class0, hashtable0);
      // Undeclared exception!
      try { 
        TypeUtils.castToEnum((Object) atomicLong0, class0, parserConfig0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to : java.time.chrono.ChronoLocalDate
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test045()  throws Throwable  {
      Class<Jdk8DateCodec> class0 = Jdk8DateCodec.class;
      Map<String, String> map0 = ZoneId.SHORT_IDS;
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.SnakeCase;
      TypeUtils.computeGettersWithFieldBase(class0, map0, true, propertyNamingStrategy0);
      TypeUtils.isNumber("Ljava.awt.Rectangle");
      ClassLoader.getSystemClassLoader();
      Short short0 = new Short((short) (-897));
      MessageFormat messageFormat0 = new MessageFormat("__STATIC_RESET");
      // Undeclared exception!
      try { 
        TypeUtils.castToInt("__STATIC_RESET");
        fail("Expecting exception: NumberFormatException");
      
      } catch(NumberFormatException e) {
         //
         // For input string: \"__STATIC_RESET\"
         //
         verifyException("java.lang.NumberFormatException", e);
      }
  }

  @Test(timeout = 4000)
  public void test046()  throws Throwable  {
      Class<String> class0 = String.class;
      TypeUtils.isKotlin(class0);
      TypeUtils.unwrapOptional(class0);
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      ClassLoader classLoader1 = classLoader0.getParent();
      TypeUtils.loadClass("java.io.Serializable", classLoader1);
      Short short0 = new Short((short)1244);
      ConcurrentHashMap<String, Field> concurrentHashMap0 = new ConcurrentHashMap<String, Field>();
      Class<SQLTransientException> class1 = SQLTransientException.class;
      JSONType jSONType0 = mock(JSONType.class, new ViolatedAssumptionAnswer());
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.CamelCase;
      TypeUtils.computeGetters((Class<?>) class1, jSONType0, (Map<String, String>) hashMap0, (Map<String, Field>) concurrentHashMap0, false, propertyNamingStrategy0);
      VerifyError verifyError0 = new VerifyError("N");
      Locale locale0 = Locale.CHINESE;
      MessageFormat messageFormat0 = new MessageFormat("%=EcR<SA;)!VE0\"s2R", locale0);
      // Undeclared exception!
      try { 
        TypeUtils.castToBigInteger(messageFormat0);
        fail("Expecting exception: NumberFormatException");
      
      } catch(NumberFormatException e) {
         //
         // For input string: \"java.te\"
         //
         verifyException("java.lang.NumberFormatException", e);
      }
  }

  @Test(timeout = 4000)
  public void test047()  throws Throwable  {
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "char");
      LinkedHashMap<OutOfMemoryError, SQLWarning> linkedHashMap0 = new LinkedHashMap<OutOfMemoryError, SQLWarning>();
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      ASMDeserializerFactory aSMDeserializerFactory0 = new ASMDeserializerFactory(classLoader0);
      ParserConfig parserConfig0 = new ParserConfig(aSMDeserializerFactory0.classLoader);
      Class<InstantiationError> class0 = InstantiationError.class;
      JavaBeanInfo javaBeanInfo0 = JavaBeanInfo.build((Class<?>) class0, (Type) class0, (PropertyNamingStrategy) null);
      aSMDeserializerFactory0.createJavaBeanDeserializer(parserConfig0, javaBeanInfo0);
      ParserConfig parserConfig1 = new ParserConfig(aSMDeserializerFactory0);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "fastjson.parser.autoTypeSupport");
      TypeUtils.fnv1a_64("");
      TreeMap<String, String> treeMap0 = new TreeMap<String, String>();
      Class<NumberFormatException> class1 = NumberFormatException.class;
      TypeUtils.computeGetters((Class<?>) class1, (Map<String, String>) treeMap0, true);
      // Undeclared exception!
      try { 
        TypeUtils.castToSqlTime(class1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to Date, value : class java.lang.NumberFormatException
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test048()  throws Throwable  {
      JSONObject jSONObject0 = new JSONObject();
      MockThread mockThread0 = new MockThread();
      ClassLoader classLoader0 = mockThread0.getContextClassLoader();
      ClassLoader classLoader1 = classLoader0.getParent();
      ParserConfig parserConfig0 = new ParserConfig(classLoader1);
      ObjectArrayCodec objectArrayCodec0 = ObjectArrayCodec.instance;
      ThreadGroup threadGroup0 = new ThreadGroup("fastjson.parser.autoTypeSupport");
      ThreadGroup threadGroup1 = new ThreadGroup(threadGroup0, "fastjson.parser.deny");
      ClassLoader classLoader2 = mockThread0.getContextClassLoader();
      ClassLoader classLoader3 = mockThread0.getContextClassLoader();
      classLoader2.setDefaultAssertionStatus(true);
      MockThread mockThread1 = new MockThread(threadGroup1, mockThread0, "fastjson.parser.autoTypeAccept");
      mockThread1.run();
      ClassLoader classLoader4 = classLoader2.getParent();
      classLoader2.setClassAssertionStatus("getgetFastMatchToken", true);
      TypeUtils.loadClass("fastjson.parser.deny", classLoader4);
      Short short0 = new Short((short)25);
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      weakHashMap0.put("fastjson.parser.autoTypeSupport", "fastjson.parser.autoTypeAccept");
      Class<MockGregorianCalendar> class0 = MockGregorianCalendar.class;
      TypeUtils.computeGetters((Class<?>) class0, (Map<String, String>) weakHashMap0);
      Short short1 = new Short((short)25);
      Class<ThrowableDeserializer> class1 = ThrowableDeserializer.class;
      TypeUtils.isProxy(class1);
      Class<?> class2 = TypeUtils.getClass((Type) class1);
      Type[] typeArray0 = new Type[0];
      ParameterizedTypeImpl parameterizedTypeImpl0 = new ParameterizedTypeImpl(typeArray0, class2, (Type) null);
      // Undeclared exception!
      try { 
        TypeUtils.cast((Object) classLoader3, (ParameterizedType) parameterizedTypeImpl0, parserConfig0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to : com.alibaba.fastjson.util.ParameterizedTypeImpl@1629
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test049()  throws Throwable  {
      Class<ParameterizedTypeImpl> class0 = ParameterizedTypeImpl.class;
      ConcurrentHashMap<String, String> concurrentHashMap0 = new ConcurrentHashMap<String, String>();
      ConcurrentHashMap<String, String> concurrentHashMap1 = new ConcurrentHashMap<String, String>();
      Function<String, StackTraceElementDeserializer> function0 = (Function<String, StackTraceElementDeserializer>) mock(Function.class, new ViolatedAssumptionAnswer());
      BiFunction<StackTraceElementDeserializer, Object, StackTraceElementDeserializer> biFunction0 = (BiFunction<StackTraceElementDeserializer, Object, StackTraceElementDeserializer>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      concurrentHashMap0.reduceKeys(127L, (Function<? super String, ? extends StackTraceElementDeserializer>) function0, (BiFunction<? super StackTraceElementDeserializer, ? super StackTraceElementDeserializer, ? extends StackTraceElementDeserializer>) biFunction0);
      concurrentHashMap0.putAll(concurrentHashMap1);
      BiFunction<String, String, Float> biFunction1 = (BiFunction<String, String, Float>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      BiFunction<Float, Object, Float> biFunction2 = (BiFunction<Float, Object, Float>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      concurrentHashMap0.reduce(127L, (BiFunction<? super String, ? super String, ? extends Float>) biFunction1, (BiFunction<? super Float, ? super Float, ? extends Float>) biFunction2);
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(45, (-1133), 45, 45, 45);
      concurrentHashMap0.remove((Object) mockGregorianCalendar0, (Object) class0);
      TypeUtils.computeGetters((Class<?>) class0, (Map<String, String>) concurrentHashMap0, true);
      Class<Annotation> class1 = Annotation.class;
      TypeUtils.getAnnotation((Class<?>) class0, class1);
      Type[] typeArray0 = new Type[6];
      typeArray0[0] = (Type) class1;
      typeArray0[1] = (Type) class1;
      typeArray0[2] = (Type) class1;
      Class<Integer> class2 = Integer.TYPE;
      typeArray0[3] = (Type) class2;
      typeArray0[4] = (Type) class1;
      typeArray0[5] = (Type) class0;
      Class<?> class3 = TypeUtils.getRawClass(typeArray0[0]);
      ParameterizedTypeImpl parameterizedTypeImpl0 = new ParameterizedTypeImpl(typeArray0, class3, class0);
      ParserConfig parserConfig0 = new ParserConfig();
      TypeUtils.cast((Object) concurrentHashMap1, (ParameterizedType) parameterizedTypeImpl0, parserConfig0);
      TypeUtils.loadClass("fastjson.parser.autoTypeAccept");
      TypeUtils.castToSqlDate((Object) null);
      TypeUtils.toLocale("fastjson.parser.autoTypeSupport");
      AtomicInteger atomicInteger0 = new AtomicInteger((-1133));
      atomicInteger0.getAndAdd((-1133));
      TypeUtils.castToShort(atomicInteger0);
      Timestamp timestamp0 = TypeUtils.castToTimestamp(mockGregorianCalendar0);
      assertEquals("1970-01-01 00:00:00.0", timestamp0.toString());
  }

  @Test(timeout = 4000)
  public void test050()  throws Throwable  {
      String string0 = TypeUtils.decapitalize("Ljava.awt.Font");
      assertNotNull(string0);
      assertEquals("ljava.awt.Font", string0);
      
      Class<Double> class0 = Double.class;
      String[] stringArray0 = TypeUtils.getKoltinConstructorParameters(class0);
      assertNull(stringArray0);
      
      Constructor<SQLNonTransientException>[] constructorArray0 = (Constructor<SQLNonTransientException>[]) Array.newInstance(Constructor.class, 0);
      Constructor constructor0 = TypeUtils.getKoltinConstructor(constructorArray0);
      assertNull(constructor0);
      
      boolean boolean0 = TypeUtils.isGenericParamType(class0);
      assertFalse(boolean0);
      
      byte[] byteArray0 = new byte[2];
      byteArray0[0] = (byte)68;
      byteArray0[1] = (byte) (-95);
      BigInteger bigInteger0 = new BigInteger(byteArray0);
      assertNotNull(bigInteger0);
      assertEquals((short)17569, bigInteger0.shortValue());
      assertEquals((byte) (-95), bigInteger0.byteValue());
      assertArrayEquals(new byte[] {(byte)68, (byte) (-95)}, byteArray0);
      
      Short short0 = TypeUtils.castToShort(bigInteger0);
      assertNotNull(short0);
      assertEquals((short)17569, bigInteger0.shortValue());
      assertEquals((byte) (-95), bigInteger0.byteValue());
      assertArrayEquals(new byte[] {(byte)68, (byte) (-95)}, byteArray0);
      assertEquals((short)17569, (short)short0);
  }

  @Test(timeout = 4000)
  public void test051()  throws Throwable  {
      Class<Jdk8DateCodec> class0 = Jdk8DateCodec.class;
      boolean boolean0 = TypeUtils.isNumber("Ljava.awt.Rectangle");
      assertFalse(boolean0);
      
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      String string0 = weakHashMap0.put("can not cast to Timestamp, value : ", "Ljava.awt.Rectangle");
      assertNull(string0);
      
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class0, (Map<String, String>) weakHashMap0);
      assertNotNull(list0);
      assertEquals(0, list0.size());
      assertTrue(list0.isEmpty());
      
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      assertNotNull(classLoader0);
      
      ClassLoader classLoader1 = classLoader0.getParent();
      assertNotNull(classLoader1);
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      ClassLoader classLoader2 = ClassLoader.getSystemClassLoader();
      assertNotNull(classLoader2);
      assertSame(classLoader2, classLoader0);
      assertFalse(classLoader2.equals((Object)classLoader1));
      
      ASMDeserializerFactory aSMDeserializerFactory0 = new ASMDeserializerFactory(classLoader2);
      assertNotNull(aSMDeserializerFactory0);
      assertFalse(classLoader2.equals((Object)classLoader1));
      
      ASMClassLoader aSMClassLoader0 = aSMDeserializerFactory0.classLoader;
      assertNotNull(aSMClassLoader0);
      
      boolean boolean1 = TypeUtils.isKotlin(class0);
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
  }

  @Test(timeout = 4000)
  public void test052()  throws Throwable  {
      NumberFormatException numberFormatException0 = new NumberFormatException();
      assertNotNull(numberFormatException0);
      assertNull(numberFormatException0.getMessage());
      assertEquals("java.lang.NumberFormatException", numberFormatException0.toString());
      
      VerifyError verifyError0 = new VerifyError("a");
      assertNotNull(verifyError0);
      assertEquals("a", verifyError0.getMessage());
      assertEquals("java.lang.VerifyError: a", verifyError0.toString());
      
      // Undeclared exception!
      try { 
        TypeUtils.castToDate("a");
        fail("Expecting exception: NumberFormatException");
      
      } catch(NumberFormatException e) {
         //
         // For input string: \"a\"
         //
         verifyException("java.lang.NumberFormatException", e);
      }
  }

  @Test(timeout = 4000)
  public void test053()  throws Throwable  {
      Class<Jdk8DateCodec> class0 = Jdk8DateCodec.class;
      Map<String, String> map0 = ZoneId.SHORT_IDS;
      assertNotNull(map0);
      assertEquals(28, map0.size());
      assertFalse(map0.isEmpty());
      
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.SnakeCase;
      List<FieldInfo> list0 = TypeUtils.computeGettersWithFieldBase(class0, map0, true, propertyNamingStrategy0);
      assertNotNull(list0);
      assertEquals(28, map0.size());
      assertFalse(map0.isEmpty());
      assertTrue(list0.isEmpty());
      assertEquals(0, list0.size());
      
      boolean boolean0 = TypeUtils.isNumber("Ljava.awt.Rectangle");
      assertFalse(boolean0);
      
      ConcurrentHashMap<String, String> concurrentHashMap0 = new ConcurrentHashMap<String, String>();
      assertNotNull(concurrentHashMap0);
      assertTrue(concurrentHashMap0.isEmpty());
      
      int int0 = concurrentHashMap0.size();
      assertTrue(concurrentHashMap0.isEmpty());
      assertEquals(0, int0);
      
      Locale locale0 = TypeUtils.toLocale("u3C'D4j%3v3ru9");
      assertNotNull(locale0);
      assertEquals("u3c'd4j%3v3ru9", locale0.toString());
      assertEquals("", locale0.getISO3Country());
      assertEquals("", locale0.getVariant());
      assertEquals("u3c'd4j%3v3ru9", locale0.getLanguage());
      assertEquals("", locale0.getCountry());
      
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      assertNotNull(classLoader0);
      
      ASMDeserializerFactory aSMDeserializerFactory0 = new ASMDeserializerFactory((ClassLoader) null);
      assertNotNull(aSMDeserializerFactory0);
      
      ParserConfig parserConfig0 = new ParserConfig(aSMDeserializerFactory0);
      assertNotNull(parserConfig0);
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      long long0 = TypeUtils.fnv1a_64("X^4Sm5~/ZN!<z");
      assertEquals(4314031097733425773L, long0);
      
      Class<ChronoLocalDate> class1 = ChronoLocalDate.class;
      List<FieldInfo> list1 = TypeUtils.computeGetters(class1, map0, true);
      assertNotNull(list1);
      assertNotSame(list1, list0);
      assertEquals(28, map0.size());
      assertFalse(map0.isEmpty());
      assertEquals(0, list1.size());
      assertTrue(list1.isEmpty());
      assertTrue(list1.equals((Object)list0));
  }

  @Test(timeout = 4000)
  public void test054()  throws Throwable  {
      LinkedHashMap<OutOfMemoryError, SQLWarning> linkedHashMap0 = new LinkedHashMap<OutOfMemoryError, SQLWarning>();
      assertNotNull(linkedHashMap0);
      assertTrue(linkedHashMap0.isEmpty());
      assertEquals(0, linkedHashMap0.size());
      
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      assertNotNull(classLoader0);
      
      ASMDeserializerFactory aSMDeserializerFactory0 = new ASMDeserializerFactory(classLoader0);
      assertNotNull(aSMDeserializerFactory0);
      
      ParserConfig parserConfig0 = new ParserConfig(aSMDeserializerFactory0);
      assertNotNull(parserConfig0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig0.fieldBased);
      
      long long0 = TypeUtils.fnv1a_64("fastjson.parser.autoTypeSupport");
      assertEquals((-852158131015463758L), long0);
      
      Class<SimpleDateFormat> class0 = SimpleDateFormat.class;
      TreeMap<String, String> treeMap0 = new TreeMap<String, String>();
      assertNotNull(treeMap0);
      assertEquals(0, treeMap0.size());
      
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class0, (Map<String, String>) treeMap0, false);
      assertNotNull(list0);
      assertEquals(0, treeMap0.size());
      assertEquals(0, list0.size());
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test055()  throws Throwable  {
      AtomicLong atomicLong0 = new AtomicLong(0L);
      assertNotNull(atomicLong0);
      assertEquals("0", atomicLong0.toString());
      assertEquals((short)0, atomicLong0.shortValue());
      assertEquals(0.0F, atomicLong0.floatValue(), 0.01F);
      assertEquals(0, atomicLong0.intValue());
      assertEquals(0L, atomicLong0.longValue());
      assertEquals(0.0, atomicLong0.doubleValue(), 0.01);
      assertEquals(0L, atomicLong0.get());
      assertEquals((byte)0, atomicLong0.byteValue());
      
      Class<ChronoLocalDate> class0 = ChronoLocalDate.class;
      ParserConfig parserConfig0 = ParserConfig.global;
      assertNotNull(parserConfig0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      LongUnaryOperator longUnaryOperator0 = mock(LongUnaryOperator.class, new ViolatedAssumptionAnswer());
      doReturn(8963398325558730460L).when(longUnaryOperator0).applyAsLong(anyLong());
      long long0 = atomicLong0.getAndUpdate(longUnaryOperator0);
      assertEquals(8963398325558730460L, atomicLong0.longValue());
      assertEquals(2000838364, atomicLong0.intValue());
      assertEquals("8963398325558730460", atomicLong0.toString());
      assertEquals((short)24284, atomicLong0.shortValue());
      assertEquals(8963398325558730460L, atomicLong0.get());
      assertEquals(8.9633983255587308E18, atomicLong0.doubleValue(), 0.01);
      assertEquals(8.9633986E18F, atomicLong0.floatValue(), 0.01F);
      assertEquals((byte) (-36), atomicLong0.byteValue());
      assertEquals(0L, long0);
      
      Hashtable<String, Field> hashtable0 = new Hashtable<String, Field>();
      assertNotNull(hashtable0);
      assertEquals(0, hashtable0.size());
      assertTrue(hashtable0.isEmpty());
      
      LongUnaryOperator longUnaryOperator1 = mock(LongUnaryOperator.class, new ViolatedAssumptionAnswer());
      doReturn(0L).when(longUnaryOperator1).applyAsLong(anyLong());
      LongBinaryOperator longBinaryOperator0 = mock(LongBinaryOperator.class, new ViolatedAssumptionAnswer());
      doReturn(8963398325558730460L).when(longBinaryOperator0).applyAsLong(anyLong() , anyLong());
      long long1 = atomicLong0.accumulateAndGet(0L, longBinaryOperator0);
      assertEquals(8963398325558730460L, atomicLong0.longValue());
      assertEquals(2000838364, atomicLong0.intValue());
      assertEquals("8963398325558730460", atomicLong0.toString());
      assertEquals((short)24284, atomicLong0.shortValue());
      assertEquals(8963398325558730460L, atomicLong0.get());
      assertEquals(8.9633983255587308E18, atomicLong0.doubleValue(), 0.01);
      assertEquals(8.9633986E18F, atomicLong0.floatValue(), 0.01F);
      assertEquals((byte) (-36), atomicLong0.byteValue());
      assertEquals(8963398325558730460L, long1);
      assertFalse(long1 == long0);
      
      long long2 = atomicLong0.getAndUpdate(longUnaryOperator1);
      assertEquals("0", atomicLong0.toString());
      assertEquals((short)0, atomicLong0.shortValue());
      assertEquals(0.0F, atomicLong0.floatValue(), 0.01F);
      assertEquals(0, atomicLong0.intValue());
      assertEquals(0L, atomicLong0.longValue());
      assertEquals(0.0, atomicLong0.doubleValue(), 0.01);
      assertEquals(0L, atomicLong0.get());
      assertEquals((byte)0, atomicLong0.byteValue());
      assertEquals(8963398325558730460L, long2);
      assertTrue(long2 == long1);
      assertFalse(long2 == long0);
      
      parserConfig0.addAccept("has");
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      atomicLong0.set(59L);
      assertEquals("59", atomicLong0.toString());
      assertEquals(59L, atomicLong0.get());
      assertEquals(59.0F, atomicLong0.floatValue(), 0.01F);
      assertEquals(59.0, atomicLong0.doubleValue(), 0.01);
      assertEquals((byte)59, atomicLong0.byteValue());
      assertEquals(59L, atomicLong0.longValue());
      assertEquals(59, atomicLong0.intValue());
      assertEquals((short)59, atomicLong0.shortValue());
      
      boolean boolean0 = atomicLong0.weakCompareAndSet(0L, 5450448828334921485L);
      assertEquals("59", atomicLong0.toString());
      assertEquals(59L, atomicLong0.get());
      assertEquals(59.0F, atomicLong0.floatValue(), 0.01F);
      assertEquals(59.0, atomicLong0.doubleValue(), 0.01);
      assertEquals((byte)59, atomicLong0.byteValue());
      assertEquals(59L, atomicLong0.longValue());
      assertEquals(59, atomicLong0.intValue());
      assertEquals((short)59, atomicLong0.shortValue());
      assertFalse(boolean0);
      
      Field field0 = ParserConfig.getFieldFromCache("()Ljava/lang/String;", hashtable0);
      assertNull(field0);
      assertEquals(0, hashtable0.size());
      assertTrue(hashtable0.isEmpty());
      
      LinkedHashMap<String, String> linkedHashMap0 = new LinkedHashMap<String, String>();
      assertNotNull(linkedHashMap0);
      assertEquals(0, linkedHashMap0.size());
      assertTrue(linkedHashMap0.isEmpty());
      
      SerializeBeanInfo serializeBeanInfo0 = TypeUtils.buildBeanInfo((Class<?>) class0, (Map<String, String>) linkedHashMap0, (PropertyNamingStrategy) null);
      assertNotNull(serializeBeanInfo0);
      assertEquals(0, linkedHashMap0.size());
      assertTrue(linkedHashMap0.isEmpty());
      
      Short short0 = TypeUtils.castToShort((Object) null);
      assertNull(short0);
  }

  @Test(timeout = 4000)
  public void test056()  throws Throwable  {
      boolean boolean0 = TypeUtils.isNumber("#?mPj((");
      assertFalse(boolean0);
      
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      assertNotNull(classLoader0);
      
      ClassLoader classLoader1 = ClassLoader.getSystemClassLoader();
      assertNotNull(classLoader1);
      assertSame(classLoader1, classLoader0);
      
      ASMDeserializerFactory aSMDeserializerFactory0 = new ASMDeserializerFactory(classLoader1);
      assertNotNull(aSMDeserializerFactory0);
      
      ParserConfig parserConfig0 = new ParserConfig(aSMDeserializerFactory0);
      assertNotNull(parserConfig0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      Class<SimpleDateFormat> class0 = SimpleDateFormat.class;
      TreeMap<String, String> treeMap0 = new TreeMap<String, String>();
      assertNotNull(treeMap0);
      assertEquals(0, treeMap0.size());
      
      NavigableSet<String> navigableSet0 = treeMap0.descendingKeySet();
      assertNotNull(navigableSet0);
      assertEquals(0, treeMap0.size());
      assertEquals(0, navigableSet0.size());
      assertTrue(navigableSet0.isEmpty());
      
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class0, (Map<String, String>) treeMap0, true);
      assertNotNull(list0);
      assertEquals(0, treeMap0.size());
      assertTrue(list0.isEmpty());
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test057()  throws Throwable  {
      Byte byte0 = TypeUtils.castToByte((Object) null);
      assertNull(byte0);
      
      boolean boolean0 = TypeUtils.isNumber("Ljava.awt.Point");
      assertFalse(boolean0);
      
      TypeUtils typeUtils0 = new TypeUtils();
      assertNotNull(typeUtils0);
      assertTrue(TypeUtils.compatibleWithFieldName);
      assertTrue(TypeUtils.compatibleWithJavaBean);
      
      Locale locale0 = Locale.JAPAN;
      assertNotNull(locale0);
      assertEquals("", locale0.getVariant());
      assertEquals("JP", locale0.getCountry());
      assertEquals("ja", locale0.getLanguage());
      assertEquals("JPN", locale0.getISO3Country());
      assertEquals("jpn", locale0.getISO3Language());
      assertEquals("ja_JP", locale0.toString());
      
      MessageFormat messageFormat0 = new MessageFormat("0$]npwXC", locale0);
      assertNotNull(messageFormat0);
      assertEquals("", locale0.getVariant());
      assertEquals("JP", locale0.getCountry());
      assertEquals("ja", locale0.getLanguage());
      assertEquals("JPN", locale0.getISO3Country());
      assertEquals("jpn", locale0.getISO3Language());
      assertEquals("ja_JP", locale0.toString());
      
      GenericArrayType genericArrayType0 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(genericArrayType0).toString();
      doReturn((Type) null).when(genericArrayType0).getGenericComponentType();
      Type type0 = TypeUtils.checkPrimitiveArray(genericArrayType0);
      assertNotNull(type0);
      
      AtomicInteger atomicInteger0 = new AtomicInteger(38);
      assertNotNull(atomicInteger0);
      assertEquals(38.0F, atomicInteger0.floatValue(), 0.01F);
      assertEquals(38, atomicInteger0.intValue());
      assertEquals((byte)38, atomicInteger0.byteValue());
      assertEquals(38L, atomicInteger0.longValue());
      assertEquals((short)38, atomicInteger0.shortValue());
      assertEquals(38, atomicInteger0.get());
      assertEquals("38", atomicInteger0.toString());
      assertEquals(38.0, atomicInteger0.doubleValue(), 0.01);
      
      Time time0 = TypeUtils.castToSqlTime(atomicInteger0);
      assertNotNull(time0);
      assertEquals(38.0F, atomicInteger0.floatValue(), 0.01F);
      assertEquals(38, atomicInteger0.intValue());
      assertEquals((byte)38, atomicInteger0.byteValue());
      assertEquals(38L, atomicInteger0.longValue());
      assertEquals((short)38, atomicInteger0.shortValue());
      assertEquals(38, atomicInteger0.get());
      assertEquals("38", atomicInteger0.toString());
      assertEquals(38.0, atomicInteger0.doubleValue(), 0.01);
      assertEquals("00:00:00", time0.toString());
      
      ParserConfig parserConfig0 = ParserConfig.getGlobalInstance();
      assertNotNull(parserConfig0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig0.fieldBased);
      
      Class<PropertyNamingStrategy> class0 = PropertyNamingStrategy.class;
      boolean boolean1 = TypeUtils.isProxy(class0);
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
      
      Class<?> class1 = TypeUtils.loadClass("E");
      assertNull(class1);
      
      // Undeclared exception!
      try { 
        TypeUtils.isPath((Class<?>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.lang.Class", e);
      }
  }

  @Test(timeout = 4000)
  public void test058()  throws Throwable  {
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      StringCharacterIterator stringCharacterIterator0 = new StringCharacterIterator("!X\"NFaL$Xqp#*'");
      assertNotNull(stringCharacterIterator0);
      assertEquals(0, stringCharacterIterator0.getBeginIndex());
      assertEquals('!', stringCharacterIterator0.current());
      assertEquals(15, stringCharacterIterator0.getEndIndex());
      assertEquals(0, stringCharacterIterator0.getIndex());
      
      Class<SQLTransientConnectionException> class0 = SQLTransientConnectionException.class;
      Hashtable<String, String> hashtable0 = new Hashtable<String, String>();
      assertNotNull(hashtable0);
      assertEquals(0, hashtable0.size());
      assertTrue(hashtable0.isEmpty());
      
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class0, (Map<String, String>) hashtable0);
      assertNotNull(list0);
      assertEquals(0, hashtable0.size());
      assertTrue(hashtable0.isEmpty());
      assertEquals(0, list0.size());
      assertTrue(list0.isEmpty());
      
      Short short0 = new Short((short)74);
      assertNotNull(short0);
      assertEquals((short)74, (short)short0);
      
      Boolean boolean0 = new Boolean("");
      assertNotNull(boolean0);
      assertFalse(boolean0);
      
      AtomicLong atomicLong0 = new AtomicLong((-491L));
      assertNotNull(atomicLong0);
      assertEquals((-491.0F), atomicLong0.floatValue(), 0.01F);
      assertEquals((-491L), atomicLong0.get());
      assertEquals((-491), atomicLong0.intValue());
      assertEquals("-491", atomicLong0.toString());
      assertEquals((short) (-491), atomicLong0.shortValue());
      assertEquals((-491.0), atomicLong0.doubleValue(), 0.01);
      assertEquals((byte)21, atomicLong0.byteValue());
      assertEquals((-491L), atomicLong0.longValue());
      
      Integer integer0 = TypeUtils.castToInt(atomicLong0);
      assertNotNull(integer0);
      assertEquals((-491.0F), atomicLong0.floatValue(), 0.01F);
      assertEquals((-491L), atomicLong0.get());
      assertEquals((-491), atomicLong0.intValue());
      assertEquals("-491", atomicLong0.toString());
      assertEquals((short) (-491), atomicLong0.shortValue());
      assertEquals((-491.0), atomicLong0.doubleValue(), 0.01);
      assertEquals((byte)21, atomicLong0.byteValue());
      assertEquals((-491L), atomicLong0.longValue());
      assertEquals((-491), (int)integer0);
      
      Class<SQLClientInfoException> class1 = SQLClientInfoException.class;
      boolean boolean1 = TypeUtils.isPath(class1);
      assertFalse(boolean1);
      
      Boolean boolean2 = TypeUtils.castToBoolean("");
      assertNull(boolean2);
  }

  @Test(timeout = 4000)
  public void test059()  throws Throwable  {
      TypeUtils typeUtils0 = new TypeUtils();
      assertNotNull(typeUtils0);
      assertTrue(TypeUtils.compatibleWithJavaBean);
      assertTrue(TypeUtils.compatibleWithFieldName);
      
      boolean boolean0 = TypeUtils.isNumber("portlist");
      assertFalse(boolean0);
      
      ThreadGroup threadGroup0 = new ThreadGroup("portlist");
      assertNotNull(threadGroup0);
      assertEquals("portlist", threadGroup0.getName());
      
      ThreadGroup threadGroup1 = new ThreadGroup(threadGroup0, "portlist");
      assertNotNull(threadGroup1);
      assertEquals("portlist", threadGroup0.getName());
      assertEquals("portlist", threadGroup1.getName());
      assertFalse(threadGroup1.equals((Object)threadGroup0));
      
      MockThread mockThread0 = new MockThread("rAr5=vRnei");
      assertNotNull(mockThread0);
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      
      MockThread mockThread1 = new MockThread(threadGroup1, mockThread0, "portlist", 867L);
      assertNotNull(mockThread1);
      assertEquals("portlist", threadGroup0.getName());
      assertEquals("portlist", threadGroup1.getName());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.isInterrupted());
      assertFalse(mockThread1.isDaemon());
      assertFalse(threadGroup0.equals((Object)threadGroup1));
      assertFalse(threadGroup1.equals((Object)threadGroup0));
      assertFalse(mockThread1.equals((Object)mockThread0));
      
      ClassLoader classLoader0 = mockThread1.getContextClassLoader();
      assertNotNull(classLoader0);
      assertNotSame(threadGroup0, threadGroup1);
      assertNotSame(threadGroup1, threadGroup0);
      assertNotSame(mockThread0, mockThread1);
      assertNotSame(mockThread1, mockThread0);
      assertEquals("portlist", threadGroup0.getName());
      assertEquals("portlist", threadGroup1.getName());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.isInterrupted());
      assertFalse(mockThread1.isDaemon());
      assertFalse(threadGroup0.equals((Object)threadGroup1));
      assertFalse(threadGroup1.equals((Object)threadGroup0));
      assertFalse(mockThread0.equals((Object)mockThread1));
      assertFalse(mockThread1.equals((Object)mockThread0));
      
      Class<IndexOutOfBoundsException> class0 = IndexOutOfBoundsException.class;
      boolean boolean1 = TypeUtils.isPath(class0);
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
      
      MockIllegalArgumentException mockIllegalArgumentException0 = new MockIllegalArgumentException("rAr5=vRnei");
      assertNotNull(mockIllegalArgumentException0);
      
      SecurityException securityException0 = new SecurityException("portlist", mockIllegalArgumentException0);
      assertNotNull(securityException0);
      assertEquals("java.lang.SecurityException: portlist", securityException0.toString());
      assertEquals("portlist", securityException0.getMessage());
      
      SQLSyntaxErrorException sQLSyntaxErrorException0 = new SQLSyntaxErrorException("portlist", "portlist", 45, mockIllegalArgumentException0);
      assertNotNull(sQLSyntaxErrorException0);
      assertEquals("portlist", sQLSyntaxErrorException0.getMessage());
      assertEquals("portlist", sQLSyntaxErrorException0.getSQLState());
      assertEquals("java.sql.SQLSyntaxErrorException: portlist", sQLSyntaxErrorException0.toString());
      assertEquals(45, sQLSyntaxErrorException0.getErrorCode());
      
      ConcurrentHashMap<Time, TimeZone> concurrentHashMap0 = new ConcurrentHashMap<Time, TimeZone>();
      assertNotNull(concurrentHashMap0);
      assertTrue(concurrentHashMap0.isEmpty());
      
      // Undeclared exception!
      try { 
        TypeUtils.castToBoolean(concurrentHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to boolean, value : {}
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test060()  throws Throwable  {
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      GenericArrayType genericArrayType0 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(genericArrayType0).toString();
      doReturn((Type) null).when(genericArrayType0).getGenericComponentType();
      Type type0 = TypeUtils.checkPrimitiveArray(genericArrayType0);
      assertNotNull(type0);
      
      Class<?> class0 = TypeUtils.getClass(type0);
      assertNotNull(class0);
      assertEquals("class java.lang.Object", class0.toString());
      assertFalse(class0.isPrimitive());
      assertEquals(1, class0.getModifiers());
      assertFalse(class0.isInterface());
      assertFalse(class0.isArray());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertFalse(class0.isAnnotation());
      
      Class<SQLClientInfoException> class1 = SQLClientInfoException.class;
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class1, (Map<String, String>) weakHashMap0, false);
      assertNotNull(list0);
      assertTrue(list0.isEmpty());
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test061()  throws Throwable  {
      Class<EnumDeserializer> class0 = EnumDeserializer.class;
      TypeUtils typeUtils0 = new TypeUtils();
      assertNotNull(typeUtils0);
      assertTrue(TypeUtils.compatibleWithFieldName);
      assertTrue(TypeUtils.compatibleWithJavaBean);
      
      Timestamp timestamp0 = TypeUtils.castToTimestamp((Object) null);
      assertNull(timestamp0);
      
      // Undeclared exception!
      try { 
        TypeUtils.getField(class0, "NextException", (Field[]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test062()  throws Throwable  {
      Class<?> class0 = TypeUtils.getClassFromMapping("[D");
      assertNotNull(class0);
      assertEquals("class [D", class0.toString());
      assertFalse(class0.isInterface());
      assertFalse(class0.isPrimitive());
      assertFalse(class0.isAnnotation());
      assertTrue(class0.isArray());
      assertEquals(1041, class0.getModifiers());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      
      GenericArrayType genericArrayType0 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(genericArrayType0).toString();
      doReturn((Type) null).when(genericArrayType0).getGenericComponentType();
      Type type0 = TypeUtils.checkPrimitiveArray(genericArrayType0);
      assertNotNull(type0);
      
      Class<?> class1 = TypeUtils.getClass((Type) class0);
      assertNotNull(class1);
      assertSame(class0, class1);
      assertSame(class1, class0);
      assertEquals("class [D", class0.toString());
      assertFalse(class0.isInterface());
      assertFalse(class0.isPrimitive());
      assertFalse(class0.isAnnotation());
      assertTrue(class0.isArray());
      assertEquals(1041, class0.getModifiers());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertFalse(class1.isInterface());
      assertEquals("class [D", class1.toString());
      assertEquals(1041, class1.getModifiers());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertTrue(class1.isArray());
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isPrimitive());
      
      Class<GridBagConstraints> class2 = GridBagConstraints.class;
      List<FieldInfo> list0 = TypeUtils.computeGetters(class2, (Map<String, String>) null, true);
      assertNotNull(list0);
      assertFalse(list0.isEmpty());
      assertEquals(11, list0.size());
  }

  @Test(timeout = 4000)
  public void test063()  throws Throwable  {
      Class<SQLFeatureNotSupportedException> class0 = SQLFeatureNotSupportedException.class;
      ConcurrentHashMap<String, String> concurrentHashMap0 = new ConcurrentHashMap<String, String>();
      assertNotNull(concurrentHashMap0);
      assertTrue(concurrentHashMap0.isEmpty());
      
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class0, (Map<String, String>) concurrentHashMap0);
      assertNotNull(list0);
      assertTrue(concurrentHashMap0.isEmpty());
      assertEquals(0, list0.size());
      assertTrue(list0.isEmpty());
      
      boolean boolean0 = TypeUtils.isProxy(class0);
      assertFalse(boolean0);
      
      GenericArrayType genericArrayType0 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(genericArrayType0).toString();
      doReturn((Type) null, (Type) null).when(genericArrayType0).getGenericComponentType();
      Type type0 = TypeUtils.checkPrimitiveArray(genericArrayType0);
      assertNotNull(type0);
      
      GenericArrayType genericArrayType1 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(genericArrayType1).toString();
      doReturn(type0).when(genericArrayType1).getGenericComponentType();
      Type type1 = TypeUtils.checkPrimitiveArray(genericArrayType1);
      assertNotNull(type1);
      assertFalse(type1.equals((Object)type0));
      
      Class<Double> class1 = Double.TYPE;
      assertNotNull(class1);
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertEquals(1041, class1.getModifiers());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertTrue(class1.isPrimitive());
      assertEquals("double", class1.toString());
      
      boolean boolean1 = TypeUtils.isGenericParamType(class1);
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertEquals(1041, class1.getModifiers());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertTrue(class1.isPrimitive());
      assertEquals("double", class1.toString());
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
      
      Class<Boolean> class2 = Boolean.TYPE;
      assertNotNull(class2);
      assertTrue(class2.isPrimitive());
      assertFalse(class2.isArray());
      assertFalse(class2.isInterface());
      assertEquals("boolean", class2.toString());
      assertFalse(class2.isEnum());
      assertEquals(1041, class2.getModifiers());
      assertFalse(class2.isSynthetic());
      assertFalse(class2.isAnnotation());
      
      Class<?> class3 = TypeUtils.getCollectionItemClass(class2);
      assertNotNull(class3);
      assertTrue(class2.isPrimitive());
      assertFalse(class2.isArray());
      assertFalse(class2.isInterface());
      assertEquals("boolean", class2.toString());
      assertFalse(class2.isEnum());
      assertEquals(1041, class2.getModifiers());
      assertFalse(class2.isSynthetic());
      assertFalse(class2.isAnnotation());
      assertFalse(class3.isInterface());
      assertFalse(class3.isArray());
      assertFalse(class3.isEnum());
      assertFalse(class3.isAnnotation());
      assertEquals(1, class3.getModifiers());
      assertFalse(class3.isSynthetic());
      assertEquals("class java.lang.Object", class3.toString());
      assertFalse(class3.isPrimitive());
      
      System.setCurrentTimeMillis(0L);
      // Undeclared exception!
      try { 
        TypeUtils.castToTimestamp(concurrentHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to Timestamp, value : {}
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test064()  throws Throwable  {
      LinkedHashMap<Jdk8DateCodec, ChoiceFormat> linkedHashMap0 = new LinkedHashMap<Jdk8DateCodec, ChoiceFormat>();
      assertNotNull(linkedHashMap0);
      assertEquals(0, linkedHashMap0.size());
      assertTrue(linkedHashMap0.isEmpty());
      
      Class<Character> class0 = Character.TYPE;
      assertNotNull(class0);
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertFalse(class0.isInterface());
      assertFalse(class0.isArray());
      assertEquals(1041, class0.getModifiers());
      assertEquals("char", class0.toString());
      assertFalse(class0.isAnnotation());
      assertTrue(class0.isPrimitive());
      
      GenericArrayType genericArrayType0 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      doReturn(class0).when(genericArrayType0).getGenericComponentType();
      Class class1 = (Class)TypeUtils.checkPrimitiveArray(genericArrayType0);
      assertNotNull(class1);
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertFalse(class0.isInterface());
      assertFalse(class0.isArray());
      assertEquals(1041, class0.getModifiers());
      assertEquals("char", class0.toString());
      assertFalse(class0.isAnnotation());
      assertTrue(class0.isPrimitive());
      assertFalse(class1.isAnnotation());
      assertTrue(class1.isArray());
      assertEquals("class [C", class1.toString());
      assertEquals(1041, class1.getModifiers());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertFalse(class1.isInterface());
      assertFalse(class1.isPrimitive());
      
      Class<?> class2 = TypeUtils.getClass((Type) class1);
      assertNotNull(class2);
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertFalse(class0.isInterface());
      assertFalse(class0.isArray());
      assertEquals(1041, class0.getModifiers());
      assertEquals("char", class0.toString());
      assertFalse(class0.isAnnotation());
      assertTrue(class0.isPrimitive());
      assertFalse(class1.isAnnotation());
      assertTrue(class1.isArray());
      assertEquals("class [C", class1.toString());
      assertEquals(1041, class1.getModifiers());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertFalse(class1.isInterface());
      assertFalse(class1.isPrimitive());
      assertEquals("class [C", class2.toString());
      assertFalse(class2.isEnum());
      assertFalse(class2.isInterface());
      assertFalse(class2.isAnnotation());
      assertFalse(class2.isPrimitive());
      assertTrue(class2.isArray());
      assertEquals(1041, class2.getModifiers());
      assertFalse(class2.isSynthetic());
      
      SQLSyntaxErrorException sQLSyntaxErrorException0 = new SQLSyntaxErrorException("Hai/nt#!5P'", "@Ej[[=d`");
      assertNotNull(sQLSyntaxErrorException0);
      assertEquals(0, sQLSyntaxErrorException0.getErrorCode());
      assertEquals("Hai/nt#!5P'", sQLSyntaxErrorException0.getMessage());
      assertEquals("java.sql.SQLSyntaxErrorException: Hai/nt#!5P'", sQLSyntaxErrorException0.toString());
      assertEquals("@Ej[[=d`", sQLSyntaxErrorException0.getSQLState());
      
      Throwable[] throwableArray0 = sQLSyntaxErrorException0.getSuppressed();
      assertNotNull(throwableArray0);
      assertEquals(0, sQLSyntaxErrorException0.getErrorCode());
      assertEquals("Hai/nt#!5P'", sQLSyntaxErrorException0.getMessage());
      assertEquals("java.sql.SQLSyntaxErrorException: Hai/nt#!5P'", sQLSyntaxErrorException0.toString());
      assertEquals("@Ej[[=d`", sQLSyntaxErrorException0.getSQLState());
      
      SecurityException securityException0 = new SecurityException("@Ej[[=d`", sQLSyntaxErrorException0);
      assertNotNull(securityException0);
      assertEquals(0, sQLSyntaxErrorException0.getErrorCode());
      assertEquals("Hai/nt#!5P'", sQLSyntaxErrorException0.getMessage());
      assertEquals("java.sql.SQLSyntaxErrorException: Hai/nt#!5P'", sQLSyntaxErrorException0.toString());
      assertEquals("@Ej[[=d`", sQLSyntaxErrorException0.getSQLState());
      assertEquals("java.lang.SecurityException: @Ej[[=d`", securityException0.toString());
      assertEquals("@Ej[[=d`", securityException0.getMessage());
      
      StackOverflowError stackOverflowError0 = new StackOverflowError("3\"4ufj");
      assertNotNull(stackOverflowError0);
      assertEquals("java.lang.StackOverflowError: 3\"4ufj", stackOverflowError0.toString());
      assertEquals("3\"4ufj", stackOverflowError0.getMessage());
      
      GenericArrayType genericArrayType1 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      doReturn(class0).when(genericArrayType1).getGenericComponentType();
      Class class3 = (Class)TypeUtils.checkPrimitiveArray(genericArrayType1);
      assertNotNull(class3);
      assertSame(class3, class1);
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertFalse(class0.isInterface());
      assertFalse(class0.isArray());
      assertEquals(1041, class0.getModifiers());
      assertEquals("char", class0.toString());
      assertFalse(class0.isAnnotation());
      assertTrue(class0.isPrimitive());
      assertFalse(class3.isPrimitive());
      assertFalse(class3.isAnnotation());
      assertTrue(class3.isArray());
      assertEquals(1041, class3.getModifiers());
      assertFalse(class3.isEnum());
      assertFalse(class3.isSynthetic());
      assertEquals("class [C", class3.toString());
      assertFalse(class3.isInterface());
      
      ParserConfig parserConfig0 = new ParserConfig(true);
      assertNotNull(parserConfig0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertTrue(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
  }

  @Test(timeout = 4000)
  public void test065()  throws Throwable  {
      TimeDeserializer timeDeserializer0 = TimeDeserializer.instance;
      assertNotNull(timeDeserializer0);
      assertEquals(2, timeDeserializer0.getFastMatchToken());
      
      Class<Byte> class0 = Byte.TYPE;
      assertNotNull(class0);
      assertFalse(class0.isAnnotation());
      assertEquals(1041, class0.getModifiers());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertTrue(class0.isPrimitive());
      assertFalse(class0.isInterface());
      assertEquals("byte", class0.toString());
      assertFalse(class0.isArray());
      
      LinkedHashMap<OutOfMemoryError, SQLWarning> linkedHashMap0 = new LinkedHashMap<OutOfMemoryError, SQLWarning>();
      assertNotNull(linkedHashMap0);
      assertEquals(0, linkedHashMap0.size());
      assertTrue(linkedHashMap0.isEmpty());
      
      OutOfMemoryError outOfMemoryError0 = new OutOfMemoryError("clazz is null");
      assertNotNull(outOfMemoryError0);
      assertEquals("clazz is null", outOfMemoryError0.getMessage());
      assertEquals("java.lang.OutOfMemoryError: clazz is null", outOfMemoryError0.toString());
      
      StackTraceElement[] stackTraceElementArray0 = outOfMemoryError0.getStackTrace();
      assertNotNull(stackTraceElementArray0);
      assertEquals("clazz is null", outOfMemoryError0.getMessage());
      assertEquals("java.lang.OutOfMemoryError: clazz is null", outOfMemoryError0.toString());
      
      SQLWarning sQLWarning0 = new SQLWarning();
      assertNotNull(sQLWarning0);
      assertNull(sQLWarning0.getSQLState());
      assertNull(sQLWarning0.getMessage());
      assertEquals("java.sql.SQLWarning", sQLWarning0.toString());
      assertEquals(0, sQLWarning0.getErrorCode());
      
      Timestamp timestamp0 = TypeUtils.castToTimestamp((Object) null);
      assertNull(timestamp0);
      
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      assertNotNull(hashMap0);
      assertTrue(hashMap0.isEmpty());
      assertEquals(0, hashMap0.size());
      
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class0, (Map<String, String>) weakHashMap0);
      assertNotNull(list0);
      assertFalse(class0.isAnnotation());
      assertEquals(1041, class0.getModifiers());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertTrue(class0.isPrimitive());
      assertFalse(class0.isInterface());
      assertEquals("byte", class0.toString());
      assertFalse(class0.isArray());
      assertEquals(0, list0.size());
      assertTrue(list0.isEmpty());
      
      GenericArrayType genericArrayType0 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      doReturn(class0).when(genericArrayType0).getGenericComponentType();
      Class class1 = (Class)TypeUtils.checkPrimitiveArray(genericArrayType0);
      assertNotNull(class1);
      assertFalse(class0.isAnnotation());
      assertEquals(1041, class0.getModifiers());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertTrue(class0.isPrimitive());
      assertFalse(class0.isInterface());
      assertEquals("byte", class0.toString());
      assertFalse(class0.isArray());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isInterface());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals("class [B", class1.toString());
      assertEquals(1041, class1.getModifiers());
      assertTrue(class1.isArray());
      
      Class<?> class2 = TypeUtils.getClass((Type) class1);
      assertNotNull(class2);
      assertFalse(class0.isAnnotation());
      assertEquals(1041, class0.getModifiers());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertTrue(class0.isPrimitive());
      assertFalse(class0.isInterface());
      assertEquals("byte", class0.toString());
      assertFalse(class0.isArray());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isInterface());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals("class [B", class1.toString());
      assertEquals(1041, class1.getModifiers());
      assertTrue(class1.isArray());
      assertFalse(class2.isPrimitive());
      assertTrue(class2.isArray());
      assertFalse(class2.isInterface());
      assertEquals(1041, class2.getModifiers());
      assertEquals("class [B", class2.toString());
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
      assertFalse(class2.isAnnotation());
      
      Class<Properties> class3 = Properties.class;
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.CamelCase;
      List<FieldInfo> list1 = TypeUtils.computeGettersWithFieldBase(class3, hashMap0, true, propertyNamingStrategy0);
      assertNotNull(list1);
      assertNotSame(list1, list0);
      assertTrue(hashMap0.isEmpty());
      assertEquals(0, hashMap0.size());
      assertTrue(list1.isEmpty());
      assertEquals(0, list1.size());
      assertTrue(list1.equals((Object)list0));
      
      Double double0 = new Double(0.0);
      assertNotNull(double0);
      assertEquals(0.0, (double)double0, 0.01);
      
      JSONPDeserializer jSONPDeserializer0 = JSONPDeserializer.instance;
      assertNotNull(jSONPDeserializer0);
      assertEquals(0, jSONPDeserializer0.getFastMatchToken());
      
      Class<JavaObjectDeserializer> class4 = JavaObjectDeserializer.class;
      List<FieldInfo> list2 = TypeUtils.computeGetters((Class<?>) class4, (Map<String, String>) hashMap0, true);
      assertNotNull(list2);
      assertNotSame(list2, list1);
      assertNotSame(list2, list0);
      assertTrue(list2.isEmpty());
      assertEquals(0, list2.size());
      assertTrue(hashMap0.isEmpty());
      assertEquals(0, hashMap0.size());
      assertTrue(list2.equals((Object)list1));
      assertTrue(list2.equals((Object)list0));
  }

  @Test(timeout = 4000)
  public void test066()  throws Throwable  {
      Class<ChronoLocalDate> class0 = ChronoLocalDate.class;
      Class<Annotation> class1 = Annotation.class;
      Annotation annotation0 = TypeUtils.getAnnotation((Class<?>) class0, class1);
      assertNull(annotation0);
      
      Class<?> class2 = TypeUtils.getCollectionItemClass(class0);
      assertNotNull(class2);
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
      assertFalse(class2.isInterface());
      assertFalse(class2.isArray());
      assertEquals(1, class2.getModifiers());
      assertEquals("class java.lang.Object", class2.toString());
      assertFalse(class2.isPrimitive());
      assertFalse(class2.isAnnotation());
      
      boolean boolean0 = TypeUtils.isNumber("(I)C");
      assertFalse(boolean0);
      
      DateFormatSymbols dateFormatSymbols0 = DateFormatSymbols.getInstance();
      assertNotNull(dateFormatSymbols0);
      assertEquals("GyMdkHmsSEDFwWahKzZ", dateFormatSymbols0.getLocalPatternChars());
      
      LinkedHashMap<Jdk8DateCodec, ChoiceFormat> linkedHashMap0 = new LinkedHashMap<Jdk8DateCodec, ChoiceFormat>();
      assertNotNull(linkedHashMap0);
      assertEquals(0, linkedHashMap0.size());
      assertTrue(linkedHashMap0.isEmpty());
      
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar((-1448), 246, (-1448), (-1448), 14);
      assertNotNull(mockGregorianCalendar0);
      assertEquals(1, mockGregorianCalendar0.getFirstDayOfWeek());
      assertEquals(1, mockGregorianCalendar0.getMinimalDaysInFirstWeek());
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=?,areFieldsSet=false,areAllFieldsSet=false,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=?,YEAR=-1448,MONTH=246,WEEK_OF_YEAR=?,WEEK_OF_MONTH=?,DAY_OF_MONTH=-1448,DAY_OF_YEAR=?,DAY_OF_WEEK=?,DAY_OF_WEEK_IN_MONTH=?,AM_PM=0,HOUR=-1448,HOUR_OF_DAY=-1448,MINUTE=14,SECOND=0,MILLISECOND=?,ZONE_OFFSET=?,DST_OFFSET=?]", mockGregorianCalendar0.toString());
      assertTrue(mockGregorianCalendar0.isLenient());
      
      mockGregorianCalendar0.set((-1448), (-2372), 90, 1, 53);
      assertEquals(1, mockGregorianCalendar0.getFirstDayOfWeek());
      assertEquals(1, mockGregorianCalendar0.getMinimalDaysInFirstWeek());
      assertTrue(mockGregorianCalendar0.isLenient());
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=?,areFieldsSet=false,areAllFieldsSet=false,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=?,YEAR=-1448,MONTH=-2372,WEEK_OF_YEAR=?,WEEK_OF_MONTH=?,DAY_OF_MONTH=90,DAY_OF_YEAR=?,DAY_OF_WEEK=?,DAY_OF_WEEK_IN_MONTH=?,AM_PM=0,HOUR=-1448,HOUR_OF_DAY=1,MINUTE=53,SECOND=0,MILLISECOND=?,ZONE_OFFSET=?,DST_OFFSET=?]", mockGregorianCalendar0.toString());
      
      Date date0 = TypeUtils.castToSqlDate(mockGregorianCalendar0);
      assertNotNull(date0);
      assertEquals(1, mockGregorianCalendar0.getFirstDayOfWeek());
      assertEquals(1, mockGregorianCalendar0.getMinimalDaysInFirstWeek());
      assertTrue(mockGregorianCalendar0.isLenient());
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=?,areFieldsSet=false,areAllFieldsSet=false,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=?,YEAR=-1448,MONTH=-2372,WEEK_OF_YEAR=?,WEEK_OF_MONTH=?,DAY_OF_MONTH=90,DAY_OF_YEAR=?,DAY_OF_WEEK=?,DAY_OF_WEEK_IN_MONTH=?,AM_PM=0,HOUR=-1448,HOUR_OF_DAY=1,MINUTE=53,SECOND=0,MILLISECOND=?,ZONE_OFFSET=?,DST_OFFSET=?]", mockGregorianCalendar0.toString());
      
      Class<?> class3 = TypeUtils.getClass((Type) class0);
      assertNotNull(class3);
      assertNotSame(class3, class2);
      assertFalse(class3.isArray());
      assertFalse(class3.isAnnotation());
      assertTrue(class3.isInterface());
      assertEquals("interface java.time.chrono.ChronoLocalDate", class3.toString());
      assertEquals(1537, class3.getModifiers());
      assertFalse(class3.isEnum());
      assertFalse(class3.isSynthetic());
      assertFalse(class3.isPrimitive());
      assertFalse(class3.equals((Object)class2));
      
      BatchUpdateException batchUpdateException0 = new BatchUpdateException();
      assertNotNull(batchUpdateException0);
      assertEquals("java.sql.BatchUpdateException", batchUpdateException0.toString());
      assertNull(batchUpdateException0.getSQLState());
      assertNull(batchUpdateException0.getMessage());
      assertEquals(0, batchUpdateException0.getErrorCode());
      
      ParserConfig parserConfig0 = ParserConfig.global;
      assertNotNull(parserConfig0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      Class<SQLSyntaxErrorException> class4 = SQLSyntaxErrorException.class;
      TreeMap<String, String> treeMap0 = new TreeMap<String, String>();
      assertNotNull(treeMap0);
      assertEquals(0, treeMap0.size());
      
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class4, (Map<String, String>) treeMap0);
      assertNotNull(list0);
      assertEquals(0, treeMap0.size());
      assertTrue(list0.isEmpty());
      assertEquals(0, list0.size());
      
      ParserConfig parserConfig1 = new ParserConfig(false);
      assertNotNull(parserConfig1);
      assertFalse(parserConfig1.isAutoTypeSupport());
      assertTrue(parserConfig1.isAsmEnable());
      assertTrue(parserConfig1.compatibleWithJavaBean);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig1.fieldBased);
      assertFalse(parserConfig1.equals((Object)parserConfig0));
      
      boolean boolean1 = TypeUtils.isGenericParamType(class4);
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
  }

  @Test(timeout = 4000)
  public void test067()  throws Throwable  {
      Class<Jdk8DateCodec> class0 = Jdk8DateCodec.class;
      Map<String, String> map0 = ZoneId.SHORT_IDS;
      assertNotNull(map0);
      assertEquals(28, map0.size());
      assertFalse(map0.isEmpty());
      
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.SnakeCase;
      List<FieldInfo> list0 = TypeUtils.computeGettersWithFieldBase(class0, map0, true, propertyNamingStrategy0);
      assertNotNull(list0);
      assertEquals(28, map0.size());
      assertFalse(map0.isEmpty());
      assertTrue(list0.isEmpty());
      assertEquals(0, list0.size());
      
      boolean boolean0 = TypeUtils.isNumber("Ljava.awt.Rectangle");
      assertFalse(boolean0);
      
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      String string0 = weakHashMap0.put("can not cast to Timestamp, value : ", "Ljava.awt.Rectangle");
      assertNull(string0);
      
      List<FieldInfo> list1 = TypeUtils.computeGetters((Class<?>) class0, (Map<String, String>) weakHashMap0);
      assertNotNull(list1);
      assertNotSame(list1, list0);
      assertTrue(list1.isEmpty());
      assertEquals(0, list1.size());
      assertTrue(list1.equals((Object)list0));
      
      Boolean boolean1 = new Boolean("d-ho1a3k");
      assertNotNull(boolean1);
      assertFalse(boolean1);
      assertTrue(boolean1.equals((Object)boolean0));
      
      Integer integer0 = TypeUtils.castToInt(boolean1);
      assertNotNull(integer0);
      assertEquals(0, (int)integer0);
      assertTrue(boolean1.equals((Object)boolean0));
      
      Class<ParameterizedTypeImpl> class1 = ParameterizedTypeImpl.class;
      boolean boolean2 = TypeUtils.isProxy(class1);
      assertFalse(boolean2);
      assertTrue(boolean2 == boolean0);
  }

  @Test(timeout = 4000)
  public void test068()  throws Throwable  {
      Class<ChoiceFormat> class0 = ChoiceFormat.class;
      ParserConfig parserConfig0 = ParserConfig.getGlobalInstance();
      assertNotNull(parserConfig0);
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      
      Class<SecurityException> class1 = SecurityException.class;
      Thread thread0 = MockThread.currentThread();
      assertNotNull(thread0);
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      
      MockThread mockThread0 = new MockThread(thread0, "fastjson.parser.deny");
      assertNotNull(mockThread0);
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isDaemon());
      
      MockThread mockThread1 = new MockThread(mockThread0);
      assertNotNull(mockThread1);
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread1.isDaemon());
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.equals((Object)mockThread0));
      
      ParserConfig parserConfig1 = ParserConfig.global;
      assertNotNull(parserConfig1);
      assertSame(parserConfig1, parserConfig0);
      assertFalse(parserConfig1.isAutoTypeSupport());
      assertTrue(parserConfig1.isAsmEnable());
      assertFalse(parserConfig1.fieldBased);
      assertTrue(parserConfig1.compatibleWithJavaBean);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      Class<Object> class2 = Object.class;
      JavaBeanInfo javaBeanInfo0 = JavaBeanInfo.build((Class<?>) class2, (Type) class0, (PropertyNamingStrategy) null, true, false);
      assertNotNull(javaBeanInfo0);
      assertEquals(0, javaBeanInfo0.parserFeatures);
      assertEquals(0, javaBeanInfo0.defaultConstructorParameterSize);
      
      ParserConfig parserConfig2 = ParserConfig.getGlobalInstance();
      assertNotNull(parserConfig2);
      assertSame(parserConfig2, parserConfig0);
      assertSame(parserConfig2, parserConfig1);
      assertTrue(parserConfig2.isAsmEnable());
      assertFalse(parserConfig2.isAutoTypeSupport());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig2.fieldBased);
      assertTrue(parserConfig2.compatibleWithJavaBean);
      
      GenericArrayType genericArrayType0 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(genericArrayType0).toString();
      doReturn(class1).when(genericArrayType0).getGenericComponentType();
      Type type0 = TypeUtils.checkPrimitiveArray(genericArrayType0);
      assertNotNull(type0);
      
      LinkedHashMap<Jdk8DateCodec, ChoiceFormat> linkedHashMap0 = new LinkedHashMap<Jdk8DateCodec, ChoiceFormat>();
      assertNotNull(linkedHashMap0);
      assertTrue(linkedHashMap0.isEmpty());
      assertEquals(0, linkedHashMap0.size());
      
      Class<?> class3 = TypeUtils.getClass((Type) class0);
      assertNotNull(class3);
      assertFalse(class3.isInterface());
      assertFalse(class3.isArray());
      assertEquals("class java.text.ChoiceFormat", class3.toString());
      assertFalse(class3.isPrimitive());
      assertFalse(class3.isAnnotation());
      assertEquals(1, class3.getModifiers());
      assertFalse(class3.isEnum());
      assertFalse(class3.isSynthetic());
      
      Class<?> class4 = TypeUtils.loadClass("java.lang.Object");
      assertNotNull(class4);
      assertNotSame(class4, class3);
      assertFalse(class4.isSynthetic());
      assertFalse(class4.isEnum());
      assertFalse(class4.isArray());
      assertFalse(class4.isInterface());
      assertFalse(class4.isPrimitive());
      assertEquals(1, class4.getModifiers());
      assertEquals("class java.lang.Object", class4.toString());
      assertFalse(class4.isAnnotation());
      assertFalse(class4.equals((Object)class3));
      
      Class<?> class5 = TypeUtils.getRawClass(javaBeanInfo0.clazz);
      assertNotNull(class5);
      assertSame(class5, class4);
      assertNotSame(class5, class3);
      assertFalse(class5.isPrimitive());
      assertFalse(class5.isAnnotation());
      assertEquals("class java.lang.Object", class5.toString());
      assertFalse(class5.isArray());
      assertFalse(class5.isInterface());
      assertEquals(1, class5.getModifiers());
      assertFalse(class5.isEnum());
      assertFalse(class5.isSynthetic());
      assertEquals(0, javaBeanInfo0.parserFeatures);
      assertEquals(0, javaBeanInfo0.defaultConstructorParameterSize);
      assertFalse(class5.equals((Object)class3));
      
      StringIndexOutOfBoundsException stringIndexOutOfBoundsException0 = new StringIndexOutOfBoundsException();
      assertNotNull(stringIndexOutOfBoundsException0);
      assertEquals("java.lang.StringIndexOutOfBoundsException", stringIndexOutOfBoundsException0.toString());
      assertNull(stringIndexOutOfBoundsException0.getMessage());
      
      Class<ChronoLocalDate> class6 = ChronoLocalDate.class;
      // Undeclared exception!
      try { 
        TypeUtils.castToEnum((Object) class0, class6, parserConfig2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to : java.time.chrono.ChronoLocalDate
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test069()  throws Throwable  {
      Class<MockJapaneseDate> class0 = MockJapaneseDate.class;
      boolean boolean0 = TypeUtils.isProxy(class0);
      assertFalse(boolean0);
      
      LinkedList<FieldInfo> linkedList0 = new LinkedList<FieldInfo>();
      assertNotNull(linkedList0);
      assertEquals(0, linkedList0.size());
      
      Hashtable<String, String> hashtable0 = new Hashtable<String, String>();
      assertNotNull(hashtable0);
      assertEquals(0, hashtable0.size());
      assertTrue(hashtable0.isEmpty());
      
      Class<RuleBasedCollator> class1 = RuleBasedCollator.class;
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.PascalCase;
      SerializeBeanInfo serializeBeanInfo0 = TypeUtils.buildBeanInfo((Class<?>) class1, (Map<String, String>) hashtable0, propertyNamingStrategy0, true);
      assertNotNull(serializeBeanInfo0);
      assertEquals(0, hashtable0.size());
      assertTrue(hashtable0.isEmpty());
      
      JavaBeanSerializer javaBeanSerializer0 = new JavaBeanSerializer(serializeBeanInfo0);
      assertNotNull(javaBeanSerializer0);
      assertEquals(0, hashtable0.size());
      assertTrue(hashtable0.isEmpty());
      
      Class<?> class2 = javaBeanSerializer0.getType();
      assertNotNull(class2);
      assertEquals(0, hashtable0.size());
      assertTrue(hashtable0.isEmpty());
      assertFalse(class2.isAnnotation());
      assertFalse(class2.isPrimitive());
      assertEquals("class java.text.RuleBasedCollator", class2.toString());
      assertEquals(1, class2.getModifiers());
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
      assertFalse(class2.isArray());
      assertFalse(class2.isInterface());
      
      Class<?> class3 = TypeUtils.getClass((Type) class2);
      assertNotNull(class3);
      assertSame(class2, class3);
      assertSame(class3, class2);
      assertEquals(0, hashtable0.size());
      assertTrue(hashtable0.isEmpty());
      assertFalse(class2.isAnnotation());
      assertFalse(class2.isPrimitive());
      assertEquals("class java.text.RuleBasedCollator", class2.toString());
      assertEquals(1, class2.getModifiers());
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
      assertFalse(class2.isArray());
      assertFalse(class2.isInterface());
      assertFalse(class3.isPrimitive());
      assertFalse(class3.isAnnotation());
      assertFalse(class3.isInterface());
      assertFalse(class3.isArray());
      assertFalse(class3.isEnum());
      assertFalse(class3.isSynthetic());
      assertEquals(1, class3.getModifiers());
      assertEquals("class java.text.RuleBasedCollator", class3.toString());
      
      Class<Double> class4 = Double.class;
      boolean boolean1 = TypeUtils.isPath(class4);
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
      
      Class<?> class5 = TypeUtils.getRawClass(class1);
      assertNotNull(class5);
      assertSame(class5, class2);
      assertSame(class5, class3);
      assertFalse(class5.isInterface());
      assertFalse(class5.isArray());
      assertFalse(class5.isAnnotation());
      assertEquals("class java.text.RuleBasedCollator", class5.toString());
      assertEquals(1, class5.getModifiers());
      assertFalse(class5.isPrimitive());
      assertFalse(class5.isEnum());
      assertFalse(class5.isSynthetic());
  }

  @Test(timeout = 4000)
  public void test070()  throws Throwable  {
      TimeDeserializer timeDeserializer0 = TimeDeserializer.instance;
      assertNotNull(timeDeserializer0);
      assertEquals(2, timeDeserializer0.getFastMatchToken());
      
      Class<Byte> class0 = Byte.TYPE;
      assertNotNull(class0);
      assertEquals(1041, class0.getModifiers());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertFalse(class0.isInterface());
      assertEquals("byte", class0.toString());
      assertFalse(class0.isArray());
      assertTrue(class0.isPrimitive());
      assertFalse(class0.isAnnotation());
      
      Class<?> class1 = TypeUtils.getClass((Type) class0);
      assertNotNull(class1);
      assertEquals(1041, class0.getModifiers());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertFalse(class0.isInterface());
      assertEquals("byte", class0.toString());
      assertFalse(class0.isArray());
      assertTrue(class0.isPrimitive());
      assertFalse(class0.isAnnotation());
      assertFalse(class1.isAnnotation());
      assertTrue(class1.isPrimitive());
      assertFalse(class1.isEnum());
      assertEquals(1041, class1.getModifiers());
      assertEquals("byte", class1.toString());
      assertFalse(class1.isSynthetic());
      assertFalse(class1.isArray());
      assertFalse(class1.isInterface());
      
      Class<?> class2 = TypeUtils.getCollectionItemClass(class1);
      assertNotNull(class2);
      assertNotSame(class1, class2);
      assertNotSame(class2, class1);
      assertEquals(1041, class0.getModifiers());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertFalse(class0.isInterface());
      assertEquals("byte", class0.toString());
      assertFalse(class0.isArray());
      assertTrue(class0.isPrimitive());
      assertFalse(class0.isAnnotation());
      assertFalse(class1.isAnnotation());
      assertTrue(class1.isPrimitive());
      assertFalse(class1.isEnum());
      assertEquals(1041, class1.getModifiers());
      assertEquals("byte", class1.toString());
      assertFalse(class1.isSynthetic());
      assertFalse(class1.isArray());
      assertFalse(class1.isInterface());
      assertFalse(class2.isPrimitive());
      assertEquals(1, class2.getModifiers());
      assertEquals("class java.lang.Object", class2.toString());
      assertFalse(class2.isInterface());
      assertFalse(class2.isArray());
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
      assertFalse(class2.isAnnotation());
      assertFalse(class2.equals((Object)class1));
      
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      assertNotNull(classLoader0);
      
      classLoader0.clearAssertionStatus();
      ASMDeserializerFactory aSMDeserializerFactory0 = new ASMDeserializerFactory(classLoader0);
      assertNotNull(aSMDeserializerFactory0);
      
      ParserConfig parserConfig0 = new ParserConfig(aSMDeserializerFactory0);
      assertNotNull(parserConfig0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      TimeDeserializer timeDeserializer1 = (TimeDeserializer)TypeUtils.cast((Object) timeDeserializer0, (Type) class2, parserConfig0);
      assertNotNull(timeDeserializer1);
      assertSame(timeDeserializer0, timeDeserializer1);
      assertNotSame(class1, class2);
      assertNotSame(class2, class1);
      assertSame(timeDeserializer1, timeDeserializer0);
      assertEquals(2, timeDeserializer0.getFastMatchToken());
      assertEquals(1041, class0.getModifiers());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertFalse(class0.isInterface());
      assertEquals("byte", class0.toString());
      assertFalse(class0.isArray());
      assertTrue(class0.isPrimitive());
      assertFalse(class0.isAnnotation());
      assertFalse(class1.isAnnotation());
      assertTrue(class1.isPrimitive());
      assertFalse(class1.isEnum());
      assertEquals(1041, class1.getModifiers());
      assertEquals("byte", class1.toString());
      assertFalse(class1.isSynthetic());
      assertFalse(class1.isArray());
      assertFalse(class1.isInterface());
      assertFalse(class2.isPrimitive());
      assertEquals(1, class2.getModifiers());
      assertEquals("class java.lang.Object", class2.toString());
      assertFalse(class2.isInterface());
      assertFalse(class2.isArray());
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
      assertFalse(class2.isAnnotation());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertEquals(2, timeDeserializer1.getFastMatchToken());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(class1.equals((Object)class2));
      assertFalse(class2.equals((Object)class1));
      
      NumberDeserializer numberDeserializer0 = (NumberDeserializer)parserConfig0.getDeserializer(class1, (Type) class0);
      assertNotNull(numberDeserializer0);
      assertNotSame(class1, class2);
      assertEquals(1041, class0.getModifiers());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertFalse(class0.isInterface());
      assertEquals("byte", class0.toString());
      assertFalse(class0.isArray());
      assertTrue(class0.isPrimitive());
      assertFalse(class0.isAnnotation());
      assertFalse(class1.isAnnotation());
      assertTrue(class1.isPrimitive());
      assertFalse(class1.isEnum());
      assertEquals(1041, class1.getModifiers());
      assertEquals("byte", class1.toString());
      assertFalse(class1.isSynthetic());
      assertFalse(class1.isArray());
      assertFalse(class1.isInterface());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertEquals(2, numberDeserializer0.getFastMatchToken());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(class1.equals((Object)class2));
      
      IllegalThreadStateException illegalThreadStateException0 = new IllegalThreadStateException("/**/");
      assertNotNull(illegalThreadStateException0);
      assertEquals("/**/", illegalThreadStateException0.getMessage());
      assertEquals("java.lang.IllegalThreadStateException: /**/", illegalThreadStateException0.toString());
      
      String string0 = TypeUtils.castToString(illegalThreadStateException0);
      assertNotNull(string0);
      assertEquals("/**/", illegalThreadStateException0.getMessage());
      assertEquals("java.lang.IllegalThreadStateException: /**/", illegalThreadStateException0.toString());
      
      String string1 = TypeUtils.castToString(class2);
      assertNotNull(string1);
      assertNotSame(class1, class2);
      assertNotSame(class2, class1);
      assertEquals(1041, class0.getModifiers());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertFalse(class0.isInterface());
      assertEquals("byte", class0.toString());
      assertFalse(class0.isArray());
      assertTrue(class0.isPrimitive());
      assertFalse(class0.isAnnotation());
      assertFalse(class1.isAnnotation());
      assertTrue(class1.isPrimitive());
      assertFalse(class1.isEnum());
      assertEquals(1041, class1.getModifiers());
      assertEquals("byte", class1.toString());
      assertFalse(class1.isSynthetic());
      assertFalse(class1.isArray());
      assertFalse(class1.isInterface());
      assertFalse(class2.isPrimitive());
      assertEquals(1, class2.getModifiers());
      assertEquals("class java.lang.Object", class2.toString());
      assertFalse(class2.isInterface());
      assertFalse(class2.isArray());
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
      assertFalse(class2.isAnnotation());
      assertFalse(class1.equals((Object)class2));
      assertFalse(class2.equals((Object)class1));
      assertFalse(string1.equals((Object)string0));
      
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.PascalCase;
      String string2 = propertyNamingStrategy0.translate("NDT");
      assertNotNull(string2);
      assertEquals("NDT", string2);
      assertFalse(string2.equals((Object)string1));
      assertFalse(string2.equals((Object)string0));
      
      Class<String> class3 = String.class;
      NumberFormatException numberFormatException0 = new NumberFormatException();
      assertNotNull(numberFormatException0);
      assertNull(numberFormatException0.getMessage());
      assertEquals("java.lang.NumberFormatException", numberFormatException0.toString());
      
      String string3 = TypeUtils.cast((Object) numberFormatException0, class3, parserConfig0);
      assertNotNull(string3);
      assertNull(numberFormatException0.getMessage());
      assertEquals("java.lang.NumberFormatException", numberFormatException0.toString());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(string3.equals((Object)string0));
      assertFalse(string3.equals((Object)string1));
      assertFalse(string3.equals((Object)string2));
      
      TreeMap<StackTraceElement, SQLException> treeMap0 = new TreeMap<StackTraceElement, SQLException>();
      assertNotNull(treeMap0);
      assertEquals(0, treeMap0.size());
      
      Class<Time> class4 = Time.class;
      // Undeclared exception!
      try { 
        TypeUtils.castToEnum((Object) "java.lang.Class@0000000041", class4, parserConfig0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to : java.sql.Time
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test071()  throws Throwable  {
      boolean boolean0 = TypeUtils.isNumber("char");
      assertFalse(boolean0);
      
      Class<SimpleDateFormat> class0 = SimpleDateFormat.class;
      ThreadGroup threadGroup0 = new ThreadGroup("char");
      assertNotNull(threadGroup0);
      assertEquals("char", threadGroup0.getName());
      
      ThreadGroup threadGroup1 = new ThreadGroup(threadGroup0, "char");
      assertNotNull(threadGroup1);
      assertEquals("char", threadGroup0.getName());
      assertEquals("char", threadGroup1.getName());
      assertFalse(threadGroup1.equals((Object)threadGroup0));
      
      MockThread mockThread0 = new MockThread("rAr5=vRnei");
      assertNotNull(mockThread0);
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      
      MockThread mockThread1 = new MockThread(threadGroup1, mockThread0, "char", 2599L);
      assertNotNull(mockThread1);
      assertEquals("char", threadGroup0.getName());
      assertEquals("char", threadGroup1.getName());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.isDaemon());
      assertFalse(threadGroup0.equals((Object)threadGroup1));
      assertFalse(threadGroup1.equals((Object)threadGroup0));
      assertFalse(mockThread1.equals((Object)mockThread0));
      
      ClassLoader classLoader0 = mockThread1.getContextClassLoader();
      assertNotNull(classLoader0);
      assertNotSame(threadGroup0, threadGroup1);
      assertNotSame(threadGroup1, threadGroup0);
      assertNotSame(mockThread0, mockThread1);
      assertNotSame(mockThread1, mockThread0);
      assertEquals("char", threadGroup0.getName());
      assertEquals("char", threadGroup1.getName());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.isDaemon());
      assertFalse(threadGroup0.equals((Object)threadGroup1));
      assertFalse(threadGroup1.equals((Object)threadGroup0));
      assertFalse(mockThread0.equals((Object)mockThread1));
      assertFalse(mockThread1.equals((Object)mockThread0));
      
      ParserConfig parserConfig0 = new ParserConfig(classLoader0);
      assertNotNull(parserConfig0);
      assertEquals("char", threadGroup0.getName());
      assertEquals("char", threadGroup1.getName());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.isDaemon());
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(threadGroup0.equals((Object)threadGroup1));
      assertFalse(threadGroup1.equals((Object)threadGroup0));
      assertFalse(mockThread0.equals((Object)mockThread1));
      assertFalse(mockThread1.equals((Object)mockThread0));
      
      // Undeclared exception!
      try { 
        TypeUtils.castToEnum((Object) "rAr5=vRnei", class0, parserConfig0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to : java.text.SimpleDateFormat
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test072()  throws Throwable  {
      TreeMap<String, Object> treeMap0 = new TreeMap<String, Object>();
      assertNotNull(treeMap0);
      assertEquals(0, treeMap0.size());
      
      String string0 = "getgetFastMatchToken";
      String string1 = treeMap0.floorKey("getgetFastMatchToken");
      assertNull(string1);
      assertEquals(0, treeMap0.size());
      
      ParserConfig parserConfig0 = new ParserConfig((ClassLoader) null);
      assertNotNull(parserConfig0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      
      GenericArrayType genericArrayType0 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl parameterizedTypeImpl0 = (sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl)TypeReference.LIST_STRING;
      assertNotNull(parameterizedTypeImpl0);
      
      Class<?> class0 = TypeUtils.getClass((Type) parameterizedTypeImpl0);
      assertNotNull(class0);
      assertFalse(class0.isArray());
      assertFalse(class0.isAnnotation());
      assertEquals("interface java.util.List", class0.toString());
      assertFalse(class0.isPrimitive());
      assertTrue(class0.isInterface());
      assertEquals(1537, class0.getModifiers());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.CamelCase;
      TreeMap<String, String> treeMap1 = new TreeMap<String, String>();
      assertNotNull(treeMap1);
      assertEquals(0, treeMap1.size());
      
      List<FieldInfo> list0 = TypeUtils.computeGettersWithFieldBase(class0, treeMap1, true, propertyNamingStrategy0);
      assertNotNull(list0);
      assertFalse(class0.isArray());
      assertFalse(class0.isAnnotation());
      assertEquals("interface java.util.List", class0.toString());
      assertFalse(class0.isPrimitive());
      assertTrue(class0.isInterface());
      assertEquals(1537, class0.getModifiers());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertEquals(0, treeMap1.size());
      assertTrue(list0.isEmpty());
      assertEquals(0, list0.size());
      
      Double double0 = new Double(0.0);
      assertNotNull(double0);
      assertEquals(0.0, (double)double0, 0.01);
      
      JSONPDeserializer jSONPDeserializer0 = JSONPDeserializer.instance;
      assertNotNull(jSONPDeserializer0);
      assertEquals(0, jSONPDeserializer0.getFastMatchToken());
      
      int int0 = 10;
      DataTruncation dataTruncation0 = new DataTruncation(104, true, false, 10, 95);
      assertNotNull(dataTruncation0);
      assertEquals("22001", dataTruncation0.getSQLState());
      assertEquals("java.sql.DataTruncation: Data truncation", dataTruncation0.toString());
      assertEquals("Data truncation", dataTruncation0.getMessage());
      assertEquals(0, dataTruncation0.getErrorCode());
      
      // Undeclared exception!
      try { 
        TypeUtils.castToBytes(double0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to int, value : 0.0
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test073()  throws Throwable  {
      ConcurrentHashMap<String, String> concurrentHashMap0 = new ConcurrentHashMap<String, String>();
      assertNotNull(concurrentHashMap0);
      assertTrue(concurrentHashMap0.isEmpty());
      
      String string0 = concurrentHashMap0.put("Xh", "Xh");
      assertNull(string0);
      assertFalse(concurrentHashMap0.isEmpty());
      
      MockThread mockThread0 = new MockThread((ThreadGroup) null, (Runnable) null);
      assertNotNull(mockThread0);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      
      ClassLoader classLoader0 = mockThread0.getContextClassLoader();
      assertNotNull(classLoader0);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      
      ClassLoader classLoader1 = mockThread0.getContextClassLoader();
      assertNotNull(classLoader1);
      assertSame(classLoader1, classLoader0);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      
      classLoader1.setDefaultAssertionStatus(false);
      assertSame(classLoader1, classLoader0);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      
      mockThread0.run();
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      
      ClassLoader classLoader2 = classLoader1.getParent();
      assertNotNull(classLoader2);
      assertSame(classLoader1, classLoader0);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(classLoader2.equals((Object)classLoader1));
      assertFalse(classLoader2.equals((Object)classLoader0));
      
      ClassLoader classLoader3 = classLoader0.getParent();
      assertNotNull(classLoader3);
      assertSame(classLoader0, classLoader1);
      assertSame(classLoader3, classLoader2);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(classLoader0.equals((Object)classLoader2));
      assertFalse(classLoader3.equals((Object)classLoader1));
      assertFalse(classLoader3.equals((Object)classLoader0));
      
      ClassLoader classLoader4 = classLoader3.getParent();
      assertNotNull(classLoader4);
      assertSame(classLoader0, classLoader1);
      assertSame(classLoader3, classLoader2);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(classLoader0.equals((Object)classLoader2));
      assertFalse(classLoader0.equals((Object)classLoader3));
      assertFalse(classLoader3.equals((Object)classLoader1));
      assertFalse(classLoader3.equals((Object)classLoader0));
      assertFalse(classLoader4.equals((Object)classLoader2));
      assertFalse(classLoader4.equals((Object)classLoader3));
      assertFalse(classLoader4.equals((Object)classLoader0));
      assertFalse(classLoader4.equals((Object)classLoader1));
      
      classLoader4.setClassAssertionStatus((String) null, false);
      assertSame(classLoader0, classLoader1);
      assertSame(classLoader3, classLoader2);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(classLoader0.equals((Object)classLoader2));
      assertFalse(classLoader0.equals((Object)classLoader4));
      assertFalse(classLoader0.equals((Object)classLoader3));
      assertFalse(classLoader3.equals((Object)classLoader1));
      assertFalse(classLoader3.equals((Object)classLoader4));
      assertFalse(classLoader3.equals((Object)classLoader0));
      assertFalse(classLoader4.equals((Object)classLoader2));
      assertFalse(classLoader4.equals((Object)classLoader3));
      assertFalse(classLoader4.equals((Object)classLoader0));
      assertFalse(classLoader4.equals((Object)classLoader1));
      
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      String string1 = weakHashMap0.put("`Q", "*6]LQDu");
      assertNull(string1);
      
      Class<SQLTransientConnectionException> class0 = SQLTransientConnectionException.class;
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class0, (Map<String, String>) weakHashMap0);
      assertNotNull(list0);
      assertTrue(list0.isEmpty());
      assertEquals(0, list0.size());
      
      Short short0 = new Short((short)74);
      assertNotNull(short0);
      assertEquals((short)74, (short)short0);
      
      Boolean boolean0 = new Boolean("*6]LQDu");
      assertNotNull(boolean0);
      assertFalse(boolean0);
      
      Integer integer0 = TypeUtils.castToInt((Object) null);
      assertNull(integer0);
      
      // Undeclared exception!
      try { 
        TypeUtils.castToBoolean("Xh");
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to boolean, value : Xh
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test074()  throws Throwable  {
      JSONObject jSONObject0 = new JSONObject();
      assertNotNull(jSONObject0);
      assertEquals(0, jSONObject0.size());
      assertTrue(jSONObject0.isEmpty());
      assertEquals(989, JSON.DEFAULT_PARSER_FEATURE);
      assertEquals(3089, JSON.DEFAULT_GENERATE_FEATURE);
      
      MockThread mockThread0 = new MockThread();
      assertNotNull(mockThread0);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      
      ClassLoader classLoader0 = mockThread0.getContextClassLoader();
      assertNotNull(classLoader0);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      
      ClassLoader classLoader1 = classLoader0.getParent();
      assertNotNull(classLoader1);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      ParserConfig parserConfig0 = new ParserConfig(classLoader1);
      assertNotNull(parserConfig0);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig0.fieldBased);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(classLoader0.equals((Object)classLoader1));
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      ObjectArrayCodec objectArrayCodec0 = ObjectArrayCodec.instance;
      assertNotNull(objectArrayCodec0);
      assertEquals(14, objectArrayCodec0.getFastMatchToken());
      
      JSONType jSONType0 = mock(JSONType.class, new ViolatedAssumptionAnswer());
      LinkedHashMap<String, String> linkedHashMap0 = new LinkedHashMap<String, String>();
      assertNotNull(linkedHashMap0);
      assertTrue(linkedHashMap0.isEmpty());
      assertEquals(0, linkedHashMap0.size());
      
      classLoader0.clearAssertionStatus();
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(classLoader0.equals((Object)classLoader1));
      
      ClassLoader classLoader2 = classLoader1.getParent();
      assertNotNull(classLoader2);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(classLoader0.equals((Object)classLoader1));
      assertFalse(classLoader1.equals((Object)classLoader0));
      assertFalse(classLoader2.equals((Object)classLoader1));
      assertFalse(classLoader2.equals((Object)classLoader0));
      
      classLoader2.setClassAssertionStatus("gjdkcS8<((7^WaXcFd", true);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(classLoader0.equals((Object)classLoader2));
      assertFalse(classLoader0.equals((Object)classLoader1));
      assertFalse(classLoader1.equals((Object)classLoader0));
      assertFalse(classLoader1.equals((Object)classLoader2));
      assertFalse(classLoader2.equals((Object)classLoader1));
      assertFalse(classLoader2.equals((Object)classLoader0));
      
      LinkedHashMap<Jdk8DateCodec, ChoiceFormat> linkedHashMap1 = new LinkedHashMap<Jdk8DateCodec, ChoiceFormat>();
      assertNotNull(linkedHashMap1);
      assertTrue(linkedHashMap1.isEmpty());
      assertEquals(0, linkedHashMap1.size());
      
      Class<Integer> class0 = Integer.TYPE;
      assertNotNull(class0);
      assertFalse(class0.isAnnotation());
      assertFalse(class0.isInterface());
      assertFalse(class0.isArray());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertEquals("int", class0.toString());
      assertEquals(1041, class0.getModifiers());
      assertTrue(class0.isPrimitive());
      
      Class<?> class1 = TypeUtils.getClass((Type) class0);
      assertNotNull(class1);
      assertFalse(class0.isAnnotation());
      assertFalse(class0.isInterface());
      assertFalse(class0.isArray());
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertEquals("int", class0.toString());
      assertEquals(1041, class0.getModifiers());
      assertTrue(class0.isPrimitive());
      assertEquals("int", class1.toString());
      assertEquals(1041, class1.getModifiers());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertTrue(class1.isPrimitive());
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      
      IllegalMonitorStateException illegalMonitorStateException0 = new IllegalMonitorStateException();
      assertNotNull(illegalMonitorStateException0);
      assertEquals("java.lang.IllegalMonitorStateException", illegalMonitorStateException0.toString());
      assertNull(illegalMonitorStateException0.getMessage());
      
      SecurityException securityException0 = new SecurityException("GonFO", illegalMonitorStateException0);
      assertNotNull(securityException0);
      assertEquals("java.lang.IllegalMonitorStateException", illegalMonitorStateException0.toString());
      assertNull(illegalMonitorStateException0.getMessage());
      assertEquals("java.lang.SecurityException: GonFO", securityException0.toString());
      assertEquals("GonFO", securityException0.getMessage());
      
      // Undeclared exception!
      try { 
        TypeUtils.cast((Object) illegalMonitorStateException0, (Type) class1, parserConfig0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to int, value : java.lang.IllegalMonitorStateException
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test075()  throws Throwable  {
      TreeMap<String, Object> treeMap0 = new TreeMap<String, Object>();
      assertNotNull(treeMap0);
      assertEquals(0, treeMap0.size());
      
      String string0 = treeMap0.floorKey("getgetFastMatchToken");
      assertNull(string0);
      assertEquals(0, treeMap0.size());
      
      ParserConfig parserConfig0 = new ParserConfig((ClassLoader) null);
      assertNotNull(parserConfig0);
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(14, 9, 14, 14, 14);
      assertNotNull(mockGregorianCalendar0);
      assertTrue(mockGregorianCalendar0.isLenient());
      assertEquals(1, mockGregorianCalendar0.getMinimalDaysInFirstWeek());
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=?,areFieldsSet=false,areAllFieldsSet=false,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=?,YEAR=14,MONTH=9,WEEK_OF_YEAR=?,WEEK_OF_MONTH=?,DAY_OF_MONTH=14,DAY_OF_YEAR=?,DAY_OF_WEEK=?,DAY_OF_WEEK_IN_MONTH=?,AM_PM=1,HOUR=2,HOUR_OF_DAY=14,MINUTE=14,SECOND=0,MILLISECOND=?,ZONE_OFFSET=?,DST_OFFSET=?]", mockGregorianCalendar0.toString());
      assertEquals(1, mockGregorianCalendar0.getFirstDayOfWeek());
      
      mockGregorianCalendar0.set(89, 9, 9, 1, (-1921));
      assertTrue(mockGregorianCalendar0.isLenient());
      assertEquals(1, mockGregorianCalendar0.getMinimalDaysInFirstWeek());
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=?,areFieldsSet=false,areAllFieldsSet=false,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=?,YEAR=89,MONTH=9,WEEK_OF_YEAR=?,WEEK_OF_MONTH=?,DAY_OF_MONTH=9,DAY_OF_YEAR=?,DAY_OF_WEEK=?,DAY_OF_WEEK_IN_MONTH=?,AM_PM=1,HOUR=2,HOUR_OF_DAY=1,MINUTE=-1921,SECOND=0,MILLISECOND=?,ZONE_OFFSET=?,DST_OFFSET=?]", mockGregorianCalendar0.toString());
      assertEquals(1, mockGregorianCalendar0.getFirstDayOfWeek());
      
      MockDate mockDate0 = new MockDate();
      assertNotNull(mockDate0);
      assertEquals("Fri Feb 14 20:21:21 GMT 2014", mockDate0.toString());
      
      Date date0 = TypeUtils.castToSqlDate(mockDate0);
      assertNotNull(date0);
      assertEquals("Fri Feb 14 20:21:21 GMT 2014", mockDate0.toString());
      
      BatchUpdateException batchUpdateException0 = new BatchUpdateException();
      assertNotNull(batchUpdateException0);
      assertEquals("java.sql.BatchUpdateException", batchUpdateException0.toString());
      assertNull(batchUpdateException0.getSQLState());
      assertNull(batchUpdateException0.getMessage());
      assertEquals(0, batchUpdateException0.getErrorCode());
      
      ParserConfig parserConfig1 = ParserConfig.global;
      assertNotNull(parserConfig1);
      assertNotSame(parserConfig1, parserConfig0);
      assertFalse(parserConfig1.isAutoTypeSupport());
      assertTrue(parserConfig1.isAsmEnable());
      assertTrue(parserConfig1.compatibleWithJavaBean);
      assertFalse(parserConfig1.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig1.equals((Object)parserConfig0));
      
      TreeMap<String, String> treeMap1 = new TreeMap<String, String>();
      assertNotNull(treeMap1);
      assertEquals(0, treeMap1.size());
      
      Class<SQLTransientConnectionException> class0 = SQLTransientConnectionException.class;
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class0, (Map<String, String>) treeMap1);
      assertNotNull(list0);
      assertEquals(0, treeMap1.size());
      assertEquals(0, list0.size());
      assertTrue(list0.isEmpty());
      
      ParserConfig parserConfig2 = new ParserConfig(false);
      assertNotNull(parserConfig2);
      assertFalse(parserConfig2.isAutoTypeSupport());
      assertTrue(parserConfig2.isAsmEnable());
      assertTrue(parserConfig2.compatibleWithJavaBean);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig2.fieldBased);
      assertFalse(parserConfig2.equals((Object)parserConfig1));
      assertFalse(parserConfig2.equals((Object)parserConfig0));
      
      Class<Byte> class1 = Byte.TYPE;
      assertNotNull(class1);
      assertEquals(1041, class1.getModifiers());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertTrue(class1.isPrimitive());
      assertFalse(class1.isAnnotation());
      assertEquals("byte", class1.toString());
      assertFalse(class1.isArray());
      assertFalse(class1.isInterface());
      
      boolean boolean0 = TypeUtils.isGenericParamType(class1);
      assertEquals(1041, class1.getModifiers());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertTrue(class1.isPrimitive());
      assertFalse(class1.isAnnotation());
      assertEquals("byte", class1.toString());
      assertFalse(class1.isArray());
      assertFalse(class1.isInterface());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test076()  throws Throwable  {
      AtomicLong atomicLong0 = new AtomicLong(0L);
      assertNotNull(atomicLong0);
      assertEquals(0L, atomicLong0.get());
      assertEquals((byte)0, atomicLong0.byteValue());
      assertEquals(0L, atomicLong0.longValue());
      assertEquals(0.0, atomicLong0.doubleValue(), 0.01);
      assertEquals((short)0, atomicLong0.shortValue());
      assertEquals(0, atomicLong0.intValue());
      assertEquals("0", atomicLong0.toString());
      assertEquals(0.0F, atomicLong0.floatValue(), 0.01F);
      
      ParserConfig parserConfig0 = ParserConfig.global;
      assertNotNull(parserConfig0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig0.fieldBased);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      
      LongUnaryOperator longUnaryOperator0 = mock(LongUnaryOperator.class, new ViolatedAssumptionAnswer());
      doReturn(0L).when(longUnaryOperator0).applyAsLong(anyLong());
      long long0 = atomicLong0.getAndUpdate(longUnaryOperator0);
      assertEquals(0L, atomicLong0.get());
      assertEquals((byte)0, atomicLong0.byteValue());
      assertEquals(0L, atomicLong0.longValue());
      assertEquals(0.0, atomicLong0.doubleValue(), 0.01);
      assertEquals((short)0, atomicLong0.shortValue());
      assertEquals(0, atomicLong0.intValue());
      assertEquals("0", atomicLong0.toString());
      assertEquals(0.0F, atomicLong0.floatValue(), 0.01F);
      assertEquals(0L, long0);
      
      ToDoubleFunction<Object> toDoubleFunction0 = (ToDoubleFunction<Object>) mock(ToDoubleFunction.class, new ViolatedAssumptionAnswer());
      doReturn(0.0, 0.0, 0.0, 0.0, 0.0).when(toDoubleFunction0).applyAsDouble(any());
      Comparator<Object> comparator0 = Comparator.comparingDouble((ToDoubleFunction<? super Object>) toDoubleFunction0);
      assertNotNull(comparator0);
      
      TreeMap<String, Object> treeMap0 = new TreeMap<String, Object>(comparator0);
      assertNotNull(treeMap0);
      assertEquals(0, treeMap0.size());
      
      WeakHashMap<OutOfMemoryError, SQLFeatureNotSupportedException> weakHashMap0 = new WeakHashMap<OutOfMemoryError, SQLFeatureNotSupportedException>();
      assertNotNull(weakHashMap0);
      
      Object object0 = treeMap0.putIfAbsent("can not cast oracle.sql.TIMESTAMP to Date", weakHashMap0);
      assertNull(object0);
      assertEquals(1, treeMap0.size());
      
      parserConfig0.setAutoTypeSupport(false);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig0.fieldBased);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      
      String string0 = "org.springframework.security.core.userdetails.User";
      ObjectArrayCodec objectArrayCodec0 = new ObjectArrayCodec();
      assertNotNull(objectArrayCodec0);
      assertEquals(14, objectArrayCodec0.getFastMatchToken());
      
      Object object1 = treeMap0.put("v#~kD=}AI+(OT90DRNH", "org.springframework.security.core.userdetails.User");
      assertNotNull(object1);
      assertEquals(1, treeMap0.size());
      
      SortedMap<String, Object> sortedMap0 = treeMap0.tailMap("fastjson.parser.autoTypeAccept");
      assertNotNull(sortedMap0);
      assertEquals(1, treeMap0.size());
      assertEquals(1, sortedMap0.size());
      assertFalse(sortedMap0.isEmpty());
      
      ThreadGroup threadGroup0 = new ThreadGroup("fastjson.parser.autoTypeSupport");
      assertNotNull(threadGroup0);
      assertEquals("fastjson.parser.autoTypeSupport", threadGroup0.getName());
      
      MockThread mockThread0 = new MockThread();
      assertNotNull(mockThread0);
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      
      MockThread mockThread1 = new MockThread(threadGroup0, mockThread0, "cs5\"o/\u0001j/?}jFbE", 0L);
      assertNotNull(mockThread1);
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.isDaemon());
      assertEquals("fastjson.parser.autoTypeSupport", threadGroup0.getName());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread1.equals((Object)mockThread0));
      
      ClassLoader classLoader0 = mockThread1.getContextClassLoader();
      assertNotNull(classLoader0);
      assertNotSame(mockThread1, mockThread0);
      assertNotSame(mockThread0, mockThread1);
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.isDaemon());
      assertEquals("fastjson.parser.autoTypeSupport", threadGroup0.getName());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread1.equals((Object)mockThread0));
      assertFalse(mockThread0.equals((Object)mockThread1));
      
      ParserConfig parserConfig1 = new ParserConfig(classLoader0);
      assertNotNull(parserConfig1);
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.isDaemon());
      assertTrue(parserConfig1.isAsmEnable());
      assertFalse(parserConfig1.isAutoTypeSupport());
      assertEquals("fastjson.parser.autoTypeSupport", threadGroup0.getName());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(parserConfig1.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig1.compatibleWithJavaBean);
      assertFalse(mockThread1.equals((Object)mockThread0));
      assertFalse(parserConfig1.equals((Object)parserConfig0));
      assertFalse(mockThread0.equals((Object)mockThread1));
      
      parserConfig1.addDeny("can not cast oracle.sql.TIMESTAMP to Date");
      assertNotSame(mockThread1, mockThread0);
      assertNotSame(parserConfig1, parserConfig0);
      assertNotSame(mockThread0, mockThread1);
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.isDaemon());
      assertTrue(parserConfig1.isAsmEnable());
      assertFalse(parserConfig1.isAutoTypeSupport());
      assertEquals("fastjson.parser.autoTypeSupport", threadGroup0.getName());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(parserConfig1.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig1.compatibleWithJavaBean);
      assertFalse(mockThread1.equals((Object)mockThread0));
      assertFalse(parserConfig1.equals((Object)parserConfig0));
      assertFalse(mockThread0.equals((Object)mockThread1));
      
      Class<SimpleDateFormat> class0 = SimpleDateFormat.class;
      // Undeclared exception!
      try { 
        TypeUtils.castToJavaBean((Map<String, Object>) sortedMap0, class0, parserConfig1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // autoType is not support. org.springframework.security.core.userdetails.User
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test077()  throws Throwable  {
      Class<MockJapaneseDate> class0 = MockJapaneseDate.class;
      boolean boolean0 = TypeUtils.isProxy(class0);
      assertFalse(boolean0);
      
      LinkedList<FieldInfo> linkedList0 = new LinkedList<FieldInfo>();
      assertNotNull(linkedList0);
      assertEquals(0, linkedList0.size());
      
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      assertNotNull(classLoader0);
      
      ClassLoader classLoader1 = classLoader0.getParent();
      assertNotNull(classLoader1);
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      ASMDeserializerFactory aSMDeserializerFactory0 = new ASMDeserializerFactory(classLoader1);
      assertNotNull(aSMDeserializerFactory0);
      assertFalse(classLoader0.equals((Object)classLoader1));
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      ASMClassLoader aSMClassLoader0 = aSMDeserializerFactory0.classLoader;
      assertNotNull(aSMClassLoader0);
      
      Class<?> class1 = TypeUtils.loadClass((String) null, (ClassLoader) aSMClassLoader0);
      assertNull(class1);
      assertFalse(classLoader0.equals((Object)classLoader1));
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      String string0 = weakHashMap0.put((String) null, (String) null);
      assertNull(string0);
      
      Class<NoClassDefFoundError> class2 = NoClassDefFoundError.class;
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class2, (Map<String, String>) weakHashMap0);
      assertNotNull(list0);
      assertEquals(0, list0.size());
      assertTrue(list0.isEmpty());
      
      Short short0 = new Short((short)7);
      assertNotNull(short0);
      assertEquals((short)7, (short)short0);
      
      // Undeclared exception!
      try { 
        TypeUtils.castToInt(classLoader0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to int, value : sun.misc.Launcher$AppClassLoader@6bc7c054
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test078()  throws Throwable  {
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      Class<ClassLoader> class0 = ClassLoader.class;
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.PascalCase;
      List<FieldInfo> list0 = TypeUtils.computeGettersWithFieldBase(class0, weakHashMap0, false, propertyNamingStrategy0);
      assertNotNull(list0);
      assertTrue(list0.isEmpty());
      assertEquals(0, list0.size());
      
      OutOfMemoryError outOfMemoryError0 = new OutOfMemoryError("'w~b");
      assertNotNull(outOfMemoryError0);
      assertEquals("java.lang.OutOfMemoryError: 'w~b", outOfMemoryError0.toString());
      assertEquals("'w~b", outOfMemoryError0.getMessage());
      
      Throwable throwable0 = outOfMemoryError0.fillInStackTrace();
      assertNotNull(throwable0);
      assertSame(outOfMemoryError0, throwable0);
      assertSame(throwable0, outOfMemoryError0);
      assertEquals("java.lang.OutOfMemoryError: 'w~b", outOfMemoryError0.toString());
      assertEquals("'w~b", outOfMemoryError0.getMessage());
      assertEquals("java.lang.OutOfMemoryError: 'w~b", throwable0.toString());
      assertEquals("'w~b", throwable0.getMessage());
      
      SQLRecoverableException sQLRecoverableException0 = new SQLRecoverableException();
      assertNotNull(sQLRecoverableException0);
      assertNull(sQLRecoverableException0.getMessage());
      assertNull(sQLRecoverableException0.getSQLState());
      assertEquals(0, sQLRecoverableException0.getErrorCode());
      assertEquals("java.sql.SQLRecoverableException", sQLRecoverableException0.toString());
      
      // Undeclared exception!
      try { 
        TypeUtils.castToSqlDate("!X\"NFaL$Xqp#*'");
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to Timestamp, value : !X\"NFaL$Xqp#*'
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test079()  throws Throwable  {
      Class<Jdk8DateCodec> class0 = Jdk8DateCodec.class;
      Map<String, String> map0 = ZoneId.SHORT_IDS;
      assertNotNull(map0);
      assertFalse(map0.isEmpty());
      assertEquals(28, map0.size());
      
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.SnakeCase;
      List<FieldInfo> list0 = TypeUtils.computeGettersWithFieldBase(class0, map0, true, propertyNamingStrategy0);
      assertNotNull(list0);
      assertFalse(map0.isEmpty());
      assertEquals(28, map0.size());
      assertEquals(0, list0.size());
      assertTrue(list0.isEmpty());
      
      boolean boolean0 = TypeUtils.isNumber("Ljava.awt.Rectangle");
      assertFalse(boolean0);
      
      MockThread mockThread0 = new MockThread((ThreadGroup) null, (Runnable) null);
      assertNotNull(mockThread0);
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      
      ClassLoader classLoader0 = mockThread0.getContextClassLoader();
      assertNotNull(classLoader0);
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      
      ClassLoader classLoader1 = mockThread0.getContextClassLoader();
      assertNotNull(classLoader1);
      assertSame(classLoader1, classLoader0);
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      
      classLoader1.setDefaultAssertionStatus(false);
      assertSame(classLoader1, classLoader0);
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      
      mockThread0.run();
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      
      IllegalThreadStateException illegalThreadStateException0 = new IllegalThreadStateException("/");
      assertNotNull(illegalThreadStateException0);
      assertEquals("/", illegalThreadStateException0.getMessage());
      assertEquals("java.lang.IllegalThreadStateException: /", illegalThreadStateException0.toString());
      
      SecurityException securityException0 = new SecurityException("getEndInclusive", illegalThreadStateException0);
      assertNotNull(securityException0);
      assertEquals("/", illegalThreadStateException0.getMessage());
      assertEquals("java.lang.IllegalThreadStateException: /", illegalThreadStateException0.toString());
      assertEquals("java.lang.SecurityException: getEndInclusive", securityException0.toString());
      assertEquals("getEndInclusive", securityException0.getMessage());
      
      ConcurrentHashMap<String, Field> concurrentHashMap0 = new ConcurrentHashMap<String, Field>();
      assertNotNull(concurrentHashMap0);
      assertTrue(concurrentHashMap0.isEmpty());
      
      Field field0 = ParserConfig.getFieldFromCache("nextException", concurrentHashMap0);
      assertNull(field0);
      assertTrue(concurrentHashMap0.isEmpty());
      
      Object object0 = new Object();
      assertNotNull(object0);
      
      Class<String> class1 = String.class;
      ASMDeserializerFactory aSMDeserializerFactory0 = new ASMDeserializerFactory(classLoader0);
      assertNotNull(aSMDeserializerFactory0);
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      
      ParserConfig parserConfig0 = new ParserConfig(aSMDeserializerFactory0);
      assertNotNull(parserConfig0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig0.fieldBased);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      
      String string0 = TypeUtils.cast((Object) "Ljava.awt.Rectangle", class1, parserConfig0);
      assertNotNull(string0);
      assertSame(classLoader0, classLoader1);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertEquals("Ljava.awt.Rectangle", string0);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig0.fieldBased);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      
      OutOfMemoryError outOfMemoryError0 = new OutOfMemoryError("Ljava.awt.Rectangle");
      assertNotNull(outOfMemoryError0);
      assertEquals("Ljava.awt.Rectangle", outOfMemoryError0.getMessage());
      assertEquals("java.lang.OutOfMemoryError: Ljava.awt.Rectangle", outOfMemoryError0.toString());
      
      Throwable throwable0 = outOfMemoryError0.fillInStackTrace();
      assertNotNull(throwable0);
      assertSame(outOfMemoryError0, throwable0);
      assertSame(throwable0, outOfMemoryError0);
      assertEquals("Ljava.awt.Rectangle", outOfMemoryError0.getMessage());
      assertEquals("java.lang.OutOfMemoryError: Ljava.awt.Rectangle", outOfMemoryError0.toString());
      assertEquals("Ljava.awt.Rectangle", throwable0.getMessage());
      assertEquals("java.lang.OutOfMemoryError: Ljava.awt.Rectangle", throwable0.toString());
      
      SQLRecoverableException sQLRecoverableException0 = new SQLRecoverableException();
      assertNotNull(sQLRecoverableException0);
      assertEquals(0, sQLRecoverableException0.getErrorCode());
      assertNull(sQLRecoverableException0.getMessage());
      assertNull(sQLRecoverableException0.getSQLState());
      assertEquals("java.sql.SQLRecoverableException", sQLRecoverableException0.toString());
      
      Point point0 = new Point(2203, 2865);
      assertNotNull(point0);
      assertEquals(2203.0, point0.getX(), 0.01);
      assertEquals(2865.0, point0.getY(), 0.01);
      assertEquals(2865, point0.y);
      assertEquals(2203, point0.x);
      
      Point point1 = new Point(point0);
      assertNotNull(point1);
      assertEquals(2203.0, point0.getX(), 0.01);
      assertEquals(2865.0, point0.getY(), 0.01);
      assertEquals(2203.0, point1.getX(), 0.01);
      assertEquals(2865.0, point1.getY(), 0.01);
      assertEquals(2865, point0.y);
      assertEquals(2203, point0.x);
      assertEquals(2203, point1.x);
      assertEquals(2865, point1.y);
      assertTrue(point1.equals((Object)point0));
      
      // Undeclared exception!
      try { 
        TypeUtils.castToSqlDate(map0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to Date, value : {CTT=Asia/Shanghai, ART=Africa/Cairo, CNT=America/St_Johns, PRT=America/Puerto_Rico, PNT=America/Phoenix, PLT=Asia/Karachi, AST=America/Anchorage, BST=Asia/Dhaka, CST=America/Chicago, EST=-05:00, HST=-10:00, JST=Asia/Tokyo, IST=Asia/Kolkata, AGT=America/Argentina/Buenos_Aires, NST=Pacific/Auckland, MST=-07:00, AET=Australia/Sydney, BET=America/Sao_Paulo, PST=America/Los_Angeles, ACT=Australia/Darwin, SST=Pacific/Guadalcanal, VST=Asia/Ho_Chi_Minh, CAT=Africa/Harare, ECT=Europe/Paris, EAT=Africa/Addis_Ababa, IET=America/Indiana/Indianapolis, MIT=Pacific/Apia, NET=Asia/Yerevan}
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test080()  throws Throwable  {
      JSONObject jSONObject0 = new JSONObject();
      assertNotNull(jSONObject0);
      assertEquals(0, jSONObject0.size());
      assertTrue(jSONObject0.isEmpty());
      assertEquals(989, JSON.DEFAULT_PARSER_FEATURE);
      assertEquals(3089, JSON.DEFAULT_GENERATE_FEATURE);
      
      MockThread mockThread0 = new MockThread();
      assertNotNull(mockThread0);
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      
      ClassLoader classLoader0 = mockThread0.getContextClassLoader();
      assertNotNull(classLoader0);
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      
      ClassLoader classLoader1 = classLoader0.getParent();
      assertNotNull(classLoader1);
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      ParserConfig parserConfig0 = new ParserConfig(classLoader1);
      assertNotNull(parserConfig0);
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(classLoader0.equals((Object)classLoader1));
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      TypeUtils.clearClassMapping();
      Class<SecurityException> class0 = SecurityException.class;
      AtomicInteger atomicInteger0 = new AtomicInteger(3089);
      assertNotNull(atomicInteger0);
      assertEquals((byte)17, atomicInteger0.byteValue());
      assertEquals(3089, atomicInteger0.intValue());
      assertEquals(3089L, atomicInteger0.longValue());
      assertEquals(3089.0, atomicInteger0.doubleValue(), 0.01);
      assertEquals(3089.0F, atomicInteger0.floatValue(), 0.01F);
      assertEquals(3089, atomicInteger0.get());
      assertEquals("3089", atomicInteger0.toString());
      assertEquals((short)3089, atomicInteger0.shortValue());
      
      java.util.Date date0 = TypeUtils.castToDate(atomicInteger0);
      assertNotNull(date0);
      assertEquals((byte)17, atomicInteger0.byteValue());
      assertEquals(3089, atomicInteger0.intValue());
      assertEquals(3089L, atomicInteger0.longValue());
      assertEquals(3089.0, atomicInteger0.doubleValue(), 0.01);
      assertEquals(3089.0F, atomicInteger0.floatValue(), 0.01F);
      assertEquals(3089, atomicInteger0.get());
      assertEquals("3089", atomicInteger0.toString());
      assertEquals((short)3089, atomicInteger0.shortValue());
      assertEquals("Thu Jan 01 00:00:03 GMT 1970", date0.toString());
      
      boolean boolean0 = TypeUtils.isPath(class0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test081()  throws Throwable  {
      TypeUtils.clearClassMapping();
      Class<SecurityException> class0 = SecurityException.class;
      java.util.Date date0 = TypeUtils.castToDate((Object) null);
      assertNull(date0);
      
      Class<?> class1 = TypeUtils.getClass((Type) class0);
      assertNotNull(class1);
      assertFalse(class1.isInterface());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals("class java.lang.SecurityException", class1.toString());
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isPrimitive());
      assertEquals(1, class1.getModifiers());
      assertFalse(class1.isArray());
      
      Class<NoClassDefFoundError> class2 = NoClassDefFoundError.class;
      boolean boolean0 = TypeUtils.isPath(class2);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test082()  throws Throwable  {
      TypeUtils.clearClassMapping();
      TreeMap<String, String> treeMap0 = new TreeMap<String, String>();
      assertNotNull(treeMap0);
      assertEquals(0, treeMap0.size());
      
      Class<DataTruncation> class0 = DataTruncation.class;
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class0, (Map<String, String>) treeMap0, true);
      assertNotNull(list0);
      assertEquals(0, treeMap0.size());
      assertTrue(list0.isEmpty());
      assertEquals(0, list0.size());
      
      Class<Insets> class1 = Insets.class;
      List<FieldInfo> list1 = TypeUtils.computeGetters((Class<?>) class1, (Map<String, String>) treeMap0, true);
      assertNotNull(list1);
      assertNotSame(list1, list0);
      assertEquals(0, treeMap0.size());
      assertEquals(0, list1.size());
      assertTrue(list1.isEmpty());
      assertTrue(list1.equals((Object)list0));
      
      NumberFormatException numberFormatException0 = new NumberFormatException();
      assertNotNull(numberFormatException0);
      assertEquals("java.lang.NumberFormatException", numberFormatException0.toString());
      assertNull(numberFormatException0.getMessage());
      
      Class<ChoiceFormat> class2 = ChoiceFormat.class;
      ParserConfig parserConfig0 = ParserConfig.getGlobalInstance();
      assertNotNull(parserConfig0);
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      
      boolean boolean0 = TypeUtils.isNumber("ha");
      assertFalse(boolean0);
      
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      assertNotNull(classLoader0);
      
      ClassLoader classLoader1 = classLoader0.getParent();
      assertNotNull(classLoader1);
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      ClassLoader classLoader2 = classLoader1.getParent();
      assertNull(classLoader2);
      assertFalse(classLoader0.equals((Object)classLoader1));
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      classLoader1.setClassAssertionStatus("isfillInStackTrace", true);
      assertFalse(classLoader0.equals((Object)classLoader1));
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      String string0 = weakHashMap0.put("methodName", "getClass");
      assertNull(string0);
      
      List<FieldInfo> list2 = TypeUtils.computeGetters((Class<?>) class1, (Map<String, String>) treeMap0);
      assertNotNull(list2);
      assertNotSame(list2, list1);
      assertNotSame(list2, list0);
      assertTrue(list2.isEmpty());
      assertEquals(0, list2.size());
      assertEquals(0, treeMap0.size());
      assertTrue(list2.equals((Object)list0));
      assertTrue(list2.equals((Object)list1));
      
      Short short0 = new Short((short)74);
      assertNotNull(short0);
      assertEquals((short)74, (short)short0);
      
      Boolean boolean1 = new Boolean("iL:hG%?#z=;1o)j");
      assertNotNull(boolean1);
      assertFalse(boolean1);
      assertTrue(boolean1.equals((Object)boolean0));
      
      Integer integer0 = TypeUtils.castToInt((Object) null);
      assertNull(integer0);
      
      boolean boolean2 = TypeUtils.isPath(class2);
      assertFalse(boolean2);
      assertTrue(boolean2 == boolean0);
      
      Boolean boolean3 = TypeUtils.castToBoolean((Object) null);
      assertNull(boolean3);
      
      boolean boolean4 = TypeUtils.isGenericParamType(class0);
      assertFalse(boolean4);
      assertTrue(boolean4 == boolean2);
      assertTrue(boolean4 == boolean0);
      
      Random.setNextRandom(5079);
  }

  @Test(timeout = 4000)
  public void test083()  throws Throwable  {
      Float float0 = new Float(3283.7262067);
      assertNotNull(float0);
      assertEquals(3283.7263F, (float)float0, 0.01F);
      
      float float1 = Float.max(1.0F, 0.0F);
      assertEquals(1.0F, float1, 0.01F);
      
      BigInteger bigInteger0 = TypeUtils.castToBigInteger(float0);
      assertNotNull(bigInteger0);
      assertEquals((byte) (-45), bigInteger0.byteValue());
      assertEquals((short)3283, bigInteger0.shortValue());
      assertNotEquals((float)float0, (float)float1, 0.01F);
  }

  @Test(timeout = 4000)
  public void test084()  throws Throwable  {
      TypeUtils.clearClassMapping();
      TreeMap<String, String> treeMap0 = new TreeMap<String, String>();
      assertNotNull(treeMap0);
      assertEquals(0, treeMap0.size());
      
      Class<DataTruncation> class0 = DataTruncation.class;
      boolean boolean0 = TypeUtils.isProxy(class0);
      assertFalse(boolean0);
      
      OutOfMemoryError outOfMemoryError0 = new OutOfMemoryError("andIncrement");
      assertNotNull(outOfMemoryError0);
      assertEquals("andIncrement", outOfMemoryError0.getMessage());
      assertEquals("java.lang.OutOfMemoryError: andIncrement", outOfMemoryError0.toString());
      
      JavaBeanSerializer javaBeanSerializer0 = new JavaBeanSerializer(class0);
      assertNotNull(javaBeanSerializer0);
      
      Class<?> class1 = javaBeanSerializer0.getType();
      assertNotNull(class1);
      assertEquals(1, class1.getModifiers());
      assertEquals("class java.sql.DataTruncation", class1.toString());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertFalse(class1.isAnnotation());
      
      Class<?> class2 = TypeUtils.getClass((Type) class0);
      assertNotNull(class2);
      assertSame(class2, class1);
      assertFalse(class2.isAnnotation());
      assertEquals("class java.sql.DataTruncation", class2.toString());
      assertFalse(class2.isSynthetic());
      assertFalse(class2.isEnum());
      assertFalse(class2.isInterface());
      assertFalse(class2.isArray());
      assertFalse(class2.isPrimitive());
      assertEquals(1, class2.getModifiers());
      
      boolean boolean1 = TypeUtils.isPath(class2);
      assertSame(class2, class1);
      assertFalse(class2.isAnnotation());
      assertEquals("class java.sql.DataTruncation", class2.toString());
      assertFalse(class2.isSynthetic());
      assertFalse(class2.isEnum());
      assertFalse(class2.isInterface());
      assertFalse(class2.isArray());
      assertFalse(class2.isPrimitive());
      assertEquals(1, class2.getModifiers());
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
      
      Class<?> class3 = TypeUtils.getRawClass(class0);
      assertNotNull(class3);
      assertSame(class3, class2);
      assertSame(class3, class1);
      assertFalse(class3.isEnum());
      assertFalse(class3.isSynthetic());
      assertEquals(1, class3.getModifiers());
      assertFalse(class3.isPrimitive());
      assertFalse(class3.isAnnotation());
      assertEquals("class java.sql.DataTruncation", class3.toString());
      assertFalse(class3.isInterface());
      assertFalse(class3.isArray());
  }

  @Test(timeout = 4000)
  public void test085()  throws Throwable  {
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      Class<ClassLoader> class0 = ClassLoader.class;
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.PascalCase;
      List<FieldInfo> list0 = TypeUtils.computeGettersWithFieldBase(class0, weakHashMap0, false, propertyNamingStrategy0);
      assertNotNull(list0);
      assertTrue(list0.isEmpty());
      assertEquals(0, list0.size());
      
      ThreadGroup threadGroup0 = new ThreadGroup("R7Xw':u/ Ib.%b;.~U");
      assertNotNull(threadGroup0);
      assertEquals("R7Xw':u/ Ib.%b;.~U", threadGroup0.getName());
      
      Thread thread0 = MockThread.currentThread();
      assertNotNull(thread0);
      assertFalse(thread0.isInterrupted());
      assertFalse(thread0.isDaemon());
      
      MockThread mockThread0 = new MockThread(thread0, "R7Xw':u/ Ib.%b;.~U");
      assertNotNull(mockThread0);
      assertFalse(thread0.isInterrupted());
      assertFalse(thread0.isDaemon());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      
      ClassLoader classLoader0 = mockThread0.getContextClassLoader();
      assertNotNull(classLoader0);
      assertFalse(thread0.isInterrupted());
      assertFalse(thread0.isDaemon());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      
      ClassLoader classLoader1 = classLoader0.getParent();
      assertNotNull(classLoader1);
      assertFalse(thread0.isInterrupted());
      assertFalse(thread0.isDaemon());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      classLoader1.setClassAssertionStatus("R7Xw':u/ Ib.%b;.~U", true);
      assertFalse(thread0.isInterrupted());
      assertFalse(thread0.isDaemon());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(classLoader0.equals((Object)classLoader1));
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      VerifyError verifyError0 = new VerifyError("R7Xw':u/ Ib.%b;.~U");
      assertNotNull(verifyError0);
      assertEquals("java.lang.VerifyError: R7Xw':u/ Ib.%b;.~U", verifyError0.toString());
      assertEquals("R7Xw':u/ Ib.%b;.~U", verifyError0.getMessage());
      
      IndexOutOfBoundsException indexOutOfBoundsException0 = new IndexOutOfBoundsException("Mi9<t2");
      assertNotNull(indexOutOfBoundsException0);
      assertEquals("Mi9<t2", indexOutOfBoundsException0.getMessage());
      assertEquals("java.lang.IndexOutOfBoundsException: Mi9<t2", indexOutOfBoundsException0.toString());
      
      java.util.Date date0 = TypeUtils.castToDate((Object) null);
      assertNull(date0);
      
      TypeUtils.clearClassMapping();
      boolean boolean0 = TypeUtils.isNumber("0-|.%cw@OPe");
      assertFalse(boolean0);
      
      WeakHashMap<String, Object> weakHashMap1 = new WeakHashMap<String, Object>();
      assertNotNull(weakHashMap1);
      
      Class<Boolean> class1 = Boolean.class;
      ParserConfig parserConfig0 = ParserConfig.getGlobalInstance();
      assertNotNull(parserConfig0);
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      
      // Undeclared exception!
      try { 
        TypeUtils.castToJavaBean((Map<String, Object>) weakHashMap1, class1, parserConfig0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // default constructor not found. class java.lang.Boolean
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test086()  throws Throwable  {
      TimeDeserializer timeDeserializer0 = TimeDeserializer.instance;
      assertNotNull(timeDeserializer0);
      assertEquals(2, timeDeserializer0.getFastMatchToken());
      
      Class<Byte> class0 = Byte.TYPE;
      assertNotNull(class0);
      assertFalse(class0.isEnum());
      assertFalse(class0.isSynthetic());
      assertEquals(1041, class0.getModifiers());
      assertFalse(class0.isInterface());
      assertEquals("byte", class0.toString());
      assertFalse(class0.isArray());
      assertTrue(class0.isPrimitive());
      assertFalse(class0.isAnnotation());
      
      LinkedHashMap<OutOfMemoryError, SQLWarning> linkedHashMap0 = new LinkedHashMap<OutOfMemoryError, SQLWarning>();
      assertNotNull(linkedHashMap0);
      assertTrue(linkedHashMap0.isEmpty());
      assertEquals(0, linkedHashMap0.size());
      
      OutOfMemoryError outOfMemoryError0 = new OutOfMemoryError("clazz is null");
      assertNotNull(outOfMemoryError0);
      assertEquals("java.lang.OutOfMemoryError: clazz is null", outOfMemoryError0.toString());
      assertEquals("clazz is null", outOfMemoryError0.getMessage());
      
      StackTraceElement[] stackTraceElementArray0 = outOfMemoryError0.getStackTrace();
      assertNotNull(stackTraceElementArray0);
      assertEquals("java.lang.OutOfMemoryError: clazz is null", outOfMemoryError0.toString());
      assertEquals("clazz is null", outOfMemoryError0.getMessage());
      
      SQLWarning sQLWarning0 = new SQLWarning();
      assertNotNull(sQLWarning0);
      assertEquals("java.sql.SQLWarning", sQLWarning0.toString());
      assertEquals(0, sQLWarning0.getErrorCode());
      assertNull(sQLWarning0.getMessage());
      assertNull(sQLWarning0.getSQLState());
      
      Timestamp timestamp0 = TypeUtils.castToTimestamp((Object) null);
      assertNull(timestamp0);
      
      HashMap<String, String> hashMap0 = new HashMap<String, String>();
      assertNotNull(hashMap0);
      assertEquals(0, hashMap0.size());
      assertTrue(hashMap0.isEmpty());
      
      Class<Integer> class1 = Integer.TYPE;
      assertNotNull(class1);
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isEnum());
      assertTrue(class1.isPrimitive());
      assertEquals("int", class1.toString());
      assertEquals(1041, class1.getModifiers());
      assertFalse(class1.isSynthetic());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      
      GenericArrayType genericArrayType0 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      doReturn(class1).when(genericArrayType0).getGenericComponentType();
      Class class2 = (Class)TypeUtils.checkPrimitiveArray(genericArrayType0);
      assertNotNull(class2);
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isEnum());
      assertTrue(class1.isPrimitive());
      assertEquals("int", class1.toString());
      assertEquals(1041, class1.getModifiers());
      assertFalse(class1.isSynthetic());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertEquals("class [I", class2.toString());
      assertFalse(class2.isAnnotation());
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
      assertTrue(class2.isArray());
      assertEquals(1041, class2.getModifiers());
      assertFalse(class2.isPrimitive());
      assertFalse(class2.isInterface());
      
      Class<?> class3 = TypeUtils.getClass((Type) class2);
      assertNotNull(class3);
      assertFalse(class1.isAnnotation());
      assertFalse(class1.isEnum());
      assertTrue(class1.isPrimitive());
      assertEquals("int", class1.toString());
      assertEquals(1041, class1.getModifiers());
      assertFalse(class1.isSynthetic());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertEquals("class [I", class2.toString());
      assertFalse(class2.isAnnotation());
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
      assertTrue(class2.isArray());
      assertEquals(1041, class2.getModifiers());
      assertFalse(class2.isPrimitive());
      assertFalse(class2.isInterface());
      assertFalse(class3.isInterface());
      assertEquals(1041, class3.getModifiers());
      assertFalse(class3.isSynthetic());
      assertFalse(class3.isPrimitive());
      assertFalse(class3.isEnum());
      assertTrue(class3.isArray());
      assertEquals("class [I", class3.toString());
      assertFalse(class3.isAnnotation());
      
      Class<Properties> class4 = Properties.class;
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.CamelCase;
      List<FieldInfo> list0 = TypeUtils.computeGettersWithFieldBase(class4, hashMap0, true, propertyNamingStrategy0);
      assertNotNull(list0);
      assertEquals(0, hashMap0.size());
      assertTrue(hashMap0.isEmpty());
      assertEquals(0, list0.size());
      assertTrue(list0.isEmpty());
      
      Double double0 = new Double(0.0);
      assertNotNull(double0);
      assertEquals(0.0, (double)double0, 0.01);
      
      JSONPDeserializer jSONPDeserializer0 = JSONPDeserializer.instance;
      assertNotNull(jSONPDeserializer0);
      assertEquals(0, jSONPDeserializer0.getFastMatchToken());
      
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      Class<?> class5 = TypeUtils.getRawClass(class4);
      assertNotNull(class5);
      assertNotSame(class5, class3);
      assertEquals(1, class5.getModifiers());
      assertFalse(class5.isEnum());
      assertFalse(class5.isSynthetic());
      assertFalse(class5.isArray());
      assertFalse(class5.isInterface());
      assertFalse(class5.isPrimitive());
      assertFalse(class5.isAnnotation());
      assertEquals("class java.util.Properties", class5.toString());
      assertFalse(class5.equals((Object)class3));
  }

  @Test(timeout = 4000)
  public void test087()  throws Throwable  {
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      assertNotNull(classLoader0);
      
      classLoader0.setDefaultAssertionStatus(true);
      classLoader0.setDefaultAssertionStatus(true);
      classLoader0.clearAssertionStatus();
      classLoader0.setClassAssertionStatus("can not cast to Date, value : ", false);
      Class<?> class0 = TypeUtils.loadClass("L", classLoader0);
      assertNull(class0);
      
      Class<SQLInvalidAuthorizationSpecException> class1 = SQLInvalidAuthorizationSpecException.class;
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      String string0 = weakHashMap0.put("can not cast to Date, value : ", "fillInStackTrace");
      assertNull(string0);
      
      String string1 = weakHashMap0.put("Ljava.util.concurrent.ConcurrentSkipListSet", "L");
      assertNull(string1);
      
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class1, (Map<String, String>) weakHashMap0);
      assertNotNull(list0);
      assertTrue(list0.isEmpty());
      assertEquals(0, list0.size());
      
      Short short0 = new Short((short)74);
      assertNotNull(short0);
      assertEquals((short)74, (short)short0);
      
      Integer integer0 = TypeUtils.castToInt(short0);
      assertNotNull(integer0);
      assertEquals(74, (int)integer0);
      
      Type type0 = TypeUtils.unwrapOptional((Type) null);
      assertNull(type0);
      
      String string2 = TypeUtils.castToString((Object) null);
      assertNull(string2);
  }

  @Test(timeout = 4000)
  public void test088()  throws Throwable  {
      NumberFormatException numberFormatException0 = new NumberFormatException();
      assertNotNull(numberFormatException0);
      assertNull(numberFormatException0.getMessage());
      assertEquals("java.lang.NumberFormatException", numberFormatException0.toString());
      
      ParserConfig parserConfig0 = ParserConfig.getGlobalInstance();
      assertNotNull(parserConfig0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      ThreadGroup threadGroup0 = new ThreadGroup("fastjson.parser.autoTypeSupport");
      assertNotNull(threadGroup0);
      assertEquals("fastjson.parser.autoTypeSupport", threadGroup0.getName());
      
      Thread thread0 = MockThread.currentThread();
      assertNotNull(thread0);
      assertFalse(thread0.isInterrupted());
      assertFalse(thread0.isDaemon());
      
      MockThread mockThread0 = new MockThread(thread0, "fastjson.parser.deny");
      assertNotNull(mockThread0);
      assertFalse(thread0.isInterrupted());
      assertFalse(thread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      
      MockThread mockThread1 = new MockThread(mockThread0);
      assertNotNull(mockThread1);
      assertFalse(thread0.isInterrupted());
      assertFalse(thread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread1.isDaemon());
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.equals((Object)mockThread0));
      
      MockThread mockThread2 = new MockThread(threadGroup0, mockThread1, "fastjson.parser.autoTypeAccept", 106L);
      assertNotNull(mockThread2);
      assertEquals("fastjson.parser.autoTypeSupport", threadGroup0.getName());
      assertFalse(thread0.isInterrupted());
      assertFalse(thread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread1.isDaemon());
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertEquals(0, mockThread2.countStackFrames());
      assertFalse(mockThread2.isInterrupted());
      assertFalse(mockThread2.isDaemon());
      assertFalse(mockThread0.equals((Object)mockThread1));
      assertFalse(mockThread1.equals((Object)mockThread0));
      assertFalse(mockThread2.equals((Object)mockThread1));
      assertFalse(mockThread2.equals((Object)mockThread0));
      
      ClassLoader classLoader0 = mockThread2.getContextClassLoader();
      assertNotNull(classLoader0);
      assertNotSame(mockThread0, mockThread2);
      assertNotSame(mockThread0, mockThread1);
      assertNotSame(mockThread1, mockThread2);
      assertNotSame(mockThread1, mockThread0);
      assertNotSame(mockThread2, mockThread1);
      assertNotSame(mockThread2, mockThread0);
      assertEquals("fastjson.parser.autoTypeSupport", threadGroup0.getName());
      assertFalse(thread0.isInterrupted());
      assertFalse(thread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread1.isDaemon());
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertEquals(0, mockThread2.countStackFrames());
      assertFalse(mockThread2.isInterrupted());
      assertFalse(mockThread2.isDaemon());
      assertFalse(mockThread0.equals((Object)mockThread2));
      assertFalse(mockThread0.equals((Object)mockThread1));
      assertFalse(mockThread1.equals((Object)mockThread2));
      assertFalse(mockThread1.equals((Object)mockThread0));
      assertFalse(mockThread2.equals((Object)mockThread1));
      assertFalse(mockThread2.equals((Object)mockThread0));
      
      ClassLoader classLoader1 = classLoader0.getParent();
      assertNotNull(classLoader1);
      assertNotSame(mockThread0, mockThread2);
      assertNotSame(mockThread0, mockThread1);
      assertNotSame(mockThread1, mockThread2);
      assertNotSame(mockThread1, mockThread0);
      assertNotSame(mockThread2, mockThread1);
      assertNotSame(mockThread2, mockThread0);
      assertEquals("fastjson.parser.autoTypeSupport", threadGroup0.getName());
      assertFalse(thread0.isInterrupted());
      assertFalse(thread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread1.isDaemon());
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertEquals(0, mockThread2.countStackFrames());
      assertFalse(mockThread2.isInterrupted());
      assertFalse(mockThread2.isDaemon());
      assertFalse(mockThread0.equals((Object)mockThread2));
      assertFalse(mockThread0.equals((Object)mockThread1));
      assertFalse(mockThread1.equals((Object)mockThread2));
      assertFalse(mockThread1.equals((Object)mockThread0));
      assertFalse(mockThread2.equals((Object)mockThread1));
      assertFalse(mockThread2.equals((Object)mockThread0));
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      ASMDeserializerFactory aSMDeserializerFactory0 = new ASMDeserializerFactory(classLoader1);
      assertNotNull(aSMDeserializerFactory0);
      assertEquals("fastjson.parser.autoTypeSupport", threadGroup0.getName());
      assertFalse(thread0.isInterrupted());
      assertFalse(thread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread1.isDaemon());
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertEquals(0, mockThread2.countStackFrames());
      assertFalse(mockThread2.isInterrupted());
      assertFalse(mockThread2.isDaemon());
      assertFalse(mockThread0.equals((Object)mockThread2));
      assertFalse(mockThread0.equals((Object)mockThread1));
      assertFalse(mockThread1.equals((Object)mockThread2));
      assertFalse(mockThread1.equals((Object)mockThread0));
      assertFalse(mockThread2.equals((Object)mockThread1));
      assertFalse(mockThread2.equals((Object)mockThread0));
      assertFalse(classLoader0.equals((Object)classLoader1));
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      ParserConfig parserConfig1 = ParserConfig.global;
      assertNotNull(parserConfig1);
      assertSame(parserConfig1, parserConfig0);
      assertFalse(parserConfig1.isAutoTypeSupport());
      assertTrue(parserConfig1.isAsmEnable());
      assertTrue(parserConfig1.compatibleWithJavaBean);
      assertFalse(parserConfig1.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      OutOfMemoryError outOfMemoryError0 = new OutOfMemoryError("fastjson.parser.autoTypeAccept");
      assertNotNull(outOfMemoryError0);
      assertEquals("fastjson.parser.autoTypeAccept", outOfMemoryError0.getMessage());
      assertEquals("java.lang.OutOfMemoryError: fastjson.parser.autoTypeAccept", outOfMemoryError0.toString());
      
      Throwable throwable0 = outOfMemoryError0.fillInStackTrace();
      assertNotNull(throwable0);
      assertSame(outOfMemoryError0, throwable0);
      assertSame(throwable0, outOfMemoryError0);
      assertEquals("fastjson.parser.autoTypeAccept", outOfMemoryError0.getMessage());
      assertEquals("java.lang.OutOfMemoryError: fastjson.parser.autoTypeAccept", outOfMemoryError0.toString());
      assertEquals("java.lang.OutOfMemoryError: fastjson.parser.autoTypeAccept", throwable0.toString());
      assertEquals("fastjson.parser.autoTypeAccept", throwable0.getMessage());
      
      SQLSyntaxErrorException sQLSyntaxErrorException0 = new SQLSyntaxErrorException((String) null, numberFormatException0);
      assertNotNull(sQLSyntaxErrorException0);
      assertNull(numberFormatException0.getMessage());
      assertEquals("java.lang.NumberFormatException", numberFormatException0.toString());
      assertEquals(0, sQLSyntaxErrorException0.getErrorCode());
      assertEquals("java.sql.SQLSyntaxErrorException", sQLSyntaxErrorException0.toString());
      assertNull(sQLSyntaxErrorException0.getSQLState());
      assertNull(sQLSyntaxErrorException0.getMessage());
      
      Double double0 = TypeUtils.castToDouble((Object) null);
      assertNull(double0);
      
      Class<VerifyError> class0 = VerifyError.class;
      boolean boolean0 = TypeUtils.isKotlin(class0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test089()  throws Throwable  {
      TreeMap<String, Object> treeMap0 = new TreeMap<String, Object>();
      assertNotNull(treeMap0);
      assertEquals(0, treeMap0.size());
      
      Class<Throwable> class0 = Throwable.class;
      boolean boolean0 = TypeUtils.isPath(class0);
      assertFalse(boolean0);
      
      BigDecimal bigDecimal0 = TypeUtils.castToBigDecimal(treeMap0);
      assertNull(bigDecimal0);
      assertEquals(0, treeMap0.size());
      
      LinkedHashMap<OutOfMemoryError, SQLWarning> linkedHashMap0 = new LinkedHashMap<OutOfMemoryError, SQLWarning>();
      assertNotNull(linkedHashMap0);
      assertEquals(0, linkedHashMap0.size());
      assertTrue(linkedHashMap0.isEmpty());
      
      String string0 = null;
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.SnakeCase;
      JavaBeanInfo javaBeanInfo0 = JavaBeanInfo.build((Class<?>) class0, (Type) class0, propertyNamingStrategy0, false, false);
      assertNotNull(javaBeanInfo0);
      assertEquals(0, javaBeanInfo0.defaultConstructorParameterSize);
      assertEquals(0, javaBeanInfo0.parserFeatures);
      
      ParserConfig parserConfig0 = ParserConfig.getGlobalInstance();
      assertNotNull(parserConfig0);
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig0.fieldBased);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      assertNotNull(classLoader0);
      
      Class<?> class1 = TypeUtils.loadClass("", classLoader0, false);
      assertNull(class1);
      
      PropertyNamingStrategy propertyNamingStrategy1 = PropertyNamingStrategy.KebabCase;
      JavaBeanInfo javaBeanInfo1 = JavaBeanInfo.build((Class<?>) class0, (Type) javaBeanInfo0.clazz, propertyNamingStrategy1, true, false);
      assertNotNull(javaBeanInfo1);
      assertNotSame(propertyNamingStrategy0, propertyNamingStrategy1);
      assertNotSame(javaBeanInfo0, javaBeanInfo1);
      assertNotSame(propertyNamingStrategy1, propertyNamingStrategy0);
      assertNotSame(javaBeanInfo1, javaBeanInfo0);
      assertEquals(0, javaBeanInfo0.defaultConstructorParameterSize);
      assertEquals(0, javaBeanInfo0.parserFeatures);
      assertEquals(0, javaBeanInfo1.defaultConstructorParameterSize);
      assertEquals(0, javaBeanInfo1.parserFeatures);
      assertFalse(propertyNamingStrategy0.equals((Object)propertyNamingStrategy1));
      assertFalse(propertyNamingStrategy1.equals((Object)propertyNamingStrategy0));
      assertFalse(javaBeanInfo1.equals((Object)javaBeanInfo0));
      
      ClassLoader classLoader1 = classLoader0.getParent();
      assertNotNull(classLoader1);
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      ASMDeserializerFactory aSMDeserializerFactory0 = new ASMDeserializerFactory(classLoader1);
      assertNotNull(aSMDeserializerFactory0);
      assertFalse(classLoader0.equals((Object)classLoader1));
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      ObjectDeserializer objectDeserializer0 = aSMDeserializerFactory0.createJavaBeanDeserializer(parserConfig0, javaBeanInfo1);
      assertNotNull(objectDeserializer0);
      assertNotSame(propertyNamingStrategy0, propertyNamingStrategy1);
      assertNotSame(javaBeanInfo0, javaBeanInfo1);
      assertNotSame(propertyNamingStrategy1, propertyNamingStrategy0);
      assertNotSame(javaBeanInfo1, javaBeanInfo0);
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertEquals(12, objectDeserializer0.getFastMatchToken());
      assertEquals(0, javaBeanInfo0.defaultConstructorParameterSize);
      assertEquals(0, javaBeanInfo0.parserFeatures);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig0.fieldBased);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertEquals(0, javaBeanInfo1.defaultConstructorParameterSize);
      assertEquals(0, javaBeanInfo1.parserFeatures);
      assertFalse(propertyNamingStrategy0.equals((Object)propertyNamingStrategy1));
      assertFalse(javaBeanInfo0.equals((Object)javaBeanInfo1));
      assertFalse(classLoader0.equals((Object)classLoader1));
      assertFalse(propertyNamingStrategy1.equals((Object)propertyNamingStrategy0));
      assertFalse(javaBeanInfo1.equals((Object)javaBeanInfo0));
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      // Undeclared exception!
      try { 
        TypeUtils.castToBytes(javaBeanInfo0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to int, value : com.alibaba.fastjson.util.JavaBeanInfo@3
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test090()  throws Throwable  {
      Constructor<Short>[] constructorArray0 = (Constructor<Short>[]) Array.newInstance(Constructor.class, 0);
      Constructor constructor0 = TypeUtils.getKoltinConstructor(constructorArray0);
      assertNull(constructor0);
      
      Class<String> class0 = String.class;
      boolean boolean0 = TypeUtils.isKotlin(class0);
      assertFalse(boolean0);
      
      Class class1 = (Class)TypeUtils.unwrapOptional(class0);
      assertNotNull(class1);
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals("class java.lang.String", class1.toString());
      assertEquals(17, class1.getModifiers());
      assertFalse(class1.isAnnotation());
      
      Jdk8DateCodec jdk8DateCodec0 = new Jdk8DateCodec();
      assertNotNull(jdk8DateCodec0);
      assertEquals(4, jdk8DateCodec0.getFastMatchToken());
      
      // Undeclared exception!
      try { 
        TypeUtils.castToFloat(jdk8DateCodec0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to float, value : com.alibaba.fastjson.parser.deserializer.Jdk8DateCodec@1
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test091()  throws Throwable  {
      Class<MockJapaneseDate> class0 = MockJapaneseDate.class;
      boolean boolean0 = TypeUtils.isPath(class0);
      assertFalse(boolean0);
      
      ParserConfig parserConfig0 = ParserConfig.global;
      assertNotNull(parserConfig0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig0.fieldBased);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      
      AtomicLong atomicLong0 = new AtomicLong(0L);
      assertNotNull(atomicLong0);
      assertEquals(0.0F, atomicLong0.floatValue(), 0.01F);
      assertEquals(0.0, atomicLong0.doubleValue(), 0.01);
      assertEquals(0L, atomicLong0.longValue());
      assertEquals((byte)0, atomicLong0.byteValue());
      assertEquals(0, atomicLong0.intValue());
      assertEquals("0", atomicLong0.toString());
      assertEquals(0L, atomicLong0.get());
      assertEquals((short)0, atomicLong0.shortValue());
      
      LongUnaryOperator longUnaryOperator0 = mock(LongUnaryOperator.class, new ViolatedAssumptionAnswer());
      doReturn(0L).when(longUnaryOperator0).applyAsLong(anyLong());
      long long0 = atomicLong0.getAndUpdate(longUnaryOperator0);
      assertEquals(0.0F, atomicLong0.floatValue(), 0.01F);
      assertEquals(0.0, atomicLong0.doubleValue(), 0.01);
      assertEquals(0L, atomicLong0.longValue());
      assertEquals((byte)0, atomicLong0.byteValue());
      assertEquals(0, atomicLong0.intValue());
      assertEquals("0", atomicLong0.toString());
      assertEquals(0L, atomicLong0.get());
      assertEquals((short)0, atomicLong0.shortValue());
      assertEquals(0L, long0);
      
      Hashtable<String, Field> hashtable0 = new Hashtable<String, Field>();
      assertNotNull(hashtable0);
      assertEquals(0, hashtable0.size());
      assertTrue(hashtable0.isEmpty());
      
      TreeMap<String, Object> treeMap0 = new TreeMap<String, Object>();
      assertNotNull(treeMap0);
      assertEquals(0, treeMap0.size());
      
      Object object0 = treeMap0.putIfAbsent("hashCode", class0);
      assertNull(object0);
      assertEquals(1, treeMap0.size());
      
      ParserConfig parserConfig1 = ParserConfig.getGlobalInstance();
      assertNotNull(parserConfig1);
      assertSame(parserConfig1, parserConfig0);
      assertTrue(parserConfig1.isAsmEnable());
      assertFalse(parserConfig1.isAutoTypeSupport());
      assertTrue(parserConfig1.compatibleWithJavaBean);
      assertFalse(parserConfig1.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      parserConfig1.setAutoTypeSupport(false);
      assertSame(parserConfig1, parserConfig0);
      assertTrue(parserConfig1.isAsmEnable());
      assertFalse(parserConfig1.isAutoTypeSupport());
      assertTrue(parserConfig1.compatibleWithJavaBean);
      assertFalse(parserConfig1.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      ObjectArrayCodec objectArrayCodec0 = new ObjectArrayCodec();
      assertNotNull(objectArrayCodec0);
      assertEquals(14, objectArrayCodec0.getFastMatchToken());
      
      Object object1 = treeMap0.put("org.;pringframework.security.core.userdetails.User", atomicLong0);
      assertNull(object1);
      assertEquals(0.0F, atomicLong0.floatValue(), 0.01F);
      assertEquals(0.0, atomicLong0.doubleValue(), 0.01);
      assertEquals(0L, atomicLong0.longValue());
      assertEquals((byte)0, atomicLong0.byteValue());
      assertEquals(0, atomicLong0.intValue());
      assertEquals("0", atomicLong0.toString());
      assertEquals(0L, atomicLong0.get());
      assertEquals((short)0, atomicLong0.shortValue());
      assertEquals(2, treeMap0.size());
      
      SortedMap<String, Object> sortedMap0 = treeMap0.tailMap("fastjson.parser.autoTypeSupport");
      assertNotNull(sortedMap0);
      assertEquals(2, treeMap0.size());
      assertEquals(2, sortedMap0.size());
      assertFalse(sortedMap0.isEmpty());
      
      parserConfig1.addDeny("parseArray");
      assertSame(parserConfig1, parserConfig0);
      assertTrue(parserConfig1.isAsmEnable());
      assertFalse(parserConfig1.isAutoTypeSupport());
      assertTrue(parserConfig1.compatibleWithJavaBean);
      assertFalse(parserConfig1.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      Class<SimpleDateFormat> class1 = SimpleDateFormat.class;
      SimpleDateFormat simpleDateFormat0 = TypeUtils.castToJavaBean((Map<String, Object>) sortedMap0, class1, parserConfig0);
      assertNotNull(simpleDateFormat0);
      assertSame(parserConfig0, parserConfig1);
      assertEquals("M/d/yy h:mm a", simpleDateFormat0.toLocalizedPattern());
      assertTrue(simpleDateFormat0.isLenient());
      assertEquals("M/d/yy h:mm a", simpleDateFormat0.toPattern());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertEquals(2, treeMap0.size());
      assertEquals(2, sortedMap0.size());
      assertFalse(sortedMap0.isEmpty());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig0.fieldBased);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      
      Class<GridBagConstraints> class2 = GridBagConstraints.class;
      ParserConfig parserConfig2 = ParserConfig.getGlobalInstance();
      assertNotNull(parserConfig2);
      assertSame(parserConfig2, parserConfig0);
      assertSame(parserConfig2, parserConfig1);
      assertFalse(parserConfig2.isAutoTypeSupport());
      assertTrue(parserConfig2.isAsmEnable());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig2.compatibleWithJavaBean);
      assertFalse(parserConfig2.fieldBased);
      
      // Undeclared exception!
      try { 
        TypeUtils.castToEnum((Object) parserConfig2, class2, parserConfig1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to : java.awt.GridBagConstraints
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test092()  throws Throwable  {
      Class<SQLFeatureNotSupportedException> class0 = SQLFeatureNotSupportedException.class;
      ConcurrentHashMap<String, String> concurrentHashMap0 = new ConcurrentHashMap<String, String>();
      assertNotNull(concurrentHashMap0);
      assertTrue(concurrentHashMap0.isEmpty());
      
      boolean boolean0 = TypeUtils.isProxy(class0);
      assertFalse(boolean0);
      
      GenericArrayType genericArrayType0 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(genericArrayType0).toString();
      doReturn(class0).when(genericArrayType0).getGenericComponentType();
      Type type0 = TypeUtils.checkPrimitiveArray(genericArrayType0);
      assertNotNull(type0);
      
      Class<Double> class1 = Double.TYPE;
      assertNotNull(class1);
      assertFalse(class1.isInterface());
      assertTrue(class1.isPrimitive());
      assertFalse(class1.isArray());
      assertEquals(1041, class1.getModifiers());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals("double", class1.toString());
      assertFalse(class1.isAnnotation());
      
      String string0 = TypeUtils.decapitalize(")_jWHI2v!?R>B|/f");
      assertNotNull(string0);
      assertEquals(")_jWHI2v!?R>B|/f", string0);
      
      Class<NoClassDefFoundError> class2 = NoClassDefFoundError.class;
      boolean boolean1 = TypeUtils.isPath(class2);
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
      
      TypeUtils typeUtils0 = new TypeUtils();
      assertNotNull(typeUtils0);
      assertTrue(TypeUtils.compatibleWithJavaBean);
      assertTrue(TypeUtils.compatibleWithFieldName);
      
      GenericArrayType genericArrayType1 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(genericArrayType1).toString();
      doReturn((Type) null).when(genericArrayType1).getGenericComponentType();
      Type type1 = TypeUtils.checkPrimitiveArray(genericArrayType1);
      assertNotNull(type1);
      assertFalse(type1.equals((Object)type0));
      
      byte[] byteArray0 = TypeUtils.castToBytes(")_jWHI2v!?R>B|/f");
      assertNotNull(byteArray0);
      
      GenericArrayType genericArrayType2 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(genericArrayType2).toString();
      doReturn((Type) null).when(genericArrayType2).getGenericComponentType();
      Type type2 = TypeUtils.checkPrimitiveArray(genericArrayType2);
      assertNotNull(type2);
      assertFalse(type2.equals((Object)type1));
      assertFalse(type2.equals((Object)type0));
  }

  @Test(timeout = 4000)
  public void test093()  throws Throwable  {
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      String string0 = "[DV#c{^j&OD5`";
      String string1 = weakHashMap0.put("[DV#c{^j&OD5`", "[DV#c{^j&OD5`");
      assertNull(string1);
      
      Class<Float> class0 = Float.class;
      List<FieldInfo> list0 = TypeUtils.computeGetters(class0, (Map<String, String>) null);
      assertNotNull(list0);
      assertFalse(list0.isEmpty());
      assertEquals(2, list0.size());
      
      Short short0 = new Short((short)1803);
      assertNotNull(short0);
      assertEquals((short)1803, (short)short0);
      
      Boolean boolean0 = new Boolean("cl");
      assertNotNull(boolean0);
      assertFalse(boolean0);
      
      Short short1 = new Short((short)1803);
      assertNotNull(short1);
      assertEquals((short)1803, (short)short1);
      assertTrue(short1.equals((Object)short0));
      
      // Undeclared exception!
      try { 
        TypeUtils.castToInt("cl");
        fail("Expecting exception: NumberFormatException");
      
      } catch(NumberFormatException e) {
         //
         // For input string: \"cl\"
         //
         verifyException("java.lang.NumberFormatException", e);
      }
  }

  @Test(timeout = 4000)
  public void test094()  throws Throwable  {
      Class<MockJapaneseDate> class0 = MockJapaneseDate.class;
      boolean boolean0 = TypeUtils.isPath(class0);
      assertFalse(boolean0);
      
      ParserConfig parserConfig0 = ParserConfig.global;
      assertNotNull(parserConfig0);
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig0.fieldBased);
      
      AtomicLong atomicLong0 = new AtomicLong(0L);
      assertNotNull(atomicLong0);
      assertEquals(0, atomicLong0.intValue());
      assertEquals(0L, atomicLong0.longValue());
      assertEquals(0.0, atomicLong0.doubleValue(), 0.01);
      assertEquals(0L, atomicLong0.get());
      assertEquals((byte)0, atomicLong0.byteValue());
      assertEquals("0", atomicLong0.toString());
      assertEquals((short)0, atomicLong0.shortValue());
      assertEquals(0.0F, atomicLong0.floatValue(), 0.01F);
      
      LongUnaryOperator longUnaryOperator0 = mock(LongUnaryOperator.class, new ViolatedAssumptionAnswer());
      doReturn(0L).when(longUnaryOperator0).applyAsLong(anyLong());
      long long0 = atomicLong0.getAndUpdate(longUnaryOperator0);
      assertEquals(0, atomicLong0.intValue());
      assertEquals(0L, atomicLong0.longValue());
      assertEquals(0.0, atomicLong0.doubleValue(), 0.01);
      assertEquals(0L, atomicLong0.get());
      assertEquals((byte)0, atomicLong0.byteValue());
      assertEquals("0", atomicLong0.toString());
      assertEquals((short)0, atomicLong0.shortValue());
      assertEquals(0.0F, atomicLong0.floatValue(), 0.01F);
      assertEquals(0L, long0);
      
      Hashtable<String, Field> hashtable0 = new Hashtable<String, Field>();
      assertNotNull(hashtable0);
      assertTrue(hashtable0.isEmpty());
      assertEquals(0, hashtable0.size());
      
      LongBinaryOperator longBinaryOperator0 = mock(LongBinaryOperator.class, new ViolatedAssumptionAnswer());
      doReturn(0L).when(longBinaryOperator0).applyAsLong(anyLong() , anyLong());
      long long1 = atomicLong0.accumulateAndGet(0L, longBinaryOperator0);
      assertEquals(0, atomicLong0.intValue());
      assertEquals(0L, atomicLong0.longValue());
      assertEquals(0.0, atomicLong0.doubleValue(), 0.01);
      assertEquals(0L, atomicLong0.get());
      assertEquals((byte)0, atomicLong0.byteValue());
      assertEquals("0", atomicLong0.toString());
      assertEquals((short)0, atomicLong0.shortValue());
      assertEquals(0.0F, atomicLong0.floatValue(), 0.01F);
      assertEquals(0L, long1);
      assertTrue(long1 == long0);
      
      AtomicLong atomicLong1 = new AtomicLong(623L);
      assertNotNull(atomicLong1);
      assertEquals((byte)111, atomicLong1.byteValue());
      assertEquals(623L, atomicLong1.get());
      assertEquals(623, atomicLong1.intValue());
      assertEquals("623", atomicLong1.toString());
      assertEquals((short)623, atomicLong1.shortValue());
      assertEquals(623.0, atomicLong1.doubleValue(), 0.01);
      assertEquals(623.0F, atomicLong1.floatValue(), 0.01F);
      assertEquals(623L, atomicLong1.longValue());
      assertFalse(atomicLong1.equals((Object)atomicLong0));
      
      LongUnaryOperator longUnaryOperator1 = mock(LongUnaryOperator.class, new ViolatedAssumptionAnswer());
      doReturn((-1L)).when(longUnaryOperator1).applyAsLong(anyLong());
      long long2 = atomicLong1.getAndUpdate(longUnaryOperator1);
      assertNotSame(atomicLong1, atomicLong0);
      assertEquals((byte) (-1), atomicLong1.byteValue());
      assertEquals((-1), atomicLong1.intValue());
      assertEquals((-1L), atomicLong1.get());
      assertEquals((short) (-1), atomicLong1.shortValue());
      assertEquals((-1.0F), atomicLong1.floatValue(), 0.01F);
      assertEquals((-1.0), atomicLong1.doubleValue(), 0.01);
      assertEquals("-1", atomicLong1.toString());
      assertEquals((-1L), atomicLong1.longValue());
      assertEquals(623L, long2);
      assertFalse(atomicLong1.equals((Object)atomicLong0));
      assertFalse(long2 == long1);
      assertFalse(long2 == long0);
      
      parserConfig0.addAccept("has");
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig0.fieldBased);
      
      atomicLong0.set(0L);
      assertNotSame(atomicLong0, atomicLong1);
      assertEquals(0, atomicLong0.intValue());
      assertEquals(0L, atomicLong0.longValue());
      assertEquals(0.0, atomicLong0.doubleValue(), 0.01);
      assertEquals(0L, atomicLong0.get());
      assertEquals((byte)0, atomicLong0.byteValue());
      assertEquals("0", atomicLong0.toString());
      assertEquals((short)0, atomicLong0.shortValue());
      assertEquals(0.0F, atomicLong0.floatValue(), 0.01F);
      assertFalse(atomicLong0.equals((Object)atomicLong1));
      
      AtomicLong atomicLong2 = new AtomicLong(0L);
      assertNotNull(atomicLong2);
      assertEquals(0L, atomicLong2.longValue());
      assertEquals("0", atomicLong2.toString());
      assertEquals(0.0F, atomicLong2.floatValue(), 0.01F);
      assertEquals((short)0, atomicLong2.shortValue());
      assertEquals(0, atomicLong2.intValue());
      assertEquals(0.0, atomicLong2.doubleValue(), 0.01);
      assertEquals(0L, atomicLong2.get());
      assertEquals((byte)0, atomicLong2.byteValue());
      assertFalse(atomicLong2.equals((Object)atomicLong0));
      assertFalse(atomicLong2.equals((Object)atomicLong1));
      
      boolean boolean1 = atomicLong2.weakCompareAndSet(0L, 0L);
      assertNotSame(atomicLong2, atomicLong0);
      assertNotSame(atomicLong2, atomicLong1);
      assertEquals(0L, atomicLong2.longValue());
      assertEquals("0", atomicLong2.toString());
      assertEquals(0.0F, atomicLong2.floatValue(), 0.01F);
      assertEquals((short)0, atomicLong2.shortValue());
      assertEquals(0, atomicLong2.intValue());
      assertEquals(0.0, atomicLong2.doubleValue(), 0.01);
      assertEquals(0L, atomicLong2.get());
      assertEquals((byte)0, atomicLong2.byteValue());
      assertTrue(boolean1);
      assertFalse(atomicLong2.equals((Object)atomicLong0));
      assertFalse(atomicLong2.equals((Object)atomicLong1));
      assertFalse(boolean1 == boolean0);
      
      String string0 = "()Ljava/lang/String;";
      Field field0 = ParserConfig.getFieldFromCache("]cZUk<m_xL7H.[", hashtable0);
      assertNull(field0);
      assertTrue(hashtable0.isEmpty());
      assertEquals(0, hashtable0.size());
      
      Class<ChoiceFormat> class1 = ChoiceFormat.class;
      ParserConfig.parserAllFieldToCache(class1, hashtable0);
      assertEquals(25, hashtable0.size());
      assertFalse(hashtable0.isEmpty());
      
      Class<ChronoLocalDate> class2 = ChronoLocalDate.class;
      Long long3 = new Long((-3582L));
      assertNotNull(long3);
      assertEquals((-3582L), (long)long3);
      assertFalse(long3.equals((Object)long2));
      assertFalse(long3.equals((Object)long1));
      assertFalse(long3.equals((Object)long0));
      
      Short short0 = TypeUtils.castToShort(long3);
      assertNotNull(short0);
      assertEquals((short) (-3582), (short)short0);
      assertFalse(long3.equals((Object)long2));
      assertFalse(long3.equals((Object)long1));
      assertFalse(long3.equals((Object)long0));
      
      // Undeclared exception!
      try { 
        TypeUtils.cast((Object) "()Ljava/lang/String;", (Type) class2, parserConfig0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // create asm serializer error, class byte
         //
         verifyException("com.alibaba.fastjson.serializer.SerializeConfig", e);
      }
  }

  @Test(timeout = 4000)
  public void test095()  throws Throwable  {
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      Class<ClassLoader> class0 = ClassLoader.class;
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.PascalCase;
      List<FieldInfo> list0 = TypeUtils.computeGettersWithFieldBase(class0, weakHashMap0, false, propertyNamingStrategy0);
      assertNotNull(list0);
      assertEquals(0, list0.size());
      assertTrue(list0.isEmpty());
      
      ThreadGroup threadGroup0 = new ThreadGroup("R7Xw':u/ Ib.%b;.~U");
      assertNotNull(threadGroup0);
      assertEquals("R7Xw':u/ Ib.%b;.~U", threadGroup0.getName());
      
      Thread thread0 = MockThread.currentThread();
      assertNotNull(thread0);
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      
      MockThread mockThread0 = new MockThread(thread0, "R7Xw':u/ Ib.%b;.~U");
      assertNotNull(mockThread0);
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      
      MockThread mockThread1 = new MockThread(threadGroup0, mockThread0);
      assertNotNull(mockThread1);
      assertEquals("R7Xw':u/ Ib.%b;.~U", threadGroup0.getName());
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread1.isDaemon());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.isInterrupted());
      assertFalse(mockThread1.equals((Object)mockThread0));
      
      ClassLoader classLoader0 = mockThread1.getContextClassLoader();
      assertNotNull(classLoader0);
      assertNotSame(mockThread0, mockThread1);
      assertNotSame(mockThread1, mockThread0);
      assertEquals("R7Xw':u/ Ib.%b;.~U", threadGroup0.getName());
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread1.isDaemon());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.isInterrupted());
      assertFalse(mockThread0.equals((Object)mockThread1));
      assertFalse(mockThread1.equals((Object)mockThread0));
      
      ClassLoader classLoader1 = classLoader0.getParent();
      assertNotNull(classLoader1);
      assertNotSame(mockThread0, mockThread1);
      assertNotSame(mockThread1, mockThread0);
      assertEquals("R7Xw':u/ Ib.%b;.~U", threadGroup0.getName());
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread1.isDaemon());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.isInterrupted());
      assertFalse(mockThread0.equals((Object)mockThread1));
      assertFalse(mockThread1.equals((Object)mockThread0));
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      classLoader1.setClassAssertionStatus("R7Xw':u/ Ib.%b;.~U", true);
      assertNotSame(mockThread0, mockThread1);
      assertNotSame(mockThread1, mockThread0);
      assertEquals("R7Xw':u/ Ib.%b;.~U", threadGroup0.getName());
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread1.isDaemon());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.isInterrupted());
      assertFalse(mockThread0.equals((Object)mockThread1));
      assertFalse(mockThread1.equals((Object)mockThread0));
      assertFalse(classLoader0.equals((Object)classLoader1));
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      Class<?> class1 = TypeUtils.loadClass("R7Xw':u/ Ib.%b;.~U", classLoader0);
      assertNull(class1);
      assertNotSame(mockThread0, mockThread1);
      assertNotSame(mockThread1, mockThread0);
      assertEquals("R7Xw':u/ Ib.%b;.~U", threadGroup0.getName());
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread1.isDaemon());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.isInterrupted());
      assertFalse(mockThread0.equals((Object)mockThread1));
      assertFalse(mockThread1.equals((Object)mockThread0));
      assertFalse(classLoader0.equals((Object)classLoader1));
      
      SQLTransactionRollbackException sQLTransactionRollbackException0 = new SQLTransactionRollbackException("lineNumber");
      assertNotNull(sQLTransactionRollbackException0);
      assertEquals(0, sQLTransactionRollbackException0.getErrorCode());
      assertEquals("lineNumber", sQLTransactionRollbackException0.getMessage());
      assertNull(sQLTransactionRollbackException0.getSQLState());
      assertEquals("java.sql.SQLTransactionRollbackException: lineNumber", sQLTransactionRollbackException0.toString());
      
      ClassLoader classLoader2 = ClassLoader.getSystemClassLoader();
      assertNotNull(classLoader2);
      assertSame(classLoader2, classLoader1);
      assertFalse(classLoader2.equals((Object)classLoader0));
      
      ParserConfig parserConfig0 = new ParserConfig(classLoader2);
      assertNotNull(parserConfig0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(classLoader2.equals((Object)classLoader0));
      
      // Undeclared exception!
      try { 
        TypeUtils.cast((Object) classLoader0, (Type) null, parserConfig0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to : null
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test096()  throws Throwable  {
      TreeMap<String, Object> treeMap0 = new TreeMap<String, Object>();
      assertNotNull(treeMap0);
      assertEquals(0, treeMap0.size());
      
      Object object0 = treeMap0.put("password", "password");
      assertNull(object0);
      assertEquals(1, treeMap0.size());
      
      Class<Throwable> class0 = Throwable.class;
      boolean boolean0 = TypeUtils.isPath(class0);
      assertFalse(boolean0);
      
      // Undeclared exception!
      try { 
        TypeUtils.castToBigDecimal(treeMap0);
        fail("Expecting exception: NumberFormatException");
      
      } catch(NumberFormatException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.math.BigDecimal", e);
      }
  }

  @Test(timeout = 4000)
  public void test097()  throws Throwable  {
      Class<ChronoLocalDate> class0 = ChronoLocalDate.class;
      Class<Annotation> class1 = Annotation.class;
      Annotation annotation0 = TypeUtils.getAnnotation((Class<?>) class0, class1);
      assertNull(annotation0);
      
      Class<?> class2 = TypeUtils.getCollectionItemClass(class0);
      assertNotNull(class2);
      assertFalse(class2.isAnnotation());
      assertEquals(1, class2.getModifiers());
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
      assertFalse(class2.isArray());
      assertFalse(class2.isPrimitive());
      assertFalse(class2.isInterface());
      assertEquals("class java.lang.Object", class2.toString());
      
      DateFormatSymbols dateFormatSymbols0 = DateFormatSymbols.getInstance();
      assertNotNull(dateFormatSymbols0);
      assertEquals("GyMdkHmsSEDFwWahKzZ", dateFormatSymbols0.getLocalPatternChars());
      
      LinkedHashMap<Jdk8DateCodec, ChoiceFormat> linkedHashMap0 = new LinkedHashMap<Jdk8DateCodec, ChoiceFormat>();
      assertNotNull(linkedHashMap0);
      assertTrue(linkedHashMap0.isEmpty());
      assertEquals(0, linkedHashMap0.size());
      
      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar((-1448), 246, (-1448), (-1448), 14);
      assertNotNull(mockGregorianCalendar0);
      assertEquals(1, mockGregorianCalendar0.getFirstDayOfWeek());
      assertEquals(1, mockGregorianCalendar0.getMinimalDaysInFirstWeek());
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=?,areFieldsSet=false,areAllFieldsSet=false,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=?,YEAR=-1448,MONTH=246,WEEK_OF_YEAR=?,WEEK_OF_MONTH=?,DAY_OF_MONTH=-1448,DAY_OF_YEAR=?,DAY_OF_WEEK=?,DAY_OF_WEEK_IN_MONTH=?,AM_PM=0,HOUR=-1448,HOUR_OF_DAY=-1448,MINUTE=14,SECOND=0,MILLISECOND=?,ZONE_OFFSET=?,DST_OFFSET=?]", mockGregorianCalendar0.toString());
      assertTrue(mockGregorianCalendar0.isLenient());
      
      mockGregorianCalendar0.set((-1448), (-2372), 90, 1, 53);
      assertEquals(1, mockGregorianCalendar0.getFirstDayOfWeek());
      assertEquals(1, mockGregorianCalendar0.getMinimalDaysInFirstWeek());
      assertTrue(mockGregorianCalendar0.isLenient());
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=?,areFieldsSet=false,areAllFieldsSet=false,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=?,YEAR=-1448,MONTH=-2372,WEEK_OF_YEAR=?,WEEK_OF_MONTH=?,DAY_OF_MONTH=90,DAY_OF_YEAR=?,DAY_OF_WEEK=?,DAY_OF_WEEK_IN_MONTH=?,AM_PM=0,HOUR=-1448,HOUR_OF_DAY=1,MINUTE=53,SECOND=0,MILLISECOND=?,ZONE_OFFSET=?,DST_OFFSET=?]", mockGregorianCalendar0.toString());
      
      Date date0 = TypeUtils.castToSqlDate(mockGregorianCalendar0);
      assertNotNull(date0);
      assertEquals(1, mockGregorianCalendar0.getFirstDayOfWeek());
      assertEquals(1, mockGregorianCalendar0.getMinimalDaysInFirstWeek());
      assertTrue(mockGregorianCalendar0.isLenient());
      assertEquals("org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=?,areFieldsSet=false,areAllFieldsSet=false,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=?,YEAR=-1448,MONTH=-2372,WEEK_OF_YEAR=?,WEEK_OF_MONTH=?,DAY_OF_MONTH=90,DAY_OF_YEAR=?,DAY_OF_WEEK=?,DAY_OF_WEEK_IN_MONTH=?,AM_PM=0,HOUR=-1448,HOUR_OF_DAY=1,MINUTE=53,SECOND=0,MILLISECOND=?,ZONE_OFFSET=?,DST_OFFSET=?]", mockGregorianCalendar0.toString());
      
      Class<?> class3 = TypeUtils.getClass((Type) class0);
      assertNotNull(class3);
      assertNotSame(class3, class2);
      assertEquals(1537, class3.getModifiers());
      assertFalse(class3.isEnum());
      assertFalse(class3.isSynthetic());
      assertEquals("interface java.time.chrono.ChronoLocalDate", class3.toString());
      assertFalse(class3.isArray());
      assertFalse(class3.isPrimitive());
      assertFalse(class3.isAnnotation());
      assertTrue(class3.isInterface());
      assertFalse(class3.equals((Object)class2));
      
      BatchUpdateException batchUpdateException0 = new BatchUpdateException();
      assertNotNull(batchUpdateException0);
      assertNull(batchUpdateException0.getMessage());
      assertNull(batchUpdateException0.getSQLState());
      assertEquals(0, batchUpdateException0.getErrorCode());
      assertEquals("java.sql.BatchUpdateException", batchUpdateException0.toString());
      
      ParserConfig parserConfig0 = ParserConfig.global;
      assertNotNull(parserConfig0);
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      
      Class<SQLSyntaxErrorException> class4 = SQLSyntaxErrorException.class;
      TreeMap<String, String> treeMap0 = new TreeMap<String, String>();
      assertNotNull(treeMap0);
      assertEquals(0, treeMap0.size());
      
      Map.Entry<String, String> map_Entry0 = treeMap0.lastEntry();
      assertNull(map_Entry0);
      assertEquals(0, treeMap0.size());
      
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class4, (Map<String, String>) treeMap0);
      assertNotNull(list0);
      assertEquals(0, treeMap0.size());
      assertTrue(list0.isEmpty());
      assertEquals(0, list0.size());
      
      ParserConfig parserConfig1 = new ParserConfig(false);
      assertNotNull(parserConfig1);
      assertFalse(parserConfig1.isAutoTypeSupport());
      assertTrue(parserConfig1.isAsmEnable());
      assertFalse(parserConfig1.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig1.compatibleWithJavaBean);
      assertFalse(parserConfig1.equals((Object)parserConfig0));
      
      boolean boolean0 = TypeUtils.isGenericParamType(class4);
      assertFalse(boolean0);
      
      Field[] fieldArray0 = new Field[0];
      Field field0 = TypeUtils.getField(class2, "localizedMessage", fieldArray0);
      assertNull(field0);
      assertNotSame(class2, class3);
      assertFalse(class2.isAnnotation());
      assertEquals(1, class2.getModifiers());
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
      assertFalse(class2.isArray());
      assertFalse(class2.isPrimitive());
      assertFalse(class2.isInterface());
      assertEquals("class java.lang.Object", class2.toString());
      assertFalse(class2.equals((Object)class3));
  }

  @Test(timeout = 4000)
  public void test098()  throws Throwable  {
      Class<ClassLoader> class0 = ClassLoader.class;
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.CamelCase;
      List<FieldInfo> list0 = TypeUtils.computeGettersWithFieldBase(class0, (Map<String, String>) null, true, propertyNamingStrategy0);
      assertNotNull(list0);
      assertFalse(list0.isEmpty());
      assertEquals(12, list0.size());
      
      OutOfMemoryError outOfMemoryError0 = new OutOfMemoryError("6@-aPGtLiCIWWF2k*:");
      assertNotNull(outOfMemoryError0);
      assertEquals("java.lang.OutOfMemoryError: 6@-aPGtLiCIWWF2k*:", outOfMemoryError0.toString());
      assertEquals("6@-aPGtLiCIWWF2k*:", outOfMemoryError0.getMessage());
      
      Throwable throwable0 = outOfMemoryError0.fillInStackTrace();
      assertNotNull(throwable0);
      assertSame(outOfMemoryError0, throwable0);
      assertSame(throwable0, outOfMemoryError0);
      assertEquals("java.lang.OutOfMemoryError: 6@-aPGtLiCIWWF2k*:", outOfMemoryError0.toString());
      assertEquals("6@-aPGtLiCIWWF2k*:", outOfMemoryError0.getMessage());
      assertEquals("6@-aPGtLiCIWWF2k*:", throwable0.getMessage());
      assertEquals("java.lang.OutOfMemoryError: 6@-aPGtLiCIWWF2k*:", throwable0.toString());
      
      SQLRecoverableException sQLRecoverableException0 = new SQLRecoverableException();
      assertNotNull(sQLRecoverableException0);
      assertEquals("java.sql.SQLRecoverableException", sQLRecoverableException0.toString());
      assertNull(sQLRecoverableException0.getMessage());
      assertNull(sQLRecoverableException0.getSQLState());
      assertEquals(0, sQLRecoverableException0.getErrorCode());
      
      Double double0 = new Double((-593.902));
      assertNotNull(double0);
      assertEquals((-593.902), (double)double0, 0.01);
      
      // Undeclared exception!
      try { 
        TypeUtils.castToSqlDate(double0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to Date, value : -593.902
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test099()  throws Throwable  {
      Class<IndexOutOfBoundsException> class0 = IndexOutOfBoundsException.class;
      boolean boolean0 = TypeUtils.isPath(class0);
      assertFalse(boolean0);
      
      long long0 = TypeUtils.fnv1a_64_lower("4=~<ub)>4/(1Bx2[<YT");
      assertEquals((-1026665568766419764L), long0);
      
      ParserConfig parserConfig0 = ParserConfig.global;
      assertNotNull(parserConfig0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      parserConfig0.setAutoTypeSupport(false);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      parserConfig0.clearDeserializers();
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      OutOfMemoryError outOfMemoryError0 = new OutOfMemoryError("fastjson.parser.autoTypeAccept");
      assertNotNull(outOfMemoryError0);
      assertEquals("fastjson.parser.autoTypeAccept", outOfMemoryError0.getMessage());
      assertEquals("java.lang.OutOfMemoryError: fastjson.parser.autoTypeAccept", outOfMemoryError0.toString());
      
      Throwable throwable0 = outOfMemoryError0.fillInStackTrace();
      assertNotNull(throwable0);
      assertSame(outOfMemoryError0, throwable0);
      assertSame(throwable0, outOfMemoryError0);
      assertEquals("fastjson.parser.autoTypeAccept", outOfMemoryError0.getMessage());
      assertEquals("java.lang.OutOfMemoryError: fastjson.parser.autoTypeAccept", outOfMemoryError0.toString());
      assertEquals("java.lang.OutOfMemoryError: fastjson.parser.autoTypeAccept", throwable0.toString());
      assertEquals("fastjson.parser.autoTypeAccept", throwable0.getMessage());
      
      SQLRecoverableException sQLRecoverableException0 = new SQLRecoverableException();
      assertNotNull(sQLRecoverableException0);
      assertEquals(0, sQLRecoverableException0.getErrorCode());
      assertEquals("java.sql.SQLRecoverableException", sQLRecoverableException0.toString());
      assertNull(sQLRecoverableException0.getSQLState());
      assertNull(sQLRecoverableException0.getMessage());
      
      byte[] byteArray0 = new byte[4];
      byteArray0[1] = (byte) (-119);
      byteArray0[2] = (byte)22;
      byteArray0[3] = (byte) (-119);
      BigInteger bigInteger0 = new BigInteger(byteArray0);
      assertNotNull(bigInteger0);
      assertEquals((short)5769, bigInteger0.shortValue());
      assertEquals((byte) (-119), bigInteger0.byteValue());
      assertArrayEquals(new byte[] {(byte)0, (byte) (-119), (byte)22, (byte) (-119)}, byteArray0);
      
      Date date0 = TypeUtils.castToSqlDate(bigInteger0);
      assertNotNull(date0);
      assertEquals((short)5769, bigInteger0.shortValue());
      assertEquals((byte) (-119), bigInteger0.byteValue());
      assertArrayEquals(new byte[] {(byte)0, (byte) (-119), (byte)22, (byte) (-119)}, byteArray0);
  }

  @Test(timeout = 4000)
  public void test100()  throws Throwable  {
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      assertNotNull(classLoader0);
      
      classLoader0.setDefaultAssertionStatus(true);
      classLoader0.setDefaultAssertionStatus(true);
      classLoader0.clearAssertionStatus();
      classLoader0.setClassAssertionStatus("L", false);
      Class<?> class0 = TypeUtils.loadClass("L", classLoader0);
      assertNull(class0);
      
      Class<SQLInvalidAuthorizationSpecException> class1 = SQLInvalidAuthorizationSpecException.class;
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      String string0 = weakHashMap0.put("NULL", "L");
      assertNull(string0);
      
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class1, (Map<String, String>) weakHashMap0);
      assertNotNull(list0);
      assertEquals(0, list0.size());
      assertTrue(list0.isEmpty());
      
      Short short0 = new Short((short)74);
      assertNotNull(short0);
      assertEquals((short)74, (short)short0);
      
      Integer integer0 = TypeUtils.castToInt(short0);
      assertNotNull(integer0);
      assertEquals(74, (int)integer0);
      
      // Undeclared exception!
      try { 
        TypeUtils.createCollection((Type) null);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // TODO
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test101()  throws Throwable  {
      Class<ChoiceFormat> class0 = ChoiceFormat.class;
      ParserConfig parserConfig0 = ParserConfig.getGlobalInstance();
      assertNotNull(parserConfig0);
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      
      Class<SecurityException> class1 = SecurityException.class;
      Thread thread0 = MockThread.currentThread();
      assertNotNull(thread0);
      assertFalse(thread0.isInterrupted());
      assertFalse(thread0.isDaemon());
      
      MockThread mockThread0 = new MockThread(thread0, "fastjson.parser.deny");
      assertNotNull(mockThread0);
      assertFalse(thread0.isInterrupted());
      assertFalse(thread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isDaemon());
      
      MockThread mockThread1 = new MockThread(mockThread0);
      assertNotNull(mockThread1);
      assertFalse(thread0.isInterrupted());
      assertFalse(thread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.isDaemon());
      assertFalse(mockThread1.isInterrupted());
      assertFalse(mockThread1.equals((Object)mockThread0));
      
      ParserConfig parserConfig1 = ParserConfig.global;
      assertNotNull(parserConfig1);
      assertSame(parserConfig1, parserConfig0);
      assertFalse(parserConfig1.isAutoTypeSupport());
      assertTrue(parserConfig1.isAsmEnable());
      assertTrue(parserConfig1.compatibleWithJavaBean);
      assertFalse(parserConfig1.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      Class<Object> class2 = Object.class;
      JavaBeanInfo javaBeanInfo0 = JavaBeanInfo.build((Class<?>) class2, (Type) class0, (PropertyNamingStrategy) null, true, false);
      assertNotNull(javaBeanInfo0);
      assertEquals(0, javaBeanInfo0.parserFeatures);
      assertEquals(0, javaBeanInfo0.defaultConstructorParameterSize);
      
      ParserConfig parserConfig2 = ParserConfig.getGlobalInstance();
      assertNotNull(parserConfig2);
      assertSame(parserConfig2, parserConfig1);
      assertSame(parserConfig2, parserConfig0);
      assertFalse(parserConfig2.isAutoTypeSupport());
      assertTrue(parserConfig2.isAsmEnable());
      assertTrue(parserConfig2.compatibleWithJavaBean);
      assertFalse(parserConfig2.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      GenericArrayType genericArrayType0 = mock(GenericArrayType.class, new ViolatedAssumptionAnswer());
      sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl parameterizedTypeImpl0 = (sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl)TypeReference.LIST_STRING;
      assertNotNull(parameterizedTypeImpl0);
      
      ParserConfig parserConfig3 = new ParserConfig(false);
      assertNotNull(parserConfig3);
      assertFalse(parserConfig3.isAutoTypeSupport());
      assertTrue(parserConfig3.isAsmEnable());
      assertTrue(parserConfig3.compatibleWithJavaBean);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig3.fieldBased);
      assertFalse(parserConfig3.equals((Object)parserConfig0));
      assertFalse(parserConfig3.equals((Object)parserConfig1));
      assertFalse(parserConfig3.equals((Object)parserConfig2));
      
      Map<String, String> map0 = ZoneId.SHORT_IDS;
      assertNotNull(map0);
      assertFalse(map0.isEmpty());
      assertEquals(28, map0.size());
      
      Jdk8DateCodec jdk8DateCodec0 = new Jdk8DateCodec();
      assertNotNull(jdk8DateCodec0);
      assertEquals(4, jdk8DateCodec0.getFastMatchToken());
      
      Byte byte0 = new Byte((byte)22);
      assertNotNull(byte0);
      assertEquals((byte)22, (byte)byte0);
      
      Float float0 = TypeUtils.castToFloat(byte0);
      assertNotNull(float0);
      assertEquals(22.0F, (float)float0, 0.01F);
  }

  @Test(timeout = 4000)
  public void test102()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "x");
      assertFalse(boolean0);
      
      Class<TimeUnit> class0 = TimeUnit.class;
      HashMap<String, String> hashMap0 = new HashMap<String, String>(1174536705, 1174536705);
      assertNotNull(hashMap0);
      assertTrue(hashMap0.isEmpty());
      assertEquals(0, hashMap0.size());
      
      java.util.IdentityHashMap<Collator, SQLIntegrityConstraintViolationException> identityHashMap0 = new java.util.IdentityHashMap<Collator, SQLIntegrityConstraintViolationException>();
      assertNotNull(identityHashMap0);
      assertEquals(0, identityHashMap0.size());
      assertTrue(identityHashMap0.isEmpty());
      
      String string0 = hashMap0.remove((Object) identityHashMap0);
      assertNull(string0);
      assertTrue(hashMap0.isEmpty());
      assertEquals(0, hashMap0.size());
      assertEquals(0, identityHashMap0.size());
      assertTrue(identityHashMap0.isEmpty());
      
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class0, (Map<String, String>) hashMap0, true);
      assertNotNull(list0);
      assertTrue(hashMap0.isEmpty());
      assertEquals(0, hashMap0.size());
      assertTrue(list0.isEmpty());
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test103()  throws Throwable  {
      Constructor<Short>[] constructorArray0 = (Constructor<Short>[]) Array.newInstance(Constructor.class, 8);
      // Undeclared exception!
      try { 
        TypeUtils.getKoltinConstructor(constructorArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test104()  throws Throwable  {
      Class<MockJapaneseDate> class0 = MockJapaneseDate.class;
      boolean boolean0 = TypeUtils.isProxy(class0);
      assertFalse(boolean0);
      
      LinkedList<FieldInfo> linkedList0 = new LinkedList<FieldInfo>();
      assertNotNull(linkedList0);
      assertEquals(0, linkedList0.size());
      
      VerifyError verifyError0 = new VerifyError("");
      assertNotNull(verifyError0);
      assertEquals("", verifyError0.getMessage());
      assertEquals("java.lang.VerifyError: ", verifyError0.toString());
      
      ThreadGroup threadGroup0 = new ThreadGroup("");
      assertNotNull(threadGroup0);
      assertEquals("", threadGroup0.getName());
      
      ThreadGroup threadGroup1 = new ThreadGroup(threadGroup0, "org.springframework.security.web.savedrequest.DefaultSavedRequest");
      assertNotNull(threadGroup1);
      assertEquals("", threadGroup0.getName());
      assertEquals("org.springframework.security.web.savedrequest.DefaultSavedRequest", threadGroup1.getName());
      assertFalse(threadGroup1.equals((Object)threadGroup0));
      
      threadGroup1.interrupt();
      assertNotSame(threadGroup0, threadGroup1);
      assertNotSame(threadGroup1, threadGroup0);
      assertEquals("", threadGroup0.getName());
      assertEquals("org.springframework.security.web.savedrequest.DefaultSavedRequest", threadGroup1.getName());
      assertFalse(threadGroup0.equals((Object)threadGroup1));
      assertFalse(threadGroup1.equals((Object)threadGroup0));
      
      Thread thread0 = MockThread.currentThread();
      assertNotNull(thread0);
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      
      MockThread mockThread0 = new MockThread(threadGroup1, thread0, "o", (-67L));
      assertNotNull(mockThread0);
      assertEquals("", threadGroup0.getName());
      assertEquals("org.springframework.security.web.savedrequest.DefaultSavedRequest", threadGroup1.getName());
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(threadGroup0.equals((Object)threadGroup1));
      assertFalse(threadGroup1.equals((Object)threadGroup0));
      
      ClassLoader classLoader0 = mockThread0.getContextClassLoader();
      assertNotNull(classLoader0);
      assertNotSame(threadGroup0, threadGroup1);
      assertNotSame(threadGroup1, threadGroup0);
      assertEquals("", threadGroup0.getName());
      assertEquals("org.springframework.security.web.savedrequest.DefaultSavedRequest", threadGroup1.getName());
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(threadGroup0.equals((Object)threadGroup1));
      assertFalse(threadGroup1.equals((Object)threadGroup0));
      
      Class<?> class1 = TypeUtils.loadClass("com.alibaba.fastjson.parser.deserializer.MapDeserializer", classLoader0, false);
      assertNotNull(class1);
      assertNotSame(threadGroup0, threadGroup1);
      assertNotSame(threadGroup1, threadGroup0);
      assertEquals("", threadGroup0.getName());
      assertEquals("org.springframework.security.web.savedrequest.DefaultSavedRequest", threadGroup1.getName());
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertEquals("class com.alibaba.fastjson.parser.deserializer.MapDeserializer", class1.toString());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals(1, class1.getModifiers());
      assertFalse(class1.isAnnotation());
      assertFalse(threadGroup0.equals((Object)threadGroup1));
      assertFalse(threadGroup1.equals((Object)threadGroup0));
      
      boolean boolean1 = TypeUtils.isNumber("moduleVersion");
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
      
      Class<?> class2 = TypeUtils.getCollectionItemClass(class1);
      assertNotNull(class2);
      assertNotSame(threadGroup0, threadGroup1);
      assertNotSame(threadGroup1, threadGroup0);
      assertNotSame(class1, class2);
      assertNotSame(class2, class1);
      assertEquals("", threadGroup0.getName());
      assertEquals("org.springframework.security.web.savedrequest.DefaultSavedRequest", threadGroup1.getName());
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertEquals("class com.alibaba.fastjson.parser.deserializer.MapDeserializer", class1.toString());
      assertFalse(class1.isPrimitive());
      assertFalse(class1.isInterface());
      assertFalse(class1.isArray());
      assertFalse(class1.isEnum());
      assertFalse(class1.isSynthetic());
      assertEquals(1, class1.getModifiers());
      assertFalse(class1.isAnnotation());
      assertEquals(1, class2.getModifiers());
      assertFalse(class2.isEnum());
      assertFalse(class2.isSynthetic());
      assertEquals("class java.lang.Object", class2.toString());
      assertFalse(class2.isPrimitive());
      assertFalse(class2.isAnnotation());
      assertFalse(class2.isArray());
      assertFalse(class2.isInterface());
      assertFalse(threadGroup0.equals((Object)threadGroup1));
      assertFalse(threadGroup1.equals((Object)threadGroup0));
      assertFalse(class2.equals((Object)class1));
  }

  @Test(timeout = 4000)
  public void test105()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "char");
      assertFalse(boolean0);
      
      String string0 = TypeUtils.decapitalize("(Z4st8rAT$r");
      assertNotNull(string0);
      assertEquals("(Z4st8rAT$r", string0);
      
      boolean boolean1 = TypeUtils.isHibernateInitialized("(Z4st8rAT$r");
      assertTrue(boolean1);
      assertFalse(boolean1 == boolean0);
      
      Class<Timestamp> class0 = Timestamp.class;
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      Class<NoSuchMethodException> class1 = NoSuchMethodException.class;
      Class<Annotation> class2 = Annotation.class;
      Annotation annotation0 = TypeUtils.getAnnotation((Class<?>) class1, class2);
      assertNull(annotation0);
      
      ParserConfig parserConfig0 = ParserConfig.global;
      assertNotNull(parserConfig0);
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      parserConfig0.setAutoTypeSupport(true);
      assertTrue(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      // Undeclared exception!
      try { 
        TypeUtils.cast((Object) "(Z4st8rAT$r", class0, parserConfig0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to Timestamp, value : (Z4st8rAT$r
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test106()  throws Throwable  {
      Class<InstantiationException> class0 = InstantiationException.class;
      ParserConfig parserConfig0 = ParserConfig.global;
      assertNotNull(parserConfig0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      parserConfig0.setAutoTypeSupport(true);
      assertTrue(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      parserConfig0.clearDeserializers();
      assertTrue(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      ParserConfig parserConfig1 = new ParserConfig(false);
      assertNotNull(parserConfig1);
      assertTrue(parserConfig1.isAsmEnable());
      assertFalse(parserConfig1.isAutoTypeSupport());
      assertTrue(parserConfig1.compatibleWithJavaBean);
      assertFalse(parserConfig1.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig1.equals((Object)parserConfig0));
      
      boolean boolean0 = TypeUtils.compatibleWithFieldName;
      assertTrue(boolean0);
      
      boolean boolean1 = TypeUtils.isPath(class0);
      assertFalse(boolean1);
      assertFalse(boolean1 == boolean0);
      
      Class<IllegalMonitorStateException> class1 = IllegalMonitorStateException.class;
      Class<SQLDataException> class2 = SQLDataException.class;
      int int0 = TypeUtils.getParserFeatures(class2);
      assertEquals(0, int0);
      
      StackOverflowError stackOverflowError0 = new StackOverflowError();
      assertNotNull(stackOverflowError0);
      assertNull(stackOverflowError0.getMessage());
      assertEquals("java.lang.StackOverflowError", stackOverflowError0.toString());
      
      SecurityException securityException0 = new SecurityException("get", stackOverflowError0);
      assertNotNull(securityException0);
      assertNull(stackOverflowError0.getMessage());
      assertEquals("java.lang.StackOverflowError", stackOverflowError0.toString());
      assertEquals("get", securityException0.getMessage());
      assertEquals("java.lang.SecurityException: get", securityException0.toString());
      
      ParserConfig parserConfig2 = new ParserConfig();
      assertNotNull(parserConfig2);
      assertFalse(parserConfig2.isAutoTypeSupport());
      assertTrue(parserConfig2.isAsmEnable());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig2.compatibleWithJavaBean);
      assertFalse(parserConfig2.fieldBased);
      assertFalse(parserConfig2.equals((Object)parserConfig0));
      assertFalse(parserConfig2.equals((Object)parserConfig1));
      
      SQLTransactionRollbackException sQLTransactionRollbackException0 = new SQLTransactionRollbackException("get");
      assertNotNull(sQLTransactionRollbackException0);
      assertEquals("get", sQLTransactionRollbackException0.getMessage());
      assertEquals("java.sql.SQLTransactionRollbackException: get", sQLTransactionRollbackException0.toString());
      assertNull(sQLTransactionRollbackException0.getSQLState());
      assertEquals(0, sQLTransactionRollbackException0.getErrorCode());
      
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      assertNotNull(classLoader0);
      
      ParserConfig parserConfig3 = new ParserConfig(classLoader0);
      assertNotNull(parserConfig3);
      assertFalse(parserConfig3.isAutoTypeSupport());
      assertTrue(parserConfig3.isAsmEnable());
      assertFalse(parserConfig3.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig3.compatibleWithJavaBean);
      assertFalse(parserConfig3.equals((Object)parserConfig0));
      assertFalse(parserConfig3.equals((Object)parserConfig1));
      assertFalse(parserConfig3.equals((Object)parserConfig2));
      
      // Undeclared exception!
      try { 
        TypeUtils.cast((Object) "getClass", (Type) class1, parserConfig3);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to : java.lang.IllegalMonitorStateException
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test107()  throws Throwable  {
      ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
      assertNotNull(classLoader0);
      
      classLoader0.setDefaultAssertionStatus(true);
      classLoader0.setDefaultAssertionStatus(true);
      classLoader0.clearAssertionStatus();
      classLoader0.setClassAssertionStatus("L", false);
      Class<?> class0 = TypeUtils.loadClass("L", classLoader0);
      assertNull(class0);
      
      Class<SQLInvalidAuthorizationSpecException> class1 = SQLInvalidAuthorizationSpecException.class;
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      String string0 = weakHashMap0.put("Ljava.util.concurrent.ConcurrentSkipListSet", "L");
      assertNull(string0);
      
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class1, (Map<String, String>) weakHashMap0);
      assertNotNull(list0);
      assertEquals(0, list0.size());
      assertTrue(list0.isEmpty());
      
      Short short0 = new Short((short)74);
      assertNotNull(short0);
      assertEquals((short)74, (short)short0);
      
      Integer integer0 = TypeUtils.castToInt(short0);
      assertNotNull(integer0);
      assertEquals(74, (int)integer0);
      
      Integer integer1 = TypeUtils.castToInt(integer0);
      assertNotNull(integer1);
      assertEquals(74, (int)integer1);
      
      Class<BatchUpdateException> class2 = BatchUpdateException.class;
      boolean boolean0 = TypeUtils.isPath(class2);
      assertFalse(boolean0);
      
      SQLNonTransientConnectionException sQLNonTransientConnectionException0 = new SQLNonTransientConnectionException("", (String) null, 8);
      assertNotNull(sQLNonTransientConnectionException0);
      assertEquals("java.sql.SQLNonTransientConnectionException: ", sQLNonTransientConnectionException0.toString());
      assertEquals(8, sQLNonTransientConnectionException0.getErrorCode());
      assertEquals("", sQLNonTransientConnectionException0.getMessage());
      assertNull(sQLNonTransientConnectionException0.getSQLState());
      
      // Undeclared exception!
      try { 
        TypeUtils.castToBoolean(sQLNonTransientConnectionException0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to boolean, value : java.sql.SQLNonTransientConnectionException: 
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test108()  throws Throwable  {
      Class<Jdk8DateCodec> class0 = Jdk8DateCodec.class;
      Map<String, String> map0 = ZoneId.SHORT_IDS;
      assertNotNull(map0);
      assertEquals(28, map0.size());
      assertFalse(map0.isEmpty());
      
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.SnakeCase;
      List<FieldInfo> list0 = TypeUtils.computeGettersWithFieldBase(class0, map0, true, propertyNamingStrategy0);
      assertNotNull(list0);
      assertEquals(28, map0.size());
      assertFalse(map0.isEmpty());
      assertEquals(0, list0.size());
      assertTrue(list0.isEmpty());
      
      boolean boolean0 = TypeUtils.isNumber("Ljava.awt.Rectangle");
      assertFalse(boolean0);
      
      MockThread mockThread0 = new MockThread((ThreadGroup) null, (Runnable) null);
      assertNotNull(mockThread0);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      
      ClassLoader classLoader0 = mockThread0.getContextClassLoader();
      assertNotNull(classLoader0);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      
      ClassLoader classLoader1 = mockThread0.getContextClassLoader();
      assertNotNull(classLoader1);
      assertSame(classLoader1, classLoader0);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      
      classLoader1.setDefaultAssertionStatus(false);
      assertSame(classLoader1, classLoader0);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      
      mockThread0.run();
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      
      ClassLoader classLoader2 = classLoader0.getParent();
      assertNotNull(classLoader2);
      assertSame(classLoader0, classLoader1);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(classLoader2.equals((Object)classLoader1));
      assertFalse(classLoader2.equals((Object)classLoader0));
      
      ClassLoader classLoader3 = classLoader2.getParent();
      assertNotNull(classLoader3);
      assertSame(classLoader0, classLoader1);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(classLoader0.equals((Object)classLoader2));
      assertFalse(classLoader2.equals((Object)classLoader1));
      assertFalse(classLoader2.equals((Object)classLoader0));
      assertFalse(classLoader3.equals((Object)classLoader2));
      assertFalse(classLoader3.equals((Object)classLoader1));
      assertFalse(classLoader3.equals((Object)classLoader0));
      
      classLoader2.setClassAssertionStatus("Lorg.springframework.util.LinkedMultiValueMap", true);
      assertSame(classLoader0, classLoader1);
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(classLoader0.equals((Object)classLoader2));
      assertFalse(classLoader0.equals((Object)classLoader3));
      assertFalse(classLoader2.equals((Object)classLoader3));
      assertFalse(classLoader2.equals((Object)classLoader1));
      assertFalse(classLoader2.equals((Object)classLoader0));
      
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      String string0 = weakHashMap0.put("can not cast to Timestamp, value : ", "^FFFg,*s]utO^JE");
      assertNull(string0);
      
      String string1 = weakHashMap0.put("can not cast to Timestamp, value : ", "Ljava.awt.Rectangle");
      assertNotNull(string1);
      assertEquals("^FFFg,*s]utO^JE", string1);
      
      List<FieldInfo> list1 = TypeUtils.computeGetters((Class<?>) class0, (Map<String, String>) weakHashMap0);
      assertNotNull(list1);
      assertNotSame(list1, list0);
      assertEquals(0, list1.size());
      assertTrue(list1.isEmpty());
      assertTrue(list1.equals((Object)list0));
      
      Short short0 = new Short((short)74);
      assertNotNull(short0);
      assertEquals((short)74, (short)short0);
      
      Boolean boolean1 = new Boolean("d-ho1a3k");
      assertNotNull(boolean1);
      assertFalse(boolean1);
      assertTrue(boolean1.equals((Object)boolean0));
      
      Integer integer0 = TypeUtils.castToInt(boolean1);
      assertNotNull(integer0);
      assertEquals(0, (int)integer0);
      assertTrue(boolean1.equals((Object)boolean0));
      
      boolean boolean2 = TypeUtils.isPath(class0);
      assertFalse(boolean2);
      assertTrue(boolean2 == boolean0);
      
      ParserConfig parserConfig0 = new ParserConfig(false);
      assertNotNull(parserConfig0);
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      
      NoSuchFieldError noSuchFieldError0 = new NoSuchFieldError("can not cast to Timestamp, value : ");
      assertNotNull(noSuchFieldError0);
      assertEquals("can not cast to Timestamp, value : ", noSuchFieldError0.getMessage());
      assertEquals("java.lang.NoSuchFieldError: can not cast to Timestamp, value : ", noSuchFieldError0.toString());
      
      Class<PropertyNamingStrategy> class1 = PropertyNamingStrategy.class;
      // Undeclared exception!
      try { 
        TypeUtils.castToJavaBean((Object) noSuchFieldError0, class1);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to : com.alibaba.fastjson.PropertyNamingStrategy
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test109()  throws Throwable  {
      Class<InstantiationException> class0 = InstantiationException.class;
      ParserConfig parserConfig0 = ParserConfig.global;
      assertNotNull(parserConfig0);
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      
      parserConfig0.setAutoTypeSupport(true);
      assertTrue(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      
      parserConfig0.clearDeserializers();
      assertTrue(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      
      ParserConfig parserConfig1 = new ParserConfig(false);
      assertNotNull(parserConfig1);
      assertFalse(parserConfig1.isAutoTypeSupport());
      assertTrue(parserConfig1.isAsmEnable());
      assertFalse(parserConfig1.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertTrue(parserConfig1.compatibleWithJavaBean);
      assertFalse(parserConfig1.equals((Object)parserConfig0));
      
      boolean boolean0 = TypeUtils.compatibleWithFieldName;
      assertTrue(boolean0);
      
      boolean boolean1 = TypeUtils.isPath(class0);
      assertFalse(boolean1);
      assertFalse(boolean1 == boolean0);
      
      Class<IllegalMonitorStateException> class1 = IllegalMonitorStateException.class;
      Class<SQLDataException> class2 = SQLDataException.class;
      int int0 = TypeUtils.getParserFeatures(class2);
      assertEquals(0, int0);
      
      StackOverflowError stackOverflowError0 = new StackOverflowError();
      assertNotNull(stackOverflowError0);
      assertNull(stackOverflowError0.getMessage());
      assertEquals("java.lang.StackOverflowError", stackOverflowError0.toString());
      
      SecurityException securityException0 = new SecurityException("get", stackOverflowError0);
      assertNotNull(securityException0);
      assertNull(stackOverflowError0.getMessage());
      assertEquals("java.lang.StackOverflowError", stackOverflowError0.toString());
      assertEquals("java.lang.SecurityException: get", securityException0.toString());
      assertEquals("get", securityException0.getMessage());
      
      ParserConfig parserConfig2 = new ParserConfig();
      assertNotNull(parserConfig2);
      assertTrue(parserConfig2.isAsmEnable());
      assertFalse(parserConfig2.isAutoTypeSupport());
      assertFalse(ParserConfig.AUTO_SUPPORT);
      assertFalse(parserConfig2.fieldBased);
      assertTrue(parserConfig2.compatibleWithJavaBean);
      assertFalse(parserConfig2.equals((Object)parserConfig0));
      assertFalse(parserConfig2.equals((Object)parserConfig1));
      
      SQLTransactionRollbackException sQLTransactionRollbackException0 = new SQLTransactionRollbackException("get");
      assertNotNull(sQLTransactionRollbackException0);
      assertEquals("java.sql.SQLTransactionRollbackException: get", sQLTransactionRollbackException0.toString());
      assertEquals(0, sQLTransactionRollbackException0.getErrorCode());
      assertNull(sQLTransactionRollbackException0.getSQLState());
      assertEquals("get", sQLTransactionRollbackException0.getMessage());
      
      Class<HttpCookie> class3 = HttpCookie.class;
      HashMap<String, Field> hashMap0 = new HashMap<String, Field>();
      assertNotNull(hashMap0);
      assertEquals(0, hashMap0.size());
      assertTrue(hashMap0.isEmpty());
      
      ParserConfig.parserAllFieldToCache(class3, hashMap0);
      assertEquals(21, hashMap0.size());
      assertFalse(hashMap0.isEmpty());
      
      java.util.IdentityHashMap<String, Field> identityHashMap0 = new java.util.IdentityHashMap<String, Field>();
      assertNotNull(identityHashMap0);
      assertTrue(identityHashMap0.isEmpty());
      assertEquals(0, identityHashMap0.size());
      
      Field field0 = ParserConfig.getFieldFromCache("fastjson.parser.autoTypeAccept", identityHashMap0);
      assertNull(field0);
      assertTrue(identityHashMap0.isEmpty());
      assertEquals(0, identityHashMap0.size());
      
      Class<ChoiceFormat> class4 = ChoiceFormat.class;
      ParserConfig.parserAllFieldToCache(class4, identityHashMap0);
      assertFalse(identityHashMap0.isEmpty());
      assertEquals(25, identityHashMap0.size());
      
      Long long0 = new Long((-5808493101479473382L));
      assertNotNull(long0);
      assertEquals((-5808493101479473382L), (long)long0);
      
      AtomicInteger atomicInteger0 = new AtomicInteger(0);
      assertNotNull(atomicInteger0);
      assertEquals(0, atomicInteger0.intValue());
      assertEquals((short)0, atomicInteger0.shortValue());
      assertEquals((byte)0, atomicInteger0.byteValue());
      assertEquals(0L, atomicInteger0.longValue());
      assertEquals(0, atomicInteger0.get());
      assertEquals(0.0, atomicInteger0.doubleValue(), 0.01);
      assertEquals(0.0F, atomicInteger0.floatValue(), 0.01F);
      assertEquals("0", atomicInteger0.toString());
      
      Short short0 = TypeUtils.castToShort(atomicInteger0);
      assertNotNull(short0);
      assertEquals(0, atomicInteger0.intValue());
      assertEquals((short)0, atomicInteger0.shortValue());
      assertEquals((byte)0, atomicInteger0.byteValue());
      assertEquals(0L, atomicInteger0.longValue());
      assertEquals(0, atomicInteger0.get());
      assertEquals(0.0, atomicInteger0.doubleValue(), 0.01);
      assertEquals(0.0F, atomicInteger0.floatValue(), 0.01F);
      assertEquals("0", atomicInteger0.toString());
      assertEquals((short)0, (short)short0);
      
      Class<Float> class5 = Float.TYPE;
      assertNotNull(class5);
      assertEquals("float", class5.toString());
      assertEquals(1041, class5.getModifiers());
      assertTrue(class5.isPrimitive());
      assertFalse(class5.isEnum());
      assertFalse(class5.isSynthetic());
      assertFalse(class5.isInterface());
      assertFalse(class5.isArray());
      assertFalse(class5.isAnnotation());
      
      // Undeclared exception!
      try { 
        TypeUtils.cast((Object) parserConfig1, (Type) class5, parserConfig2);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to float, value : com.alibaba.fastjson.parser.ParserConfig@de
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test110()  throws Throwable  {
      BigInteger bigInteger0 = TypeUtils.castToBigInteger((Object) null);
      assertNull(bigInteger0);
  }

  @Test(timeout = 4000)
  public void test111()  throws Throwable  {
      Class<MockJapaneseDate> class0 = MockJapaneseDate.class;
      boolean boolean0 = TypeUtils.isPath(class0);
      assertFalse(boolean0);
      
      String string0 = TypeUtils.decapitalize("(Z4st8rAT$r");
      assertNotNull(string0);
      assertEquals("(Z4st8rAT$r", string0);
      
      boolean boolean1 = TypeUtils.isHibernateInitialized(class0);
      assertTrue(boolean1);
      assertFalse(boolean1 == boolean0);
      
      Class<Timestamp> class1 = Timestamp.class;
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      Class<Annotation> class2 = Annotation.class;
      Class<SQLIntegrityConstraintViolationException> class3 = SQLIntegrityConstraintViolationException.class;
      Annotation annotation0 = TypeUtils.getAnnotation((Class<?>) class3, class2);
      assertNull(annotation0);
      
      ParserConfig parserConfig0 = ParserConfig.global;
      assertNotNull(parserConfig0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      parserConfig0.setAutoTypeSupport(true);
      assertTrue(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      Float float0 = new Float(0.0);
      assertNotNull(float0);
      assertEquals(0.0F, (float)float0, 0.01F);
      
      // Undeclared exception!
      try { 
        TypeUtils.cast((Object) float0, class1, parserConfig0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to Timestamp, value : 0.0
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test112()  throws Throwable  {
      Class<MockThaiBuddhistDate> class0 = MockThaiBuddhistDate.class;
      Class<ClassLoader> class1 = ClassLoader.class;
      LinkedHashMap<String, String> linkedHashMap0 = new LinkedHashMap<String, String>();
      assertNotNull(linkedHashMap0);
      assertEquals(0, linkedHashMap0.size());
      assertTrue(linkedHashMap0.isEmpty());
      
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.PascalCase;
      List<FieldInfo> list0 = TypeUtils.computeGettersWithFieldBase(class0, linkedHashMap0, false, propertyNamingStrategy0);
      assertNotNull(list0);
      assertEquals(0, linkedHashMap0.size());
      assertTrue(linkedHashMap0.isEmpty());
      assertTrue(list0.isEmpty());
      assertEquals(0, list0.size());
      
      SQLRecoverableException sQLRecoverableException0 = new SQLRecoverableException();
      assertNotNull(sQLRecoverableException0);
      assertNull(sQLRecoverableException0.getSQLState());
      assertEquals(0, sQLRecoverableException0.getErrorCode());
      assertEquals("java.sql.SQLRecoverableException", sQLRecoverableException0.toString());
      assertNull(sQLRecoverableException0.getMessage());
      
      List<FieldInfo> list1 = TypeUtils.computeGetters((Class<?>) class1, (Map<String, String>) linkedHashMap0, false);
      assertNotNull(list1);
      assertNotSame(list1, list0);
      assertEquals(0, linkedHashMap0.size());
      assertTrue(linkedHashMap0.isEmpty());
      assertTrue(list1.isEmpty());
      assertEquals(0, list1.size());
      assertTrue(list1.equals((Object)list0));
  }

  @Test(timeout = 4000)
  public void test113()  throws Throwable  {
      TypeUtils.clearClassMapping();
      TreeMap<String, String> treeMap0 = new TreeMap<String, String>();
      assertNotNull(treeMap0);
      assertEquals(0, treeMap0.size());
      
      Class<DataTruncation> class0 = DataTruncation.class;
      boolean boolean0 = TypeUtils.isNumber("");
      assertTrue(boolean0);
      
      Short short0 = new Short((short)244);
      assertNotNull(short0);
      assertEquals((short)244, (short)short0);
      
      ConcurrentHashMap<String, Field> concurrentHashMap0 = new ConcurrentHashMap<String, Field>();
      assertNotNull(concurrentHashMap0);
      assertTrue(concurrentHashMap0.isEmpty());
      
      VerifyError verifyError0 = new VerifyError("3('I");
      assertNotNull(verifyError0);
      assertEquals("java.lang.VerifyError: 3('I", verifyError0.toString());
      assertEquals("3('I", verifyError0.getMessage());
      
      // Undeclared exception!
      try { 
        TypeUtils.castToBigInteger("3('I");
        fail("Expecting exception: NumberFormatException");
      
      } catch(NumberFormatException e) {
         //
         // For input string: \"java.lang\"
         //
         verifyException("java.lang.NumberFormatException", e);
      }
  }

  @Test(timeout = 4000)
  public void test114()  throws Throwable  {
      boolean boolean0 = TypeUtils.isNumber("#?mPj((");
      assertFalse(boolean0);
      
      Class<SQLNonTransientConnectionException> class0 = SQLNonTransientConnectionException.class;
      java.util.IdentityHashMap<String, String> identityHashMap0 = new java.util.IdentityHashMap<String, String>();
      assertNotNull(identityHashMap0);
      assertEquals(0, identityHashMap0.size());
      assertTrue(identityHashMap0.isEmpty());
      
      LinkedHashMap<String, String> linkedHashMap0 = new LinkedHashMap<String, String>();
      assertNotNull(linkedHashMap0);
      assertTrue(linkedHashMap0.isEmpty());
      assertEquals(0, linkedHashMap0.size());
      
      String string0 = linkedHashMap0.put("Lorg.springframework.util.LinkedMultiValueMap", "Ljava.awt.Font");
      assertNull(string0);
      assertEquals(1, linkedHashMap0.size());
      assertFalse(linkedHashMap0.isEmpty());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      String string1 = linkedHashMap0.put("C!hSyU(b2I=Q)U<ZM", "C!hSyU(b2I=Q)U<ZM");
      assertNull(string1);
      assertEquals(2, linkedHashMap0.size());
      assertFalse(linkedHashMap0.isEmpty());
      
      boolean boolean1 = FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "C!hSyU(b2I=Q)U<ZM");
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
      
      String string2 = linkedHashMap0.replace("", "C!hSyU(b2I=Q)U<ZM");
      assertNull(string2);
      assertEquals(2, linkedHashMap0.size());
      assertFalse(linkedHashMap0.isEmpty());
      
      String string3 = identityHashMap0.put("getCause", ":zzF53!L");
      assertNull(string3);
      assertEquals(1, identityHashMap0.size());
      assertFalse(identityHashMap0.isEmpty());
      
      Collection<String> collection0 = identityHashMap0.values();
      assertNotNull(collection0);
      assertEquals(1, identityHashMap0.size());
      assertFalse(identityHashMap0.isEmpty());
      
      identityHashMap0.putAll(linkedHashMap0);
      assertEquals(3, identityHashMap0.size());
      assertFalse(identityHashMap0.isEmpty());
      assertEquals(2, linkedHashMap0.size());
      assertFalse(linkedHashMap0.isEmpty());
      
      List<FieldInfo> list0 = TypeUtils.computeGetters((Class<?>) class0, (Map<String, String>) identityHashMap0, false);
      assertNotNull(list0);
      assertEquals(3, identityHashMap0.size());
      assertFalse(identityHashMap0.isEmpty());
      assertEquals(0, list0.size());
      assertTrue(list0.isEmpty());
      
      Random.setNextRandom((-1726704164));
      Locale locale0 = TypeUtils.toLocale("WriteNullNumberAsZero");
      assertNotNull(locale0);
      assertEquals("", locale0.getCountry());
      assertEquals("", locale0.getVariant());
      assertEquals("", locale0.getISO3Country());
      assertEquals("writenullnumberaszero", locale0.getLanguage());
      assertEquals("writenullnumberaszero", locale0.toString());
      
      boolean boolean2 = TypeUtils.isNumber("");
      assertTrue(boolean2);
      assertFalse(boolean2 == boolean0);
      assertFalse(boolean2 == boolean1);
      
      // Undeclared exception!
      try { 
        TypeUtils.castToLong(identityHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to long, value : {C!hSyU(b2I=Q)U<ZM=C!hSyU(b2I=Q)U<ZM, Lorg.springframework.util.LinkedMultiValueMap=Ljava.awt.Font, getCause=:zzF53!L}
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test115()  throws Throwable  {
      WeakHashMap<String, String> weakHashMap0 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap0);
      
      Class<ClassLoader> class0 = ClassLoader.class;
      String string0 = weakHashMap0.put("Op#P2Brx(r~`r@t", "]iL;BW\"YN4!N");
      assertNull(string0);
      
      PropertyNamingStrategy propertyNamingStrategy0 = PropertyNamingStrategy.PascalCase;
      List<FieldInfo> list0 = TypeUtils.computeGettersWithFieldBase(class0, weakHashMap0, false, propertyNamingStrategy0);
      assertNotNull(list0);
      assertEquals(0, list0.size());
      assertTrue(list0.isEmpty());
      
      ThreadGroup threadGroup0 = new ThreadGroup("R7Xw':u/ Ib.%b;.~U");
      assertNotNull(threadGroup0);
      assertEquals("R7Xw':u/ Ib.%b;.~U", threadGroup0.getName());
      
      Thread thread0 = MockThread.currentThread();
      assertNotNull(thread0);
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      MockThread mockThread0 = new MockThread(thread0, "R7Xw':u/ Ib.%b;.~U");
      assertNotNull(mockThread0);
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      
      MockThread mockThread1 = new MockThread(threadGroup0, mockThread0);
      assertNotNull(mockThread1);
      assertEquals("R7Xw':u/ Ib.%b;.~U", threadGroup0.getName());
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread1.isDaemon());
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread1.equals((Object)mockThread0));
      
      ClassLoader classLoader0 = mockThread1.getContextClassLoader();
      assertNotNull(classLoader0);
      assertNotSame(mockThread0, mockThread1);
      assertNotSame(mockThread1, mockThread0);
      assertEquals("R7Xw':u/ Ib.%b;.~U", threadGroup0.getName());
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread1.isDaemon());
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread0.equals((Object)mockThread1));
      assertFalse(mockThread1.equals((Object)mockThread0));
      
      ClassLoader classLoader1 = classLoader0.getParent();
      assertNotNull(classLoader1);
      assertNotSame(mockThread0, mockThread1);
      assertNotSame(mockThread1, mockThread0);
      assertEquals("R7Xw':u/ Ib.%b;.~U", threadGroup0.getName());
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread1.isDaemon());
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread0.equals((Object)mockThread1));
      assertFalse(mockThread1.equals((Object)mockThread0));
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      classLoader1.setClassAssertionStatus("R7Xw':u/ Ib.%b;.~U", true);
      assertNotSame(mockThread0, mockThread1);
      assertNotSame(mockThread1, mockThread0);
      assertEquals("R7Xw':u/ Ib.%b;.~U", threadGroup0.getName());
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread1.isDaemon());
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread0.equals((Object)mockThread1));
      assertFalse(mockThread1.equals((Object)mockThread0));
      assertFalse(classLoader0.equals((Object)classLoader1));
      assertFalse(classLoader1.equals((Object)classLoader0));
      
      Class<?> class1 = TypeUtils.loadClass(" le>)EgVw=", classLoader0);
      assertNull(class1);
      assertNotSame(mockThread0, mockThread1);
      assertNotSame(mockThread1, mockThread0);
      assertEquals("R7Xw':u/ Ib.%b;.~U", threadGroup0.getName());
      assertFalse(thread0.isDaemon());
      assertFalse(thread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertFalse(mockThread0.isInterrupted());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread1.isDaemon());
      assertFalse(mockThread1.isInterrupted());
      assertEquals(0, mockThread1.countStackFrames());
      assertFalse(mockThread0.equals((Object)mockThread1));
      assertFalse(mockThread1.equals((Object)mockThread0));
      assertFalse(classLoader0.equals((Object)classLoader1));
      
      WeakHashMap<String, String> weakHashMap1 = new WeakHashMap<String, String>();
      assertNotNull(weakHashMap1);
      assertFalse(weakHashMap1.equals((Object)weakHashMap0));
      
      String string1 = weakHashMap0.put("3", "getSQLState");
      assertNull(string1);
      assertNotSame(weakHashMap0, weakHashMap1);
      assertFalse(weakHashMap0.equals((Object)weakHashMap1));
      
      byte[] byteArray0 = TypeUtils.castToBytes("Op#P2Brx(r~`r@t");
      assertNotNull(byteArray0);
      
      Short short0 = new Short((short)1464);
      assertNotNull(short0);
      assertEquals((short)1464, (short)short0);
      
      // Undeclared exception!
      try { 
        TypeUtils.castToInt(weakHashMap0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to int, value : {3=getSQLState, Op#P2Brx(r~`r@t=]iL;BW\"YN4!N}
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }

  @Test(timeout = 4000)
  public void test116()  throws Throwable  {
      Class<MockJapaneseDate> class0 = MockJapaneseDate.class;
      boolean boolean0 = TypeUtils.isPath(class0);
      assertFalse(boolean0);
      
      ParserConfig parserConfig0 = ParserConfig.global;
      assertNotNull(parserConfig0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      AtomicLong atomicLong0 = new AtomicLong(0L);
      assertNotNull(atomicLong0);
      assertEquals("0", atomicLong0.toString());
      assertEquals((short)0, atomicLong0.shortValue());
      assertEquals(0.0, atomicLong0.doubleValue(), 0.01);
      assertEquals(0, atomicLong0.intValue());
      assertEquals(0L, atomicLong0.longValue());
      assertEquals((byte)0, atomicLong0.byteValue());
      assertEquals(0L, atomicLong0.get());
      assertEquals(0.0F, atomicLong0.floatValue(), 0.01F);
      
      LongUnaryOperator longUnaryOperator0 = mock(LongUnaryOperator.class, new ViolatedAssumptionAnswer());
      doReturn(0L).when(longUnaryOperator0).applyAsLong(anyLong());
      long long0 = atomicLong0.updateAndGet(longUnaryOperator0);
      assertEquals("0", atomicLong0.toString());
      assertEquals((short)0, atomicLong0.shortValue());
      assertEquals(0.0, atomicLong0.doubleValue(), 0.01);
      assertEquals(0, atomicLong0.intValue());
      assertEquals(0L, atomicLong0.longValue());
      assertEquals((byte)0, atomicLong0.byteValue());
      assertEquals(0L, atomicLong0.get());
      assertEquals(0.0F, atomicLong0.floatValue(), 0.01F);
      assertEquals(0L, long0);
      
      LongUnaryOperator longUnaryOperator1 = mock(LongUnaryOperator.class, new ViolatedAssumptionAnswer());
      doReturn(0L).when(longUnaryOperator1).applyAsLong(anyLong());
      long long1 = atomicLong0.getAndUpdate(longUnaryOperator1);
      assertEquals("0", atomicLong0.toString());
      assertEquals((short)0, atomicLong0.shortValue());
      assertEquals(0.0, atomicLong0.doubleValue(), 0.01);
      assertEquals(0, atomicLong0.intValue());
      assertEquals(0L, atomicLong0.longValue());
      assertEquals((byte)0, atomicLong0.byteValue());
      assertEquals(0L, atomicLong0.get());
      assertEquals(0.0F, atomicLong0.floatValue(), 0.01F);
      assertEquals(0L, long1);
      assertTrue(long1 == long0);
      
      Hashtable<String, Field> hashtable0 = new Hashtable<String, Field>();
      assertNotNull(hashtable0);
      assertEquals(0, hashtable0.size());
      assertTrue(hashtable0.isEmpty());
      
      Class<SQLException> class1 = SQLException.class;
      List<FieldInfo> list0 = TypeUtils.computeGettersWithFieldBase(class1, (Map<String, String>) null, true, (PropertyNamingStrategy) null);
      assertNotNull(list0);
      assertEquals(7, list0.size());
      assertFalse(list0.isEmpty());
      
      StringCharacterIterator stringCharacterIterator0 = new StringCharacterIterator("fastjson.parser.autoTypeSupport");
      assertNotNull(stringCharacterIterator0);
      assertEquals(31, stringCharacterIterator0.getEndIndex());
      assertEquals(0, stringCharacterIterator0.getIndex());
      assertEquals(0, stringCharacterIterator0.getBeginIndex());
      assertEquals('f', stringCharacterIterator0.current());
      
      TreeSet<ChronoLocalDate> treeSet0 = new TreeSet<ChronoLocalDate>();
      assertNotNull(treeSet0);
      
      JavaBeanDeserializer javaBeanDeserializer0 = new JavaBeanDeserializer(parserConfig0, class0);
      assertNotNull(javaBeanDeserializer0);
      assertFalse(parserConfig0.isAutoTypeSupport());
      assertTrue(parserConfig0.isAsmEnable());
      assertEquals(12, javaBeanDeserializer0.getFastMatchToken());
      assertTrue(parserConfig0.compatibleWithJavaBean);
      assertFalse(parserConfig0.fieldBased);
      assertFalse(ParserConfig.AUTO_SUPPORT);
      
      // Undeclared exception!
      try { 
        TypeUtils.castToDouble(javaBeanDeserializer0);
        fail("Expecting exception: RuntimeException");
      
      } catch(RuntimeException e) {
         //
         // can not cast to double, value : com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer@9
         //
         verifyException("com.alibaba.fastjson.util.TypeUtils", e);
      }
  }
}
