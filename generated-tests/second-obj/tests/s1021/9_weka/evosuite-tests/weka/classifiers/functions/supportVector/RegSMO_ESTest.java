/*
 * This file was automatically generated by EvoSuite
 * Sat Jul 07 07:56:38 GMT 2018
 */

package weka.classifiers.functions.supportVector;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.LineNumberReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Locale;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.mock.java.util.MockRandom;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;
import weka.classifiers.bayes.BayesNet;
import weka.classifiers.functions.GaussianProcesses;
import weka.classifiers.functions.SGDText;
import weka.classifiers.functions.supportVector.Kernel;
import weka.classifiers.functions.supportVector.RBFKernel;
import weka.classifiers.functions.supportVector.RegSMO;
import weka.classifiers.functions.supportVector.StringKernel;
import weka.classifiers.lazy.kstar.KStarConstants;
import weka.classifiers.misc.InputMappedClassifier;
import weka.core.Attribute;
import weka.core.Drawable;
import weka.core.Instances;
import weka.core.NormalizableDistance;
import weka.core.TechnicalInformation;
import weka.core.tokenizers.AlphabeticTokenizer;
import weka.core.tokenizers.WordTokenizer;
import weka.filters.AllFilter;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class RegSMO_ESTest extends RegSMO_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      try { 
        regSMO0.wrapUp();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegOptimizer", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      String string0 = regSMO0.globalInfo();
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Implementation of SMO for support vector regression as described in :\n\nA.J. Smola, B. Schoelkopf (1998). A tutorial on support vector regression.", string0);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      int int0 = regSMO0.takeStep((-632), (-632), (-632), 842.07, 32.3318313);
      assertEquals(0, int0);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      System.setCurrentTimeMillis(0L);
      RegSMO regSMO0 = new RegSMO();
      String[] stringArray0 = new String[0];
      regSMO0.setOptions(stringArray0);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      String string0 = regSMO0.getRevision();
      assertEquals("8034", string0);
      
      regSMO0.listOptions();
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2521, 291.04985477043004, 291.04985477043004, 2521, 2521, 2521, 2521, 2521, 2521, 2521, 2521);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(1073741824, (-346.0), 1073741824, 65.2391656018278, 1073741824, (-346.0), 65.2391656018278, 1073741824, (-625.0), 65.2391656018278, 65.2391656018278);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2500, 0.0, 0.0, 683.769999931623, 2500, 683.769999931623, 683.769999931623, 683.769999931623, 0.0, 2.9104985477043007E-8, 683.769999931623);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, 0, 0, 1.7976931348623157E308, 0, 2.75, 0, 2.75, 0, 254.518790561, (-936.99080100494));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, 156.462, 156.462, 0, (-2145052561), (-2145052561), 0, 156.462, 156.462, 156.462, 156.462);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-2446), (-2446), (-378.0), (-2446), 1777, (-378.0), (-378.0), 1777, 3195.1193504252, 1777, 3003.091029);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertNotNull(regSMO0);
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2500, 644.3, (-45.0), 4.8, 1, 1, 644.3, 2500, 1, 4.8, 15.6870229973443);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertNotNull(regSMO0);
      
      String string0 = regSMO0.epsilonTipText();
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", string0);
      assertNotNull(string0);
      
      // Undeclared exception!
      try { 
        regSMO0.secondChoiceHeuristic(1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertNotNull(regSMO0);
      
      TechnicalInformation technicalInformation0 = regSMO0.getTechnicalInformation();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertFalse(technicalInformation0.hasAdditional());
      assertEquals(TechnicalInformation.Type.MISC, technicalInformation0.getType());
      assertNotNull(technicalInformation0);
      
      try { 
        regSMO0.takeStep(68, (-194), (-194), 68, 68);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertNotNull(regSMO0);
      
      boolean boolean0 = regSMO0.findOptimalPointOnLine((-3674), (-545.5316), (-545.5316), (-3674), (-3674), (-545.5316), (-3674), (-3674), (-545.5316), (-3674), (-545.5316));
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(boolean0);
      
      TechnicalInformation technicalInformation0 = regSMO0.getTechnicalInformation();
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(TechnicalInformation.Type.MISC, technicalInformation0.getType());
      assertFalse(technicalInformation0.hasAdditional());
      assertNotNull(technicalInformation0);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertNotNull(regSMO0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2500, 2500, 1664.673, 4.8, 1, 1, 0.0, 2500, 1, 4.8, 4.8);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertNotNull(regSMO0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2500, 2500, 1664.673, 4.8, 1, 1, 0.0, 2500, 1, 4.8, 15.6870229973443);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(regSMO0);
      
      StringKernel stringKernel0 = new StringKernel();
      assertEquals("The size of the cache (a prime number).", stringKernel0.cacheSizeTipText());
      assertEquals(3, stringKernel0.getSubsequenceLength());
      assertEquals(9, stringKernel0.getMaxSubsequenceLength());
      assertFalse(stringKernel0.getUseNormalization());
      assertFalse(stringKernel0.getDebug());
      assertEquals("The subsequence length.", stringKernel0.subsequenceLengthTipText());
      assertEquals("The size of the internal cache (a prime number).", stringKernel0.internalCacheSizeTipText());
      assertEquals("Penalizes non-continuous subsequence matches, from (0,1)", stringKernel0.lambdaTipText());
      assertEquals(0, stringKernel0.numEvals());
      assertEquals("Turns on the output of debugging information.", stringKernel0.debugTipText());
      assertFalse(stringKernel0.getChecksTurnedOff());
      assertEquals(0.5, stringKernel0.getLambda(), 0.01);
      assertEquals("Turns time-consuming checks off - use with caution.", stringKernel0.checksTurnedOffTipText());
      assertEquals((-1), stringKernel0.numCacheHits());
      assertEquals(200003, stringKernel0.getInternalCacheSize());
      assertEquals(250007, stringKernel0.getCacheSize());
      assertEquals("The maximum subsequence length (theta in the paper)", stringKernel0.maxSubsequenceLengthTipText());
      assertEquals("The pruning method.", stringKernel0.pruningMethodTipText());
      assertEquals("Whether to use normalization.", stringKernel0.useNormalizationTipText());
      assertEquals(0, StringKernel.PRUNING_NONE);
      assertEquals(1, StringKernel.PRUNING_LAMBDA);
      assertNotNull(stringKernel0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2488, 291.04985477043004, 1665.311378997483, 1665.311378997483, 23, 23, 2488, 2488, 23, 1665.311378997483, 291.04985477043004);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertNotNull(regSMO0);
      
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      regSMO0.m_nEvals = 303;
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(303, regSMO0.getKernelEvaluations());
      
      regSMO0.m_nInstances = 303;
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(303, regSMO0.getKernelEvaluations());
      
      try { 
        regSMO0.optimize();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-3294), (-3294), 1.0E-10, 1.0E-10, 1073741824, 1073741824, (-452.7281740817394), (-3294), 1073741824, 1.0E-12, (-452.7281740817394));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertNotNull(regSMO0);
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2500, 291.04985477043004, 1664.673, 2500, 0, 0, 0.0, 2500, 0, 2500, 2500);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertNotNull(regSMO0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2500, 2500, (-42.808), 4.553841383366498, (-12), (-12), 2500, 2500, (-12), 4.553841383366498, 15.687);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-3294), (-3294), 1.0E-10, 1.0E-10, 1073741824, 1073741824, 1.0E-10, 683.77, 64.0, 1.0E-12, 1.0E-10);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertNotNull(regSMO0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(2500, 2500, 0.0, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 0.0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[5];
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, 156.462, 156.462, 156.462, 0, 0.0, 696.6146301155923, 156.462, (-84.54), 156.462, 2.75);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertNotNull(regSMO0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(59, (-346.0), 59, 683.769999931623, 59, (-346.0), 683.769999931623, 1073741824, (-346.0), 1073741824, 683.769999931623);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[4];
      doubleArray0[0] = (-2841.34778);
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(7, 1.7960253506643653E-7, 696.6146301155923, 1601.21282, 7, 0.9999999960088326, 7, 0.9999999960088326, 1.0E-12, 57.0, (-2841.34778));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertNotNull(regSMO0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-1323), 0.0, 1.0, 183.57954301629727, (-451), 1.796025350799706E-7, 1.0, 183.57954301629727, (-38.709092554), 45.0, 1.796025350799706E-7);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(regSMO0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-3294), 1664.673, 1.0E-10, 680.09005096598, 1, 1, 291.04985477043004, 2202.06, 2500, 15.6870229973443, (-3294));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[5];
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, 0.0, 0, 291.04985477043, 0, 0.0, 696.6146301155923, 156.462, 0.0, 291.04985477043, 2.75);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[4];
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, 1.7960253506643653E-7, 696.6146301155923, 1601.21282, 0, 0.9999999960088326, 0, 0.9999999960088326, 1.0E-12, 57.0, (-2841.34778));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertNotNull(regSMO0);
      
      String[] stringArray0 = regSMO0.getOptions();
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertNotNull(stringArray0);
      
      regSMO0.setOptions(stringArray0);
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(1287, 1287, 1287, 1125.1, (-1), 2500.0, 1.0E75, 839.9, (-1), 1287, 1125.1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertNotNull(regSMO0);
      
      // Undeclared exception!
      try { 
        regSMO0.secondChoiceHeuristic(0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(regSMO0);
      
      double double0 = regSMO0.getScore();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.0, double0, 0.01);
      
      double[] doubleArray0 = new double[5];
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, 156.462, 156.462, 156.462, 0, 0.0, (-1.0), 156.462, (-84.54), 156.462, 2.75);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertNotNull(regSMO0);
      
      int int0 = 619;
      regSMO0.m_nSeed = 619;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(619, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      int int1 = (-1323);
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      double double0 = (-0.5417513232971374);
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((-1323), 0.0, 1.0000000000000001E-20, 183.10800244097229, 619, (-0.5417513232971374), 1.0000000000000001E-20, 619, (-38.709092554), 1.0000000000000001E-20, (-0.5417513232971374));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[17];
      String string0 = regSMO0.epsilonParameterTipText();
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", string0);
      assertNotNull(string0);
      
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      RBFKernel rBFKernel0 = new RBFKernel();
      assertEquals("Turns on the output of debugging information.", rBFKernel0.debugTipText());
      assertFalse(rBFKernel0.getChecksTurnedOff());
      assertEquals(0, rBFKernel0.numCacheHits());
      assertEquals("The Gamma value.", rBFKernel0.gammaTipText());
      assertEquals("The size of the cache (a prime number), 0 for full cache and -1 to turn it off.", rBFKernel0.cacheSizeTipText());
      assertFalse(rBFKernel0.getDebug());
      assertEquals(0, rBFKernel0.numEvals());
      assertEquals(0.01, rBFKernel0.getGamma(), 0.01);
      assertEquals("The RBF kernel. K(x, y) = e^-(gamma * <x-y, x-y>^2)", rBFKernel0.globalInfo());
      assertEquals(250007, rBFKernel0.getCacheSize());
      assertEquals("Turns time-consuming checks off - use with caution.", rBFKernel0.checksTurnedOffTipText());
      assertNotNull(rBFKernel0);
      
      regSMO0.m_kernel = (Kernel) rBFKernel0;
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Turns on the output of debugging information.", rBFKernel0.debugTipText());
      assertFalse(rBFKernel0.getChecksTurnedOff());
      assertEquals(0, rBFKernel0.numCacheHits());
      assertEquals("The Gamma value.", rBFKernel0.gammaTipText());
      assertEquals("The size of the cache (a prime number), 0 for full cache and -1 to turn it off.", rBFKernel0.cacheSizeTipText());
      assertFalse(rBFKernel0.getDebug());
      assertEquals(0, rBFKernel0.numEvals());
      assertEquals(0.01, rBFKernel0.getGamma(), 0.01);
      assertEquals("The RBF kernel. K(x, y) = e^-(gamma * <x-y, x-y>^2)", rBFKernel0.globalInfo());
      assertEquals(250007, rBFKernel0.getCacheSize());
      assertEquals("Turns time-consuming checks off - use with caution.", rBFKernel0.checksTurnedOffTipText());
      assertFalse(regSMO0.m_kernel.getDebug());
      assertEquals("Turns on the output of debugging information.", regSMO0.m_kernel.debugTipText());
      assertFalse(regSMO0.m_kernel.getChecksTurnedOff());
      assertEquals("Turns time-consuming checks off - use with caution.", regSMO0.m_kernel.checksTurnedOffTipText());
      
      int int0 = Drawable.NOT_DRAWABLE;
      assertEquals(0, int0);
      
      regSMO0.m_alpha = regSMO0.m_alphaStar;
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      int int1 = GaussianProcesses.FILTER_NORMALIZE;
      assertEquals(0, int1);
      assertTrue(int1 == int0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, 1.0E-12, 1.0E-12, 1.0E-12, 0, 0.0, (byte) (-92), 1.0E-12, (byte) (-92), 1.0E-12, (byte) (-92));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[1];
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte) (-99);
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, 1.0E-12, 89.29256063988184, 89.29256063988184, 0, 89.29256063988184, 718.3095468344169, 89.29256063988184, (byte) (-99), 89.29256063988184, (byte)58);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[1];
      regSMO0.m_alpha = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      byte[] byteArray0 = new byte[3];
      boolean boolean1 = FileSystemHandling.setPermissions((EvoSuiteFile) null, false, false, false);
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
      
      // Undeclared exception!
      try { 
        regSMO0.secondChoiceHeuristic(59);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[8];
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      regSMO0.m_target = regSMO0.m_alphaStar;
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      Enumeration enumeration0 = regSMO0.listOptions();
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertNotNull(enumeration0);
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      String string0 = regSMO0.toString();
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("SMOreg\n\nSupport vectors:\n +       0     \n\n\n\nNumber of kernel evaluations: 0", string0);
      assertNotNull(string0);
      
      regSMO0.m_epsilon = (double) 1704;
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1704.0, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      
      int int0 = regSMO0.secondChoiceHeuristic(1704);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1704.0, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), int0);
      
      regSMO0.optimize();
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[2];
      byte[] byteArray0 = new byte[19];
      byteArray0[0] = (byte) (-100);
      byteArray0[2] = (byte)58;
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      regSMO0.m_nInstances = (int) (byte)43;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, 107.7919838310126, 107.7919838310126, 107.7919838310126, 0, 107.7919838310126, (byte)43, 107.7919838310126, (-84.9112224798739), 107.7919838310126, 0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[15];
      regSMO0.m_target = doubleArray0;
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      
      Enumeration enumeration0 = regSMO0.listOptions();
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertNotNull(enumeration0);
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      
      regSMO0.m_nSeed = (int) (byte)9;
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(9, regSMO0.getSeed());
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((byte)9, 1.7976931348623157E308, (-45.0), 2936.0, 215, 0.693147181, (byte)9, 2936.0, 2430.1123, 2430.1123, 215);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[1];
      int int0 = 0;
      regSMO0.m_target = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      
      double double0 = 2.75;
      regSMO0.m_nInstances = (int) (byte)43;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      
      String string0 = regSMO0.getRevision();
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("8034", string0);
      assertNotNull(string0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, 108.60660773337091, 108.60660773337091, 108.60660773337091, 0, 108.60660773337091, (byte)43, 108.60660773337091, (-91.07742454609576), 108.60660773337091, 2.75);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[9];
      doubleArray0[4] = 2637.203285138363;
      doubleArray0[1] = (-21.504568012668916);
      doubleArray0[0] = 1.5;
      regSMO0.m_alpha = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      double[] doubleArray1 = new double[13];
      assertFalse(doubleArray1.equals((Object)doubleArray0));
      
      regSMO0.m_alphaStar = regSMO0.m_alpha;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      regSMO0.m_alpha = doubleArray1;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      regSMO0.m_target = regSMO0.m_alphaStar;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      
      int int0 = GaussianProcesses.FILTER_NORMALIZE;
      assertEquals(0, int0);
      
      boolean boolean0 = regSMO0.m_bModelBuilt;
      assertFalse(boolean0);
      
      double double0 = RegSMO.m_Del;
      assertEquals(1.0E-10, double0, 0.01);
      
      int int1 = regSMO0.secondChoiceHeuristic(2476);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), int1);
      assertFalse(int1 == int0);
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[6];
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      regSMO0.m_target = regSMO0.m_alphaStar;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      regSMO0.m_alpha = regSMO0.m_alphaStar;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      String[] stringArray0 = regSMO0.getOptions();
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertNotNull(stringArray0);
      
      String string0 = regSMO0.epsilonTipText();
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", string0);
      assertNotNull(string0);
      
      regSMO0.setSeed((byte) (-100));
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-100), regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertFalse(regSMO0.modelBuilt());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      int int0 = NormalizableDistance.R_MAX;
      assertEquals(1, int0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(1, 1, 0.0, (byte) (-100), 1, 0.1, 0.0, (byte) (-100), (-1203.4895364), 1, 1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[17];
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      byte[] byteArray0 = new byte[2];
      doubleArray0[0] = (double) (byte)26;
      byteArray0[1] = (byte)26;
      regSMO0.m_classIndex = (int) (byte)26;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      
      int int0 = regSMO0.secondChoiceHeuristic((byte)26);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals((-1), int0);
      
      TechnicalInformation technicalInformation0 = regSMO0.getTechnicalInformation();
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(technicalInformation0.hasAdditional());
      assertEquals(TechnicalInformation.Type.MISC, technicalInformation0.getType());
      assertNotNull(technicalInformation0);
      
      double double0 = KStarConstants.FLOOR;
      assertEquals(0.0, double0, 0.01);
      
      boolean boolean0 = FileSystemHandling.createFolder((EvoSuiteFile) null);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[11];
      doubleArray0[10] = 568.5841519386848;
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      FileSystemHandling fileSystemHandling1 = new FileSystemHandling();
      assertNotNull(fileSystemHandling1);
      assertFalse(fileSystemHandling1.equals((Object)fileSystemHandling0));
      
      regSMO0.m_alpha = regSMO0.m_alphaStar;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      
      regSMO0.m_sparseIndices = null;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      
      String[] stringArray0 = Locale.getISOLanguages();
      assertNotNull(stringArray0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(0, (-12.709671314486283), 89.3, 89.3, 0, 89.3, 718.3095468344169, 89.3, (byte) (-99), 89.3, (byte) (-99));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[14];
      String[] stringArray0 = Locale.getISOLanguages();
      assertNotNull(stringArray0);
      
      regSMO0.m_b = 610.480361075228;
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      
      regSMO0.m_eps = 610.480361075228;
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(610.480361075228, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(610.480361075228, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(610.480361075228, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      
      boolean boolean0 = regSMO0.findOptimalPointOnLine(0, 90.02712524259503, 90.02712524259503, 90.02712524259503, 0, 0.0, (byte) (-99), 90.02712524259503, (byte) (-99), 90.02712524259503, (byte) (-99));
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(610.480361075228, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertFalse(boolean0);
      
      try { 
        regSMO0.buildClassifier((Instances) null);
        fail("Expecting exception: Exception");
      
      } catch(Exception e) {
         //
         // SVM not initialized in optimizer. Use RegOptimizer.setSVMReg()
         //
         verifyException("weka.classifiers.functions.supportVector.RegOptimizer", e);
      }
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[17];
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      
      byte[] byteArray0 = new byte[12];
      doubleArray0[0] = (double) (byte)10;
      byteArray0[1] = (byte)10;
      boolean boolean0 = FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      assertFalse(boolean0);
      
      regSMO0.m_alpha = regSMO0.m_alphaStar;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      
      int int0 = regSMO0.secondChoiceHeuristic((byte)10);
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals((-1), int0);
      
      boolean boolean1 = regSMO0.m_bModelBuilt;
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
      
      boolean boolean2 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean2);
      assertFalse(boolean2 == boolean0);
      assertFalse(boolean2 == boolean1);
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      String[] stringArray0 = Locale.getISOLanguages();
      assertNotNull(stringArray0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine((byte)10, (-656.0), (-1.0), 2642.8749909, (byte)10, 1.0E-10, 1250.61116, 55.977110753223016, 568.5841519386848, 2642.8749909, 419.8939996471789);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[10];
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      regSMO0.m_alphaStar = regSMO0.m_alphaStar;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      doubleArray0[4] = (double) 487;
      regSMO0.m_target = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      regSMO0.m_alpha = doubleArray0;
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      try { 
        regSMO0.optimize();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test49()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[21];
      String[] stringArray0 = Locale.getISOCountries();
      assertNotNull(stringArray0);
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      MockRandom mockRandom0 = new MockRandom();
      assertNotNull(mockRandom0);
      
      regSMO0.m_random = (java.util.Random) mockRandom0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      doubleArray0[14] = 610.480361075228;
      regSMO0.m_eps = 610.480361075228;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(610.480361075228, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      byte[] byteArray0 = new byte[0];
      mockRandom0.nextBytes(byteArray0);
      assertArrayEquals(new byte[] {}, byteArray0);
      
      String string0 = regSMO0.epsilonParameterTipText();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(610.480361075228, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", string0);
      assertNotNull(string0);
      
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(610.480361075228, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      DoubleStream doubleStream0 = mockRandom0.doubles();
      assertNotNull(doubleStream0);
      
      int int0 = SGDText.LOGLOSS;
      assertEquals(1, int0);
      
      IntStream intStream0 = mockRandom0.ints((-100), 1);
      assertNotNull(intStream0);
      
      regSMO0.m_alpha = regSMO0.m_alphaStar;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(610.480361075228, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      WordTokenizer wordTokenizer0 = new WordTokenizer();
      assertEquals(" \r\n\t.,;:'\"()?!", wordTokenizer0.getDelimiters());
      assertEquals("A simple tokenizer that is using the java.util.StringTokenizer class to tokenize the strings.", wordTokenizer0.globalInfo());
      assertEquals("Set of delimiter characters to use in tokenizing (\\r, \\n and \\t can be used for carriage-return, line-feed and tab)", wordTokenizer0.delimitersTipText());
      assertNotNull(wordTokenizer0);
      
      double double0 = regSMO0.getEpsilon();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(610.480361075228, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(610.480361075228, double0, 0.01);
      
      Enumeration enumeration0 = regSMO0.listOptions();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(610.480361075228, regSMO0.getEpsilon(), 0.01);
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(enumeration0);
      
      BayesNet bayesNet0 = new BayesNet();
      assertEquals("Set the name of a file in BIF XML format. A Bayes network learned from data can be compared with the Bayes network represented by the BIF file. Statistics calculated are o.a. the number of missing and extra arcs.", bayesNet0.BIFFileTipText());
      assertFalse(bayesNet0.getUseADTree());
      assertEquals("When ADTree (the data structure for increasing speed on counts, not to be confused with the classifier under the same name) is used learning time goes down typically. However, because ADTrees are memory intensive, memory problems may occur. Switching this option off makes the structure learning algorithms slower, and run with less memory. By default, ADTrees are used.", bayesNet0.useADTreeTipText());
      assertEquals("Select Estimator algorithm for finding the conditional probability tables of the Bayes Network.", bayesNet0.estimatorTipText());
      assertEquals(2, bayesNet0.graphType());
      assertFalse(bayesNet0.getDebug());
      assertEquals("Select method used for searching network structures.", bayesNet0.searchAlgorithmTipText());
      assertEquals("Bayes Network learning using various search algorithms and quality measures.\nBase class for a Bayes Network classifier. Provides datastructures (network structure, conditional probability distributions, etc.) and facilities common to Bayes Network learning algorithms like K2 and B.\n\nFor more information see:\n\nhttp://www.cs.waikato.ac.nz/~remco/weka.pdf", bayesNet0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", bayesNet0.debugTipText());
      assertNotNull(bayesNet0);
      
      Instances instances0 = bayesNet0.m_Instances;
      assertNull(instances0);
      
      // Undeclared exception!
      try { 
        regSMO0.findOptimalPointOnLine(1, 8.230072126025334E-7, 8.230072126025334E-7, (-4.0), 0, (-5879.30115), 2028.8771952142322, 610.480361075228, 2028.8771952142322, 656.1, 0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test50()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[6];
      regSMO0.m_alphaStar = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      
      regSMO0.m_target = regSMO0.m_alphaStar;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      
      regSMO0.setSeed((-2314));
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-2314), regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      
      regSMO0.m_alpha = regSMO0.m_alphaStar;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-2314), regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      assertNotNull(arrayList0);
      
      regSMO0.optimize();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals((-2314), regSMO0.getSeed());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      
      int int0 = NormalizableDistance.R_MAX;
      assertEquals(1, int0);
      
      AlphabeticTokenizer alphabeticTokenizer0 = new AlphabeticTokenizer();
      assertEquals("Alphabetic string tokenizer, tokens are to be formed only from contiguous alphabetic sequences.", alphabeticTokenizer0.globalInfo());
      assertNotNull(alphabeticTokenizer0);
      
      try { 
        regSMO0.takeStep((byte) (-115), (-2314), 1799, 1799, (-2314));
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test51()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[2];
      byte[] byteArray0 = new byte[7];
      byteArray0[0] = (byte)26;
      byteArray0[1] = (byte)70;
      byteArray0[2] = (byte) (-39);
      byteArray0[3] = (byte)51;
      byteArray0[4] = (byte) (-52);
      byteArray0[5] = (byte)2;
      byteArray0[6] = (byte)19;
      boolean boolean0 = FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      assertFalse(boolean0);
      assertArrayEquals(new byte[] {(byte)26, (byte)70, (byte) (-39), (byte)51, (byte) (-52), (byte)2, (byte)19}, byteArray0);
      
      doubleArray0[0] = 0.1;
      doubleArray0[1] = 4225.868597882;
      regSMO0.m_alpha = doubleArray0;
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      
      String[] stringArray0 = regSMO0.getOptions();
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(stringArray0);
      
      int int0 = regSMO0.secondChoiceHeuristic((byte) (-52));
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void test52()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[9];
      doubleArray0[4] = 2637.203285138363;
      doubleArray0[1] = 2637.203285138363;
      doubleArray0[0] = 2637.203285138363;
      regSMO0.m_alpha = doubleArray0;
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      double[] doubleArray1 = new double[13];
      assertFalse(doubleArray1.equals((Object)doubleArray0));
      
      regSMO0.m_alphaStar = regSMO0.m_alpha;
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      regSMO0.m_alpha = doubleArray1;
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      regSMO0.m_target = regSMO0.m_alphaStar;
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      
      int int0 = NormalizableDistance.R_WIDTH;
      assertEquals(2, int0);
      
      boolean boolean0 = regSMO0.m_bModelBuilt;
      assertFalse(boolean0);
      
      try { 
        regSMO0.optimize();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }

  @Test(timeout = 4000)
  public void test53()  throws Throwable  {
      RegSMO regSMO0 = new RegSMO();
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertNotNull(regSMO0);
      
      double[] doubleArray0 = new double[5];
      doubleArray0[0] = 2641.4323193882;
      doubleArray0[1] = 1.0E-10;
      doubleArray0[0] = 1.0E-10;
      doubleArray0[3] = (-4781.587603161);
      doubleArray0[4] = 1.0E-10;
      regSMO0.m_alpha = doubleArray0;
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      
      double[] doubleArray1 = new double[8];
      assertFalse(doubleArray1.equals((Object)doubleArray0));
      
      regSMO0.m_alphaStar = regSMO0.m_alpha;
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      
      regSMO0.m_alpha = doubleArray1;
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      
      regSMO0.m_target = regSMO0.m_alphaStar;
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      
      int[] intArray0 = new int[11];
      intArray0[0] = 4857;
      intArray0[2] = 2198;
      intArray0[3] = 2198;
      String string0 = regSMO0.toString();
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("SMOreg\n\nSupport vectors:\n +       0     \n\n\n\nNumber of kernel evaluations: 0", string0);
      assertNotNull(string0);
      
      int int0 = regSMO0.secondChoiceHeuristic(2198);
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals(0, int0);
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      RegSMO regSMO1 = new RegSMO();
      assertEquals(0.001, regSMO1.getEpsilonParameter(), 0.01);
      assertFalse(regSMO1.modelBuilt());
      assertEquals(0, regSMO1.getKernelEvaluations());
      assertEquals(1, regSMO1.getSeed());
      assertEquals("Seed for random number generator.", regSMO1.seedTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO1.epsilonTipText());
      assertEquals(1.0E-12, regSMO1.getEpsilon(), 0.01);
      assertEquals((-1), regSMO1.getCacheHits());
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO1.epsilonParameterTipText());
      assertNotNull(regSMO1);
      assertFalse(regSMO1.equals((Object)regSMO0));
      
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      String string1 = regSMO0.epsilonTipText();
      assertEquals((-1), regSMO0.getCacheHits());
      assertEquals(0.001, regSMO0.getEpsilonParameter(), 0.01);
      assertEquals(0, regSMO0.getKernelEvaluations());
      assertEquals(1.0E-12, regSMO0.getEpsilon(), 0.01);
      assertEquals("The epsilon parameter of the epsilon insensitive loss function.(default 0.001).", regSMO0.epsilonParameterTipText());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", regSMO0.epsilonTipText());
      assertEquals("Seed for random number generator.", regSMO0.seedTipText());
      assertFalse(regSMO0.modelBuilt());
      assertEquals(1, regSMO0.getSeed());
      assertEquals("The epsilon for round-off error (shouldn't be changed).", string1);
      assertNotSame(regSMO0, regSMO1);
      assertNotNull(string1);
      assertFalse(regSMO0.equals((Object)regSMO1));
      assertFalse(string1.equals((Object)string0));
      
      try { 
        regSMO1.optimize();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.classifiers.functions.supportVector.RegSMO", e);
      }
  }
}
