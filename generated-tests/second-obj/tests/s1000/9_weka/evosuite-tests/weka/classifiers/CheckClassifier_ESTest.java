/*
 * This file was automatically generated by EvoSuite
 * Fri Jul 06 15:26:20 GMT 2018
 */

package weka.classifiers;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.LineNumberReader;
import java.io.PushbackReader;
import java.io.StringReader;
import java.util.Arrays;
import java.util.Enumeration;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;
import weka.attributeSelection.PrincipalComponents;
import weka.classifiers.CheckClassifier;
import weka.classifiers.Classifier;
import weka.classifiers.CostMatrix;
import weka.classifiers.Evaluation;
import weka.classifiers.functions.SGDText;
import weka.classifiers.functions.SimpleLogistic;
import weka.classifiers.lazy.IBk;
import weka.classifiers.lazy.LWL;
import weka.classifiers.meta.Stacking;
import weka.classifiers.rules.JRip;
import weka.classifiers.rules.M5Rules;
import weka.classifiers.trees.REPTree;
import weka.classifiers.trees.m5.RuleNode;
import weka.core.Capabilities;
import weka.core.CheckScheme;
import weka.core.Instances;
import weka.core.TestInstances;
import weka.core.Utils;
import weka.filters.AllFilter;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class CheckClassifier_ESTest extends CheckClassifier_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(false, false, false, true, false, false, 118);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '118' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleOnlyClass(true, false, false, false, true, 26);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '26' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.canPredict(true, true, true, true, true, true, 2);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(true, true, true, true, true, true, 81);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '81' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(true, false, true, false, false, true, (-2887));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-2887' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      boolean boolean0 = true;
      checkClassifier0.getOptions();
      boolean boolean1 = true;
      boolean boolean2 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(true, true, true, true, true, true, 98);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '98' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      String[] stringArray0 = new String[7];
      stringArray0[0] = "";
      stringArray0[1] = "=== Test Dataset ===\n";
      stringArray0[2] = "";
      stringArray0[3] = " (OK error message)";
      checkClassifier0.multiInstanceHandler();
      stringArray0[4] = "";
      stringArray0[5] = "";
      stringArray0[6] = "";
      CheckClassifier.main(stringArray0);
      checkClassifier0.setWordSeparators("");
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(true, false, false, false, true, true, 3277);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '3277' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.setSilent(false);
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(false, false, false, true, true, true, 118);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '118' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.printAttributeSummary(false, false, false, true, true, false, 100);
      assertFalse(checkClassifier0.getDebug());
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "5$=J`4)S>m0`&&r_i5");
      checkClassifier0.canTakeOptions();
      checkClassifier0.testToString();
      Random.setNextRandom(4);
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(false, false, true, false, true, true, (-914));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-914' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.getWords();
      checkClassifier0.setNumNumeric((-691));
      checkClassifier0.setNumString((-691));
      checkClassifier0.setNumString((-2112));
      checkClassifier0.getClassifier();
      checkClassifier0.canTakeOptions();
      String[] stringArray0 = new String[0];
      checkClassifier0.setOptions(stringArray0);
      checkClassifier0.printAttributeSummary(false, false, true, true, true, true, (-691));
      assertEquals(20, checkClassifier0.getNumInstances());
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.getOptions();
      // Undeclared exception!
      try { 
        checkClassifier0.testsPerClassType(3910, false, false, false);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '3910' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.canTakeOptions();
      boolean boolean0 = false;
      checkClassifier0.printAttributeSummary(true, false, true, true, false, false, (-2244));
      boolean boolean1 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(true, false, false, true, false, true, 36);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '36' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "5$=J`4)S>m0`&&r_i5");
      assertFalse(boolean0);
      
      String string0 = checkClassifier0.getRevision();
      assertEquals("8034", string0);
      assertNotNull(string0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      
      boolean boolean1 = true;
      boolean[] booleanArray0 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(false, true, false, true, true, true, (-2373));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-2373' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(false, false, false, false, true, true, 18);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '18' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      boolean[] booleanArray0 = checkClassifier0.correctBuildInitialisation(true, true, true, false, true, false, 0);
      assertNotNull(booleanArray0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      boolean[] booleanArray1 = checkClassifier0.declaresSerialVersionUID();
      assertNotNull(booleanArray1);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      boolean[] booleanArray2 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray2);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray2));
      assertNotSame(booleanArray2, booleanArray1);
      assertNotSame(booleanArray2, booleanArray0);
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      assertFalse(booleanArray2.equals((Object)booleanArray0));
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      boolean[] booleanArray0 = checkClassifier0.testToString();
      assertNotNull(booleanArray0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      String string0 = checkClassifier0.getRevision();
      assertEquals("8034", string0);
      assertNotNull(string0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(false, true, true, false, false, true, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean[] booleanArray0 = checkClassifier0.correctBuildInitialisation(true, true, false, true, true, false, 0);
      assertNotNull(booleanArray0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      boolean[] booleanArray1 = checkClassifier0.declaresSerialVersionUID();
      assertNotNull(booleanArray1);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      boolean[] booleanArray2 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray2);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray2));
      assertNotSame(booleanArray2, booleanArray0);
      assertNotSame(booleanArray2, booleanArray1);
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      assertFalse(booleanArray2.equals((Object)booleanArray1));
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean[] booleanArray0 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray0);
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      boolean boolean1 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleMissing(false, true, true, true, true, true, 0, true, true, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      
      boolean boolean0 = false;
      int int0 = (-716);
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(false, true, true, false, true, true, (-716));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-716' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      
      boolean boolean0 = false;
      int int0 = (-1167);
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(false, false, false, false, false, false, (-1167));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-1167' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.createFolder((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      Random.setNextRandom(11);
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      
      String string0 = checkClassifier0.getRevision();
      assertEquals("8034", string0);
      assertNotNull(string0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      
      boolean[] booleanArray0 = checkClassifier0.multiInstanceHandler();
      assertNotNull(booleanArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      
      // Undeclared exception!
      try { 
        checkClassifier0.canPredict(false, false, false, false, false, false, 11);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '11' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      
      boolean[] booleanArray0 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "zvc{grm");
      assertFalse(boolean0);
      
      boolean[] booleanArray1 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray1);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      boolean[] booleanArray2 = checkClassifier0.testToString();
      assertNotNull(booleanArray2);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray2));
      assertNotSame(booleanArray2, booleanArray1);
      assertNotSame(booleanArray2, booleanArray0);
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      
      Random.setNextRandom((-914));
      boolean boolean1 = FileSystemHandling.createFolder((EvoSuiteFile) null);
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
      
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(false, false, false, false, true, true, 34);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '34' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "overall");
      assertFalse(boolean0);
      
      boolean[] booleanArray0 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      boolean[] booleanArray1 = checkClassifier0.testToString();
      assertNotNull(booleanArray1);
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      Random.setNextRandom(0);
      boolean boolean1 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "overall");
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
      
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(false, true, false, true, true, false, (-914));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-914' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      boolean boolean1 = true;
      boolean boolean2 = FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      assertFalse(boolean2);
      assertFalse(boolean2 == boolean1);
      assertFalse(boolean2 == boolean0);
      
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      int int0 = (-4529);
      JRip jRip0 = new JRip();
      assertNotNull(jRip0);
      assertFalse(jRip0.getDebug());
      assertEquals("Determines the amount of data used for pruning. One fold is used for pruning, the rest for growing the rules.", jRip0.foldsTipText());
      assertEquals("The seed used for randomizing the data.", jRip0.seedTipText());
      assertEquals("The number of optimization runs.", jRip0.optimizationsTipText());
      assertTrue(jRip0.getUsePruning());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(1L, jRip0.getSeed());
      assertEquals(3, jRip0.getFolds());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals("The minimum total weight of the instances in a rule.", jRip0.minNoTipText());
      assertEquals("Whether check for error rate >= 1/2 is included in stopping criterion.", jRip0.checkErrorRateTipText());
      assertEquals("Whether pruning is performed.", jRip0.usePruningTipText());
      assertEquals("Whether debug information is output to the console.", jRip0.debugTipText());
      assertEquals(2.0, jRip0.getMinNo(), 0.01);
      
      checkClassifier0.m_Classifier = (Classifier) jRip0;
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(jRip0.getDebug());
      assertEquals("Determines the amount of data used for pruning. One fold is used for pruning, the rest for growing the rules.", jRip0.foldsTipText());
      assertEquals("The seed used for randomizing the data.", jRip0.seedTipText());
      assertEquals("The number of optimization runs.", jRip0.optimizationsTipText());
      assertTrue(jRip0.getUsePruning());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(1L, jRip0.getSeed());
      assertEquals(3, jRip0.getFolds());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals("The minimum total weight of the instances in a rule.", jRip0.minNoTipText());
      assertEquals("Whether check for error rate >= 1/2 is included in stopping criterion.", jRip0.checkErrorRateTipText());
      assertEquals("Whether pruning is performed.", jRip0.usePruningTipText());
      assertEquals("Whether debug information is output to the console.", jRip0.debugTipText());
      assertEquals(2.0, jRip0.getMinNo(), 0.01);
      
      checkClassifier0.setNumDate(5);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(5, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      Capabilities capabilities0 = jRip0.getCapabilities();
      assertNotNull(capabilities0);
      assertFalse(jRip0.getDebug());
      assertEquals("Determines the amount of data used for pruning. One fold is used for pruning, the rest for growing the rules.", jRip0.foldsTipText());
      assertEquals("The seed used for randomizing the data.", jRip0.seedTipText());
      assertEquals("The number of optimization runs.", jRip0.optimizationsTipText());
      assertTrue(jRip0.getUsePruning());
      assertTrue(jRip0.getCheckErrorRate());
      assertEquals(1L, jRip0.getSeed());
      assertEquals(3, jRip0.getFolds());
      assertEquals(2, jRip0.getOptimizations());
      assertEquals("The minimum total weight of the instances in a rule.", jRip0.minNoTipText());
      assertEquals("Whether check for error rate >= 1/2 is included in stopping criterion.", jRip0.checkErrorRateTipText());
      assertEquals("Whether pruning is performed.", jRip0.usePruningTipText());
      assertEquals("Whether debug information is output to the console.", jRip0.debugTipText());
      assertEquals(2.0, jRip0.getMinNo(), 0.01);
      assertEquals(3, capabilities0.getMinimumNumberInstances());
      assertFalse(capabilities0.hasDependencies());
      
      checkClassifier0.setNumInstancesRelational((-4529));
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(5, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals((-4529), checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(false, true, false, false, false, true, (-4529));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-4529' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "5$=J`4)S>m0`&&r_i5");
      assertFalse(boolean0);
      
      boolean[] booleanArray0 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      boolean[] booleanArray1 = checkClassifier0.testToString();
      assertNotNull(booleanArray1);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleZeroTraining(true, true, true, true, true, true, 3277);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '3277' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "5$=J`4)S>m0`&&r_i5");
      assertFalse(boolean0);
      
      boolean[] booleanArray0 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      boolean[] booleanArray1 = checkClassifier0.testToString();
      assertNotNull(booleanArray1);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleMissing(false, true, false, true, false, true, (-75), false, false, (-75));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-75' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      
      boolean[] booleanArray0 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      boolean boolean0 = true;
      boolean boolean1 = false;
      boolean boolean2 = true;
      boolean[] booleanArray1 = checkClassifier0.canHandleZeroTraining(true, true, true, true, false, true, 0);
      assertNotNull(booleanArray1);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      boolean boolean3 = false;
      SGDText sGDText0 = new SGDText();
      assertNotNull(sGDText0);
      assertFalse(sGDText0.getOutputProbsForSVM());
      assertEquals("The loss function to use. Hinge loss (SVM), log loss (logistic regression) or squared loss (regression).", sGDText0.lossFunctionTipText());
      assertEquals(1.0, sGDText0.getNorm(), 0.01);
      assertFalse(sGDText0.getUseStopList());
      assertEquals("The norm of the instances after normalization.", sGDText0.normTipText());
      assertEquals(1, sGDText0.getSeed());
      assertEquals("The LNorm to use for document length normalization.", sGDText0.LNormTipText());
      assertEquals(1.0E-4, sGDText0.getLambda(), 0.01);
      assertEquals("Implements stochastic gradient descent for learning a linear binary class SVM or binary class logistic regression on text data. Operates directly (and only) on String attributes. Other types of input attributes are accepted but ignored during training and classification.", sGDText0.globalInfo());
      assertFalse(sGDText0.getUseWordFrequencies());
      assertEquals("The regularization constant. (default = 0.0001)", sGDText0.lambdaTipText());
      assertEquals("Fit a logistic regression to the output of SVM for producing probability estimates", sGDText0.outputProbsForSVMTipText());
      assertEquals("Whether to convert all tokens to lowercase", sGDText0.lowercaseTokensTipText());
      assertEquals("Use word frequencies rather than binary bag of words representation", sGDText0.useWordFrequenciesTipText());
      assertEquals(3.0, sGDText0.getMinWordFrequency(), 0.01);
      assertEquals("The stemming algorithm to use on the words.", sGDText0.stemmerTipText());
      assertEquals("If true, ignores all words that are on the stoplist.", sGDText0.useStopListTipText());
      assertEquals(2.0, sGDText0.getLNorm(), 0.01);
      assertEquals("The number of epochs to perform (batch learning). The total number of iterations is epochs * num instances.", sGDText0.epochsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sGDText0.debugTipText());
      assertEquals(0, sGDText0.getPeriodicPruning());
      assertEquals("The file containing the stopwords (if this is a directory then the default ones are used).", sGDText0.stopwordsTipText());
      assertEquals(500, sGDText0.getEpochs());
      assertFalse(sGDText0.getDebug());
      assertEquals("Ignore any words that don't occur at least min frequency times in the training data. If periodic pruning is turned on, then the dictionary is pruned according to this value", sGDText0.minWordFrequencyTipText());
      assertEquals(0.01, sGDText0.getLearningRate(), 0.01);
      assertFalse(sGDText0.getLowercaseTokens());
      assertEquals("How often (number of instances) to prune the dictionary of low frequency terms. 0 means don't prune. Setting a positive integer n means prune after every n instances", sGDText0.periodicPruningTipText());
      assertEquals("If true then document length is normalized according to the settings for norm and lnorm", sGDText0.normalizeDocLengthTipText());
      assertEquals("The learning rate.", sGDText0.learningRateTipText());
      assertEquals("The random number seed to be used.", sGDText0.seedTipText());
      assertFalse(sGDText0.getNormalizeDocLength());
      assertEquals("The tokenizing algorithm to use on the strings.", sGDText0.tokenizerTipText());
      assertEquals(0, SGDText.HINGE);
      assertEquals(1, SGDText.LOGLOSS);
      
      sGDText0.setNormalizeDocLength(false);
      assertFalse(sGDText0.getOutputProbsForSVM());
      assertEquals("The loss function to use. Hinge loss (SVM), log loss (logistic regression) or squared loss (regression).", sGDText0.lossFunctionTipText());
      assertEquals(1.0, sGDText0.getNorm(), 0.01);
      assertFalse(sGDText0.getUseStopList());
      assertEquals("The norm of the instances after normalization.", sGDText0.normTipText());
      assertEquals(1, sGDText0.getSeed());
      assertEquals("The LNorm to use for document length normalization.", sGDText0.LNormTipText());
      assertEquals(1.0E-4, sGDText0.getLambda(), 0.01);
      assertEquals("Implements stochastic gradient descent for learning a linear binary class SVM or binary class logistic regression on text data. Operates directly (and only) on String attributes. Other types of input attributes are accepted but ignored during training and classification.", sGDText0.globalInfo());
      assertFalse(sGDText0.getUseWordFrequencies());
      assertEquals("The regularization constant. (default = 0.0001)", sGDText0.lambdaTipText());
      assertEquals("Fit a logistic regression to the output of SVM for producing probability estimates", sGDText0.outputProbsForSVMTipText());
      assertEquals("Whether to convert all tokens to lowercase", sGDText0.lowercaseTokensTipText());
      assertEquals("Use word frequencies rather than binary bag of words representation", sGDText0.useWordFrequenciesTipText());
      assertEquals(3.0, sGDText0.getMinWordFrequency(), 0.01);
      assertEquals("The stemming algorithm to use on the words.", sGDText0.stemmerTipText());
      assertEquals("If true, ignores all words that are on the stoplist.", sGDText0.useStopListTipText());
      assertEquals(2.0, sGDText0.getLNorm(), 0.01);
      assertEquals("The number of epochs to perform (batch learning). The total number of iterations is epochs * num instances.", sGDText0.epochsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sGDText0.debugTipText());
      assertEquals(0, sGDText0.getPeriodicPruning());
      assertEquals("The file containing the stopwords (if this is a directory then the default ones are used).", sGDText0.stopwordsTipText());
      assertEquals(500, sGDText0.getEpochs());
      assertFalse(sGDText0.getDebug());
      assertEquals("Ignore any words that don't occur at least min frequency times in the training data. If periodic pruning is turned on, then the dictionary is pruned according to this value", sGDText0.minWordFrequencyTipText());
      assertEquals(0.01, sGDText0.getLearningRate(), 0.01);
      assertFalse(sGDText0.getLowercaseTokens());
      assertEquals("How often (number of instances) to prune the dictionary of low frequency terms. 0 means don't prune. Setting a positive integer n means prune after every n instances", sGDText0.periodicPruningTipText());
      assertEquals("If true then document length is normalized according to the settings for norm and lnorm", sGDText0.normalizeDocLengthTipText());
      assertEquals("The learning rate.", sGDText0.learningRateTipText());
      assertEquals("The random number seed to be used.", sGDText0.seedTipText());
      assertFalse(sGDText0.getNormalizeDocLength());
      assertEquals("The tokenizing algorithm to use on the strings.", sGDText0.tokenizerTipText());
      assertEquals(0, SGDText.HINGE);
      assertEquals(1, SGDText.LOGLOSS);
      
      checkClassifier0.setClassifier(sGDText0);
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(sGDText0.getOutputProbsForSVM());
      assertEquals("The loss function to use. Hinge loss (SVM), log loss (logistic regression) or squared loss (regression).", sGDText0.lossFunctionTipText());
      assertEquals(1.0, sGDText0.getNorm(), 0.01);
      assertFalse(sGDText0.getUseStopList());
      assertEquals("The norm of the instances after normalization.", sGDText0.normTipText());
      assertEquals(1, sGDText0.getSeed());
      assertEquals("The LNorm to use for document length normalization.", sGDText0.LNormTipText());
      assertEquals(1.0E-4, sGDText0.getLambda(), 0.01);
      assertEquals("Implements stochastic gradient descent for learning a linear binary class SVM or binary class logistic regression on text data. Operates directly (and only) on String attributes. Other types of input attributes are accepted but ignored during training and classification.", sGDText0.globalInfo());
      assertFalse(sGDText0.getUseWordFrequencies());
      assertEquals("The regularization constant. (default = 0.0001)", sGDText0.lambdaTipText());
      assertEquals("Fit a logistic regression to the output of SVM for producing probability estimates", sGDText0.outputProbsForSVMTipText());
      assertEquals("Whether to convert all tokens to lowercase", sGDText0.lowercaseTokensTipText());
      assertEquals("Use word frequencies rather than binary bag of words representation", sGDText0.useWordFrequenciesTipText());
      assertEquals(3.0, sGDText0.getMinWordFrequency(), 0.01);
      assertEquals("The stemming algorithm to use on the words.", sGDText0.stemmerTipText());
      assertEquals("If true, ignores all words that are on the stoplist.", sGDText0.useStopListTipText());
      assertEquals(2.0, sGDText0.getLNorm(), 0.01);
      assertEquals("The number of epochs to perform (batch learning). The total number of iterations is epochs * num instances.", sGDText0.epochsTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", sGDText0.debugTipText());
      assertEquals(0, sGDText0.getPeriodicPruning());
      assertEquals("The file containing the stopwords (if this is a directory then the default ones are used).", sGDText0.stopwordsTipText());
      assertEquals(500, sGDText0.getEpochs());
      assertFalse(sGDText0.getDebug());
      assertEquals("Ignore any words that don't occur at least min frequency times in the training data. If periodic pruning is turned on, then the dictionary is pruned according to this value", sGDText0.minWordFrequencyTipText());
      assertEquals(0.01, sGDText0.getLearningRate(), 0.01);
      assertFalse(sGDText0.getLowercaseTokens());
      assertEquals("How often (number of instances) to prune the dictionary of low frequency terms. 0 means don't prune. Setting a positive integer n means prune after every n instances", sGDText0.periodicPruningTipText());
      assertEquals("If true then document length is normalized according to the settings for norm and lnorm", sGDText0.normalizeDocLengthTipText());
      assertEquals("The learning rate.", sGDText0.learningRateTipText());
      assertEquals("The random number seed to be used.", sGDText0.seedTipText());
      assertFalse(sGDText0.getNormalizeDocLength());
      assertEquals("The tokenizing algorithm to use on the strings.", sGDText0.tokenizerTipText());
      assertEquals(0, SGDText.HINGE);
      assertEquals(1, SGDText.LOGLOSS);
      
      boolean boolean4 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.canPredict(true, true, false, false, true, true, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      Enumeration enumeration0 = checkClassifier0.listOptions();
      assertNotNull(enumeration0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleClassAsNthAttribute(false, true, true, false, true, true, 0, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      boolean[] booleanArray0 = checkClassifier0.canHandleZeroTraining(false, true, false, true, false, true, 0);
      assertNotNull(booleanArray0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertNotNull(checkClassifier1);
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      
      // Undeclared exception!
      try { 
        checkClassifier1.correctBuildInitialisation(false, true, true, false, true, true, 1972);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '1972' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      // Undeclared exception!
      try { 
        checkClassifier0.testsPerClassType(1, true, true, true);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      SimpleLogistic simpleLogistic0 = new SimpleLogistic();
      assertNotNull(simpleLogistic0);
      assertEquals("Use error on the probabilties as error measure when determining the best number of LogitBoost iterations. If set, the number of LogitBoost iterations is chosen that minimizes the root mean squared error (either on the training set or in the cross-validation, depending on useCrossValidation).", simpleLogistic0.errorOnProbabilitiesTipText());
      assertFalse(simpleLogistic0.getDebug());
      assertEquals("Set fixed number of iterations for LogitBoost. If >= 0, this sets the number of LogitBoost iterations to perform. If < 0, the number is cross-validated or a stopping criterion on the training set is used (depending on the value of useCrossValidation).", simpleLogistic0.numBoostingIterationsTipText());
      assertEquals("Sets whether the number of LogitBoost iterations is to be cross-validated or the stopping criterion on the training set should be used. If not set (and no fixed number of iterations was given), the number of LogitBoost iterations is used that minimizes the error on the training set (misclassification error or error on probabilities depending on errorOnProbabilities).", simpleLogistic0.useCrossValidationTipText());
      assertEquals(500, simpleLogistic0.getMaxBoostingIterations());
      assertEquals("If heuristicStop > 0, the heuristic for greedy stopping while cross-validating the number of LogitBoost iterations is enabled. This means LogitBoost is stopped if no new error minimum has been reached in the last heuristicStop iterations. It is recommended to use this heuristic, it gives a large speed-up especially on small datasets. The default value is 50.", simpleLogistic0.heuristicStopTipText());
      assertEquals(0, simpleLogistic0.getNumBoostingIterations());
      assertEquals(50, simpleLogistic0.getHeuristicStop());
      assertTrue(simpleLogistic0.getUseCrossValidation());
      assertFalse(simpleLogistic0.getErrorOnProbabilities());
      assertFalse(simpleLogistic0.getUseAIC());
      assertEquals("Sets the maximum number of iterations for LogitBoost. Default value is 500, for very small/large datasets a lower/higher value might be preferable.", simpleLogistic0.maxBoostingIterationsTipText());
      assertEquals("Set the beta value used for weight trimming in LogitBoost. Only instances carrying (1 - beta)% of the weight from previous iteration are used in the next iteration. Set to 0 for no weight trimming. The default value is 0.", simpleLogistic0.weightTrimBetaTipText());
      assertEquals(0.0, simpleLogistic0.getWeightTrimBeta(), 0.01);
      assertEquals("The AIC is used to determine when to stop LogitBoost iterations (instead of cross-validation or training error).", simpleLogistic0.useAICTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", simpleLogistic0.debugTipText());
      
      checkClassifier0.m_Classifier = (Classifier) simpleLogistic0;
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals("Use error on the probabilties as error measure when determining the best number of LogitBoost iterations. If set, the number of LogitBoost iterations is chosen that minimizes the root mean squared error (either on the training set or in the cross-validation, depending on useCrossValidation).", simpleLogistic0.errorOnProbabilitiesTipText());
      assertFalse(simpleLogistic0.getDebug());
      assertEquals("Set fixed number of iterations for LogitBoost. If >= 0, this sets the number of LogitBoost iterations to perform. If < 0, the number is cross-validated or a stopping criterion on the training set is used (depending on the value of useCrossValidation).", simpleLogistic0.numBoostingIterationsTipText());
      assertEquals("Sets whether the number of LogitBoost iterations is to be cross-validated or the stopping criterion on the training set should be used. If not set (and no fixed number of iterations was given), the number of LogitBoost iterations is used that minimizes the error on the training set (misclassification error or error on probabilities depending on errorOnProbabilities).", simpleLogistic0.useCrossValidationTipText());
      assertEquals(500, simpleLogistic0.getMaxBoostingIterations());
      assertEquals("If heuristicStop > 0, the heuristic for greedy stopping while cross-validating the number of LogitBoost iterations is enabled. This means LogitBoost is stopped if no new error minimum has been reached in the last heuristicStop iterations. It is recommended to use this heuristic, it gives a large speed-up especially on small datasets. The default value is 50.", simpleLogistic0.heuristicStopTipText());
      assertEquals(0, simpleLogistic0.getNumBoostingIterations());
      assertEquals(50, simpleLogistic0.getHeuristicStop());
      assertTrue(simpleLogistic0.getUseCrossValidation());
      assertFalse(simpleLogistic0.getErrorOnProbabilities());
      assertFalse(simpleLogistic0.getUseAIC());
      assertEquals("Sets the maximum number of iterations for LogitBoost. Default value is 500, for very small/large datasets a lower/higher value might be preferable.", simpleLogistic0.maxBoostingIterationsTipText());
      assertEquals("Set the beta value used for weight trimming in LogitBoost. Only instances carrying (1 - beta)% of the weight from previous iteration are used in the next iteration. Set to 0 for no weight trimming. The default value is 0.", simpleLogistic0.weightTrimBetaTipText());
      assertEquals(0.0, simpleLogistic0.getWeightTrimBeta(), 0.01);
      assertEquals("The AIC is used to determine when to stop LogitBoost iterations (instead of cross-validation or training error).", simpleLogistic0.useAICTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", simpleLogistic0.debugTipText());
      
      int int0 = 0;
      simpleLogistic0.setHeuristicStop(0);
      assertEquals("Use error on the probabilties as error measure when determining the best number of LogitBoost iterations. If set, the number of LogitBoost iterations is chosen that minimizes the root mean squared error (either on the training set or in the cross-validation, depending on useCrossValidation).", simpleLogistic0.errorOnProbabilitiesTipText());
      assertFalse(simpleLogistic0.getDebug());
      assertEquals("Set fixed number of iterations for LogitBoost. If >= 0, this sets the number of LogitBoost iterations to perform. If < 0, the number is cross-validated or a stopping criterion on the training set is used (depending on the value of useCrossValidation).", simpleLogistic0.numBoostingIterationsTipText());
      assertEquals("Sets whether the number of LogitBoost iterations is to be cross-validated or the stopping criterion on the training set should be used. If not set (and no fixed number of iterations was given), the number of LogitBoost iterations is used that minimizes the error on the training set (misclassification error or error on probabilities depending on errorOnProbabilities).", simpleLogistic0.useCrossValidationTipText());
      assertEquals(500, simpleLogistic0.getMaxBoostingIterations());
      assertEquals("If heuristicStop > 0, the heuristic for greedy stopping while cross-validating the number of LogitBoost iterations is enabled. This means LogitBoost is stopped if no new error minimum has been reached in the last heuristicStop iterations. It is recommended to use this heuristic, it gives a large speed-up especially on small datasets. The default value is 50.", simpleLogistic0.heuristicStopTipText());
      assertEquals(0, simpleLogistic0.getNumBoostingIterations());
      assertEquals(500, simpleLogistic0.getHeuristicStop());
      assertTrue(simpleLogistic0.getUseCrossValidation());
      assertFalse(simpleLogistic0.getErrorOnProbabilities());
      assertFalse(simpleLogistic0.getUseAIC());
      assertEquals("Sets the maximum number of iterations for LogitBoost. Default value is 500, for very small/large datasets a lower/higher value might be preferable.", simpleLogistic0.maxBoostingIterationsTipText());
      assertEquals("Set the beta value used for weight trimming in LogitBoost. Only instances carrying (1 - beta)% of the weight from previous iteration are used in the next iteration. Set to 0 for no weight trimming. The default value is 0.", simpleLogistic0.weightTrimBetaTipText());
      assertEquals(0.0, simpleLogistic0.getWeightTrimBeta(), 0.01);
      assertEquals("The AIC is used to determine when to stop LogitBoost iterations (instead of cross-validation or training error).", simpleLogistic0.useAICTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", simpleLogistic0.debugTipText());
      
      checkClassifier0.m_Classifier = (Classifier) simpleLogistic0;
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals("Use error on the probabilties as error measure when determining the best number of LogitBoost iterations. If set, the number of LogitBoost iterations is chosen that minimizes the root mean squared error (either on the training set or in the cross-validation, depending on useCrossValidation).", simpleLogistic0.errorOnProbabilitiesTipText());
      assertFalse(simpleLogistic0.getDebug());
      assertEquals("Set fixed number of iterations for LogitBoost. If >= 0, this sets the number of LogitBoost iterations to perform. If < 0, the number is cross-validated or a stopping criterion on the training set is used (depending on the value of useCrossValidation).", simpleLogistic0.numBoostingIterationsTipText());
      assertEquals("Sets whether the number of LogitBoost iterations is to be cross-validated or the stopping criterion on the training set should be used. If not set (and no fixed number of iterations was given), the number of LogitBoost iterations is used that minimizes the error on the training set (misclassification error or error on probabilities depending on errorOnProbabilities).", simpleLogistic0.useCrossValidationTipText());
      assertEquals(500, simpleLogistic0.getMaxBoostingIterations());
      assertEquals("If heuristicStop > 0, the heuristic for greedy stopping while cross-validating the number of LogitBoost iterations is enabled. This means LogitBoost is stopped if no new error minimum has been reached in the last heuristicStop iterations. It is recommended to use this heuristic, it gives a large speed-up especially on small datasets. The default value is 50.", simpleLogistic0.heuristicStopTipText());
      assertEquals(0, simpleLogistic0.getNumBoostingIterations());
      assertEquals(500, simpleLogistic0.getHeuristicStop());
      assertTrue(simpleLogistic0.getUseCrossValidation());
      assertFalse(simpleLogistic0.getErrorOnProbabilities());
      assertFalse(simpleLogistic0.getUseAIC());
      assertEquals("Sets the maximum number of iterations for LogitBoost. Default value is 500, for very small/large datasets a lower/higher value might be preferable.", simpleLogistic0.maxBoostingIterationsTipText());
      assertEquals("Set the beta value used for weight trimming in LogitBoost. Only instances carrying (1 - beta)% of the weight from previous iteration are used in the next iteration. Set to 0 for no weight trimming. The default value is 0.", simpleLogistic0.weightTrimBetaTipText());
      assertEquals(0.0, simpleLogistic0.getWeightTrimBeta(), 0.01);
      assertEquals("The AIC is used to determine when to stop LogitBoost iterations (instead of cross-validation or training error).", simpleLogistic0.useAICTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", simpleLogistic0.debugTipText());
      
      boolean boolean0 = false;
      boolean boolean1 = true;
      int int1 = 2003;
      // Undeclared exception!
      try { 
        checkClassifier0.updatingEquality(false, false, false, true, false, true, 2003);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '2003' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleClassAsNthAttribute(false, false, false, false, false, false, 1070, (-1761));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '1070' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      boolean[] booleanArray0 = checkClassifier0.weightedInstancesHandler();
      assertNotNull(booleanArray0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      String string0 = checkClassifier0.getWords();
      assertEquals("The,quick,brown,fox,jumps,over,the,lazy,dog", string0);
      assertNotNull(string0);
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(true, true, true, true, false, false, 8, false, false);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '8' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      String string0 = checkClassifier0.getRevision();
      assertEquals("8034", string0);
      assertNotNull(string0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      
      Utils.SMALL = (-1562.0);
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "5$=J`4)S>m0`&&r_i5");
      assertFalse(boolean0);
      
      boolean[] booleanArray0 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      boolean[] booleanArray1 = checkClassifier0.declaresSerialVersionUID();
      assertNotNull(booleanArray1);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.getDebug());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(false, true, true, false, true, false, (-75), true, false);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-75' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      
      boolean boolean0 = false;
      boolean[] booleanArray0 = checkClassifier0.canHandleClassAsNthAttribute(true, true, true, false, false, false, 0, 0);
      assertNotNull(booleanArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertFalse(checkClassifier0.getDebug());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      // Undeclared exception!
      try { 
        checkClassifier0.doTests();
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Problem determining ZeroR performance: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      
      boolean[] booleanArray0 = checkClassifier0.testToString();
      assertNotNull(booleanArray0);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      Random.setNextRandom(18);
      boolean[] booleanArray1 = checkClassifier0.instanceWeights(false, true, true, false, false, true, 0);
      assertNotNull(booleanArray1);
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      
      boolean[] booleanArray0 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      boolean boolean0 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "WKZ8>E]>");
      assertFalse(boolean0);
      
      boolean[] booleanArray1 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray1);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      boolean[] booleanArray2 = checkClassifier0.testToString();
      assertNotNull(booleanArray2);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray2));
      assertNotSame(booleanArray2, booleanArray1);
      assertNotSame(booleanArray2, booleanArray0);
      assertFalse(booleanArray2.equals((Object)booleanArray1));
      assertFalse(booleanArray2.equals((Object)booleanArray0));
      
      Random.setNextRandom(4);
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(false, false, false, true, false, false, 4);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: weka.classifiers.rules.ZeroR: Cannot handle relational class!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      
      CheckScheme.PostProcessor checkScheme_PostProcessor0 = checkClassifier0.getPostProcessor();
      assertNull(checkScheme_PostProcessor0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      
      checkClassifier0.setPostProcessor((CheckScheme.PostProcessor) null);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      
      boolean[] booleanArray0 = checkClassifier0.updateableClassifier();
      assertNotNull(booleanArray0);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertTrue(Arrays.equals(new boolean[] {false, false}, booleanArray0));
      
      Random.setNextRandom(0);
      boolean[] booleanArray1 = checkClassifier0.instanceWeights(false, true, false, true, true, false, 0);
      assertNotNull(booleanArray1);
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumDate());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      CheckClassifier checkClassifier1 = new CheckClassifier();
      assertNotNull(checkClassifier1);
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
      
      String[] stringArray0 = checkClassifier1.getOptions();
      assertNotNull(stringArray0);
      assertEquals(" ", checkClassifier1.getWordSeparators());
      assertEquals(20, checkClassifier1.getNumInstances());
      assertEquals(1, checkClassifier1.getNumRelational());
      assertFalse(checkClassifier1.hasClasspathProblems());
      assertFalse(checkClassifier1.getSilent());
      assertEquals(1, checkClassifier1.getNumString());
      assertEquals(10, checkClassifier1.getNumInstancesRelational());
      assertEquals(1, checkClassifier1.getNumDate());
      assertEquals(2, checkClassifier1.getNumNominal());
      assertFalse(checkClassifier1.getDebug());
      assertEquals(1, checkClassifier1.getNumNumeric());
      assertNotSame(checkClassifier1, checkClassifier0);
      assertFalse(checkClassifier1.equals((Object)checkClassifier0));
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      boolean boolean0 = true;
      boolean[] booleanArray0 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      boolean boolean1 = true;
      boolean[] booleanArray1 = checkClassifier0.datasetIntegrity(true, true, true, true, false, true, 0, false, true);
      assertNotNull(booleanArray1);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getSilent());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      int int0 = (-762);
      // Undeclared exception!
      try { 
        checkClassifier0.correctBuildInitialisation(false, true, false, true, false, true, (-762));
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-762' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertEquals(1, checkClassifier0.getNumString());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      
      boolean boolean0 = true;
      boolean boolean1 = true;
      int int0 = 284;
      boolean boolean2 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.datasetIntegrity(true, false, false, true, true, false, 284, true, true);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '284' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      assertNotNull(checkClassifier0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      
      boolean boolean0 = true;
      boolean[] booleanArray0 = checkClassifier0.canTakeOptions();
      assertNotNull(booleanArray0);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray0));
      
      boolean[] booleanArray1 = checkClassifier0.datasetIntegrity(true, false, true, true, true, false, 0, true, true);
      assertNotNull(booleanArray1);
      assertEquals(" ", checkClassifier0.getWordSeparators());
      assertEquals(1, checkClassifier0.getNumNumeric());
      assertEquals(1, checkClassifier0.getNumDate());
      assertEquals(10, checkClassifier0.getNumInstancesRelational());
      assertFalse(checkClassifier0.getSilent());
      assertEquals(20, checkClassifier0.getNumInstances());
      assertEquals(1, checkClassifier0.getNumString());
      assertFalse(checkClassifier0.getDebug());
      assertEquals(2, checkClassifier0.getNumNominal());
      assertEquals(1, checkClassifier0.getNumRelational());
      assertFalse(checkClassifier0.hasClasspathProblems());
      assertTrue(Arrays.equals(new boolean[] {true, false}, booleanArray1));
      assertNotSame(booleanArray1, booleanArray0);
      assertFalse(booleanArray1.equals((Object)booleanArray0));
      
      boolean boolean1 = true;
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(true, true, false, true, true, true, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "5$=J`4)S>m0`&&r_i5");
      checkClassifier0.testToString();
      Random.setNextRandom((-914));
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(true, false, true, true, false, true, 4);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Loop has been executed more times than the allowed 10000
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.canTakeOptions();
      checkClassifier0.datasetIntegrity(true, false, false, true, true, false, 0, true, false);
      checkClassifier0.instanceWeights(false, false, false, false, false, true, 0);
      String[] stringArray0 = new String[5];
      stringArray0[0] = "!@6RZ/e8UD+iP)UsG/";
      stringArray0[1] = "";
      stringArray0[2] = "Of9)S$e`(";
      stringArray0[3] = "\tWhether to turn on the output of the class distribution.\n\tOnly for nominal class attributes.\n\t(default: off)";
      stringArray0[4] = "(WBM";
      CheckClassifier.main(stringArray0);
      LWL lWL0 = new LWL();
      lWL0.getClassifier();
      CostMatrix costMatrix0 = new CostMatrix(0);
      Evaluation evaluation0 = null;
      try {
        evaluation0 = new Evaluation((Instances) null, costMatrix0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.core.Instances", e);
      }
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.updatingEquality(true, false, true, false, true, false, 0);
      checkClassifier0.canPredict(false, true, false, true, false, true, 0);
      checkClassifier0.canHandleZeroTraining(true, true, false, false, true, false, 0);
      checkClassifier0.getOptions();
      checkClassifier0.getRevision();
      JRip jRip0 = new JRip();
      jRip0.setUsePruning(true);
      jRip0.setOptimizations(186);
      jRip0.toString();
      jRip0.getRevision();
      checkClassifier0.setClassifier(jRip0);
      checkClassifier0.multiInstanceHandler();
      // Undeclared exception!
      try { 
        checkClassifier0.doesntUseTestClassVal(false, false, true, false, true, false, 0);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: weka.classifiers.rules.JRip: Cannot handle string attributes!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.updatingEquality(true, false, true, false, true, false, 0);
      checkClassifier0.canPredict(false, true, false, true, false, true, 0);
      Random.setNextRandom(11);
      CheckClassifier checkClassifier1 = new CheckClassifier();
      // Undeclared exception!
      try { 
        checkClassifier0.instanceWeights(false, true, true, false, true, true, 1162);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '1162' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.getPostProcessor();
      checkClassifier0.setPostProcessor((CheckScheme.PostProcessor) null);
      checkClassifier0.correctBuildInitialisation(true, true, false, true, false, false, 0);
      Random.setNextRandom(0);
      checkClassifier0.weightedInstancesHandler();
      checkClassifier0.canTakeOptions();
      checkClassifier0.testToString();
      checkClassifier0.getOptions();
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      String[] stringArray0 = new String[1];
      stringArray0[0] = ">rS(LS^E8\"y";
      CheckClassifier.main(stringArray0);
      CheckClassifier checkClassifier0 = new CheckClassifier();
      boolean boolean0 = true;
      boolean boolean1 = false;
      checkClassifier0.correctBuildInitialisation(true, false, false, true, false, false, 0);
      CheckClassifier checkClassifier1 = new CheckClassifier();
      checkClassifier1.declaresSerialVersionUID();
      checkClassifier1.canTakeOptions();
      // Undeclared exception!
      try { 
        checkClassifier1.testsPerClassType(17, true, true, true);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '17' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.getPostProcessor();
      checkClassifier0.setPostProcessor((CheckScheme.PostProcessor) null);
      checkClassifier0.printAttributeSummary(true, false, true, true, false, false, (-441));
      // Undeclared exception!
      try { 
        checkClassifier0.canHandleMissing(true, false, false, false, true, false, (-790), true, false, 1945);
        fail("Expecting exception: Error");
      
      } catch(Error e) {
         //
         // Error setting up for tests: Attribute type '-790' unknown!
         //
         verifyException("weka.classifiers.CheckClassifier", e);
      }
  }

  @Test(timeout = 4000)
  public void test49()  throws Throwable  {
      CheckClassifier checkClassifier0 = new CheckClassifier();
      checkClassifier0.updatingEquality(true, false, true, false, true, false, 0);
      checkClassifier0.updatingEquality(false, true, true, false, false, false, 0);
      checkClassifier0.canHandleZeroTraining(true, true, false, false, true, false, 0);
      checkClassifier0.getOptions();
      checkClassifier0.getRevision();
      JRip jRip0 = new JRip();
      jRip0.setUsePruning(true);
      jRip0.setOptimizations(186);
      jRip0.toString();
      checkClassifier0.datasetIntegrity(true, false, false, true, false, true, 0, false, false);
      jRip0.getRevision();
      checkClassifier0.setClassifier(jRip0);
      checkClassifier0.multiInstanceHandler();
      checkClassifier0.testToString();
      checkClassifier0.getOptions();
      checkClassifier0.updateableClassifier();
  }
}
