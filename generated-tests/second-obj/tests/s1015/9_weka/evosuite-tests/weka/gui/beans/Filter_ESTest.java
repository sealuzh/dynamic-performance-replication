/*
 * This file was automatically generated by EvoSuite
 * Sat Jul 07 03:29:08 GMT 2018
 */

package weka.gui.beans;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.MockitoExtension.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.AWTEventMulticaster;
import java.awt.Dialog;
import java.awt.Dimension;
import java.awt.FocusTraversalPolicy;
import java.awt.Font;
import java.awt.Frame;
import java.awt.GraphicsConfiguration;
import java.awt.HeadlessException;
import java.awt.Insets;
import java.awt.Label;
import java.awt.Rectangle;
import java.awt.TextField;
import java.awt.event.ComponentListener;
import java.awt.event.ContainerListener;
import java.awt.event.KeyListener;
import java.beans.EventSetDescriptor;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.ListIterator;
import java.util.Map;
import java.util.Stack;
import java.util.Vector;
import javax.accessibility.AccessibleContext;
import javax.swing.Action;
import javax.swing.InputMap;
import javax.swing.JToolTip;
import javax.swing.ScrollPaneConstants;
import javax.swing.border.CompoundBorder;
import javax.swing.plaf.metal.MetalToolBarUI;
import javax.swing.text.DefaultEditorKit;
import javax.swing.text.StyleContext;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.lang.MockThread;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;
import weka.classifiers.bayes.BayesNet;
import weka.classifiers.misc.InputMappedClassifier;
import weka.core.AbstractInstance;
import weka.core.Attribute;
import weka.core.BinarySparseInstance;
import weka.core.ChebyshevDistance;
import weka.core.EuclideanDistance;
import weka.core.FindWithCapabilities;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.TestInstances;
import weka.core.converters.MatlabLoader;
import weka.core.converters.TextDirectoryLoader;
import weka.core.tokenizers.AlphabeticTokenizer;
import weka.core.tokenizers.WordTokenizer;
import weka.filters.AllFilter;
import weka.filters.MultiFilter;
import weka.filters.supervised.attribute.AttributeSelection;
import weka.filters.supervised.attribute.ClassOrder;
import weka.filters.supervised.instance.Resample;
import weka.filters.supervised.instance.SpreadSubsample;
import weka.filters.unsupervised.attribute.Add;
import weka.gui.SysErrLog;
import weka.gui.beans.Appender;
import weka.gui.beans.Associator;
import weka.gui.beans.AttributeSummarizer;
import weka.gui.beans.BeanVisual;
import weka.gui.beans.Classifier;
import weka.gui.beans.Clusterer;
import weka.gui.beans.ClustererPerformanceEvaluator;
import weka.gui.beans.ConfigurationListener;
import weka.gui.beans.CrossValidationFoldMaker;
import weka.gui.beans.DataSetEvent;
import weka.gui.beans.DataVisualizer;
import weka.gui.beans.Filter;
import weka.gui.beans.FlowByExpression;
import weka.gui.beans.GraphViewer;
import weka.gui.beans.InstanceEvent;
import weka.gui.beans.InstanceStreamToBatchMaker;
import weka.gui.beans.KnowledgeFlowApp;
import weka.gui.beans.Loader;
import weka.gui.beans.MetaBean;
import weka.gui.beans.PredictionAppender;
import weka.gui.beans.Saver;
import weka.gui.beans.ScatterPlotMatrix;
import weka.gui.beans.SerializedModelSaver;
import weka.gui.beans.Sorter;
import weka.gui.beans.SubstringLabeler;
import weka.gui.beans.SubstringReplacer;
import weka.gui.beans.TestSetEvent;
import weka.gui.beans.TestSetListener;
import weka.gui.beans.TestSetMaker;
import weka.gui.beans.TextViewer;
import weka.gui.beans.TrainTestSplitMaker;
import weka.gui.beans.TrainingSetEvent;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class Filter_ESTest extends Filter_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Filter filter0 = new Filter();
      CrossValidationFoldMaker crossValidationFoldMaker0 = new CrossValidationFoldMaker();
      filter0.removeTrainingSetListener(crossValidationFoldMaker0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.addTestSetListener((TestSetListener) null);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      Filter filter0 = new Filter();
      Enumeration enumeration0 = filter0.enumerateRequests();
      DataSetEvent dataSetEvent0 = new DataSetEvent(enumeration0, (Instances) null);
      filter0.acceptDataSet(dataSetEvent0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.getWrappedAlgorithm();
      Sorter sorter0 = new Sorter();
      sorter0.getStructure("e{)xa");
      EuclideanDistance euclideanDistance0 = new EuclideanDistance((Instances) null);
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(euclideanDistance0, (Instances) null, (-1285), 2);
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Filter filter0 = new Filter();
      Appender appender0 = new Appender();
      filter0.addTrainingSetListener(appender0);
      InstanceStreamToBatchMaker instanceStreamToBatchMaker0 = new InstanceStreamToBatchMaker();
      filter0.removeInstanceListener(instanceStreamToBatchMaker0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Filter filter0 = new Filter();
      Sorter sorter0 = new Sorter();
      BeanVisual beanVisual0 = sorter0.getVisual();
      filter0.setVisual(beanVisual0);
      ClassOrder classOrder0 = new ClassOrder();
      filter0.setFilter(classOrder0);
      assertEquals("ClassOrder", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.getCursor();
      FindWithCapabilities findWithCapabilities0 = new FindWithCapabilities();
      filter0.disconnectionNotification("\tMust handle binary attributes.", findWithCapabilities0);
      MultiFilter multiFilter0 = new MultiFilter();
      filter0.setFilter(multiFilter0);
      filter0.stop();
      assertEquals("MultiFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Filter filter0 = new Filter();
      boolean boolean0 = filter0.isBusy();
      assertFalse(boolean0);
      
      BeanVisual beanVisual0 = filter0.m_visual;
      assertEquals("weka/gui/beans/icons/DefaultFilter.gif", beanVisual0.getIconPath());
      assertEquals("weka/gui/beans/icons/DefaultFilter_animated.gif", beanVisual0.getAnimatedIconPath());
      
      SysErrLog sysErrLog0 = new SysErrLog();
      filter0.setLog(sysErrLog0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.connectionNotification(",Jw7o1", ",Jw7o1");
      filter0.stop();
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Filter filter0 = new Filter();
      boolean boolean0 = filter0.eventGeneratable("8 wO{VJ$Cz03");
      assertFalse(boolean0);
      
      EuclideanDistance euclideanDistance0 = new EuclideanDistance();
      filter0.disconnectionNotification("8 wO{VJ$Cz03", euclideanDistance0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.getFilter();
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      filter0.addConfigurationListener(configurationListener0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      MetaBean metaBean0 = new MetaBean();
      Stack<FlowByExpression.ExpressionClause.ExpressionType> stack0 = new Stack<FlowByExpression.ExpressionClause.ExpressionType>();
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      textDirectoryLoader0.setRetrieval((-23));
      Resample resample0 = new Resample();
      Clusterer clusterer0 = new Clusterer();
      clusterer0.getHierarchyListeners();
      Appender appender0 = new Appender();
      AllFilter allFilter0 = new AllFilter();
      DataSetEvent dataSetEvent0 = new DataSetEvent(allFilter0, instances0);
      Filter filter0 = new Filter();
      filter0.acceptDataSet(dataSetEvent0);
      weka.filters.Filter filter1 = filter0.getFilter();
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter1.isOutputFormatDefined());
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Filter filter0 = new Filter();
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      filter0.isValidateRoot();
      Instances instances0 = textDirectoryLoader0.getDataSet();
      MetaBean metaBean0 = new MetaBean();
      textDirectoryLoader0.reset();
      filter0.requestFocusInWindow();
      FileSystemHandling.shouldAllThrowIOExceptions();
      filter0.acceptInstance((InstanceEvent) null);
      filter0.eventGeneratable("6:");
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(metaBean0, instances0);
      filter0.acceptTrainingSet(trainingSetEvent0);
      // Undeclared exception!
      try { 
        filter0.performRequest("6:");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // 6: not supported (Filter)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Filter filter0 = new Filter();
      ScatterPlotMatrix scatterPlotMatrix0 = new ScatterPlotMatrix();
      filter0.connectionNotification("testSet", scatterPlotMatrix0);
      FileSystemHandling.shouldAllThrowIOExceptions();
      FileSystemHandling.shouldAllThrowIOExceptions();
      PredictionAppender predictionAppender0 = new PredictionAppender();
      FileSystemHandling.shouldAllThrowIOExceptions();
      filter0.acceptInstance((InstanceEvent) null);
      filter0.eventGeneratable("Ld");
      filter0.getCustomName();
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/mnt/gaiagpfs/users/homedirs/apanichella/Evosuite_performance/Dataset/gordon_script_sum/projects/9_weka");
      FileSystemHandling.setPermissions(evoSuiteFile0, true, false, true);
      Loader loader0 = new Loader();
      loader0.getStructure("Ld");
      TestSetEvent testSetEvent0 = null;
      try {
        testSetEvent0 = new TestSetEvent((Object) null, (Instances) null, 358, (-3811));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // null source
         //
         verifyException("java.util.EventObject", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, true);
      Filter filter0 = new Filter();
      String string0 = filter0.getCustomName();
      assertEquals("AllFilter", string0);
      
      filter0.getBorder();
      filter0.acceptTrainingSet((TrainingSetEvent) null);
      TestInstances testInstances0 = new TestInstances();
      testInstances0.getRelationalClassFormat();
      DataSetEvent dataSetEvent0 = new DataSetEvent("AllFilter", (Instances) null);
      filter0.acceptDataSet(dataSetEvent0);
      boolean boolean0 = filter0.isBusy();
      filter0.stop();
      System.setCurrentTimeMillis(123L);
      boolean boolean1 = filter0.eventGeneratable("llN){%bhsCC#");
      assertTrue(boolean1 == boolean0);
      assertFalse(boolean1);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      Filter filter0 = new Filter();
      FileSystemHandling.shouldAllThrowIOExceptions();
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "}??");
      byte[] byteArray0 = new byte[3];
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "}??");
      byteArray0[0] = (byte) (-53);
      byteArray0[1] = (byte) (-53);
      Rectangle rectangle0 = new Rectangle((byte) (-53), (byte) (-53));
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      filter0.connectionNotification("nS,Q&j@tuZ", substringLabeler0);
      Sorter sorter0 = new Sorter();
      sorter0.getToolkit();
      BeanVisual beanVisual0 = sorter0.getVisual();
      filter0.setVisual(beanVisual0);
      filter0.useDefaultVisual();
      filter0.addInstanceListener(sorter0);
      InstanceEvent instanceEvent0 = new InstanceEvent(filter0);
      // Undeclared exception!
      try { 
        filter0.notifyInstanceListeners(instanceEvent0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.core.Instances", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.connectionNotification("Y[)pW*4X", "Y[)pW*4X");
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      byte[] byteArray0 = new byte[3];
      byteArray0[1] = (byte)2;
      byteArray0[2] = (byte) (-96);
      FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      FlowByExpression flowByExpression0 = new FlowByExpression();
      flowByExpression0.getComponents();
      filter0.addInstanceListener(flowByExpression0);
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      InstanceEvent instanceEvent0 = substringReplacer0.m_ie;
      filter0.notifyInstanceListeners(instanceEvent0);
      filter0.getGraphicsConfiguration();
      Frame frame0 = null;
      try {
        frame0 = new Frame("Y[)pW*4X", (GraphicsConfiguration) null);
        fail("Expecting exception: HeadlessException");
      
      } catch(HeadlessException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.awt.GraphicsEnvironment", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      Rectangle rectangle0 = filter0.getVisibleRect();
      assertNotNull(rectangle0);
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals(0.0, rectangle0.getWidth(), 0.01);
      assertEquals(0.0, rectangle0.getY(), 0.01);
      assertEquals(0.0, rectangle0.getX(), 0.01);
      assertEquals(0.0, rectangle0.getMinX(), 0.01);
      assertEquals(0.0, rectangle0.getCenterX(), 0.01);
      assertEquals(0.0, rectangle0.getMaxY(), 0.01);
      assertTrue(rectangle0.isEmpty());
      assertEquals(0.0, rectangle0.getMinY(), 0.01);
      assertEquals(0.0, rectangle0.getMaxX(), 0.01);
      assertEquals(0.0, rectangle0.getHeight(), 0.01);
      assertEquals(0.0, rectangle0.getCenterY(), 0.01);
      assertEquals(0, rectangle0.y);
      assertEquals(0, rectangle0.x);
      assertEquals(0, rectangle0.width);
      assertEquals(0, rectangle0.height);
      
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      PredictionAppender predictionAppender0 = new PredictionAppender();
      assertNotNull(predictionAppender0);
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      assertFalse(predictionAppender0.isFocusCycleRoot());
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertFalse(predictionAppender0.isBusy());
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      
      InstanceEvent instanceEvent0 = predictionAppender0.m_instanceEvent;
      assertNull(instanceEvent0);
      
      filter0.acceptInstance((InstanceEvent) null);
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isFirstBatchDone());
      
      filter0.setWrappedAlgorithm(multiFilter0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isFirstBatchDone());
      
      Sorter sorter0 = new Sorter();
      assertNotNull(sorter0);
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isBusy());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.getIgnoreRepaint());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isFocusCycleRoot());
      assertEquals("", sorter0.getTempDirectory());
      assertNull(sorter0.getSortDetails());
      
      filter0.addDataSourceListener(sorter0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isBusy());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.getIgnoreRepaint());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isFocusCycleRoot());
      assertEquals("", sorter0.getTempDirectory());
      assertNull(sorter0.getSortDetails());
      
      // Undeclared exception!
      try { 
        filter0.performRequest("yI<#r3l3HUUeND]g");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // yI<#r3l3HUUeND]g not supported (Filter)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      boolean boolean1 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, "r~uD");
      assertFalse(boolean1);
      assertFalse(boolean1 == boolean0);
      
      boolean boolean2 = FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, false);
      assertFalse(boolean2);
      assertTrue(boolean2 == boolean1);
      assertFalse(boolean2 == boolean0);
      
      PredictionAppender predictionAppender0 = new PredictionAppender();
      assertNotNull(predictionAppender0);
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      assertFalse(predictionAppender0.isFocusCycleRoot());
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertFalse(predictionAppender0.isBusy());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      
      DataVisualizer dataVisualizer0 = new DataVisualizer();
      assertNotNull(dataVisualizer0);
      assertFalse(dataVisualizer0.isFocusTraversalPolicySet());
      assertFalse(dataVisualizer0.isFocusTraversalPolicyProvider());
      assertFalse(dataVisualizer0.isFocusCycleRoot());
      assertEquals("", dataVisualizer0.getOffscreenAdditionalOpts());
      assertEquals("500", dataVisualizer0.getOffscreenWidth());
      assertTrue(dataVisualizer0.getFocusTraversalKeysEnabled());
      assertEquals("", dataVisualizer0.getOffscreenXAxis());
      assertFalse(dataVisualizer0.getIgnoreRepaint());
      assertFalse(dataVisualizer0.isBusy());
      assertEquals("DataVisualizer", dataVisualizer0.getCustomName());
      assertEquals("400", dataVisualizer0.getOffscreenHeight());
      assertEquals("Visualize incoming data/training/test sets in a 2D scatter plot.", dataVisualizer0.globalInfo());
      assertEquals("", dataVisualizer0.getOffscreenYAxis());
      assertEquals("Weka Chart Renderer", dataVisualizer0.getOffscreenRendererName());
      
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("AllFilter", filter0.getCustomName());
      
      // Undeclared exception!
      try { 
        filter0.connectionAllowed((EventSetDescriptor) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      
      MetaBean metaBean0 = new MetaBean();
      assertNotNull(metaBean0);
      assertTrue(metaBean0.getFocusTraversalKeysEnabled());
      assertFalse(metaBean0.getIgnoreRepaint());
      assertFalse(metaBean0.isFocusTraversalPolicySet());
      assertFalse(metaBean0.isFocusCycleRoot());
      assertEquals("Group", metaBean0.getCustomName());
      assertFalse(metaBean0.isFocusTraversalPolicyProvider());
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      filter0.acceptInstance((InstanceEvent) null);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      
      boolean boolean1 = filter0.eventGeneratable(".bsi");
      assertFalse(boolean1);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(boolean1 == boolean0);
      
      String string0 = filter0.getCustomName();
      assertEquals("AllFilter", string0);
      assertNotNull(string0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      
      TestSetEvent testSetEvent0 = new TestSetEvent(instances0, instances0, 358, 800);
      assertNotNull(testSetEvent0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertTrue(testSetEvent0.isStructureOnly());
      assertEquals(358, testSetEvent0.getSetNumber());
      assertEquals(800, testSetEvent0.getMaxSetNumber());
      assertEquals(1, testSetEvent0.getRunNumber());
      
      filter0.acceptTestSet(testSetEvent0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertTrue(testSetEvent0.isStructureOnly());
      assertEquals(358, testSetEvent0.getSetNumber());
      assertEquals(800, testSetEvent0.getMaxSetNumber());
      assertEquals(1, testSetEvent0.getRunNumber());
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      boolean boolean0 = filter0.isRequestFocusEnabled();
      assertTrue(boolean0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      int int0 = filter0.getX();
      assertEquals(0, int0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      filter0.connectionNotification("f.1M}ZWueeP<8n3J^}", "f.1M}ZWueeP<8n3J^}");
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      boolean boolean1 = filter0.eventGeneratable("f.1M}ZWueeP<8n3J^}");
      assertTrue(boolean1);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(boolean1 == boolean0);
      
      TestInstances testInstances0 = new TestInstances();
      assertNotNull(testInstances0);
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertFalse(testInstances0.getNoClass());
      assertEquals(20, testInstances0.getNumInstances());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      assertNotNull(arrayList0);
      assertEquals(0, arrayList0.size());
      assertTrue(arrayList0.isEmpty());
      
      Instances instances0 = null;
      try {
        instances0 = new Instances("$FX>.V9", arrayList0, (-2997));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Illegal Capacity: -2997
         //
         verifyException("java.util.ArrayList", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      ComponentListener componentListener0 = mock(ComponentListener.class, new ViolatedAssumptionAnswer());
      filter0.removeInstanceListener(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      boolean boolean1 = filter0.eventGeneratable("configuration");
      assertTrue(boolean1);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertTrue(boolean1 == boolean0);
      
      StyleContext styleContext0 = StyleContext.getDefaultStyleContext();
      assertNotNull(styleContext0);
      
      Font font0 = Font.getFont("configuration");
      assertNull(font0);
      
      filter0.connectionNotification("configuration", componentListener0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      Loader loader0 = new Loader();
      assertNotNull(loader0);
      assertFalse(loader0.isFocusTraversalPolicySet());
      assertFalse(loader0.isFocusCycleRoot());
      assertEquals("ArffLoader", loader0.getCustomName());
      assertEquals("<html><font color=blue>Reads a source that is in arff (attribute relation file format) format</font> <br></html>", loader0.globalInfo());
      assertTrue(loader0.getFocusTraversalKeysEnabled());
      assertFalse(loader0.getIgnoreRepaint());
      assertFalse(loader0.isFocusTraversalPolicyProvider());
      assertFalse(loader0.isBusy());
      
      BeanVisual beanVisual0 = loader0.m_visual;
      assertNotNull(beanVisual0);
      assertFalse(beanVisual0.getIgnoreRepaint());
      assertTrue(beanVisual0.getFocusTraversalKeysEnabled());
      assertFalse(beanVisual0.isFocusTraversalPolicySet());
      assertFalse(beanVisual0.isFocusCycleRoot());
      assertEquals("ArffLoader", beanVisual0.getText());
      assertFalse(beanVisual0.isFocusTraversalPolicyProvider());
      assertEquals("weka/gui/beans/icons/DefaultDataSource_animated.gif", beanVisual0.getAnimatedIconPath());
      assertEquals("weka/gui/beans/icons/DefaultDataSource.gif", beanVisual0.getIconPath());
      assertEquals(0, BeanVisual.NORTH_CONNECTOR);
      assertEquals(1, BeanVisual.SOUTH_CONNECTOR);
      assertEquals(3, BeanVisual.WEST_CONNECTOR);
      assertEquals(2, BeanVisual.EAST_CONNECTOR);
      
      beanVisual0.validate();
      assertFalse(loader0.isFocusTraversalPolicySet());
      assertFalse(loader0.isFocusCycleRoot());
      assertEquals("ArffLoader", loader0.getCustomName());
      assertEquals("<html><font color=blue>Reads a source that is in arff (attribute relation file format) format</font> <br></html>", loader0.globalInfo());
      assertTrue(loader0.getFocusTraversalKeysEnabled());
      assertFalse(loader0.getIgnoreRepaint());
      assertFalse(loader0.isFocusTraversalPolicyProvider());
      assertFalse(loader0.isBusy());
      assertFalse(beanVisual0.getIgnoreRepaint());
      assertTrue(beanVisual0.getFocusTraversalKeysEnabled());
      assertFalse(beanVisual0.isFocusTraversalPolicySet());
      assertFalse(beanVisual0.isFocusCycleRoot());
      assertEquals("ArffLoader", beanVisual0.getText());
      assertFalse(beanVisual0.isFocusTraversalPolicyProvider());
      assertEquals("weka/gui/beans/icons/DefaultDataSource_animated.gif", beanVisual0.getAnimatedIconPath());
      assertEquals("weka/gui/beans/icons/DefaultDataSource.gif", beanVisual0.getIconPath());
      assertEquals(0, BeanVisual.NORTH_CONNECTOR);
      assertEquals(1, BeanVisual.SOUTH_CONNECTOR);
      assertEquals(3, BeanVisual.WEST_CONNECTOR);
      assertEquals(2, BeanVisual.EAST_CONNECTOR);
      
      Random.setNextRandom(1);
      PredictionAppender predictionAppender0 = new PredictionAppender();
      assertNotNull(predictionAppender0);
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertFalse(predictionAppender0.isBusy());
      assertFalse(predictionAppender0.isFocusCycleRoot());
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      
      InstanceEvent instanceEvent0 = predictionAppender0.m_instanceEvent;
      assertNull(instanceEvent0);
      
      filter0.notifyInstanceListeners((InstanceEvent) null);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      filter0.addConfigurationListener(configurationListener0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      boolean boolean2 = filter0.connectionAllowed("configuration");
      assertFalse(boolean2);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(boolean2 == boolean0);
      assertFalse(boolean2 == boolean1);
      
      Associator associator0 = new Associator();
      assertNotNull(associator0);
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      assertFalse(associator0.isFocusCycleRoot());
      assertFalse(associator0.getIgnoreRepaint());
      assertEquals("Apriori", associator0.getCustomName());
      assertFalse(associator0.isBusy());
      assertTrue(associator0.getFocusTraversalKeysEnabled());
      
      filter0.removeDataSourceListener(associator0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      assertFalse(associator0.isFocusCycleRoot());
      assertFalse(associator0.getIgnoreRepaint());
      assertEquals("Apriori", associator0.getCustomName());
      assertFalse(associator0.isBusy());
      assertTrue(associator0.getFocusTraversalKeysEnabled());
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      
      WordTokenizer wordTokenizer0 = new WordTokenizer();
      assertNotNull(wordTokenizer0);
      assertEquals(" \r\n\t.,;:'\"()?!", wordTokenizer0.getDelimiters());
      assertEquals("Set of delimiter characters to use in tokenizing (\\r, \\n and \\t can be used for carriage-return, line-feed and tab)", wordTokenizer0.delimitersTipText());
      assertEquals("A simple tokenizer that is using the java.util.StringTokenizer class to tokenize the strings.", wordTokenizer0.globalInfo());
      
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      assertNotNull(trainTestSplitMaker0);
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      
      MetalToolBarUI metalToolBarUI0 = new MetalToolBarUI();
      assertNotNull(metalToolBarUI0);
      
      Resample resample0 = new Resample();
      assertNotNull(resample0);
      assertFalse(resample0.getInvertSelection());
      assertFalse(resample0.isFirstBatchDone());
      assertTrue(resample0.isNewBatch());
      assertEquals("The subsample size as a percentage of the original set.", resample0.sampleSizePercentTipText());
      assertEquals(1, resample0.getRandomSeed());
      assertEquals(0.0, resample0.getBiasToUniformClass(), 0.01);
      assertFalse(resample0.getNoReplacement());
      assertEquals(100.0, resample0.getSampleSizePercent(), 0.01);
      assertFalse(resample0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample0.globalInfo());
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample0.biasToUniformClassTipText());
      assertEquals("Disables the replacement of instances.", resample0.noReplacementTipText());
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample0.invertSelectionTipText());
      assertEquals("Sets the random number seed for subsampling.", resample0.randomSeedTipText());
      assertFalse(resample0.isOutputFormatDefined());
      
      Saver saver0 = new Saver();
      assertNotNull(saver0);
      assertFalse(saver0.isFocusTraversalPolicySet());
      assertTrue(saver0.getFocusTraversalKeysEnabled());
      assertTrue(saver0.getRelationNameForFilename());
      assertFalse(saver0.getIgnoreRepaint());
      assertFalse(saver0.isFocusTraversalPolicyProvider());
      assertEquals("ArffSaver", saver0.getCustomName());
      assertFalse(saver0.isFocusCycleRoot());
      assertFalse(saver0.isBusy());
      assertEquals("<html><font color=blue>Writes to a destination that is in arff (attribute relation file format) format</font><br><br> The data can be compressed with gzip in order to save space.<br></html>", saver0.globalInfo());
      
      Filter filter1 = new Filter();
      assertNotNull(filter1);
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.getIgnoreRepaint());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isBusy());
      assertFalse(filter1.equals((Object)filter0));
      
      Enumeration enumeration0 = filter1.enumerateRequests();
      assertNotNull(enumeration0);
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.getIgnoreRepaint());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isBusy());
      assertFalse(filter1.equals((Object)filter0));
      assertNotSame(filter1, filter0);
      
      String string0 = filter1.getCustomName();
      assertEquals("AllFilter", string0);
      assertNotNull(string0);
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.getIgnoreRepaint());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isBusy());
      assertFalse(filter1.equals((Object)filter0));
      assertNotSame(filter1, filter0);
      
      ThreadGroup threadGroup0 = new ThreadGroup("h:{uZ");
      assertNotNull(threadGroup0);
      assertEquals("h:{uZ", threadGroup0.getName());
      
      MockThread mockThread0 = new MockThread(threadGroup0, "AllFilter");
      assertNotNull(mockThread0);
      assertEquals("h:{uZ", threadGroup0.getName());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      
      mockThread0.setUncaughtExceptionHandler(threadGroup0);
      assertEquals("h:{uZ", threadGroup0.getName());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      
      filter1.m_filterThread = (Thread) mockThread0;
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertTrue(filter1.isBusy());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.getIgnoreRepaint());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertEquals("h:{uZ", threadGroup0.getName());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertEquals(0, filter1.m_filterThread.countStackFrames());
      assertFalse(filter1.m_filterThread.isDaemon());
      assertFalse(filter1.m_filterThread.isInterrupted());
      
      Enumeration enumeration1 = filter1.enumerateRequests();
      assertNotNull(enumeration1);
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertTrue(filter1.isBusy());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.getIgnoreRepaint());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.equals((Object)filter0));
      assertFalse(enumeration1.equals((Object)enumeration0));
      assertNotSame(filter1, filter0);
      assertNotSame(enumeration1, enumeration0);
      
      String string1 = filter0.getCustomName();
      assertEquals("AllFilter", string1);
      assertNotNull(string1);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.equals((Object)filter1));
      assertTrue(string1.equals((Object)string0));
      assertNotSame(filter0, filter1);
      
      String string2 = DefaultEditorKit.selectionBeginLineAction;
      assertEquals("selection-begin-line", string2);
      assertNotNull(string2);
      assertFalse(string2.equals((Object)string1));
      assertFalse(string2.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      
      filter0.setOpaque(false);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.getIgnoreRepaint());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      
      Instances instances0 = appender0.m_completeHeader;
      assertNull(instances0);
      
      WordTokenizer wordTokenizer0 = new WordTokenizer();
      assertNotNull(wordTokenizer0);
      assertEquals("A simple tokenizer that is using the java.util.StringTokenizer class to tokenize the strings.", wordTokenizer0.globalInfo());
      assertEquals("Set of delimiter characters to use in tokenizing (\\r, \\n and \\t can be used for carriage-return, line-feed and tab)", wordTokenizer0.delimitersTipText());
      assertEquals(" \r\n\t.,;:'\"()?!", wordTokenizer0.getDelimiters());
      
      filter0.revalidate();
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      assertNotNull(trainTestSplitMaker0);
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      
      Insets insets0 = appender0.getInsets();
      assertNotNull(insets0);
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.getIgnoreRepaint());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertEquals(0, insets0.bottom);
      assertEquals(0, insets0.left);
      assertEquals(0, insets0.right);
      assertEquals(0, insets0.top);
      
      filter0.disconnectionNotification("@data", (Object) null);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      
      Filter filter1 = new Filter();
      assertNotNull(filter1);
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.equals((Object)filter0));
      
      AlphabeticTokenizer alphabeticTokenizer0 = new AlphabeticTokenizer();
      assertNotNull(alphabeticTokenizer0);
      assertEquals("Alphabetic string tokenizer, tokens are to be formed only from contiguous alphabetic sequences.", alphabeticTokenizer0.globalInfo());
      
      Appender appender1 = new Appender();
      assertNotNull(appender1);
      assertTrue(appender1.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender1.getCustomName());
      assertFalse(appender1.isFocusTraversalPolicyProvider());
      assertFalse(appender1.getIgnoreRepaint());
      assertFalse(appender1.isFocusTraversalPolicySet());
      assertFalse(appender1.isFocusCycleRoot());
      assertFalse(appender1.isBusy());
      assertFalse(appender1.equals((Object)appender0));
      
      Rectangle rectangle0 = new Rectangle(0, 0);
      assertNotNull(rectangle0);
      assertEquals(0.0, rectangle0.getWidth(), 0.01);
      assertEquals(0.0, rectangle0.getCenterY(), 0.01);
      assertTrue(rectangle0.isEmpty());
      assertEquals(0.0, rectangle0.getHeight(), 0.01);
      assertEquals(0.0, rectangle0.getMinX(), 0.01);
      assertEquals(0.0, rectangle0.getCenterX(), 0.01);
      assertEquals(0.0, rectangle0.getY(), 0.01);
      assertEquals(0.0, rectangle0.getMinY(), 0.01);
      assertEquals(0.0, rectangle0.getX(), 0.01);
      assertEquals(0.0, rectangle0.getMaxX(), 0.01);
      assertEquals(0.0, rectangle0.getMaxY(), 0.01);
      assertEquals(0, rectangle0.width);
      assertEquals(0, rectangle0.x);
      assertEquals(0, rectangle0.height);
      assertEquals(0, rectangle0.y);
      
      rectangle0.y = 0;
      assertEquals(0.0, rectangle0.getWidth(), 0.01);
      assertEquals(0.0, rectangle0.getCenterY(), 0.01);
      assertTrue(rectangle0.isEmpty());
      assertEquals(0.0, rectangle0.getHeight(), 0.01);
      assertEquals(0.0, rectangle0.getMinX(), 0.01);
      assertEquals(0.0, rectangle0.getCenterX(), 0.01);
      assertEquals(0.0, rectangle0.getY(), 0.01);
      assertEquals(0.0, rectangle0.getMinY(), 0.01);
      assertEquals(0.0, rectangle0.getX(), 0.01);
      assertEquals(0.0, rectangle0.getMaxX(), 0.01);
      assertEquals(0.0, rectangle0.getMaxY(), 0.01);
      
      filter1.setBounds(rectangle0);
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertEquals(0.0, rectangle0.getWidth(), 0.01);
      assertEquals(0.0, rectangle0.getCenterY(), 0.01);
      assertTrue(rectangle0.isEmpty());
      assertEquals(0.0, rectangle0.getHeight(), 0.01);
      assertEquals(0.0, rectangle0.getMinX(), 0.01);
      assertEquals(0.0, rectangle0.getCenterX(), 0.01);
      assertEquals(0.0, rectangle0.getY(), 0.01);
      assertEquals(0.0, rectangle0.getMinY(), 0.01);
      assertEquals(0.0, rectangle0.getX(), 0.01);
      assertEquals(0.0, rectangle0.getMaxX(), 0.01);
      assertEquals(0.0, rectangle0.getMaxY(), 0.01);
      assertFalse(filter1.equals((Object)filter0));
      assertEquals(0, rectangle0.width);
      assertEquals(0, rectangle0.x);
      assertEquals(0, rectangle0.height);
      assertEquals(0, rectangle0.y);
      assertNotSame(filter1, filter0);
      
      AccessibleContext accessibleContext0 = filter1.getAccessibleContext();
      assertNotNull(accessibleContext0);
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.equals((Object)filter0));
      assertNotSame(filter1, filter0);
      
      String string0 = filter1.getCustomName();
      assertEquals("AllFilter", string0);
      assertNotNull(string0);
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.equals((Object)filter0));
      assertNotSame(filter1, filter0);
      
      boolean boolean0 = filter0.connectionAllowed("h:{uZ");
      assertTrue(boolean0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.equals((Object)filter1));
      assertNotSame(filter0, filter1);
      
      ThreadGroup threadGroup0 = new ThreadGroup(".bsi");
      assertNotNull(threadGroup0);
      assertEquals(".bsi", threadGroup0.getName());
      
      MockThread mockThread0 = new MockThread(threadGroup0, "AllFilter");
      assertNotNull(mockThread0);
      assertEquals(".bsi", threadGroup0.getName());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      
      Map<Thread, StackTraceElement[]> map0 = MockThread.getAllStackTraces();
      assertNotNull(map0);
      assertEquals(19, map0.size());
      assertFalse(map0.isEmpty());
      
      filter1.m_filterThread = (Thread) mockThread0;
      assertEquals(".bsi", threadGroup0.getName());
      assertFalse(mockThread0.isDaemon());
      assertEquals(0, mockThread0.countStackFrames());
      assertFalse(mockThread0.isInterrupted());
      assertFalse(filter1.m_filterThread.isInterrupted());
      assertFalse(filter1.m_filterThread.isDaemon());
      assertEquals(0, filter1.m_filterThread.countStackFrames());
      assertTrue(filter1.isBusy());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      
      String string1 = filter1.getCustomName();
      assertEquals("AllFilter", string1);
      assertNotNull(string1);
      assertTrue(filter1.isBusy());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertFalse(filter1.equals((Object)filter0));
      assertNotSame(filter1, filter0);
      
      filter0.removeConfigurationListener((ConfigurationListener) null);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.equals((Object)filter1));
      assertNotSame(filter0, filter1);
      
      boolean boolean1 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean1);
      assertFalse(boolean1 == boolean0);
      
      boolean boolean2 = filter1.isBusy();
      assertTrue(boolean2);
      assertTrue(filter1.isBusy());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertTrue(boolean2 == boolean0);
      assertFalse(boolean2 == boolean1);
      assertFalse(filter1.equals((Object)filter0));
      assertNotSame(filter1, filter0);
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      
      MetaBean metaBean0 = new MetaBean();
      assertNotNull(metaBean0);
      assertFalse(metaBean0.isFocusTraversalPolicySet());
      assertFalse(metaBean0.isFocusCycleRoot());
      assertTrue(metaBean0.getFocusTraversalKeysEnabled());
      assertFalse(metaBean0.isFocusTraversalPolicyProvider());
      assertEquals("Group", metaBean0.getCustomName());
      assertFalse(metaBean0.getIgnoreRepaint());
      
      JToolTip jToolTip0 = filter0.createToolTip();
      assertNotNull(jToolTip0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(jToolTip0.isFocusCycleRoot());
      assertFalse(jToolTip0.isFocusTraversalPolicyProvider());
      assertFalse(jToolTip0.getIgnoreRepaint());
      assertFalse(jToolTip0.isFocusTraversalPolicySet());
      assertTrue(jToolTip0.getFocusTraversalKeysEnabled());
      
      Vector<AttributeSummarizer> vector0 = new Vector<AttributeSummarizer>();
      assertNotNull(vector0);
      assertTrue(vector0.isEmpty());
      assertEquals("[]", vector0.toString());
      assertEquals(0, vector0.size());
      assertEquals(10, vector0.capacity());
      
      Rectangle rectangle0 = new Rectangle((-3), 3167);
      assertNotNull(rectangle0);
      assertEquals(0.0, rectangle0.getMinX(), 0.01);
      assertTrue(rectangle0.isEmpty());
      assertEquals(0.0, rectangle0.getMinY(), 0.01);
      assertEquals(3167.0, rectangle0.getMaxY(), 0.01);
      assertEquals((-1.5), rectangle0.getCenterX(), 0.01);
      assertEquals(0.0, rectangle0.getX(), 0.01);
      assertEquals((-3.0), rectangle0.getMaxX(), 0.01);
      assertEquals(0.0, rectangle0.getY(), 0.01);
      assertEquals((-3.0), rectangle0.getWidth(), 0.01);
      assertEquals(3167.0, rectangle0.getHeight(), 0.01);
      assertEquals(1583.5, rectangle0.getCenterY(), 0.01);
      assertEquals((-3), rectangle0.width);
      assertEquals(0, rectangle0.y);
      assertEquals(0, rectangle0.x);
      assertEquals(3167, rectangle0.height);
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      ClustererPerformanceEvaluator clustererPerformanceEvaluator0 = new ClustererPerformanceEvaluator();
      assertNotNull(clustererPerformanceEvaluator0);
      assertFalse(clustererPerformanceEvaluator0.isFocusCycleRoot());
      assertFalse(clustererPerformanceEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals("Evaluate the performance of batch trained clusterers.", clustererPerformanceEvaluator0.globalInfo());
      assertEquals("ClustererPerformanceEvaluator", clustererPerformanceEvaluator0.getCustomName());
      assertFalse(clustererPerformanceEvaluator0.getIgnoreRepaint());
      assertFalse(clustererPerformanceEvaluator0.isFocusTraversalPolicySet());
      assertTrue(clustererPerformanceEvaluator0.getFocusTraversalKeysEnabled());
      assertFalse(clustererPerformanceEvaluator0.isBusy());
      
      TestSetEvent testSetEvent0 = new TestSetEvent(clustererPerformanceEvaluator0, (Instances) null, 3167, (-3), (-3), (-3));
      assertNotNull(testSetEvent0);
      assertFalse(clustererPerformanceEvaluator0.isFocusCycleRoot());
      assertFalse(clustererPerformanceEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals("Evaluate the performance of batch trained clusterers.", clustererPerformanceEvaluator0.globalInfo());
      assertEquals("ClustererPerformanceEvaluator", clustererPerformanceEvaluator0.getCustomName());
      assertFalse(clustererPerformanceEvaluator0.getIgnoreRepaint());
      assertFalse(clustererPerformanceEvaluator0.isFocusTraversalPolicySet());
      assertTrue(clustererPerformanceEvaluator0.getFocusTraversalKeysEnabled());
      assertFalse(clustererPerformanceEvaluator0.isBusy());
      assertEquals((-3), testSetEvent0.getSetNumber());
      assertFalse(testSetEvent0.isStructureOnly());
      assertEquals((-3), testSetEvent0.getMaxSetNumber());
      assertEquals(3167, testSetEvent0.getRunNumber());
      assertEquals((-3), testSetEvent0.getMaxRunNumber());
      
      Resample resample0 = new Resample();
      assertNotNull(resample0);
      assertEquals("The subsample size as a percentage of the original set.", resample0.sampleSizePercentTipText());
      assertEquals("Disables the replacement of instances.", resample0.noReplacementTipText());
      assertTrue(resample0.isNewBatch());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample0.globalInfo());
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample0.invertSelectionTipText());
      assertFalse(resample0.getNoReplacement());
      assertFalse(resample0.isFirstBatchDone());
      assertEquals(0.0, resample0.getBiasToUniformClass(), 0.01);
      assertFalse(resample0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample0.biasToUniformClassTipText());
      assertFalse(resample0.isOutputFormatDefined());
      assertEquals(100.0, resample0.getSampleSizePercent(), 0.01);
      assertEquals("Sets the random number seed for subsampling.", resample0.randomSeedTipText());
      assertFalse(resample0.getInvertSelection());
      assertEquals(1, resample0.getRandomSeed());
      
      Resample resample1 = (Resample)weka.filters.Filter.makeCopy(resample0);
      assertNotNull(resample1);
      assertEquals("The subsample size as a percentage of the original set.", resample0.sampleSizePercentTipText());
      assertEquals("Disables the replacement of instances.", resample0.noReplacementTipText());
      assertTrue(resample0.isNewBatch());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample0.globalInfo());
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample0.invertSelectionTipText());
      assertFalse(resample0.getNoReplacement());
      assertFalse(resample0.isFirstBatchDone());
      assertEquals(0.0, resample0.getBiasToUniformClass(), 0.01);
      assertFalse(resample0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample0.biasToUniformClassTipText());
      assertFalse(resample0.isOutputFormatDefined());
      assertEquals(100.0, resample0.getSampleSizePercent(), 0.01);
      assertEquals("Sets the random number seed for subsampling.", resample0.randomSeedTipText());
      assertFalse(resample0.getInvertSelection());
      assertEquals(1, resample0.getRandomSeed());
      assertEquals(1, resample1.getRandomSeed());
      assertEquals(0.0, resample1.getBiasToUniformClass(), 0.01);
      assertFalse(resample1.getNoReplacement());
      assertFalse(resample1.getInvertSelection());
      assertFalse(resample1.isFirstBatchDone());
      assertEquals("The subsample size as a percentage of the original set.", resample1.sampleSizePercentTipText());
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample1.biasToUniformClassTipText());
      assertTrue(resample1.isNewBatch());
      assertFalse(resample1.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Disables the replacement of instances.", resample1.noReplacementTipText());
      assertFalse(resample1.isOutputFormatDefined());
      assertEquals("Sets the random number seed for subsampling.", resample1.randomSeedTipText());
      assertEquals(100.0, resample1.getSampleSizePercent(), 0.01);
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample1.invertSelectionTipText());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample1.globalInfo());
      assertFalse(resample1.equals((Object)resample0));
      assertNotSame(resample0, resample1);
      assertNotSame(resample1, resample0);
      
      filter0.setFilter(resample1);
      assertEquals("Resample", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory</font><br><br> The number of instances in the generated dataset may be specified.<br>The dataset must have a nominal class attribute.<br>If not, use the unsupervised version.<br>The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution.<br>When used in batch mode (i.e.<br>in the FilteredClassifier), subsequent batches are NOT resampled.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("The subsample size as a percentage of the original set.", resample0.sampleSizePercentTipText());
      assertEquals("Disables the replacement of instances.", resample0.noReplacementTipText());
      assertTrue(resample0.isNewBatch());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample0.globalInfo());
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample0.invertSelectionTipText());
      assertFalse(resample0.getNoReplacement());
      assertFalse(resample0.isFirstBatchDone());
      assertEquals(0.0, resample0.getBiasToUniformClass(), 0.01);
      assertFalse(resample0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample0.biasToUniformClassTipText());
      assertFalse(resample0.isOutputFormatDefined());
      assertEquals(100.0, resample0.getSampleSizePercent(), 0.01);
      assertEquals("Sets the random number seed for subsampling.", resample0.randomSeedTipText());
      assertFalse(resample0.getInvertSelection());
      assertEquals(1, resample0.getRandomSeed());
      assertEquals(1, resample1.getRandomSeed());
      assertEquals(0.0, resample1.getBiasToUniformClass(), 0.01);
      assertFalse(resample1.getNoReplacement());
      assertFalse(resample1.getInvertSelection());
      assertFalse(resample1.isFirstBatchDone());
      assertEquals("The subsample size as a percentage of the original set.", resample1.sampleSizePercentTipText());
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample1.biasToUniformClassTipText());
      assertTrue(resample1.isNewBatch());
      assertFalse(resample1.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Disables the replacement of instances.", resample1.noReplacementTipText());
      assertFalse(resample1.isOutputFormatDefined());
      assertEquals("Sets the random number seed for subsampling.", resample1.randomSeedTipText());
      assertEquals(100.0, resample1.getSampleSizePercent(), 0.01);
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample1.invertSelectionTipText());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample1.globalInfo());
      assertFalse(resample0.equals((Object)resample1));
      assertFalse(resample1.equals((Object)resample0));
      assertNotSame(resample0, resample1);
      assertNotSame(resample1, resample0);
      
      FlowByExpression flowByExpression0 = new FlowByExpression();
      assertNotNull(flowByExpression0);
      assertFalse(flowByExpression0.isBusy());
      assertEquals("", flowByExpression0.getExpressionString());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      
      SerializedModelSaver serializedModelSaver0 = new SerializedModelSaver();
      assertNotNull(serializedModelSaver0);
      assertEquals("", serializedModelSaver0.getPrefix());
      assertFalse(serializedModelSaver0.getIncludeRelationName());
      assertEquals("Save trained models to serialized object files.", serializedModelSaver0.globalInfo());
      assertFalse(serializedModelSaver0.isBusy());
      assertFalse(serializedModelSaver0.isFocusCycleRoot());
      assertFalse(serializedModelSaver0.isFocusTraversalPolicyProvider());
      assertFalse(serializedModelSaver0.getUseRelativePath());
      assertFalse(serializedModelSaver0.getIgnoreRepaint());
      assertEquals("SerializedModelSaver", serializedModelSaver0.getCustomName());
      assertTrue(serializedModelSaver0.getFocusTraversalKeysEnabled());
      assertFalse(serializedModelSaver0.isFocusTraversalPolicySet());
      assertEquals(2, SerializedModelSaver.XSTREAM);
      assertEquals(1, SerializedModelSaver.KOMLV);
      assertEquals(0, SerializedModelSaver.BINARY);
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(serializedModelSaver0, (Instances) null, 3167, 0, 0, 0);
      assertNotNull(trainingSetEvent0);
      assertEquals("", serializedModelSaver0.getPrefix());
      assertFalse(serializedModelSaver0.getIncludeRelationName());
      assertEquals("Save trained models to serialized object files.", serializedModelSaver0.globalInfo());
      assertFalse(serializedModelSaver0.isBusy());
      assertFalse(serializedModelSaver0.isFocusCycleRoot());
      assertFalse(serializedModelSaver0.isFocusTraversalPolicyProvider());
      assertFalse(serializedModelSaver0.getUseRelativePath());
      assertFalse(serializedModelSaver0.getIgnoreRepaint());
      assertEquals("SerializedModelSaver", serializedModelSaver0.getCustomName());
      assertTrue(serializedModelSaver0.getFocusTraversalKeysEnabled());
      assertFalse(serializedModelSaver0.isFocusTraversalPolicySet());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(0, trainingSetEvent0.getMaxRunNumber());
      assertFalse(trainingSetEvent0.isStructureOnly());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(3167, trainingSetEvent0.getRunNumber());
      assertEquals(2, SerializedModelSaver.XSTREAM);
      assertEquals(1, SerializedModelSaver.KOMLV);
      assertEquals(0, SerializedModelSaver.BINARY);
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertEquals("Resample", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory</font><br><br> The number of instances in the generated dataset may be specified.<br>The dataset must have a nominal class attribute.<br>If not, use the unsupervised version.<br>The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution.<br>When used in batch mode (i.e.<br>in the FilteredClassifier), subsequent batches are NOT resampled.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("", serializedModelSaver0.getPrefix());
      assertFalse(serializedModelSaver0.getIncludeRelationName());
      assertEquals("Save trained models to serialized object files.", serializedModelSaver0.globalInfo());
      assertFalse(serializedModelSaver0.isBusy());
      assertFalse(serializedModelSaver0.isFocusCycleRoot());
      assertFalse(serializedModelSaver0.isFocusTraversalPolicyProvider());
      assertFalse(serializedModelSaver0.getUseRelativePath());
      assertFalse(serializedModelSaver0.getIgnoreRepaint());
      assertEquals("SerializedModelSaver", serializedModelSaver0.getCustomName());
      assertTrue(serializedModelSaver0.getFocusTraversalKeysEnabled());
      assertFalse(serializedModelSaver0.isFocusTraversalPolicySet());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(0, trainingSetEvent0.getMaxRunNumber());
      assertFalse(trainingSetEvent0.isStructureOnly());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(3167, trainingSetEvent0.getRunNumber());
      assertEquals(2, SerializedModelSaver.XSTREAM);
      assertEquals(1, SerializedModelSaver.KOMLV);
      assertEquals(0, SerializedModelSaver.BINARY);
      
      String string0 = "weka/gui/beans/icons/DefaultFilter.gif";
      // Undeclared exception!
      try { 
        filter0.performRequest("weka/gui/beans/icons/DefaultFilter.gif");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // weka/gui/beans/icons/DefaultFilter.gif not supported (Filter)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      
      MetaBean metaBean0 = new MetaBean();
      assertNotNull(metaBean0);
      assertTrue(metaBean0.getFocusTraversalKeysEnabled());
      assertFalse(metaBean0.isFocusTraversalPolicySet());
      assertFalse(metaBean0.getIgnoreRepaint());
      assertFalse(metaBean0.isFocusCycleRoot());
      assertEquals("Group", metaBean0.getCustomName());
      assertFalse(metaBean0.isFocusTraversalPolicyProvider());
      
      Rectangle rectangle0 = filter0.getBounds();
      assertNotNull(rectangle0);
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals(0.0, rectangle0.getHeight(), 0.01);
      assertEquals(0.0, rectangle0.getMaxY(), 0.01);
      assertTrue(rectangle0.isEmpty());
      assertEquals(0.0, rectangle0.getWidth(), 0.01);
      assertEquals(0.0, rectangle0.getCenterY(), 0.01);
      assertEquals(0.0, rectangle0.getMinY(), 0.01);
      assertEquals(0.0, rectangle0.getY(), 0.01);
      assertEquals(0.0, rectangle0.getCenterX(), 0.01);
      assertEquals(0.0, rectangle0.getMaxX(), 0.01);
      assertEquals(0.0, rectangle0.getMinX(), 0.01);
      assertEquals(0.0, rectangle0.getX(), 0.01);
      assertEquals(0, rectangle0.height);
      assertEquals(0, rectangle0.width);
      assertEquals(0, rectangle0.x);
      assertEquals(0, rectangle0.y);
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      boolean boolean1 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean1);
      assertFalse(boolean1 == boolean0);
      
      boolean boolean2 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean2);
      assertTrue(boolean2 == boolean1);
      assertFalse(boolean2 == boolean0);
      
      PredictionAppender predictionAppender0 = new PredictionAppender();
      assertNotNull(predictionAppender0);
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertFalse(predictionAppender0.isBusy());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      assertFalse(predictionAppender0.isFocusCycleRoot());
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      
      InstanceEvent instanceEvent0 = predictionAppender0.m_instanceEvent;
      assertNull(instanceEvent0);
      
      boolean boolean3 = FileSystemHandling.setPermissions((EvoSuiteFile) null, true, false, false);
      assertFalse(boolean3);
      assertFalse(boolean3 == boolean0);
      assertTrue(boolean3 == boolean1);
      assertTrue(boolean3 == boolean2);
      
      filter0.acceptInstance((InstanceEvent) null);
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      
      Enumeration enumeration0 = filter0.enumerateRequests();
      assertNotNull(enumeration0);
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertTrue(multiFilter0.isNewBatch());
      
      filter0.setWrappedAlgorithm(multiFilter0);
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertTrue(multiFilter0.isNewBatch());
      
      Sorter sorter0 = new Sorter();
      assertNotNull(sorter0);
      assertEquals("10000", sorter0.getBufferSize());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusCycleRoot());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isBusy());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("Sorter", sorter0.getCustomName());
      
      sorter0.computeVisibleRect(rectangle0);
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals(0.0, rectangle0.getHeight(), 0.01);
      assertEquals(0.0, rectangle0.getMaxY(), 0.01);
      assertTrue(rectangle0.isEmpty());
      assertEquals(0.0, rectangle0.getWidth(), 0.01);
      assertEquals(0.0, rectangle0.getCenterY(), 0.01);
      assertEquals(0.0, rectangle0.getMinY(), 0.01);
      assertEquals(0.0, rectangle0.getY(), 0.01);
      assertEquals(0.0, rectangle0.getCenterX(), 0.01);
      assertEquals(0.0, rectangle0.getMaxX(), 0.01);
      assertEquals(0.0, rectangle0.getMinX(), 0.01);
      assertEquals(0.0, rectangle0.getX(), 0.01);
      assertEquals("10000", sorter0.getBufferSize());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusCycleRoot());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isBusy());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("Sorter", sorter0.getCustomName());
      assertEquals(0, rectangle0.height);
      assertEquals(0, rectangle0.width);
      assertEquals(0, rectangle0.x);
      assertEquals(0, rectangle0.y);
      
      filter0.addDataSourceListener(sorter0);
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("10000", sorter0.getBufferSize());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusCycleRoot());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isBusy());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("Sorter", sorter0.getCustomName());
      
      // Undeclared exception!
      try { 
        filter0.acceptInstance((InstanceEvent) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      MetaBean metaBean0 = new MetaBean();
      assertNotNull(metaBean0);
      assertFalse(metaBean0.isFocusTraversalPolicyProvider());
      assertFalse(metaBean0.isFocusCycleRoot());
      assertTrue(metaBean0.getFocusTraversalKeysEnabled());
      assertEquals("Group", metaBean0.getCustomName());
      assertFalse(metaBean0.getIgnoreRepaint());
      assertFalse(metaBean0.isFocusTraversalPolicySet());
      
      Rectangle rectangle0 = filter0.getBounds();
      assertNotNull(rectangle0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals(0.0, rectangle0.getMinX(), 0.01);
      assertEquals(0.0, rectangle0.getCenterX(), 0.01);
      assertTrue(rectangle0.isEmpty());
      assertEquals(0.0, rectangle0.getMinY(), 0.01);
      assertEquals(0.0, rectangle0.getMaxX(), 0.01);
      assertEquals(0.0, rectangle0.getMaxY(), 0.01);
      assertEquals(0.0, rectangle0.getWidth(), 0.01);
      assertEquals(0.0, rectangle0.getX(), 0.01);
      assertEquals(0.0, rectangle0.getHeight(), 0.01);
      assertEquals(0.0, rectangle0.getY(), 0.01);
      assertEquals(0.0, rectangle0.getCenterY(), 0.01);
      assertEquals(0, rectangle0.y);
      assertEquals(0, rectangle0.x);
      assertEquals(0, rectangle0.width);
      assertEquals(0, rectangle0.height);
      
      boolean boolean0 = rectangle0.contains(1201.785, 1201.785, 0.0, 1201.785);
      assertFalse(boolean0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals(0.0, rectangle0.getMinX(), 0.01);
      assertEquals(0.0, rectangle0.getCenterX(), 0.01);
      assertTrue(rectangle0.isEmpty());
      assertEquals(0.0, rectangle0.getMinY(), 0.01);
      assertEquals(0.0, rectangle0.getMaxX(), 0.01);
      assertEquals(0.0, rectangle0.getMaxY(), 0.01);
      assertEquals(0.0, rectangle0.getWidth(), 0.01);
      assertEquals(0.0, rectangle0.getX(), 0.01);
      assertEquals(0.0, rectangle0.getHeight(), 0.01);
      assertEquals(0.0, rectangle0.getY(), 0.01);
      assertEquals(0.0, rectangle0.getCenterY(), 0.01);
      assertEquals(0, rectangle0.y);
      assertEquals(0, rectangle0.x);
      assertEquals(0, rectangle0.width);
      assertEquals(0, rectangle0.height);
      
      TextViewer textViewer0 = new TextViewer();
      assertNotNull(textViewer0);
      assertFalse(textViewer0.getIgnoreRepaint());
      assertTrue(textViewer0.getFocusTraversalKeysEnabled());
      assertFalse(textViewer0.isBusy());
      assertEquals("General purpose text display.", textViewer0.globalInfo());
      assertFalse(textViewer0.isFocusCycleRoot());
      assertFalse(textViewer0.isFocusTraversalPolicySet());
      assertFalse(textViewer0.isFocusTraversalPolicyProvider());
      
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      assertNotNull(inputMappedClassifier0);
      assertTrue(inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals("The base classifier to be used.", inputMappedClassifier0.classifierTipText());
      assertTrue(inputMappedClassifier0.getTrim());
      assertEquals("Don't output a report of model-to-input mappings.", inputMappedClassifier0.suppressMappingReportTipText());
      assertEquals("If set to true, classifier may output additional info to the console.", inputMappedClassifier0.debugTipText());
      assertEquals("", inputMappedClassifier0.getModelPath());
      assertEquals("Ignore case when matching attribute names and nomina values.", inputMappedClassifier0.ignoreCaseForNamesTipText());
      assertFalse(inputMappedClassifier0.getDebug());
      assertEquals(0, inputMappedClassifier0.graphType());
      assertEquals("Set the path from which to load a model. Loading occurs when the first test instance is received. Environment variables can be used in the supplied path.", inputMappedClassifier0.modelPathTipText());
      assertEquals("Trim white space from each end of attribute names and nominal values before matching.", inputMappedClassifier0.trimTipText());
      assertEquals("Wrapper classifier that addresses incompatible training and test data by building a mapping between the training data that a classifier has been built with and the incoming test instances' structure. Model attributes that are not found in the incoming instances receive missing values, so do incoming nominal attribute values that the classifier has not seen before. A new classifier can be trained or an existing one loaded from a file.", inputMappedClassifier0.globalInfo());
      assertFalse(inputMappedClassifier0.getSuppressMappingReport());
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      
      boolean boolean1 = FileSystemHandling.appendLineToFile((EvoSuiteFile) null, (String) null);
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
      
      filter0.addDataSourceListener(textViewer0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(textViewer0.getIgnoreRepaint());
      assertTrue(textViewer0.getFocusTraversalKeysEnabled());
      assertFalse(textViewer0.isBusy());
      assertEquals("General purpose text display.", textViewer0.globalInfo());
      assertFalse(textViewer0.isFocusCycleRoot());
      assertFalse(textViewer0.isFocusTraversalPolicySet());
      assertFalse(textViewer0.isFocusTraversalPolicyProvider());
      
      ScatterPlotMatrix scatterPlotMatrix0 = new ScatterPlotMatrix();
      assertNotNull(scatterPlotMatrix0);
      assertEquals("400", scatterPlotMatrix0.getOffscreenHeight());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicyProvider());
      assertEquals("Visualize incoming data/training/test sets in a scatter plot matrix.", scatterPlotMatrix0.globalInfo());
      assertEquals("DataVisualizer", scatterPlotMatrix0.getCustomName());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTitle());
      assertEquals("", scatterPlotMatrix0.getOffscreenXAxis());
      assertTrue(scatterPlotMatrix0.getFocusTraversalKeysEnabled());
      assertFalse(scatterPlotMatrix0.isFocusCycleRoot());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTipText());
      assertEquals("", scatterPlotMatrix0.getOffscreenYAxis());
      assertEquals("", scatterPlotMatrix0.getOffscreenAdditionalOpts());
      assertEquals("Weka Chart Renderer", scatterPlotMatrix0.getOffscreenRendererName());
      assertTrue(scatterPlotMatrix0.acceptsInstances());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicySet());
      assertFalse(scatterPlotMatrix0.isBusy());
      assertFalse(scatterPlotMatrix0.getIgnoreRepaint());
      assertEquals("500", scatterPlotMatrix0.getOffscreenWidth());
      
      DataSetEvent dataSetEvent0 = new DataSetEvent(metaBean0, instances0);
      assertNotNull(dataSetEvent0);
      assertFalse(metaBean0.isFocusTraversalPolicyProvider());
      assertFalse(metaBean0.isFocusCycleRoot());
      assertTrue(metaBean0.getFocusTraversalKeysEnabled());
      assertEquals("Group", metaBean0.getCustomName());
      assertFalse(metaBean0.getIgnoreRepaint());
      assertFalse(metaBean0.isFocusTraversalPolicySet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertTrue(dataSetEvent0.isStructureOnly());
      
      filter0.acceptDataSet(dataSetEvent0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(metaBean0.isFocusTraversalPolicyProvider());
      assertFalse(metaBean0.isFocusCycleRoot());
      assertTrue(metaBean0.getFocusTraversalKeysEnabled());
      assertEquals("Group", metaBean0.getCustomName());
      assertFalse(metaBean0.getIgnoreRepaint());
      assertFalse(metaBean0.isFocusTraversalPolicySet());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertTrue(dataSetEvent0.isStructureOnly());
      
      BeanVisual beanVisual0 = filter0.getVisual();
      assertNotNull(beanVisual0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(beanVisual0.getIgnoreRepaint());
      assertEquals("weka/gui/beans/icons/DefaultFilter.gif", beanVisual0.getIconPath());
      assertTrue(beanVisual0.getFocusTraversalKeysEnabled());
      assertFalse(beanVisual0.isFocusCycleRoot());
      assertEquals("weka/gui/beans/icons/DefaultFilter_animated.gif", beanVisual0.getAnimatedIconPath());
      assertFalse(beanVisual0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", beanVisual0.getText());
      assertFalse(beanVisual0.isFocusTraversalPolicyProvider());
      assertEquals(2, BeanVisual.EAST_CONNECTOR);
      assertEquals(3, BeanVisual.WEST_CONNECTOR);
      assertEquals(1, BeanVisual.SOUTH_CONNECTOR);
      assertEquals(0, BeanVisual.NORTH_CONNECTOR);
      
      // Undeclared exception!
      try { 
        filter0.performRequest("Uia_bp>O]");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Uia_bp>O] not supported (Filter)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      
      ScatterPlotMatrix scatterPlotMatrix0 = new ScatterPlotMatrix();
      assertNotNull(scatterPlotMatrix0);
      assertEquals("DataVisualizer", scatterPlotMatrix0.getCustomName());
      assertFalse(scatterPlotMatrix0.isFocusCycleRoot());
      assertEquals("", scatterPlotMatrix0.getOffscreenXAxis());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTitle());
      assertEquals("", scatterPlotMatrix0.getOffscreenAdditionalOpts());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicyProvider());
      assertEquals("500", scatterPlotMatrix0.getOffscreenWidth());
      assertFalse(scatterPlotMatrix0.getIgnoreRepaint());
      assertTrue(scatterPlotMatrix0.acceptsInstances());
      assertFalse(scatterPlotMatrix0.isBusy());
      assertTrue(scatterPlotMatrix0.getFocusTraversalKeysEnabled());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTipText());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicySet());
      assertEquals("400", scatterPlotMatrix0.getOffscreenHeight());
      assertEquals("Visualize incoming data/training/test sets in a scatter plot matrix.", scatterPlotMatrix0.globalInfo());
      assertEquals("Weka Chart Renderer", scatterPlotMatrix0.getOffscreenRendererName());
      assertEquals("", scatterPlotMatrix0.getOffscreenYAxis());
      
      filter0.connectionNotification("testSet", scatterPlotMatrix0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("DataVisualizer", scatterPlotMatrix0.getCustomName());
      assertFalse(scatterPlotMatrix0.isFocusCycleRoot());
      assertEquals("", scatterPlotMatrix0.getOffscreenXAxis());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTitle());
      assertEquals("", scatterPlotMatrix0.getOffscreenAdditionalOpts());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicyProvider());
      assertEquals("500", scatterPlotMatrix0.getOffscreenWidth());
      assertFalse(scatterPlotMatrix0.getIgnoreRepaint());
      assertTrue(scatterPlotMatrix0.acceptsInstances());
      assertFalse(scatterPlotMatrix0.isBusy());
      assertTrue(scatterPlotMatrix0.getFocusTraversalKeysEnabled());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTipText());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicySet());
      assertEquals("400", scatterPlotMatrix0.getOffscreenHeight());
      assertEquals("Visualize incoming data/training/test sets in a scatter plot matrix.", scatterPlotMatrix0.globalInfo());
      assertEquals("Weka Chart Renderer", scatterPlotMatrix0.getOffscreenRendererName());
      assertEquals("", scatterPlotMatrix0.getOffscreenYAxis());
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      boolean boolean1 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean1);
      assertFalse(boolean1 == boolean0);
      
      boolean boolean2 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean2);
      assertFalse(boolean2 == boolean0);
      assertTrue(boolean2 == boolean1);
      
      PredictionAppender predictionAppender0 = new PredictionAppender();
      assertNotNull(predictionAppender0);
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertFalse(predictionAppender0.isFocusCycleRoot());
      assertFalse(predictionAppender0.isBusy());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      
      InstanceEvent instanceEvent0 = predictionAppender0.m_instanceEvent;
      assertNull(instanceEvent0);
      
      StyleContext styleContext0 = StyleContext.getDefaultStyleContext();
      assertNotNull(styleContext0);
      
      Font font0 = Font.getFont("testSet");
      assertNull(font0);
      
      filter0.connectionNotification("testSet", (Object) null);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      
      Loader loader0 = new Loader();
      assertNotNull(loader0);
      assertFalse(loader0.getIgnoreRepaint());
      assertFalse(loader0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Reads a source that is in arff (attribute relation file format) format</font> <br></html>", loader0.globalInfo());
      assertFalse(loader0.isFocusTraversalPolicySet());
      assertFalse(loader0.isFocusCycleRoot());
      assertEquals("ArffLoader", loader0.getCustomName());
      assertFalse(loader0.isBusy());
      assertTrue(loader0.getFocusTraversalKeysEnabled());
      
      BeanVisual beanVisual0 = loader0.m_visual;
      assertNotNull(beanVisual0);
      assertFalse(beanVisual0.isFocusTraversalPolicySet());
      assertFalse(beanVisual0.isFocusCycleRoot());
      assertEquals("ArffLoader", beanVisual0.getText());
      assertTrue(beanVisual0.getFocusTraversalKeysEnabled());
      assertFalse(beanVisual0.getIgnoreRepaint());
      assertEquals("weka/gui/beans/icons/DefaultDataSource.gif", beanVisual0.getIconPath());
      assertFalse(beanVisual0.isFocusTraversalPolicyProvider());
      assertEquals("weka/gui/beans/icons/DefaultDataSource_animated.gif", beanVisual0.getAnimatedIconPath());
      assertEquals(2, BeanVisual.EAST_CONNECTOR);
      assertEquals(3, BeanVisual.WEST_CONNECTOR);
      assertEquals(1, BeanVisual.SOUTH_CONNECTOR);
      assertEquals(0, BeanVisual.NORTH_CONNECTOR);
      
      Random.setNextRandom((-1195));
      PredictionAppender predictionAppender1 = new PredictionAppender();
      assertNotNull(predictionAppender1);
      assertFalse(predictionAppender1.getIgnoreRepaint());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender1.globalInfo());
      assertFalse(predictionAppender1.getAppendPredictedProbabilities());
      assertTrue(predictionAppender1.getFocusTraversalKeysEnabled());
      assertFalse(predictionAppender1.isFocusTraversalPolicySet());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender1.appendPredictedProbabilitiesTipText());
      assertFalse(predictionAppender1.isBusy());
      assertEquals("PredictionAppender", predictionAppender1.getCustomName());
      assertFalse(predictionAppender1.isFocusCycleRoot());
      assertFalse(predictionAppender1.isFocusTraversalPolicyProvider());
      assertFalse(predictionAppender1.equals((Object)predictionAppender0));
      
      InstanceEvent instanceEvent1 = predictionAppender1.m_instanceEvent;
      assertNull(instanceEvent1);
      
      filter0.notifyInstanceListeners((InstanceEvent) null);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      
      boolean boolean3 = FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, true);
      assertFalse(boolean3);
      assertFalse(boolean3 == boolean0);
      assertTrue(boolean3 == boolean1);
      assertTrue(boolean3 == boolean2);
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      filter0.addConfigurationListener(configurationListener0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      
      String string0 = filter0.globalInfo();
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", string0);
      assertNotNull(string0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      filter0.requestFocus();
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      ScatterPlotMatrix scatterPlotMatrix0 = new ScatterPlotMatrix();
      assertNotNull(scatterPlotMatrix0);
      assertEquals("", scatterPlotMatrix0.getOffscreenXAxis());
      assertTrue(scatterPlotMatrix0.getFocusTraversalKeysEnabled());
      assertEquals("Visualize incoming data/training/test sets in a scatter plot matrix.", scatterPlotMatrix0.globalInfo());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicyProvider());
      assertFalse(scatterPlotMatrix0.isFocusCycleRoot());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTitle());
      assertEquals("", scatterPlotMatrix0.getOffscreenAdditionalOpts());
      assertEquals("", scatterPlotMatrix0.getOffscreenYAxis());
      assertFalse(scatterPlotMatrix0.isBusy());
      assertEquals("Weka Chart Renderer", scatterPlotMatrix0.getOffscreenRendererName());
      assertEquals("400", scatterPlotMatrix0.getOffscreenHeight());
      assertEquals("DataVisualizer", scatterPlotMatrix0.getCustomName());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTipText());
      assertFalse(scatterPlotMatrix0.getIgnoreRepaint());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicySet());
      assertEquals("500", scatterPlotMatrix0.getOffscreenWidth());
      assertTrue(scatterPlotMatrix0.acceptsInstances());
      
      filter0.connectionNotification("testSet", scatterPlotMatrix0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("", scatterPlotMatrix0.getOffscreenXAxis());
      assertTrue(scatterPlotMatrix0.getFocusTraversalKeysEnabled());
      assertEquals("Visualize incoming data/training/test sets in a scatter plot matrix.", scatterPlotMatrix0.globalInfo());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicyProvider());
      assertFalse(scatterPlotMatrix0.isFocusCycleRoot());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTitle());
      assertEquals("", scatterPlotMatrix0.getOffscreenAdditionalOpts());
      assertEquals("", scatterPlotMatrix0.getOffscreenYAxis());
      assertFalse(scatterPlotMatrix0.isBusy());
      assertEquals("Weka Chart Renderer", scatterPlotMatrix0.getOffscreenRendererName());
      assertEquals("400", scatterPlotMatrix0.getOffscreenHeight());
      assertEquals("DataVisualizer", scatterPlotMatrix0.getCustomName());
      assertEquals("Scatter plot matrix", scatterPlotMatrix0.getPerspectiveTipText());
      assertFalse(scatterPlotMatrix0.getIgnoreRepaint());
      assertFalse(scatterPlotMatrix0.isFocusTraversalPolicySet());
      assertEquals("500", scatterPlotMatrix0.getOffscreenWidth());
      assertTrue(scatterPlotMatrix0.acceptsInstances());
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      boolean boolean1 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean1);
      assertFalse(boolean1 == boolean0);
      
      boolean boolean2 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean2);
      assertTrue(boolean2 == boolean1);
      assertFalse(boolean2 == boolean0);
      
      TestSetMaker testSetMaker0 = new TestSetMaker();
      assertNotNull(testSetMaker0);
      assertTrue(testSetMaker0.getFocusTraversalKeysEnabled());
      assertFalse(testSetMaker0.isFocusTraversalPolicySet());
      assertFalse(testSetMaker0.isFocusCycleRoot());
      assertFalse(testSetMaker0.isBusy());
      assertEquals("Designate an incoming data set as a test set.", testSetMaker0.globalInfo());
      assertFalse(testSetMaker0.isFocusTraversalPolicyProvider());
      assertFalse(testSetMaker0.getIgnoreRepaint());
      assertEquals("TestSetMaker", testSetMaker0.getCustomName());
      
      AllFilter allFilter0 = new AllFilter();
      assertNotNull(allFilter0);
      assertFalse(allFilter0.isOutputFormatDefined());
      assertFalse(allFilter0.isFirstBatchDone());
      assertFalse(allFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(allFilter0.isNewBatch());
      assertEquals("An instance filter that passes all instances through unmodified. Primarily for testing purposes.", allFilter0.globalInfo());
      
      FlowByExpression.ExpressionClause.ExpressionType flowByExpression_ExpressionClause_ExpressionType0 = FlowByExpression.ExpressionClause.ExpressionType.GREATERTHAN;
      SpreadSubsample spreadSubsample0 = new SpreadSubsample();
      assertNotNull(spreadSubsample0);
      assertFalse(spreadSubsample0.isOutputFormatDefined());
      assertEquals(0.0, spreadSubsample0.getMaxCount(), 0.01);
      assertEquals("Wether instance weights will be adjusted to maintain total weight per class.", spreadSubsample0.adjustWeightsTipText());
      assertEquals("The maximum count for any class value (0 = unlimited).", spreadSubsample0.maxCountTipText());
      assertFalse(spreadSubsample0.getAdjustWeights());
      assertEquals(0.0, spreadSubsample0.getDistributionSpread(), 0.01);
      assertEquals("The maximum class distribution spread. (0 = no maximum spread, 1 = uniform distribution, 10 = allow at most a 10:1 ratio between the classes).", spreadSubsample0.distributionSpreadTipText());
      assertEquals("Produces a random subsample of a dataset. The original dataset must fit entirely in memory. This filter allows you to specify the maximum \"spread\" between the rarest and most common class. For example, you may specify that there be at most a 2:1 difference in class frequencies. When used in batch mode, subsequent batches are NOT resampled.", spreadSubsample0.globalInfo());
      assertEquals(1, spreadSubsample0.getRandomSeed());
      assertTrue(spreadSubsample0.isNewBatch());
      assertEquals("Sets the random number seed for subsampling.", spreadSubsample0.randomSeedTipText());
      assertFalse(spreadSubsample0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(spreadSubsample0.isFirstBatchDone());
      
      filter0.connectionNotification("ZUia_bp>O]", flowByExpression_ExpressionClause_ExpressionType0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      weka.gui.LogPanel logPanel0 = new weka.gui.LogPanel();
      assertNotNull(logPanel0);
      assertFalse(logPanel0.getIgnoreRepaint());
      assertTrue(logPanel0.getFocusTraversalKeysEnabled());
      assertFalse(logPanel0.isFocusTraversalPolicySet());
      assertFalse(logPanel0.isFocusCycleRoot());
      assertFalse(logPanel0.isFocusTraversalPolicyProvider());
      
      GraphicsConfiguration graphicsConfiguration0 = filter0.getGraphicsConfiguration();
      assertNull(graphicsConfiguration0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      filter0.setLog(logPanel0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(logPanel0.getIgnoreRepaint());
      assertTrue(logPanel0.getFocusTraversalKeysEnabled());
      assertFalse(logPanel0.isFocusTraversalPolicySet());
      assertFalse(logPanel0.isFocusCycleRoot());
      assertFalse(logPanel0.isFocusTraversalPolicyProvider());
      
      AttributeSelection attributeSelection0 = new AttributeSelection();
      assertNotNull(attributeSelection0);
      assertEquals("A supervised attribute filter that can be used to select attributes. It is very flexible and allows various search and evaluation methods to be combined.", attributeSelection0.globalInfo());
      assertEquals("Determines the search method.", attributeSelection0.searchTipText());
      assertFalse(attributeSelection0.isFirstBatchDone());
      assertTrue(attributeSelection0.isNewBatch());
      assertFalse(attributeSelection0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Determines how attributes/attribute subsets are evaluated.", attributeSelection0.evaluatorTipText());
      assertFalse(attributeSelection0.isOutputFormatDefined());
      
      boolean boolean3 = filter0.eventGeneratable("testSet");
      assertFalse(boolean3);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(boolean3 == boolean0);
      assertTrue(boolean3 == boolean2);
      assertTrue(boolean3 == boolean1);
      
      MatlabLoader matlabLoader0 = new MatlabLoader();
      assertNotNull(matlabLoader0);
      assertFalse(matlabLoader0.getUseRelativePath());
      assertEquals("Use relative rather than absolute paths", matlabLoader0.useRelativePathTipText());
      assertEquals("Matlab ASCII files", matlabLoader0.getFileDescription());
      assertEquals("http://", matlabLoader0.retrieveURL());
      assertEquals("Reads a Matlab file containing a single matrix in ASCII format.", matlabLoader0.globalInfo());
      assertEquals(".m", matlabLoader0.getFileExtension());
      
      Clusterer clusterer0 = new Clusterer();
      assertNotNull(clusterer0);
      assertFalse(clusterer0.getIgnoreRepaint());
      assertTrue(clusterer0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Simple EM (expectation maximisation) class.\n\nEM assigns a probability distribution to each instance which indicates the probability of it belonging to each of the clusters</font><br><br> EM can decide how many clusters to create by cross validation, or you may specify apriori how many clusters to generate.<br><br>The cross validation performed to determine the number of clusters is done in the following steps:<br>1. the number of clusters is set to 1<br>2. the training set is split randomly into 10 folds.<br>3. EM is performed 10 times using the 10 folds the usual CV way.<br>4. the loglikelihood is averaged over all 10 results.<br>5.<br>if loglikelihood has increased the number of clusters is increased by 1 and the program continues at step 2.<br><br><br>The number of folds is fixed to 10, as long as the number of instances in the training set is not smaller 10.<br>If this is the case the number of folds is set equal to the number of instances.<br></html>", clusterer0.globalInfo());
      assertEquals("EM", clusterer0.getCustomName());
      assertFalse(clusterer0.isFocusTraversalPolicySet());
      assertFalse(clusterer0.hasIncomingBatchInstances());
      assertFalse(clusterer0.isBusy());
      assertFalse(clusterer0.isFocusTraversalPolicyProvider());
      assertFalse(clusterer0.isFocusCycleRoot());
      
      try { 
        matlabLoader0.getStructure();
        fail("Expecting exception: IOException");
      
      } catch(IOException e) {
         //
         // No source has been specified
         //
         verifyException("weka.core.converters.MatlabLoader", e);
      }
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      byte[] byteArray0 = new byte[2];
      byteArray0[0] = (byte) (-1);
      byteArray0[1] = (byte) (-3);
      boolean boolean0 = FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      assertFalse(boolean0);
      assertArrayEquals(new byte[] {(byte) (-1), (byte) (-3)}, byteArray0);
      
      Loader loader0 = new Loader();
      assertNotNull(loader0);
      assertFalse(loader0.isFocusCycleRoot());
      assertFalse(loader0.isFocusTraversalPolicySet());
      assertFalse(loader0.isFocusTraversalPolicyProvider());
      assertFalse(loader0.isBusy());
      assertEquals("ArffLoader", loader0.getCustomName());
      assertTrue(loader0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Reads a source that is in arff (attribute relation file format) format</font> <br></html>", loader0.globalInfo());
      assertFalse(loader0.getIgnoreRepaint());
      
      filter0.connectionNotification("Y[)pW*4X", loader0);
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(loader0.isFocusCycleRoot());
      assertFalse(loader0.isFocusTraversalPolicySet());
      assertFalse(loader0.isFocusTraversalPolicyProvider());
      assertFalse(loader0.isBusy());
      assertEquals("ArffLoader", loader0.getCustomName());
      assertTrue(loader0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Reads a source that is in arff (attribute relation file format) format</font> <br></html>", loader0.globalInfo());
      assertFalse(loader0.getIgnoreRepaint());
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      boolean boolean1 = loader0.m_design;
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
      
      boolean boolean2 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean2);
      assertFalse(boolean2 == boolean0);
      assertFalse(boolean2 == boolean1);
      
      boolean boolean3 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean3);
      assertTrue(boolean3 == boolean1);
      assertFalse(boolean3 == boolean2);
      assertTrue(boolean3 == boolean0);
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertNotNull(substringReplacer0);
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      
      InstanceEvent instanceEvent0 = substringReplacer0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      boolean boolean4 = filter0.eventGeneratable("Y[)pW*4X");
      assertTrue(boolean4);
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(boolean4 == boolean2);
      assertFalse(boolean4 == boolean3);
      assertFalse(boolean4 == boolean1);
      assertFalse(boolean4 == boolean0);
      
      boolean boolean5 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean5);
      assertFalse(boolean5 == boolean4);
      assertFalse(boolean5 == boolean2);
      assertTrue(boolean5 == boolean3);
      assertTrue(boolean5 == boolean1);
      assertTrue(boolean5 == boolean0);
      
      FileSystemHandling fileSystemHandling1 = new FileSystemHandling();
      assertNotNull(fileSystemHandling1);
      assertFalse(fileSystemHandling1.equals((Object)fileSystemHandling0));
      
      boolean boolean6 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean6);
      assertTrue(boolean6 == boolean3);
      assertTrue(boolean6 == boolean0);
      assertTrue(boolean6 == boolean1);
      assertTrue(boolean6 == boolean5);
      assertFalse(boolean6 == boolean4);
      assertFalse(boolean6 == boolean2);
      
      SubstringReplacer substringReplacer1 = new SubstringReplacer();
      assertNotNull(substringReplacer1);
      assertFalse(substringReplacer1.getIgnoreRepaint());
      assertEquals("", substringReplacer1.getMatchReplaceDetails());
      assertFalse(substringReplacer1.isFocusTraversalPolicySet());
      assertTrue(substringReplacer1.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer1.isBusy());
      assertFalse(substringReplacer1.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer1.getCustomName());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer1.globalInfo());
      assertFalse(substringReplacer1.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer1.equals((Object)substringReplacer0));
      
      InstanceEvent instanceEvent1 = substringReplacer1.m_ie;
      assertNotNull(instanceEvent1);
      assertEquals(0, instanceEvent1.getStatus());
      assertFalse(instanceEvent1.equals((Object)instanceEvent0));
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertNotSame(instanceEvent1, instanceEvent0);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals(0, instanceEvent0.getStatus());
      assertFalse(substringReplacer0.equals((Object)substringReplacer1));
      assertFalse(instanceEvent0.equals((Object)instanceEvent1));
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertNotSame(substringReplacer0, substringReplacer1);
      assertNotSame(instanceEvent0, instanceEvent1);
      
      TestSetMaker testSetMaker0 = new TestSetMaker();
      assertNotNull(testSetMaker0);
      assertFalse(testSetMaker0.isBusy());
      assertFalse(testSetMaker0.isFocusTraversalPolicyProvider());
      assertFalse(testSetMaker0.isFocusTraversalPolicySet());
      assertEquals("Designate an incoming data set as a test set.", testSetMaker0.globalInfo());
      assertFalse(testSetMaker0.getIgnoreRepaint());
      assertFalse(testSetMaker0.isFocusCycleRoot());
      assertTrue(testSetMaker0.getFocusTraversalKeysEnabled());
      assertEquals("TestSetMaker", testSetMaker0.getCustomName());
      
      boolean boolean7 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean7);
      assertFalse(boolean7 == boolean2);
      assertTrue(boolean7 == boolean1);
      assertTrue(boolean7 == boolean0);
      assertTrue(boolean7 == boolean5);
      assertTrue(boolean7 == boolean6);
      assertTrue(boolean7 == boolean3);
      assertFalse(boolean7 == boolean4);
      
      // Undeclared exception!
      try { 
        filter0.setWrappedAlgorithm(fileSystemHandling1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // class org.evosuite.runtime.testdata.FileSystemHandling : incorrect type of algorithm (Filter)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertNotNull(textDirectoryLoader0);
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      
      Instances instances0 = textDirectoryLoader0.getDataSet();
      assertNotNull(instances0);
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      
      ListIterator<Instance> listIterator0 = instances0.listIterator();
      assertNotNull(listIterator0);
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, instances0.numClasses());
      assertEquals(1, instances0.classIndex());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertFalse(listIterator0.hasPrevious());
      assertFalse(listIterator0.hasNext());
      
      boolean boolean0 = FileSystemHandling.createFolder((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      PredictionAppender predictionAppender0 = new PredictionAppender();
      assertNotNull(predictionAppender0);
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertFalse(predictionAppender0.isBusy());
      assertFalse(predictionAppender0.isFocusCycleRoot());
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      
      InstanceEvent instanceEvent0 = predictionAppender0.m_instanceEvent;
      assertNull(instanceEvent0);
      
      TestSetMaker testSetMaker0 = new TestSetMaker();
      assertNotNull(testSetMaker0);
      assertEquals("Designate an incoming data set as a test set.", testSetMaker0.globalInfo());
      assertEquals("TestSetMaker", testSetMaker0.getCustomName());
      assertFalse(testSetMaker0.getIgnoreRepaint());
      assertFalse(testSetMaker0.isBusy());
      assertFalse(testSetMaker0.isFocusTraversalPolicyProvider());
      assertFalse(testSetMaker0.isFocusCycleRoot());
      assertFalse(testSetMaker0.isFocusTraversalPolicySet());
      assertTrue(testSetMaker0.getFocusTraversalKeysEnabled());
      
      boolean boolean1 = predictionAppender0.m_appendProbabilities;
      assertFalse(boolean1);
      assertTrue(boolean1 == boolean0);
      
      AllFilter allFilter0 = new AllFilter();
      assertNotNull(allFilter0);
      assertFalse(allFilter0.isFirstBatchDone());
      assertFalse(allFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(allFilter0.isNewBatch());
      assertEquals("An instance filter that passes all instances through unmodified. Primarily for testing purposes.", allFilter0.globalInfo());
      assertFalse(allFilter0.isOutputFormatDefined());
      
      boolean boolean2 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean2);
      assertFalse(boolean2 == boolean0);
      assertFalse(boolean2 == boolean1);
      
      weka.gui.LogPanel logPanel0 = new weka.gui.LogPanel();
      assertNotNull(logPanel0);
      assertFalse(logPanel0.getIgnoreRepaint());
      assertFalse(logPanel0.isFocusTraversalPolicyProvider());
      assertFalse(logPanel0.isFocusCycleRoot());
      assertFalse(logPanel0.isFocusTraversalPolicySet());
      assertTrue(logPanel0.getFocusTraversalKeysEnabled());
      
      filter0.setLog(logPanel0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(logPanel0.getIgnoreRepaint());
      assertFalse(logPanel0.isFocusTraversalPolicyProvider());
      assertFalse(logPanel0.isFocusCycleRoot());
      assertFalse(logPanel0.isFocusTraversalPolicySet());
      assertTrue(logPanel0.getFocusTraversalKeysEnabled());
      
      AttributeSelection attributeSelection0 = new AttributeSelection();
      assertNotNull(attributeSelection0);
      assertEquals("A supervised attribute filter that can be used to select attributes. It is very flexible and allows various search and evaluation methods to be combined.", attributeSelection0.globalInfo());
      assertEquals("Determines the search method.", attributeSelection0.searchTipText());
      assertFalse(attributeSelection0.isFirstBatchDone());
      assertFalse(attributeSelection0.isOutputFormatDefined());
      assertTrue(attributeSelection0.isNewBatch());
      assertFalse(attributeSelection0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Determines how attributes/attribute subsets are evaluated.", attributeSelection0.evaluatorTipText());
      
      CompoundBorder compoundBorder0 = new CompoundBorder();
      assertNotNull(compoundBorder0);
      
      filter0.acceptInstance((InstanceEvent) null);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      String string0 = Action.SMALL_ICON;
      assertEquals("SmallIcon", string0);
      assertNotNull(string0);
      
      boolean boolean3 = FileSystemHandling.setPermissions((EvoSuiteFile) null, false, true, false);
      assertFalse(boolean3);
      assertTrue(boolean3 == boolean0);
      assertTrue(boolean3 == boolean1);
      assertFalse(boolean3 == boolean2);
      
      Instances instances1 = predictionAppender0.m_format;
      assertNull(instances1);
      
      TestSetMaker testSetMaker1 = new TestSetMaker();
      assertNotNull(testSetMaker1);
      assertTrue(testSetMaker1.getFocusTraversalKeysEnabled());
      assertFalse(testSetMaker1.isFocusCycleRoot());
      assertFalse(testSetMaker1.isBusy());
      assertFalse(testSetMaker1.isFocusTraversalPolicyProvider());
      assertEquals("TestSetMaker", testSetMaker1.getCustomName());
      assertEquals("Designate an incoming data set as a test set.", testSetMaker1.globalInfo());
      assertFalse(testSetMaker1.isFocusTraversalPolicySet());
      assertFalse(testSetMaker1.getIgnoreRepaint());
      assertFalse(testSetMaker1.equals((Object)testSetMaker0));
      
      TestSetEvent testSetEvent0 = new TestSetEvent(testSetMaker1, (Instances) null, 0, 0);
      assertNotNull(testSetEvent0);
      assertTrue(testSetMaker1.getFocusTraversalKeysEnabled());
      assertFalse(testSetMaker1.isFocusCycleRoot());
      assertFalse(testSetMaker1.isBusy());
      assertFalse(testSetMaker1.isFocusTraversalPolicyProvider());
      assertEquals("TestSetMaker", testSetMaker1.getCustomName());
      assertEquals("Designate an incoming data set as a test set.", testSetMaker1.globalInfo());
      assertFalse(testSetMaker1.isFocusTraversalPolicySet());
      assertFalse(testSetMaker1.getIgnoreRepaint());
      assertEquals(0, testSetEvent0.getMaxSetNumber());
      assertEquals(1, testSetEvent0.getRunNumber());
      assertEquals(0, testSetEvent0.getSetNumber());
      assertFalse(testSetEvent0.isStructureOnly());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertFalse(testSetMaker1.equals((Object)testSetMaker0));
      
      filter0.acceptTestSet(testSetEvent0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(testSetMaker1.getFocusTraversalKeysEnabled());
      assertFalse(testSetMaker1.isFocusCycleRoot());
      assertFalse(testSetMaker1.isBusy());
      assertFalse(testSetMaker1.isFocusTraversalPolicyProvider());
      assertEquals("TestSetMaker", testSetMaker1.getCustomName());
      assertEquals("Designate an incoming data set as a test set.", testSetMaker1.globalInfo());
      assertFalse(testSetMaker1.isFocusTraversalPolicySet());
      assertFalse(testSetMaker1.getIgnoreRepaint());
      assertEquals(0, testSetEvent0.getMaxSetNumber());
      assertEquals(1, testSetEvent0.getRunNumber());
      assertEquals(0, testSetEvent0.getSetNumber());
      assertFalse(testSetEvent0.isStructureOnly());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertFalse(testSetMaker1.equals((Object)testSetMaker0));
      assertNotSame(testSetMaker1, testSetMaker0);
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/mnt/gaiagpfs/users/homedirs/apanichella/Evosuite_performance/Dataset/gordon_script_sum/projects/9_weka");
      boolean boolean0 = FileSystemHandling.createFolder(evoSuiteFile0);
      assertTrue(boolean0);
      
      TestInstances testInstances0 = new TestInstances();
      assertNotNull(testInstances0);
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals("Testdata", testInstances0.getRelation());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      
      testInstances0.setNumString((byte)34);
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals("Testdata", testInstances0.getRelation());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(36, testInstances0.getNumAttributes());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(34, testInstances0.getNumString());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      
      boolean boolean1 = FileSystemHandling.shouldThrowIOException(evoSuiteFile0);
      assertTrue(boolean1);
      assertTrue(boolean1 == boolean0);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      
      filter0.setWrappedAlgorithm(multiFilter0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertTrue(multiFilter0.isNewBatch());
      
      Sorter sorter0 = new Sorter();
      assertNotNull(sorter0);
      assertEquals("10000", sorter0.getBufferSize());
      assertNull(sorter0.getSortDetails());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isFocusCycleRoot());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.isBusy());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.getIgnoreRepaint());
      
      KeyListener keyListener0 = mock(KeyListener.class, new ViolatedAssumptionAnswer());
      KeyListener keyListener1 = AWTEventMulticaster.add(keyListener0, keyListener0);
      assertNotNull(keyListener1);
      
      sorter0.removeKeyListener(keyListener1);
      assertEquals("10000", sorter0.getBufferSize());
      assertNull(sorter0.getSortDetails());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isFocusCycleRoot());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.isBusy());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.getIgnoreRepaint());
      
      Sorter sorter1 = new Sorter();
      assertNotNull(sorter1);
      assertTrue(sorter1.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter1.globalInfo());
      assertFalse(sorter1.getIgnoreRepaint());
      assertEquals("10000", sorter1.getBufferSize());
      assertFalse(sorter1.isFocusTraversalPolicySet());
      assertEquals("Sorter", sorter1.getCustomName());
      assertFalse(sorter1.isBusy());
      assertFalse(sorter1.isFocusCycleRoot());
      assertFalse(sorter1.isFocusTraversalPolicyProvider());
      assertEquals("", sorter1.getTempDirectory());
      assertNull(sorter1.getSortDetails());
      assertFalse(sorter1.equals((Object)sorter0));
      
      filter0.addDataSourceListener(sorter1);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(sorter1.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter1.globalInfo());
      assertFalse(sorter1.getIgnoreRepaint());
      assertEquals("10000", sorter1.getBufferSize());
      assertFalse(sorter1.isFocusTraversalPolicySet());
      assertEquals("Sorter", sorter1.getCustomName());
      assertFalse(sorter1.isBusy());
      assertFalse(sorter1.isFocusCycleRoot());
      assertFalse(sorter1.isFocusTraversalPolicyProvider());
      assertEquals("", sorter1.getTempDirectory());
      assertNull(sorter1.getSortDetails());
      assertFalse(sorter1.equals((Object)sorter0));
      assertNotSame(sorter1, sorter0);
      
      boolean boolean2 = FileSystemHandling.shouldThrowIOException(evoSuiteFile0);
      assertFalse(boolean2);
      assertFalse(boolean2 == boolean1);
      assertFalse(boolean2 == boolean0);
      
      Dimension dimension0 = filter0.getMinimumSize();
      assertNotNull(dimension0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals(67.0, dimension0.getWidth(), 0.01);
      assertEquals(68.0, dimension0.getHeight(), 0.01);
      assertEquals(68, dimension0.height);
      assertEquals(67, dimension0.width);
      
      InstanceEvent instanceEvent0 = sorter0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      filter0.acceptInstance(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertEquals("10000", sorter0.getBufferSize());
      assertNull(sorter0.getSortDetails());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isFocusCycleRoot());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.isBusy());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.equals((Object)sorter1));
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertNotSame(sorter0, sorter1);
      
      String string0 = filter0.globalInfo();
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", string0);
      assertNotNull(string0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      
      // Undeclared exception!
      try { 
        filter0.acceptTestSet((TestSetEvent) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      
      MetaBean metaBean0 = new MetaBean();
      assertNotNull(metaBean0);
      assertTrue(metaBean0.getFocusTraversalKeysEnabled());
      assertFalse(metaBean0.isFocusTraversalPolicyProvider());
      assertFalse(metaBean0.getIgnoreRepaint());
      assertFalse(metaBean0.isFocusTraversalPolicySet());
      assertFalse(metaBean0.isFocusCycleRoot());
      assertEquals("Group", metaBean0.getCustomName());
      
      JToolTip jToolTip0 = filter0.createToolTip();
      assertNotNull(jToolTip0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(jToolTip0.getIgnoreRepaint());
      assertFalse(jToolTip0.isFocusTraversalPolicyProvider());
      assertFalse(jToolTip0.isFocusCycleRoot());
      assertFalse(jToolTip0.isFocusTraversalPolicySet());
      assertTrue(jToolTip0.getFocusTraversalKeysEnabled());
      
      Vector<AttributeSummarizer> vector0 = new Vector<AttributeSummarizer>();
      assertNotNull(vector0);
      assertTrue(vector0.isEmpty());
      assertEquals(10, vector0.capacity());
      assertEquals("[]", vector0.toString());
      assertEquals(0, vector0.size());
      
      Rectangle rectangle0 = new Rectangle((-3), 3167);
      assertNotNull(rectangle0);
      assertEquals(1583.5, rectangle0.getCenterY(), 0.01);
      assertEquals(0.0, rectangle0.getMinX(), 0.01);
      assertEquals(0.0, rectangle0.getY(), 0.01);
      assertEquals(0.0, rectangle0.getMinY(), 0.01);
      assertEquals(0.0, rectangle0.getX(), 0.01);
      assertEquals(3167.0, rectangle0.getMaxY(), 0.01);
      assertEquals((-3.0), rectangle0.getWidth(), 0.01);
      assertEquals(3167.0, rectangle0.getHeight(), 0.01);
      assertEquals((-1.5), rectangle0.getCenterX(), 0.01);
      assertTrue(rectangle0.isEmpty());
      assertEquals((-3.0), rectangle0.getMaxX(), 0.01);
      assertEquals(0, rectangle0.y);
      assertEquals((-3), rectangle0.width);
      assertEquals(3167, rectangle0.height);
      assertEquals(0, rectangle0.x);
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      ClustererPerformanceEvaluator clustererPerformanceEvaluator0 = new ClustererPerformanceEvaluator();
      assertNotNull(clustererPerformanceEvaluator0);
      assertFalse(clustererPerformanceEvaluator0.isBusy());
      assertFalse(clustererPerformanceEvaluator0.isFocusCycleRoot());
      assertFalse(clustererPerformanceEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals("ClustererPerformanceEvaluator", clustererPerformanceEvaluator0.getCustomName());
      assertFalse(clustererPerformanceEvaluator0.getIgnoreRepaint());
      assertEquals("Evaluate the performance of batch trained clusterers.", clustererPerformanceEvaluator0.globalInfo());
      assertFalse(clustererPerformanceEvaluator0.isFocusTraversalPolicySet());
      assertTrue(clustererPerformanceEvaluator0.getFocusTraversalKeysEnabled());
      
      ComponentListener componentListener0 = mock(ComponentListener.class, new ViolatedAssumptionAnswer());
      ComponentListener componentListener1 = AWTEventMulticaster.add(componentListener0, componentListener0);
      assertNotNull(componentListener1);
      
      ComponentListener componentListener2 = AWTEventMulticaster.remove(componentListener1, componentListener1);
      assertNull(componentListener2);
      
      clustererPerformanceEvaluator0.addComponentListener((ComponentListener) null);
      assertFalse(clustererPerformanceEvaluator0.isBusy());
      assertFalse(clustererPerformanceEvaluator0.isFocusCycleRoot());
      assertFalse(clustererPerformanceEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals("ClustererPerformanceEvaluator", clustererPerformanceEvaluator0.getCustomName());
      assertFalse(clustererPerformanceEvaluator0.getIgnoreRepaint());
      assertEquals("Evaluate the performance of batch trained clusterers.", clustererPerformanceEvaluator0.globalInfo());
      assertFalse(clustererPerformanceEvaluator0.isFocusTraversalPolicySet());
      assertTrue(clustererPerformanceEvaluator0.getFocusTraversalKeysEnabled());
      
      TestSetEvent testSetEvent0 = new TestSetEvent(clustererPerformanceEvaluator0, (Instances) null, 3167, (-3), (-3), (-3));
      assertNotNull(testSetEvent0);
      assertFalse(clustererPerformanceEvaluator0.isBusy());
      assertFalse(clustererPerformanceEvaluator0.isFocusCycleRoot());
      assertFalse(clustererPerformanceEvaluator0.isFocusTraversalPolicyProvider());
      assertEquals("ClustererPerformanceEvaluator", clustererPerformanceEvaluator0.getCustomName());
      assertFalse(clustererPerformanceEvaluator0.getIgnoreRepaint());
      assertEquals("Evaluate the performance of batch trained clusterers.", clustererPerformanceEvaluator0.globalInfo());
      assertFalse(clustererPerformanceEvaluator0.isFocusTraversalPolicySet());
      assertTrue(clustererPerformanceEvaluator0.getFocusTraversalKeysEnabled());
      assertFalse(testSetEvent0.isStructureOnly());
      assertEquals((-3), testSetEvent0.getSetNumber());
      assertEquals(3167, testSetEvent0.getRunNumber());
      assertEquals((-3), testSetEvent0.getMaxSetNumber());
      assertEquals((-3), testSetEvent0.getMaxRunNumber());
      
      Resample resample0 = new Resample();
      assertNotNull(resample0);
      assertEquals("Sets the random number seed for subsampling.", resample0.randomSeedTipText());
      assertFalse(resample0.isFirstBatchDone());
      assertFalse(resample0.getNoReplacement());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample0.globalInfo());
      assertFalse(resample0.isOutputFormatDefined());
      assertEquals(0.0, resample0.getBiasToUniformClass(), 0.01);
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample0.invertSelectionTipText());
      assertEquals(100.0, resample0.getSampleSizePercent(), 0.01);
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample0.biasToUniformClassTipText());
      assertEquals(1, resample0.getRandomSeed());
      assertFalse(resample0.getInvertSelection());
      assertEquals("The subsample size as a percentage of the original set.", resample0.sampleSizePercentTipText());
      assertTrue(resample0.isNewBatch());
      assertFalse(resample0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Disables the replacement of instances.", resample0.noReplacementTipText());
      
      Resample resample1 = (Resample)weka.filters.Filter.makeCopy(resample0);
      assertNotNull(resample1);
      assertEquals("Sets the random number seed for subsampling.", resample0.randomSeedTipText());
      assertFalse(resample0.isFirstBatchDone());
      assertFalse(resample0.getNoReplacement());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample0.globalInfo());
      assertFalse(resample0.isOutputFormatDefined());
      assertEquals(0.0, resample0.getBiasToUniformClass(), 0.01);
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample0.invertSelectionTipText());
      assertEquals(100.0, resample0.getSampleSizePercent(), 0.01);
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample0.biasToUniformClassTipText());
      assertEquals(1, resample0.getRandomSeed());
      assertFalse(resample0.getInvertSelection());
      assertEquals("The subsample size as a percentage of the original set.", resample0.sampleSizePercentTipText());
      assertTrue(resample0.isNewBatch());
      assertFalse(resample0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Disables the replacement of instances.", resample0.noReplacementTipText());
      assertFalse(resample1.getInvertSelection());
      assertEquals(100.0, resample1.getSampleSizePercent(), 0.01);
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample1.biasToUniformClassTipText());
      assertTrue(resample1.isNewBatch());
      assertFalse(resample1.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Disables the replacement of instances.", resample1.noReplacementTipText());
      assertEquals(1, resample1.getRandomSeed());
      assertEquals("Sets the random number seed for subsampling.", resample1.randomSeedTipText());
      assertEquals("The subsample size as a percentage of the original set.", resample1.sampleSizePercentTipText());
      assertFalse(resample1.isOutputFormatDefined());
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample1.invertSelectionTipText());
      assertFalse(resample1.getNoReplacement());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample1.globalInfo());
      assertFalse(resample1.isFirstBatchDone());
      assertEquals(0.0, resample1.getBiasToUniformClass(), 0.01);
      assertFalse(resample1.equals((Object)resample0));
      assertNotSame(resample0, resample1);
      assertNotSame(resample1, resample0);
      
      rectangle0.height = (-854);
      assertEquals((-854.0), rectangle0.getMaxY(), 0.01);
      assertEquals(0.0, rectangle0.getMinX(), 0.01);
      assertEquals(0.0, rectangle0.getY(), 0.01);
      assertEquals((-427.0), rectangle0.getCenterY(), 0.01);
      assertEquals(0.0, rectangle0.getMinY(), 0.01);
      assertEquals(0.0, rectangle0.getX(), 0.01);
      assertEquals((-3.0), rectangle0.getWidth(), 0.01);
      assertEquals((-1.5), rectangle0.getCenterX(), 0.01);
      assertEquals((-854.0), rectangle0.getHeight(), 0.01);
      assertTrue(rectangle0.isEmpty());
      assertEquals((-3.0), rectangle0.getMaxX(), 0.01);
      
      filter0.setFilter(resample1);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Resample", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory</font><br><br> The number of instances in the generated dataset may be specified.<br>The dataset must have a nominal class attribute.<br>If not, use the unsupervised version.<br>The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution.<br>When used in batch mode (i.e.<br>in the FilteredClassifier), subsequent batches are NOT resampled.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("Sets the random number seed for subsampling.", resample0.randomSeedTipText());
      assertFalse(resample0.isFirstBatchDone());
      assertFalse(resample0.getNoReplacement());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample0.globalInfo());
      assertFalse(resample0.isOutputFormatDefined());
      assertEquals(0.0, resample0.getBiasToUniformClass(), 0.01);
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample0.invertSelectionTipText());
      assertEquals(100.0, resample0.getSampleSizePercent(), 0.01);
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample0.biasToUniformClassTipText());
      assertEquals(1, resample0.getRandomSeed());
      assertFalse(resample0.getInvertSelection());
      assertEquals("The subsample size as a percentage of the original set.", resample0.sampleSizePercentTipText());
      assertTrue(resample0.isNewBatch());
      assertFalse(resample0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Disables the replacement of instances.", resample0.noReplacementTipText());
      assertFalse(resample1.getInvertSelection());
      assertEquals(100.0, resample1.getSampleSizePercent(), 0.01);
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample1.biasToUniformClassTipText());
      assertTrue(resample1.isNewBatch());
      assertFalse(resample1.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Disables the replacement of instances.", resample1.noReplacementTipText());
      assertEquals(1, resample1.getRandomSeed());
      assertEquals("Sets the random number seed for subsampling.", resample1.randomSeedTipText());
      assertEquals("The subsample size as a percentage of the original set.", resample1.sampleSizePercentTipText());
      assertFalse(resample1.isOutputFormatDefined());
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample1.invertSelectionTipText());
      assertFalse(resample1.getNoReplacement());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample1.globalInfo());
      assertFalse(resample1.isFirstBatchDone());
      assertEquals(0.0, resample1.getBiasToUniformClass(), 0.01);
      assertFalse(resample0.equals((Object)resample1));
      assertFalse(resample1.equals((Object)resample0));
      assertNotSame(resample0, resample1);
      assertNotSame(resample1, resample0);
      
      FlowByExpression flowByExpression0 = new FlowByExpression();
      assertNotNull(flowByExpression0);
      assertFalse(flowByExpression0.isBusy());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertEquals("", flowByExpression0.getExpressionString());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertEquals("", flowByExpression0.getTrueStepName());
      
      SerializedModelSaver serializedModelSaver0 = new SerializedModelSaver();
      assertNotNull(serializedModelSaver0);
      assertTrue(serializedModelSaver0.getFocusTraversalKeysEnabled());
      assertFalse(serializedModelSaver0.isBusy());
      assertFalse(serializedModelSaver0.getIgnoreRepaint());
      assertFalse(serializedModelSaver0.isFocusTraversalPolicySet());
      assertEquals("SerializedModelSaver", serializedModelSaver0.getCustomName());
      assertEquals("", serializedModelSaver0.getPrefix());
      assertFalse(serializedModelSaver0.isFocusTraversalPolicyProvider());
      assertEquals("Save trained models to serialized object files.", serializedModelSaver0.globalInfo());
      assertFalse(serializedModelSaver0.getUseRelativePath());
      assertFalse(serializedModelSaver0.isFocusCycleRoot());
      assertFalse(serializedModelSaver0.getIncludeRelationName());
      assertEquals(1, SerializedModelSaver.KOMLV);
      assertEquals(2, SerializedModelSaver.XSTREAM);
      assertEquals(0, SerializedModelSaver.BINARY);
      
      int int0 = serializedModelSaver0.getWidth();
      assertEquals(0, int0);
      assertTrue(serializedModelSaver0.getFocusTraversalKeysEnabled());
      assertFalse(serializedModelSaver0.isBusy());
      assertFalse(serializedModelSaver0.getIgnoreRepaint());
      assertFalse(serializedModelSaver0.isFocusTraversalPolicySet());
      assertEquals("SerializedModelSaver", serializedModelSaver0.getCustomName());
      assertEquals("", serializedModelSaver0.getPrefix());
      assertFalse(serializedModelSaver0.isFocusTraversalPolicyProvider());
      assertEquals("Save trained models to serialized object files.", serializedModelSaver0.globalInfo());
      assertFalse(serializedModelSaver0.getUseRelativePath());
      assertFalse(serializedModelSaver0.isFocusCycleRoot());
      assertFalse(serializedModelSaver0.getIncludeRelationName());
      assertEquals(1, SerializedModelSaver.KOMLV);
      assertEquals(2, SerializedModelSaver.XSTREAM);
      assertEquals(0, SerializedModelSaver.BINARY);
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(serializedModelSaver0, (Instances) null, (-854), 0, 0, 0);
      assertNotNull(trainingSetEvent0);
      assertTrue(serializedModelSaver0.getFocusTraversalKeysEnabled());
      assertFalse(serializedModelSaver0.isBusy());
      assertFalse(serializedModelSaver0.getIgnoreRepaint());
      assertFalse(serializedModelSaver0.isFocusTraversalPolicySet());
      assertEquals("SerializedModelSaver", serializedModelSaver0.getCustomName());
      assertEquals("", serializedModelSaver0.getPrefix());
      assertFalse(serializedModelSaver0.isFocusTraversalPolicyProvider());
      assertEquals("Save trained models to serialized object files.", serializedModelSaver0.globalInfo());
      assertFalse(serializedModelSaver0.getUseRelativePath());
      assertFalse(serializedModelSaver0.isFocusCycleRoot());
      assertFalse(serializedModelSaver0.getIncludeRelationName());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(0, trainingSetEvent0.getMaxRunNumber());
      assertEquals((-854), trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertFalse(trainingSetEvent0.isStructureOnly());
      assertEquals(1, SerializedModelSaver.KOMLV);
      assertEquals(2, SerializedModelSaver.XSTREAM);
      assertEquals(0, SerializedModelSaver.BINARY);
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Resample", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory</font><br><br> The number of instances in the generated dataset may be specified.<br>The dataset must have a nominal class attribute.<br>If not, use the unsupervised version.<br>The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution.<br>When used in batch mode (i.e.<br>in the FilteredClassifier), subsequent batches are NOT resampled.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertTrue(serializedModelSaver0.getFocusTraversalKeysEnabled());
      assertFalse(serializedModelSaver0.isBusy());
      assertFalse(serializedModelSaver0.getIgnoreRepaint());
      assertFalse(serializedModelSaver0.isFocusTraversalPolicySet());
      assertEquals("SerializedModelSaver", serializedModelSaver0.getCustomName());
      assertEquals("", serializedModelSaver0.getPrefix());
      assertFalse(serializedModelSaver0.isFocusTraversalPolicyProvider());
      assertEquals("Save trained models to serialized object files.", serializedModelSaver0.globalInfo());
      assertFalse(serializedModelSaver0.getUseRelativePath());
      assertFalse(serializedModelSaver0.isFocusCycleRoot());
      assertFalse(serializedModelSaver0.getIncludeRelationName());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(0, trainingSetEvent0.getMaxRunNumber());
      assertEquals((-854), trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertFalse(trainingSetEvent0.isStructureOnly());
      assertEquals(1, SerializedModelSaver.KOMLV);
      assertEquals(2, SerializedModelSaver.XSTREAM);
      assertEquals(0, SerializedModelSaver.BINARY);
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertNotNull(substringReplacer0);
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.isBusy());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      
      substringReplacer0.removeContainerListener((ContainerListener) null);
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.isBusy());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      
      InstanceEvent instanceEvent0 = substringReplacer0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Resample", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory</font><br><br> The number of instances in the generated dataset may be specified.<br>The dataset must have a nominal class attribute.<br>If not, use the unsupervised version.<br>The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution.<br>When used in batch mode (i.e.<br>in the FilteredClassifier), subsequent batches are NOT resampled.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.isBusy());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      TestSetMaker testSetMaker0 = new TestSetMaker();
      assertNotNull(testSetMaker0);
      assertFalse(testSetMaker0.isBusy());
      assertFalse(testSetMaker0.isFocusTraversalPolicyProvider());
      assertFalse(testSetMaker0.isFocusTraversalPolicySet());
      assertEquals("Designate an incoming data set as a test set.", testSetMaker0.globalInfo());
      assertFalse(testSetMaker0.getIgnoreRepaint());
      assertFalse(testSetMaker0.isFocusCycleRoot());
      assertTrue(testSetMaker0.getFocusTraversalKeysEnabled());
      assertEquals("TestSetMaker", testSetMaker0.getCustomName());
      
      boolean boolean1 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertFalse(boolean1);
      assertFalse(boolean1 == boolean0);
      
      GraphViewer graphViewer0 = new GraphViewer();
      assertNotNull(graphViewer0);
      assertFalse(graphViewer0.isFocusCycleRoot());
      assertTrue(graphViewer0.getFocusTraversalKeysEnabled());
      assertFalse(graphViewer0.isFocusTraversalPolicySet());
      assertFalse(graphViewer0.getIgnoreRepaint());
      assertEquals("Graphically visualize trees or graphs produced by classifiers/clusterers.", graphViewer0.globalInfo());
      assertFalse(graphViewer0.isFocusTraversalPolicyProvider());
      
      TestSetEvent testSetEvent1 = new TestSetEvent(graphViewer0, (Instances) null);
      assertNotNull(testSetEvent1);
      assertFalse(graphViewer0.isFocusCycleRoot());
      assertTrue(graphViewer0.getFocusTraversalKeysEnabled());
      assertFalse(graphViewer0.isFocusTraversalPolicySet());
      assertFalse(graphViewer0.getIgnoreRepaint());
      assertEquals("Graphically visualize trees or graphs produced by classifiers/clusterers.", graphViewer0.globalInfo());
      assertFalse(graphViewer0.isFocusTraversalPolicyProvider());
      assertEquals(0, testSetEvent1.getMaxSetNumber());
      assertEquals(1, testSetEvent1.getRunNumber());
      assertFalse(testSetEvent1.isStructureOnly());
      assertEquals(0, testSetEvent1.getSetNumber());
      assertEquals(1, testSetEvent1.getMaxRunNumber());
      assertFalse(testSetEvent1.equals((Object)testSetEvent0));
      
      filter0.acceptTestSet(testSetEvent1);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Resample", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory</font><br><br> The number of instances in the generated dataset may be specified.<br>The dataset must have a nominal class attribute.<br>If not, use the unsupervised version.<br>The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution.<br>When used in batch mode (i.e.<br>in the FilteredClassifier), subsequent batches are NOT resampled.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(graphViewer0.isFocusCycleRoot());
      assertTrue(graphViewer0.getFocusTraversalKeysEnabled());
      assertFalse(graphViewer0.isFocusTraversalPolicySet());
      assertFalse(graphViewer0.getIgnoreRepaint());
      assertEquals("Graphically visualize trees or graphs produced by classifiers/clusterers.", graphViewer0.globalInfo());
      assertFalse(graphViewer0.isFocusTraversalPolicyProvider());
      assertEquals(0, testSetEvent1.getMaxSetNumber());
      assertEquals(1, testSetEvent1.getRunNumber());
      assertFalse(testSetEvent1.isStructureOnly());
      assertEquals(0, testSetEvent1.getSetNumber());
      assertEquals(1, testSetEvent1.getMaxRunNumber());
      assertFalse(testSetEvent1.equals((Object)testSetEvent0));
      assertNotSame(testSetEvent1, testSetEvent0);
      
      Resample resample2 = (Resample)filter0.getFilter();
      assertNotNull(resample2);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Resample", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory</font><br><br> The number of instances in the generated dataset may be specified.<br>The dataset must have a nominal class attribute.<br>If not, use the unsupervised version.<br>The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution.<br>When used in batch mode (i.e.<br>in the FilteredClassifier), subsequent batches are NOT resampled.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals(0.0, resample2.getBiasToUniformClass(), 0.01);
      assertFalse(resample2.getNoReplacement());
      assertEquals(1, resample2.getRandomSeed());
      assertFalse(resample2.getInvertSelection());
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample2.invertSelectionTipText());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample2.globalInfo());
      assertEquals("Disables the replacement of instances.", resample2.noReplacementTipText());
      assertFalse(resample2.isOutputFormatDefined());
      assertEquals(100.0, resample2.getSampleSizePercent(), 0.01);
      assertEquals("Sets the random number seed for subsampling.", resample2.randomSeedTipText());
      assertTrue(resample2.isNewBatch());
      assertFalse(resample2.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(resample2.isFirstBatchDone());
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample2.biasToUniformClassTipText());
      assertEquals("The subsample size as a percentage of the original set.", resample2.sampleSizePercentTipText());
      assertFalse(resample2.equals((Object)resample0));
      assertSame(resample2, resample1);
      assertNotSame(resample2, resample0);
      
      Add add0 = new Add();
      assertNotNull(add0);
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("last", add0.getAttributeIndex());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertFalse(add0.isFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      
      // Undeclared exception!
      try { 
        add0.getCapabilities((Instances) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.filters.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/mnt/gaiagpfs/users/homedirs/apanichella/Evosuite_performance/Dataset/gordon_script_sum/projects/9_weka");
      boolean boolean0 = FileSystemHandling.createFolder(evoSuiteFile0);
      assertTrue(boolean0);
      
      boolean boolean1 = FileSystemHandling.createFolder(evoSuiteFile0);
      assertTrue(boolean1);
      assertTrue(boolean1 == boolean0);
      
      Enumeration enumeration0 = filter0.enumerateRequests();
      assertNotNull(enumeration0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.getDebug());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      
      filter0.setWrappedAlgorithm(multiFilter0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.getDebug());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      
      Sorter sorter0 = new Sorter();
      assertNotNull(sorter0);
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.isFocusCycleRoot());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isBusy());
      
      Sorter sorter1 = new Sorter();
      assertNotNull(sorter1);
      assertFalse(sorter1.isBusy());
      assertFalse(sorter1.isFocusCycleRoot());
      assertFalse(sorter1.isFocusTraversalPolicyProvider());
      assertEquals("", sorter1.getTempDirectory());
      assertNull(sorter1.getSortDetails());
      assertTrue(sorter1.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter1.globalInfo());
      assertFalse(sorter1.getIgnoreRepaint());
      assertEquals("10000", sorter1.getBufferSize());
      assertEquals("Sorter", sorter1.getCustomName());
      assertFalse(sorter1.isFocusTraversalPolicySet());
      assertFalse(sorter1.equals((Object)sorter0));
      
      KeyListener keyListener0 = mock(KeyListener.class, new ViolatedAssumptionAnswer());
      boolean boolean2 = FileSystemHandling.createFolder(evoSuiteFile0);
      assertTrue(boolean2);
      assertTrue(boolean2 == boolean1);
      assertTrue(boolean2 == boolean0);
      
      InputMap inputMap0 = sorter1.getInputMap();
      assertNotNull(inputMap0);
      assertFalse(sorter1.isBusy());
      assertFalse(sorter1.isFocusCycleRoot());
      assertFalse(sorter1.isFocusTraversalPolicyProvider());
      assertEquals("", sorter1.getTempDirectory());
      assertNull(sorter1.getSortDetails());
      assertTrue(sorter1.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter1.globalInfo());
      assertFalse(sorter1.getIgnoreRepaint());
      assertEquals("10000", sorter1.getBufferSize());
      assertEquals("Sorter", sorter1.getCustomName());
      assertFalse(sorter1.isFocusTraversalPolicySet());
      assertFalse(sorter1.equals((Object)sorter0));
      assertNotSame(sorter1, sorter0);
      
      Sorter sorter2 = new Sorter();
      assertNotNull(sorter2);
      assertEquals("", sorter2.getTempDirectory());
      assertFalse(sorter2.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter2.globalInfo());
      assertNull(sorter2.getSortDetails());
      assertFalse(sorter2.isBusy());
      assertFalse(sorter2.isFocusTraversalPolicySet());
      assertFalse(sorter2.isFocusCycleRoot());
      assertTrue(sorter2.getFocusTraversalKeysEnabled());
      assertEquals("10000", sorter2.getBufferSize());
      assertEquals("Sorter", sorter2.getCustomName());
      assertFalse(sorter2.getIgnoreRepaint());
      assertFalse(sorter2.equals((Object)sorter1));
      assertFalse(sorter2.equals((Object)sorter0));
      
      boolean boolean3 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean3);
      assertTrue(boolean3 == boolean2);
      assertTrue(boolean3 == boolean0);
      assertTrue(boolean3 == boolean1);
      
      ComponentListener[] componentListenerArray0 = sorter0.getComponentListeners();
      assertNotNull(componentListenerArray0);
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.isFocusCycleRoot());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.equals((Object)sorter2));
      assertFalse(sorter0.equals((Object)sorter1));
      assertNotSame(sorter0, sorter2);
      assertNotSame(sorter0, sorter1);
      
      InstanceEvent instanceEvent0 = sorter0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      instanceEvent0.setStatus(26);
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.isFocusCycleRoot());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isBusy());
      assertEquals(26, instanceEvent0.getStatus());
      assertFalse(sorter0.equals((Object)sorter2));
      assertFalse(sorter0.equals((Object)sorter1));
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertNotSame(sorter0, sorter2);
      assertNotSame(sorter0, sorter1);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.isFocusCycleRoot());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isBusy());
      assertEquals(26, instanceEvent0.getStatus());
      assertFalse(sorter0.equals((Object)sorter2));
      assertFalse(sorter0.equals((Object)sorter1));
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertNotSame(sorter0, sorter2);
      assertNotSame(sorter0, sorter1);
      
      Clusterer clusterer0 = new Clusterer();
      assertNotNull(clusterer0);
      assertFalse(clusterer0.isBusy());
      assertTrue(clusterer0.getFocusTraversalKeysEnabled());
      assertFalse(clusterer0.getIgnoreRepaint());
      assertFalse(clusterer0.isFocusTraversalPolicySet());
      assertFalse(clusterer0.isFocusCycleRoot());
      assertEquals("EM", clusterer0.getCustomName());
      assertEquals("<html><font color=blue>Simple EM (expectation maximisation) class.\n\nEM assigns a probability distribution to each instance which indicates the probability of it belonging to each of the clusters</font><br><br> EM can decide how many clusters to create by cross validation, or you may specify apriori how many clusters to generate.<br><br>The cross validation performed to determine the number of clusters is done in the following steps:<br>1. the number of clusters is set to 1<br>2. the training set is split randomly into 10 folds.<br>3. EM is performed 10 times using the 10 folds the usual CV way.<br>4. the loglikelihood is averaged over all 10 results.<br>5.<br>if loglikelihood has increased the number of clusters is increased by 1 and the program continues at step 2.<br><br><br>The number of folds is fixed to 10, as long as the number of instances in the training set is not smaller 10.<br>If this is the case the number of folds is set equal to the number of instances.<br></html>", clusterer0.globalInfo());
      assertFalse(clusterer0.hasIncomingBatchInstances());
      assertFalse(clusterer0.isFocusTraversalPolicyProvider());
      
      TestInstances testInstances0 = new TestInstances();
      assertNotNull(testInstances0);
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumString());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(20, testInstances0.getNumInstances());
      assertFalse(testInstances0.getNoClass());
      assertEquals(1, testInstances0.getClassType());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      
      boolean boolean4 = filter0.connectionAllowed("Wl~G");
      assertTrue(boolean4);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(boolean4 == boolean1);
      assertTrue(boolean4 == boolean2);
      assertTrue(boolean4 == boolean3);
      assertTrue(boolean4 == boolean0);
      
      filter0.setCustomName("");
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      filter0.notifyInstanceListeners(instanceEvent0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.isFocusCycleRoot());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isBusy());
      assertEquals(26, instanceEvent0.getStatus());
      assertFalse(sorter0.equals((Object)sorter2));
      assertFalse(sorter0.equals((Object)sorter1));
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertNotSame(sorter0, sorter2);
      assertNotSame(sorter0, sorter1);
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      filter0.removeConfigurationListener((ConfigurationListener) null);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("", filter0.getCustomName());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      TestInstances testInstances0 = new TestInstances();
      assertNotNull(testInstances0);
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getClassType());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumAttributes());
      assertFalse(testInstances0.getNoClass());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.isOutputFormatDefined());
      
      String string0 = testInstances0.getRevision();
      assertEquals("8034", string0);
      assertNotNull(string0);
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getClassType());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumAttributes());
      assertFalse(testInstances0.getNoClass());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      
      filter0.setWrappedAlgorithm(multiFilter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.isOutputFormatDefined());
      
      Sorter sorter0 = new Sorter();
      assertNotNull(sorter0);
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isBusy());
      assertEquals("", sorter0.getTempDirectory());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isFocusCycleRoot());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorter", sorter0.getCustomName());
      
      Sorter sorter1 = new Sorter();
      assertNotNull(sorter1);
      assertEquals("", sorter1.getTempDirectory());
      assertFalse(sorter1.getIgnoreRepaint());
      assertFalse(sorter1.isBusy());
      assertFalse(sorter1.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter1.globalInfo());
      assertNull(sorter1.getSortDetails());
      assertFalse(sorter1.isFocusCycleRoot());
      assertEquals("10000", sorter1.getBufferSize());
      assertTrue(sorter1.getFocusTraversalKeysEnabled());
      assertEquals("Sorter", sorter1.getCustomName());
      assertFalse(sorter1.isFocusTraversalPolicySet());
      assertFalse(sorter1.equals((Object)sorter0));
      
      filter0.addDataSourceListener(sorter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isBusy());
      assertEquals("", sorter0.getTempDirectory());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isFocusCycleRoot());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.equals((Object)sorter1));
      assertNotSame(sorter0, sorter1);
      
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      InstanceEvent instanceEvent0 = sorter0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(69);
      assertNotNull(binarySparseInstance0);
      assertEquals(69, binarySparseInstance0.numAttributes());
      assertEquals(69, binarySparseInstance0.numValues());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      instanceEvent0.setInstance(binarySparseInstance0);
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isBusy());
      assertEquals("", sorter0.getTempDirectory());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isFocusCycleRoot());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorter", sorter0.getCustomName());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(69, binarySparseInstance0.numAttributes());
      assertEquals(69, binarySparseInstance0.numValues());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertFalse(sorter0.equals((Object)sorter1));
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      assertNotSame(sorter0, sorter1);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isBusy());
      assertEquals("", sorter0.getTempDirectory());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isFocusCycleRoot());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorter", sorter0.getCustomName());
      assertEquals(0, instanceEvent0.getStatus());
      assertFalse(sorter0.equals((Object)sorter1));
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertNotSame(sorter0, sorter1);
      
      String string1 = filter0.globalInfo();
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", string1);
      assertNotNull(string1);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(string1.equals((Object)string0));
      
      Sorter sorter2 = new Sorter();
      assertNotNull(sorter2);
      assertFalse(sorter2.isFocusTraversalPolicyProvider());
      assertFalse(sorter2.isFocusCycleRoot());
      assertEquals("", sorter2.getTempDirectory());
      assertFalse(sorter2.isBusy());
      assertTrue(sorter2.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter2.globalInfo());
      assertEquals("10000", sorter2.getBufferSize());
      assertNull(sorter2.getSortDetails());
      assertFalse(sorter2.isFocusTraversalPolicySet());
      assertEquals("Sorter", sorter2.getCustomName());
      assertFalse(sorter2.getIgnoreRepaint());
      assertFalse(sorter2.equals((Object)sorter0));
      assertFalse(sorter2.equals((Object)sorter1));
      
      instanceEvent0.setStatus(1784);
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isBusy());
      assertEquals("", sorter0.getTempDirectory());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isFocusCycleRoot());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorter", sorter0.getCustomName());
      assertEquals(1784, instanceEvent0.getStatus());
      assertFalse(sorter0.equals((Object)sorter2));
      assertFalse(sorter0.equals((Object)sorter1));
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertNotSame(sorter0, sorter2);
      assertNotSame(sorter0, sorter1);
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      assertEquals("Appender", appender0.getCustomName());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      
      InstanceEvent instanceEvent1 = appender0.m_ie;
      assertNotNull(instanceEvent1);
      assertEquals(0, instanceEvent1.getStatus());
      assertFalse(instanceEvent1.equals((Object)instanceEvent0));
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertNotSame(instanceEvent1, instanceEvent0);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.getIgnoreRepaint());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isBusy());
      assertEquals("", sorter0.getTempDirectory());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isFocusCycleRoot());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorter", sorter0.getCustomName());
      assertEquals(1784, instanceEvent0.getStatus());
      assertFalse(sorter0.equals((Object)sorter2));
      assertFalse(sorter0.equals((Object)sorter1));
      assertFalse(instanceEvent0.equals((Object)instanceEvent1));
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertNotSame(sorter0, sorter2);
      assertNotSame(sorter0, sorter1);
      assertNotSame(instanceEvent0, instanceEvent1);
      
      Clusterer clusterer0 = new Clusterer();
      assertNotNull(clusterer0);
      assertFalse(clusterer0.isBusy());
      assertFalse(clusterer0.isFocusTraversalPolicyProvider());
      assertFalse(clusterer0.isFocusTraversalPolicySet());
      assertFalse(clusterer0.getIgnoreRepaint());
      assertFalse(clusterer0.isFocusCycleRoot());
      assertTrue(clusterer0.getFocusTraversalKeysEnabled());
      assertFalse(clusterer0.hasIncomingBatchInstances());
      assertEquals("<html><font color=blue>Simple EM (expectation maximisation) class.\n\nEM assigns a probability distribution to each instance which indicates the probability of it belonging to each of the clusters</font><br><br> EM can decide how many clusters to create by cross validation, or you may specify apriori how many clusters to generate.<br><br>The cross validation performed to determine the number of clusters is done in the following steps:<br>1. the number of clusters is set to 1<br>2. the training set is split randomly into 10 folds.<br>3. EM is performed 10 times using the 10 folds the usual CV way.<br>4. the loglikelihood is averaged over all 10 results.<br>5.<br>if loglikelihood has increased the number of clusters is increased by 1 and the program continues at step 2.<br><br><br>The number of folds is fixed to 10, as long as the number of instances in the training set is not smaller 10.<br>If this is the case the number of folds is set equal to the number of instances.<br></html>", clusterer0.globalInfo());
      assertEquals("EM", clusterer0.getCustomName());
      
      filter0.removeTestSetListener(clusterer0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(clusterer0.isBusy());
      assertFalse(clusterer0.isFocusTraversalPolicyProvider());
      assertFalse(clusterer0.isFocusTraversalPolicySet());
      assertFalse(clusterer0.getIgnoreRepaint());
      assertFalse(clusterer0.isFocusCycleRoot());
      assertTrue(clusterer0.getFocusTraversalKeysEnabled());
      assertFalse(clusterer0.hasIncomingBatchInstances());
      assertEquals("<html><font color=blue>Simple EM (expectation maximisation) class.\n\nEM assigns a probability distribution to each instance which indicates the probability of it belonging to each of the clusters</font><br><br> EM can decide how many clusters to create by cross validation, or you may specify apriori how many clusters to generate.<br><br>The cross validation performed to determine the number of clusters is done in the following steps:<br>1. the number of clusters is set to 1<br>2. the training set is split randomly into 10 folds.<br>3. EM is performed 10 times using the 10 folds the usual CV way.<br>4. the loglikelihood is averaged over all 10 results.<br>5.<br>if loglikelihood has increased the number of clusters is increased by 1 and the program continues at step 2.<br><br><br>The number of folds is fixed to 10, as long as the number of instances in the training set is not smaller 10.<br>If this is the case the number of folds is set equal to the number of instances.<br></html>", clusterer0.globalInfo());
      assertEquals("EM", clusterer0.getCustomName());
      
      MultiFilter multiFilter1 = (MultiFilter)filter0.getWrappedAlgorithm();
      assertNotNull(multiFilter1);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(multiFilter1.isNewBatch());
      assertFalse(multiFilter1.isFirstBatchDone());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      assertFalse(multiFilter1.getDebug());
      assertSame(multiFilter1, multiFilter0);
      
      TextField textField0 = null;
      try {
        textField0 = new TextField();
        fail("Expecting exception: HeadlessException");
      
      } catch(HeadlessException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.awt.GraphicsEnvironment", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      
      filter0.setDoubleBuffered(false);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      
      FocusTraversalPolicy focusTraversalPolicy0 = filter0.getFocusTraversalPolicy();
      assertNull(focusTraversalPolicy0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      
      filter0.setFocusTraversalPolicy((FocusTraversalPolicy) null);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      
      boolean boolean0 = filter0.connectionAllowed("instance");
      assertFalse(boolean0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      
      boolean boolean1 = filter0.isBusy();
      assertFalse(boolean1);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(boolean1 == boolean0);
      
      Associator associator0 = new Associator();
      assertNotNull(associator0);
      assertFalse(associator0.getIgnoreRepaint());
      assertEquals("Apriori", associator0.getCustomName());
      assertFalse(associator0.isBusy());
      assertTrue(associator0.getFocusTraversalKeysEnabled());
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      assertFalse(associator0.isFocusCycleRoot());
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      
      filter0.disconnectionNotification("instance", associator0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(associator0.getIgnoreRepaint());
      assertEquals("Apriori", associator0.getCustomName());
      assertFalse(associator0.isBusy());
      assertTrue(associator0.getFocusTraversalKeysEnabled());
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      assertFalse(associator0.isFocusCycleRoot());
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      
      BayesNet bayesNet0 = new BayesNet();
      assertNotNull(bayesNet0);
      assertEquals("Select Estimator algorithm for finding the conditional probability tables of the Bayes Network.", bayesNet0.estimatorTipText());
      assertFalse(bayesNet0.getDebug());
      assertEquals(2, bayesNet0.graphType());
      assertEquals("When ADTree (the data structure for increasing speed on counts, not to be confused with the classifier under the same name) is used learning time goes down typically. However, because ADTrees are memory intensive, memory problems may occur. Switching this option off makes the structure learning algorithms slower, and run with less memory. By default, ADTrees are used.", bayesNet0.useADTreeTipText());
      assertEquals("Select method used for searching network structures.", bayesNet0.searchAlgorithmTipText());
      assertEquals("Bayes Network learning using various search algorithms and quality measures.\nBase class for a Bayes Network classifier. Provides datastructures (network structure, conditional probability distributions, etc.) and facilities common to Bayes Network learning algorithms like K2 and B.\n\nFor more information see:\n\nhttp://www.cs.waikato.ac.nz/~remco/weka.pdf", bayesNet0.globalInfo());
      assertFalse(bayesNet0.getUseADTree());
      assertEquals("If set to true, classifier may output additional info to the console.", bayesNet0.debugTipText());
      assertEquals("Set the name of a file in BIF XML format. A Bayes network learned from data can be compared with the Bayes network represented by the BIF file. Statistics calculated are o.a. the number of missing and extra arcs.", bayesNet0.BIFFileTipText());
      
      Instances instances0 = bayesNet0.m_Instances;
      assertNull(instances0);
      
      AttributeSelection attributeSelection0 = new AttributeSelection();
      assertNotNull(attributeSelection0);
      assertFalse(attributeSelection0.isOutputFormatDefined());
      assertEquals("Determines how attributes/attribute subsets are evaluated.", attributeSelection0.evaluatorTipText());
      assertEquals("Determines the search method.", attributeSelection0.searchTipText());
      assertTrue(attributeSelection0.isNewBatch());
      assertFalse(attributeSelection0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("A supervised attribute filter that can be used to select attributes. It is very flexible and allows various search and evaluation methods to be combined.", attributeSelection0.globalInfo());
      assertFalse(attributeSelection0.isFirstBatchDone());
      
      try { 
        weka.filters.Filter.useFilter((Instances) null, attributeSelection0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.filters.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      Filter filter0 = new Filter();
      assertNotNull(filter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      
      TestInstances testInstances0 = new TestInstances();
      assertNotNull(testInstances0);
      assertEquals(0, testInstances0.getNumString());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertNotNull(multiFilter0);
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      
      String string0 = multiFilter0.toString();
      assertEquals("weka.filters.MultiFilter", string0);
      assertNotNull(string0);
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      
      filter0.setWrappedAlgorithm(multiFilter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(multiFilter0.getDebug());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      
      Sorter sorter0 = new Sorter();
      assertNotNull(sorter0);
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("Sorter", sorter0.getCustomName());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      
      sorter0.removeKeyListener((KeyListener) null);
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("Sorter", sorter0.getCustomName());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      
      Sorter sorter1 = new Sorter();
      assertNotNull(sorter1);
      assertEquals("", sorter1.getTempDirectory());
      assertFalse(sorter1.getIgnoreRepaint());
      assertEquals("Sorter", sorter1.getCustomName());
      assertFalse(sorter1.isBusy());
      assertTrue(sorter1.getFocusTraversalKeysEnabled());
      assertNull(sorter1.getSortDetails());
      assertFalse(sorter1.isFocusTraversalPolicySet());
      assertFalse(sorter1.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter1.globalInfo());
      assertFalse(sorter1.isFocusCycleRoot());
      assertEquals("10000", sorter1.getBufferSize());
      assertFalse(sorter1.equals((Object)sorter0));
      
      filter0.addDataSourceListener(sorter0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("Sorter", sorter0.getCustomName());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.equals((Object)sorter1));
      assertNotSame(sorter0, sorter1);
      
      boolean boolean0 = FileSystemHandling.shouldThrowIOException((EvoSuiteFile) null);
      assertFalse(boolean0);
      
      InstanceEvent instanceEvent0 = sorter0.m_ie;
      assertNotNull(instanceEvent0);
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      BinarySparseInstance binarySparseInstance0 = new BinarySparseInstance(69);
      assertNotNull(binarySparseInstance0);
      assertEquals(69, binarySparseInstance0.numValues());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(69, binarySparseInstance0.numAttributes());
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      
      instanceEvent0.setInstance(binarySparseInstance0);
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("Sorter", sorter0.getCustomName());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(69, binarySparseInstance0.numValues());
      assertEquals(1.0, binarySparseInstance0.weight(), 0.01);
      assertEquals(69, binarySparseInstance0.numAttributes());
      assertFalse(sorter0.equals((Object)sorter1));
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(6, AbstractInstance.s_numericAfterDecimalPoint);
      assertNotSame(sorter0, sorter1);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("Sorter", sorter0.getCustomName());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertEquals(0, instanceEvent0.getStatus());
      assertFalse(sorter0.equals((Object)sorter1));
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertNotSame(sorter0, sorter1);
      
      String string1 = filter0.globalInfo();
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", string1);
      assertNotNull(string1);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(string1.equals((Object)string0));
      
      Dimension dimension0 = new Dimension(2, (-2));
      assertNotNull(dimension0);
      assertEquals(2.0, dimension0.getWidth(), 0.01);
      assertEquals((-2.0), dimension0.getHeight(), 0.01);
      assertEquals(2, dimension0.width);
      assertEquals((-2), dimension0.height);
      
      dimension0.height = (-2);
      assertEquals(2.0, dimension0.getWidth(), 0.01);
      assertEquals((-2.0), dimension0.getHeight(), 0.01);
      
      Sorter sorter2 = new Sorter();
      assertNotNull(sorter2);
      assertFalse(sorter2.getIgnoreRepaint());
      assertTrue(sorter2.getFocusTraversalKeysEnabled());
      assertFalse(sorter2.isFocusTraversalPolicySet());
      assertFalse(sorter2.isBusy());
      assertEquals("Sorter", sorter2.getCustomName());
      assertEquals("", sorter2.getTempDirectory());
      assertEquals("10000", sorter2.getBufferSize());
      assertNull(sorter2.getSortDetails());
      assertFalse(sorter2.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter2.globalInfo());
      assertFalse(sorter2.isFocusCycleRoot());
      assertFalse(sorter2.equals((Object)sorter0));
      assertFalse(sorter2.equals((Object)sorter1));
      
      sorter1.setMinimumSize(dimension0);
      assertEquals("", sorter1.getTempDirectory());
      assertFalse(sorter1.getIgnoreRepaint());
      assertEquals("Sorter", sorter1.getCustomName());
      assertFalse(sorter1.isBusy());
      assertTrue(sorter1.getFocusTraversalKeysEnabled());
      assertNull(sorter1.getSortDetails());
      assertFalse(sorter1.isFocusTraversalPolicySet());
      assertFalse(sorter1.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter1.globalInfo());
      assertFalse(sorter1.isFocusCycleRoot());
      assertEquals("10000", sorter1.getBufferSize());
      assertEquals(2.0, dimension0.getWidth(), 0.01);
      assertEquals((-2.0), dimension0.getHeight(), 0.01);
      assertFalse(sorter1.equals((Object)sorter2));
      assertFalse(sorter1.equals((Object)sorter0));
      assertEquals(2, dimension0.width);
      assertEquals((-2), dimension0.height);
      assertNotSame(sorter1, sorter2);
      assertNotSame(sorter1, sorter0);
      
      instanceEvent0.setStatus(2);
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("Sorter", sorter0.getCustomName());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertEquals(2, instanceEvent0.getStatus());
      assertFalse(sorter0.equals((Object)sorter2));
      assertFalse(sorter0.equals((Object)sorter1));
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertNotSame(sorter0, sorter2);
      assertNotSame(sorter0, sorter1);
      
      instanceEvent0.setStatus(2);
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("Sorter", sorter0.getCustomName());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertEquals(2, instanceEvent0.getStatus());
      assertFalse(sorter0.equals((Object)sorter2));
      assertFalse(sorter0.equals((Object)sorter1));
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertNotSame(sorter0, sorter2);
      assertNotSame(sorter0, sorter1);
      
      Appender appender0 = new Appender();
      assertNotNull(appender0);
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertEquals("Appender", appender0.getCustomName());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      
      InstanceEvent instanceEvent1 = appender0.m_ie;
      assertNotNull(instanceEvent1);
      assertEquals(0, instanceEvent1.getStatus());
      assertFalse(instanceEvent1.equals((Object)instanceEvent0));
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertNotSame(instanceEvent1, instanceEvent0);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("Sorter", sorter0.getCustomName());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("10000", sorter0.getBufferSize());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertEquals(2, instanceEvent0.getStatus());
      assertFalse(sorter0.equals((Object)sorter2));
      assertFalse(sorter0.equals((Object)sorter1));
      assertFalse(instanceEvent0.equals((Object)instanceEvent1));
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertNotSame(sorter0, sorter2);
      assertNotSame(sorter0, sorter1);
      assertNotSame(instanceEvent0, instanceEvent1);
      
      Clusterer clusterer0 = new Clusterer();
      assertNotNull(clusterer0);
      assertFalse(clusterer0.isFocusTraversalPolicyProvider());
      assertEquals("EM", clusterer0.getCustomName());
      assertFalse(clusterer0.isBusy());
      assertEquals("<html><font color=blue>Simple EM (expectation maximisation) class.\n\nEM assigns a probability distribution to each instance which indicates the probability of it belonging to each of the clusters</font><br><br> EM can decide how many clusters to create by cross validation, or you may specify apriori how many clusters to generate.<br><br>The cross validation performed to determine the number of clusters is done in the following steps:<br>1. the number of clusters is set to 1<br>2. the training set is split randomly into 10 folds.<br>3. EM is performed 10 times using the 10 folds the usual CV way.<br>4. the loglikelihood is averaged over all 10 results.<br>5.<br>if loglikelihood has increased the number of clusters is increased by 1 and the program continues at step 2.<br><br><br>The number of folds is fixed to 10, as long as the number of instances in the training set is not smaller 10.<br>If this is the case the number of folds is set equal to the number of instances.<br></html>", clusterer0.globalInfo());
      assertFalse(clusterer0.getIgnoreRepaint());
      assertFalse(clusterer0.isFocusTraversalPolicySet());
      assertTrue(clusterer0.getFocusTraversalKeysEnabled());
      assertFalse(clusterer0.hasIncomingBatchInstances());
      assertFalse(clusterer0.isFocusCycleRoot());
      
      filter0.removeTestSetListener(clusterer0);
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(clusterer0.isFocusTraversalPolicyProvider());
      assertEquals("EM", clusterer0.getCustomName());
      assertFalse(clusterer0.isBusy());
      assertEquals("<html><font color=blue>Simple EM (expectation maximisation) class.\n\nEM assigns a probability distribution to each instance which indicates the probability of it belonging to each of the clusters</font><br><br> EM can decide how many clusters to create by cross validation, or you may specify apriori how many clusters to generate.<br><br>The cross validation performed to determine the number of clusters is done in the following steps:<br>1. the number of clusters is set to 1<br>2. the training set is split randomly into 10 folds.<br>3. EM is performed 10 times using the 10 folds the usual CV way.<br>4. the loglikelihood is averaged over all 10 results.<br>5.<br>if loglikelihood has increased the number of clusters is increased by 1 and the program continues at step 2.<br><br><br>The number of folds is fixed to 10, as long as the number of instances in the training set is not smaller 10.<br>If this is the case the number of folds is set equal to the number of instances.<br></html>", clusterer0.globalInfo());
      assertFalse(clusterer0.getIgnoreRepaint());
      assertFalse(clusterer0.isFocusTraversalPolicySet());
      assertTrue(clusterer0.getFocusTraversalKeysEnabled());
      assertFalse(clusterer0.hasIncomingBatchInstances());
      assertFalse(clusterer0.isFocusCycleRoot());
      
      TextField textField0 = null;
      try {
        textField0 = new TextField();
        fail("Expecting exception: HeadlessException");
      
      } catch(HeadlessException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.awt.GraphicsEnvironment", e);
      }
  }
}
