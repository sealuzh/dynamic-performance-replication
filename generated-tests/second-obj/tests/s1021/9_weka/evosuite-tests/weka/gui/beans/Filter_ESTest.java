/*
 * This file was automatically generated by EvoSuite
 * Sat Jul 07 07:56:55 GMT 2018
 */

package weka.gui.beans;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.MockitoExtension.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.awt.AWTEventMulticaster;
import java.awt.Canvas;
import java.awt.Choice;
import java.awt.Component;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.GraphicsConfiguration;
import java.awt.HeadlessException;
import java.awt.PopupMenu;
import java.awt.event.HierarchyBoundsListener;
import java.awt.event.HierarchyListener;
import java.awt.event.InputMethodListener;
import java.awt.event.KeyListener;
import java.awt.event.MouseListener;
import java.awt.image.DirectColorModel;
import java.beans.EventSetDescriptor;
import java.beans.PropertyChangeListener;
import java.beans.beancontext.BeanContext;
import java.io.PrintWriter;
import java.util.Enumeration;
import java.util.Vector;
import javax.accessibility.AccessibleContext;
import javax.swing.JLayeredPane;
import javax.swing.KeyStroke;
import javax.swing.text.DefaultCaret;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockPrintWriter;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.evosuite.runtime.util.SystemInUtil;
import org.junit.runner.RunWith;
import weka.classifiers.bayes.BayesNet;
import weka.classifiers.meta.FilteredClassifier;
import weka.core.AllJavadoc;
import weka.core.Attribute;
import weka.core.ChebyshevDistance;
import weka.core.CheckGOE;
import weka.core.CheckOptionHandler;
import weka.core.Instances;
import weka.core.ManhattanDistance;
import weka.core.MinkowskiDistance;
import weka.core.NormalizableDistance;
import weka.core.OptionHandlerJavadoc;
import weka.core.TestInstances;
import weka.core.converters.CSVLoader;
import weka.core.converters.TextDirectoryLoader;
import weka.filters.AllFilter;
import weka.filters.MultiFilter;
import weka.filters.supervised.attribute.ClassOrder;
import weka.filters.supervised.attribute.Discretize;
import weka.filters.supervised.attribute.NominalToBinary;
import weka.filters.supervised.instance.Resample;
import weka.filters.unsupervised.attribute.Add;
import weka.gui.Logger;
import weka.gui.beans.Appender;
import weka.gui.beans.Associator;
import weka.gui.beans.AttributeSummarizer;
import weka.gui.beans.BeanVisual;
import weka.gui.beans.ClassAssigner;
import weka.gui.beans.ClassValuePicker;
import weka.gui.beans.Classifier;
import weka.gui.beans.ClassifierPerformanceEvaluator;
import weka.gui.beans.Clusterer;
import weka.gui.beans.ConfigurationListener;
import weka.gui.beans.CostBenefitAnalysis;
import weka.gui.beans.CrossValidationFoldMaker;
import weka.gui.beans.DataSetEvent;
import weka.gui.beans.DataVisualizer;
import weka.gui.beans.Filter;
import weka.gui.beans.FlowByExpression;
import weka.gui.beans.InstanceEvent;
import weka.gui.beans.InstanceStreamToBatchMaker;
import weka.gui.beans.KnowledgeFlowApp;
import weka.gui.beans.Loader;
import weka.gui.beans.MetaBean;
import weka.gui.beans.PredictionAppender;
import weka.gui.beans.Saver;
import weka.gui.beans.ScatterPlotMatrix;
import weka.gui.beans.Sorter;
import weka.gui.beans.SubstringLabeler;
import weka.gui.beans.SubstringReplacer;
import weka.gui.beans.TestSetEvent;
import weka.gui.beans.TestSetMaker;
import weka.gui.beans.TextViewer;
import weka.gui.beans.TrainTestSplitMaker;
import weka.gui.beans.TrainingSetEvent;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true) 
public class Filter_ESTest extends Filter_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Filter filter0 = new Filter();
      BayesNet bayesNet0 = new BayesNet();
      Instances instances0 = bayesNet0.m_Instances;
      DataSetEvent dataSetEvent0 = new DataSetEvent(filter0, (Instances) null);
      filter0.acceptDataSet(dataSetEvent0);
      filter0.stop();
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Filter filter0 = new Filter();
      ScatterPlotMatrix scatterPlotMatrix0 = new ScatterPlotMatrix();
      filter0.addTestSetListener(scatterPlotMatrix0);
      filter0.removeTrainingSetListener(scatterPlotMatrix0);
      Sorter sorter0 = new Sorter();
      BeanVisual beanVisual0 = sorter0.getVisual();
      filter0.setVisual(beanVisual0);
      assertEquals("Sorter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.acceptDataSet((DataSetEvent) null);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Filter filter0 = new Filter();
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      filter0.addConfigurationListener(configurationListener0);
      filter0.stop();
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.getWrappedAlgorithm();
      BeanVisual beanVisual0 = filter0.getVisual();
      assertEquals("weka/gui/beans/icons/DefaultFilter.gif", beanVisual0.getIconPath());
      assertEquals("AllFilter", beanVisual0.getText());
      assertEquals("weka/gui/beans/icons/DefaultFilter_animated.gif", beanVisual0.getAnimatedIconPath());
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Filter filter0 = new Filter();
      FlowByExpression flowByExpression0 = new FlowByExpression();
      filter0.addTrainingSetListener(flowByExpression0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Filter filter0 = new Filter();
      CrossValidationFoldMaker crossValidationFoldMaker0 = new CrossValidationFoldMaker();
      filter0.removeDataSourceListener(crossValidationFoldMaker0);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.getWrappedAlgorithm();
      ClassOrder classOrder0 = new ClassOrder();
      filter0.setWrappedAlgorithm(classOrder0);
      filter0.setLog((Logger) null);
      FlowByExpression flowByExpression0 = new FlowByExpression();
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Filter filter0 = new Filter();
      Sorter sorter0 = new Sorter();
      sorter0.getConnectedFormat();
      filter0.eventGeneratable("@relation");
      filter0.setCustomName("@relation");
      KnowledgeFlowApp knowledgeFlowApp0 = KnowledgeFlowApp.getSingleton();
      assertNull(knowledgeFlowApp0);
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Filter filter0 = new Filter();
      HierarchyBoundsListener hierarchyBoundsListener0 = mock(HierarchyBoundsListener.class, new ViolatedAssumptionAnswer());
      HierarchyBoundsListener hierarchyBoundsListener1 = AWTEventMulticaster.add(hierarchyBoundsListener0, hierarchyBoundsListener0);
      AWTEventMulticaster.remove(hierarchyBoundsListener1, hierarchyBoundsListener1);
      filter0.removeHierarchyBoundsListener((HierarchyBoundsListener) null);
      filter0.useDefaultVisual();
      HierarchyBoundsListener hierarchyBoundsListener2 = mock(HierarchyBoundsListener.class, new ViolatedAssumptionAnswer());
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      filter0.removeTestSetListener(trainTestSplitMaker0);
      ManhattanDistance manhattanDistance0 = new ManhattanDistance();
      filter0.disconnectionNotification("", (Object) null);
      TestInstances testInstances0 = new TestInstances();
      ChebyshevDistance chebyshevDistance0 = new ChebyshevDistance();
      DataSetEvent dataSetEvent0 = new DataSetEvent(chebyshevDistance0, (Instances) null);
      filter0.acceptDataSet(dataSetEvent0);
      Filter filter1 = new Filter();
      filter1.getFilter();
      Filter filter2 = new Filter();
      filter1.isBusy();
      Sorter sorter0 = new Sorter();
      InstanceEvent instanceEvent0 = sorter0.m_ie;
      filter1.notifyInstanceListeners(instanceEvent0);
      filter2.addTestSetListener(filter1);
      MultiFilter multiFilter0 = new MultiFilter();
      Sorter sorter1 = new Sorter();
      sorter0.getConnectedFormat();
      FlowByExpression.ExpressionClause.ExpressionType flowByExpression_ExpressionClause_ExpressionType0 = FlowByExpression.ExpressionClause.ExpressionType.LESSTHAN;
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(flowByExpression_ExpressionClause_ExpressionType0, (Instances) null, 21, 0);
      Random.setNextRandom(1);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Filter filter0 = new Filter();
      FileSystemHandling.shouldAllThrowIOExceptions();
      filter0.isBusy();
      Saver saver0 = new Saver();
      ClassOrder classOrder0 = new ClassOrder();
      ClassOrder classOrder1 = new ClassOrder();
      BayesNet bayesNet0 = new BayesNet();
      CrossValidationFoldMaker crossValidationFoldMaker0 = new CrossValidationFoldMaker();
      filter0.addInstanceListener(saver0);
      ClassifierPerformanceEvaluator classifierPerformanceEvaluator0 = new ClassifierPerformanceEvaluator();
      InstanceEvent instanceEvent0 = new InstanceEvent(classifierPerformanceEvaluator0);
      // Undeclared exception!
      try { 
        filter0.notifyInstanceListeners(instanceEvent0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.gui.beans.Saver", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Filter filter0 = new Filter();
      filter0.getAccessibleContext();
      filter0.enumerateRequests();
      filter0.getPropertyChangeListeners();
      InputMethodListener inputMethodListener0 = mock(InputMethodListener.class, new ViolatedAssumptionAnswer());
      AWTEventMulticaster.remove(inputMethodListener0, inputMethodListener0);
      AWTEventMulticaster.add((InputMethodListener) null, (InputMethodListener) null);
      filter0.addInputMethodListener((InputMethodListener) null);
      filter0.acceptTrainingSet((TrainingSetEvent) null);
      filter0.setCustomName("");
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      filter0.addInstanceListener(substringLabeler0);
      filter0.getCustomName();
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      filter0.setWrappedAlgorithm(nominalToBinary0);
      InstanceEvent instanceEvent0 = new InstanceEvent("", (Instances) null);
      filter0.notifyInstanceListeners(instanceEvent0);
      filter0.connectionAllowed("");
      filter0.notifyInstanceListeners(instanceEvent0);
      assertEquals("NominalToBinary", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Filter filter0 = new Filter();
      Sorter sorter0 = new Sorter();
      boolean boolean0 = filter0.eventGeneratable("shh9~&'e@~BDD");
      assertFalse(boolean0);
      
      Clusterer clusterer0 = new Clusterer();
      filter0.connectionNotification("Passing on pending instances...", sorter0);
      PredictionAppender predictionAppender0 = new PredictionAppender();
      filter0.transferFocusDownCycle();
      Classifier classifier0 = new Classifier();
      filter0.removeInstanceListener(sorter0);
      TestSetMaker testSetMaker0 = new TestSetMaker();
      InstanceEvent instanceEvent0 = predictionAppender0.m_instanceEvent;
      filter0.acceptInstance((InstanceEvent) null);
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Filter filter0 = new Filter();
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertNotNull(filter0);
      
      filter0.useDefaultVisual();
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      HierarchyBoundsListener hierarchyBoundsListener0 = mock(HierarchyBoundsListener.class, new ViolatedAssumptionAnswer());
      HierarchyBoundsListener hierarchyBoundsListener1 = mock(HierarchyBoundsListener.class, new ViolatedAssumptionAnswer());
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      OptionHandlerJavadoc optionHandlerJavadoc0 = new OptionHandlerJavadoc();
      assertTrue(optionHandlerJavadoc0.getUseStars());
      assertEquals("weka.core.Javadoc", optionHandlerJavadoc0.getClassname());
      assertFalse(optionHandlerJavadoc0.getSilent());
      assertTrue(optionHandlerJavadoc0.getProlog());
      assertEquals("", optionHandlerJavadoc0.getDir());
      assertNotNull(optionHandlerJavadoc0);
      
      filter0.connectionNotification("e.gw6&YT<5yn0}", optionHandlerJavadoc0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertTrue(optionHandlerJavadoc0.getUseStars());
      assertEquals("weka.core.Javadoc", optionHandlerJavadoc0.getClassname());
      assertFalse(optionHandlerJavadoc0.getSilent());
      assertTrue(optionHandlerJavadoc0.getProlog());
      assertEquals("", optionHandlerJavadoc0.getDir());
      
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      assertTrue(nominalToBinary0.isNewBatch());
      assertFalse(nominalToBinary0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(nominalToBinary0.getTransformAllValues());
      assertFalse(nominalToBinary0.isFirstBatchDone());
      assertFalse(nominalToBinary0.isOutputFormatDefined());
      assertFalse(nominalToBinary0.getBinaryAttributesNominal());
      assertEquals("Whether all nominal values are turned into new attributes, not only if there are more than 2.", nominalToBinary0.transformAllValuesTipText());
      assertEquals("Whether resulting binary attributes will be nominal.", nominalToBinary0.binaryAttributesNominalTipText());
      assertNotNull(nominalToBinary0);
      
      nominalToBinary0.setTransformAllValues(true);
      assertTrue(nominalToBinary0.isNewBatch());
      assertFalse(nominalToBinary0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(nominalToBinary0.isFirstBatchDone());
      assertFalse(nominalToBinary0.isOutputFormatDefined());
      assertFalse(nominalToBinary0.getBinaryAttributesNominal());
      assertEquals("Whether all nominal values are turned into new attributes, not only if there are more than 2.", nominalToBinary0.transformAllValuesTipText());
      assertTrue(nominalToBinary0.getTransformAllValues());
      assertEquals("Whether resulting binary attributes will be nominal.", nominalToBinary0.binaryAttributesNominalTipText());
      
      filter0.setFilter(nominalToBinary0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("NominalToBinary", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Converts all nominal attributes into binary numeric attributes</font><br><br> An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach).<br>Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al.<br>(i.e.<br>taking the average class value associated with each attribute value into account)<br><br>For more information, see:<br><br>L.<br>Breiman, J.H.<br>Friedman, R.A.<br>Olshen, C.J.<br>Stone (1984).<br>Classification and Regression Trees.<br>Wadsworth Inc.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertTrue(nominalToBinary0.isNewBatch());
      assertFalse(nominalToBinary0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(nominalToBinary0.isFirstBatchDone());
      assertFalse(nominalToBinary0.isOutputFormatDefined());
      assertFalse(nominalToBinary0.getBinaryAttributesNominal());
      assertEquals("Whether all nominal values are turned into new attributes, not only if there are more than 2.", nominalToBinary0.transformAllValuesTipText());
      assertTrue(nominalToBinary0.getTransformAllValues());
      assertEquals("Whether resulting binary attributes will be nominal.", nominalToBinary0.binaryAttributesNominalTipText());
      
      Associator associator0 = new Associator();
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      assertFalse(associator0.isFocusCycleRoot());
      assertFalse(associator0.isBusy());
      assertTrue(associator0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      assertEquals("Apriori", associator0.getCustomName());
      assertFalse(associator0.getIgnoreRepaint());
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertNotNull(associator0);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertNotNull(multiFilter0);
      
      filter0.connectionNotification("e.gw6&YT<5yn0}", multiFilter0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("NominalToBinary", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Converts all nominal attributes into binary numeric attributes</font><br><br> An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach).<br>Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al.<br>(i.e.<br>taking the average class value associated with each attribute value into account)<br><br>For more information, see:<br><br>L.<br>Breiman, J.H.<br>Friedman, R.A.<br>Olshen, C.J.<br>Stone (1984).<br>Classification and Regression Trees.<br>Wadsworth Inc.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertTrue(multiFilter0.isNewBatch());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertFalse(multiFilter0.getDebug());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      
      filter0.transferFocusDownCycle();
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("NominalToBinary", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Converts all nominal attributes into binary numeric attributes</font><br><br> An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach).<br>Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al.<br>(i.e.<br>taking the average class value associated with each attribute value into account)<br><br>For more information, see:<br><br>L.<br>Breiman, J.H.<br>Friedman, R.A.<br>Olshen, C.J.<br>Stone (1984).<br>Classification and Regression Trees.<br>Wadsworth Inc.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      Classifier classifier0 = new Classifier();
      assertTrue(classifier0.getUpdateIncrementalClassifier());
      assertFalse(classifier0.getResetIncrementalClassifier());
      assertFalse(classifier0.isFocusCycleRoot());
      assertEquals(2, classifier0.getExecutionSlots());
      assertEquals("ZeroR", classifier0.getCustomName());
      assertFalse(classifier0.getBlockOnLastFold());
      assertFalse(classifier0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Class for building and using a 0-R classifier</font><br><br> Predicts the mean (for a numeric class) or the mode (for a nominal class).<br></html>", classifier0.globalInfo());
      assertEquals("", classifier0.getLoadClassifierFileName());
      assertFalse(classifier0.getIgnoreRepaint());
      assertTrue(classifier0.getFocusTraversalKeysEnabled());
      assertFalse(classifier0.isFocusTraversalPolicySet());
      assertFalse(classifier0.hasIncomingBatchInstances());
      assertFalse(classifier0.hasIncomingStreamInstances());
      assertNotNull(classifier0);
      
      filter0.removeInstanceListener(classifier0);
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("NominalToBinary", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>Converts all nominal attributes into binary numeric attributes</font><br><br> An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach).<br>Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al.<br>(i.e.<br>taking the average class value associated with each attribute value into account)<br><br>For more information, see:<br><br>L.<br>Breiman, J.H.<br>Friedman, R.A.<br>Olshen, C.J.<br>Stone (1984).<br>Classification and Regression Trees.<br>Wadsworth Inc.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertTrue(classifier0.getUpdateIncrementalClassifier());
      assertFalse(classifier0.getResetIncrementalClassifier());
      assertFalse(classifier0.isFocusCycleRoot());
      assertEquals(2, classifier0.getExecutionSlots());
      assertEquals("ZeroR", classifier0.getCustomName());
      assertFalse(classifier0.getBlockOnLastFold());
      assertFalse(classifier0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Class for building and using a 0-R classifier</font><br><br> Predicts the mean (for a numeric class) or the mode (for a nominal class).<br></html>", classifier0.globalInfo());
      assertEquals("", classifier0.getLoadClassifierFileName());
      assertFalse(classifier0.getIgnoreRepaint());
      assertTrue(classifier0.getFocusTraversalKeysEnabled());
      assertFalse(classifier0.isFocusTraversalPolicySet());
      assertFalse(classifier0.hasIncomingBatchInstances());
      assertFalse(classifier0.hasIncomingStreamInstances());
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertNotNull(filter0);
      
      TestInstances testInstances0 = new TestInstances();
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(1, testInstances0.getSeed());
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertNotNull(testInstances0);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertNotNull(textDirectoryLoader0);
      
      Instances instances0 = textDirectoryLoader0.getStructure();
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertNotNull(instances0);
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(testInstances0, instances0);
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(1, testInstances0.getSeed());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertNotNull(trainingSetEvent0);
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(1, testInstances0.getSeed());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals(0, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      
      Enumeration enumeration0 = filter0.enumerateRequests();
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertNotNull(enumeration0);
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      filter0.removeConfigurationListener(configurationListener0);
      assertFalse(filter0.isBusy());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      
      Random.setNextRandom(10021);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertNotNull(filter0);
      
      AccessibleContext accessibleContext0 = filter0.getAccessibleContext();
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertNotNull(accessibleContext0);
      
      Enumeration enumeration0 = filter0.enumerateRequests();
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertNotNull(enumeration0);
      
      PropertyChangeListener[] propertyChangeListenerArray0 = filter0.getPropertyChangeListeners();
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertNotNull(propertyChangeListenerArray0);
      
      filter0.acceptTrainingSet((TrainingSetEvent) null);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      Canvas canvas0 = new Canvas((GraphicsConfiguration) null);
      assertEquals(0.5F, canvas0.getAlignmentY(), 0.01F);
      assertFalse(canvas0.getIgnoreRepaint());
      assertFalse(canvas0.isDoubleBuffered());
      assertEquals(0.5F, canvas0.getAlignmentX(), 0.01F);
      assertFalse(canvas0.isOpaque());
      assertEquals(0, canvas0.getWidth());
      assertEquals(Component.BaselineResizeBehavior.OTHER, canvas0.getBaselineResizeBehavior());
      assertTrue(canvas0.getFocusTraversalKeysEnabled());
      assertEquals(0, canvas0.getY());
      assertEquals(0, canvas0.getHeight());
      assertEquals(0, canvas0.getX());
      assertNotNull(canvas0);
      
      Loader loader0 = new Loader();
      assertFalse(loader0.isFocusTraversalPolicyProvider());
      assertFalse(loader0.isFocusCycleRoot());
      assertFalse(loader0.getIgnoreRepaint());
      assertFalse(loader0.isFocusTraversalPolicySet());
      assertTrue(loader0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Reads a source that is in arff (attribute relation file format) format</font> <br></html>", loader0.globalInfo());
      assertEquals("ArffLoader", loader0.getCustomName());
      assertFalse(loader0.isBusy());
      assertNotNull(loader0);
      
      Instances instances0 = loader0.getStructure("T7p<[{uA[y1D_U03K\"");
      assertFalse(loader0.isFocusTraversalPolicyProvider());
      assertFalse(loader0.isFocusCycleRoot());
      assertFalse(loader0.getIgnoreRepaint());
      assertFalse(loader0.isFocusTraversalPolicySet());
      assertTrue(loader0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Reads a source that is in arff (attribute relation file format) format</font> <br></html>", loader0.globalInfo());
      assertEquals("ArffLoader", loader0.getCustomName());
      assertFalse(loader0.isBusy());
      assertNull(instances0);
      
      int int0 = 2;
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(canvas0, (Instances) null, 2, 2, 2, 2);
      assertEquals(0.5F, canvas0.getAlignmentY(), 0.01F);
      assertFalse(canvas0.getIgnoreRepaint());
      assertFalse(canvas0.isDoubleBuffered());
      assertEquals(0.5F, canvas0.getAlignmentX(), 0.01F);
      assertFalse(canvas0.isOpaque());
      assertEquals(0, canvas0.getWidth());
      assertEquals(Component.BaselineResizeBehavior.OTHER, canvas0.getBaselineResizeBehavior());
      assertTrue(canvas0.getFocusTraversalKeysEnabled());
      assertEquals(0, canvas0.getY());
      assertEquals(0, canvas0.getHeight());
      assertEquals(0, canvas0.getX());
      assertEquals(2, trainingSetEvent0.getSetNumber());
      assertEquals(2, trainingSetEvent0.getRunNumber());
      assertEquals(2, trainingSetEvent0.getMaxSetNumber());
      assertEquals(2, trainingSetEvent0.getMaxRunNumber());
      assertFalse(trainingSetEvent0.isStructureOnly());
      assertNotNull(trainingSetEvent0);
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals(0.5F, canvas0.getAlignmentY(), 0.01F);
      assertFalse(canvas0.getIgnoreRepaint());
      assertFalse(canvas0.isDoubleBuffered());
      assertEquals(0.5F, canvas0.getAlignmentX(), 0.01F);
      assertFalse(canvas0.isOpaque());
      assertEquals(0, canvas0.getWidth());
      assertEquals(Component.BaselineResizeBehavior.OTHER, canvas0.getBaselineResizeBehavior());
      assertTrue(canvas0.getFocusTraversalKeysEnabled());
      assertEquals(0, canvas0.getY());
      assertEquals(0, canvas0.getHeight());
      assertEquals(0, canvas0.getX());
      assertEquals(2, trainingSetEvent0.getSetNumber());
      assertEquals(2, trainingSetEvent0.getRunNumber());
      assertEquals(2, trainingSetEvent0.getMaxSetNumber());
      assertEquals(2, trainingSetEvent0.getMaxRunNumber());
      assertFalse(trainingSetEvent0.isStructureOnly());
      
      Filter filter1 = new Filter();
      assertFalse(filter1.equals((Object)filter0));
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isBusy());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isFocusCycleRoot());
      assertNotNull(filter1);
      
      Classifier classifier0 = new Classifier();
      assertEquals("ZeroR", classifier0.getCustomName());
      assertFalse(classifier0.hasIncomingBatchInstances());
      assertFalse(classifier0.getResetIncrementalClassifier());
      assertTrue(classifier0.getUpdateIncrementalClassifier());
      assertFalse(classifier0.isFocusTraversalPolicyProvider());
      assertFalse(classifier0.getBlockOnLastFold());
      assertEquals("", classifier0.getLoadClassifierFileName());
      assertFalse(classifier0.getIgnoreRepaint());
      assertFalse(classifier0.isFocusCycleRoot());
      assertFalse(classifier0.hasIncomingStreamInstances());
      assertEquals(2, classifier0.getExecutionSlots());
      assertFalse(classifier0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Class for building and using a 0-R classifier</font><br><br> Predicts the mean (for a numeric class) or the mode (for a nominal class).<br></html>", classifier0.globalInfo());
      assertTrue(classifier0.getFocusTraversalKeysEnabled());
      assertNotNull(classifier0);
      
      filter0.removeInstanceListener(classifier0);
      assertFalse(filter0.equals((Object)filter1));
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("ZeroR", classifier0.getCustomName());
      assertFalse(classifier0.hasIncomingBatchInstances());
      assertFalse(classifier0.getResetIncrementalClassifier());
      assertTrue(classifier0.getUpdateIncrementalClassifier());
      assertFalse(classifier0.isFocusTraversalPolicyProvider());
      assertFalse(classifier0.getBlockOnLastFold());
      assertEquals("", classifier0.getLoadClassifierFileName());
      assertFalse(classifier0.getIgnoreRepaint());
      assertFalse(classifier0.isFocusCycleRoot());
      assertFalse(classifier0.hasIncomingStreamInstances());
      assertEquals(2, classifier0.getExecutionSlots());
      assertFalse(classifier0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Class for building and using a 0-R classifier</font><br><br> Predicts the mean (for a numeric class) or the mode (for a nominal class).<br></html>", classifier0.globalInfo());
      assertTrue(classifier0.getFocusTraversalKeysEnabled());
      assertNotSame(filter0, filter1);
      
      Choice choice0 = null;
      try {
        choice0 = new Choice();
        fail("Expecting exception: HeadlessException");
      
      } catch(HeadlessException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.awt.GraphicsEnvironment", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertNotNull(filter0);
      
      Sorter sorter0 = new Sorter();
      assertNull(sorter0.getSortDetails());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isFocusCycleRoot());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("Sorter", sorter0.getCustomName());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isBusy());
      assertNotNull(sorter0);
      
      boolean boolean0 = filter0.eventGeneratable("j");
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(boolean0);
      
      Clusterer clusterer0 = new Clusterer();
      assertFalse(clusterer0.hasIncomingBatchInstances());
      assertFalse(clusterer0.isFocusTraversalPolicyProvider());
      assertFalse(clusterer0.isFocusTraversalPolicySet());
      assertFalse(clusterer0.isFocusCycleRoot());
      assertFalse(clusterer0.isBusy());
      assertEquals("EM", clusterer0.getCustomName());
      assertFalse(clusterer0.getIgnoreRepaint());
      assertTrue(clusterer0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Simple EM (expectation maximisation) class.\n\nEM assigns a probability distribution to each instance which indicates the probability of it belonging to each of the clusters</font><br><br> EM can decide how many clusters to create by cross validation, or you may specify apriori how many clusters to generate.<br><br>The cross validation performed to determine the number of clusters is done in the following steps:<br>1. the number of clusters is set to 1<br>2. the training set is split randomly into 10 folds.<br>3. EM is performed 10 times using the 10 folds the usual CV way.<br>4. the loglikelihood is averaged over all 10 results.<br>5.<br>if loglikelihood has increased the number of clusters is increased by 1 and the program continues at step 2.<br><br><br>The number of folds is fixed to 10, as long as the number of instances in the training set is not smaller 10.<br>If this is the case the number of folds is set equal to the number of instances.<br></html>", clusterer0.globalInfo());
      assertNotNull(clusterer0);
      
      filter0.connectionNotification("shh9~&'e@~BDD", "Passing on pending instances...");
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      
      PredictionAppender predictionAppender0 = new PredictionAppender();
      assertFalse(predictionAppender0.isBusy());
      assertFalse(predictionAppender0.isFocusTraversalPolicyProvider());
      assertFalse(predictionAppender0.isFocusCycleRoot());
      assertFalse(predictionAppender0.isFocusTraversalPolicySet());
      assertFalse(predictionAppender0.getIgnoreRepaint());
      assertEquals("append probabilities rather than labels for discrete class predictions", predictionAppender0.appendPredictedProbabilitiesTipText());
      assertEquals("PredictionAppender", predictionAppender0.getCustomName());
      assertTrue(predictionAppender0.getFocusTraversalKeysEnabled());
      assertFalse(predictionAppender0.getAppendPredictedProbabilities());
      assertEquals("Accepts batch or incremental classifier events and produces a new data set with classifier predictions appended.", predictionAppender0.globalInfo());
      assertNotNull(predictionAppender0);
      
      filter0.transferFocusDownCycle();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      
      filter0.removeInstanceListener(sorter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertFalse(sorter0.isFocusCycleRoot());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("Sorter", sorter0.getCustomName());
      assertEquals("", sorter0.getTempDirectory());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertFalse(sorter0.isBusy());
      
      TestSetMaker testSetMaker0 = new TestSetMaker();
      assertEquals("TestSetMaker", testSetMaker0.getCustomName());
      assertFalse(testSetMaker0.getIgnoreRepaint());
      assertEquals("Designate an incoming data set as a test set.", testSetMaker0.globalInfo());
      assertFalse(testSetMaker0.isFocusTraversalPolicyProvider());
      assertFalse(testSetMaker0.isFocusTraversalPolicySet());
      assertFalse(testSetMaker0.isFocusCycleRoot());
      assertFalse(testSetMaker0.isBusy());
      assertTrue(testSetMaker0.getFocusTraversalKeysEnabled());
      assertNotNull(testSetMaker0);
      
      TrainTestSplitMaker trainTestSplitMaker0 = new TrainTestSplitMaker();
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertNotNull(trainTestSplitMaker0);
      
      InstanceEvent instanceEvent0 = new InstanceEvent(trainTestSplitMaker0);
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertNotNull(instanceEvent0);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("The randomization seed", trainTestSplitMaker0.seedTipText());
      assertEquals(1, trainTestSplitMaker0.getSeed());
      assertEquals(66.0, trainTestSplitMaker0.getTrainPercent(), 0.01);
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicySet());
      assertTrue(trainTestSplitMaker0.getFocusTraversalKeysEnabled());
      assertEquals("Split an incoming data set into separate train and test sets.", trainTestSplitMaker0.globalInfo());
      assertFalse(trainTestSplitMaker0.getIgnoreRepaint());
      assertFalse(trainTestSplitMaker0.isFocusCycleRoot());
      assertEquals("TrainTestSplitMaker", trainTestSplitMaker0.getCustomName());
      assertFalse(trainTestSplitMaker0.isBusy());
      assertEquals("The percentage of data to go into the training set", trainTestSplitMaker0.trainPercentTipText());
      assertFalse(trainTestSplitMaker0.isFocusTraversalPolicyProvider());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      Filter filter0 = new Filter();
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertNotNull(filter0);
      
      filter0.acceptInstance((InstanceEvent) null);
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      
      weka.gui.LogPanel logPanel0 = new weka.gui.LogPanel();
      assertTrue(logPanel0.getFocusTraversalKeysEnabled());
      assertFalse(logPanel0.isFocusTraversalPolicyProvider());
      assertFalse(logPanel0.getIgnoreRepaint());
      assertFalse(logPanel0.isFocusTraversalPolicySet());
      assertFalse(logPanel0.isFocusCycleRoot());
      assertNotNull(logPanel0);
      
      filter0.setLog(logPanel0);
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(logPanel0.getFocusTraversalKeysEnabled());
      assertFalse(logPanel0.isFocusTraversalPolicyProvider());
      assertFalse(logPanel0.getIgnoreRepaint());
      assertFalse(logPanel0.isFocusTraversalPolicySet());
      assertFalse(logPanel0.isFocusCycleRoot());
      
      String string0 = filter0.globalInfo();
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", string0);
      assertNotNull(string0);
      
      byte[] byteArray0 = new byte[6];
      byteArray0[0] = (byte)59;
      byteArray0[3] = (byte) (-87);
      byteArray0[4] = (byte) (-31);
      byteArray0[5] = (byte) (-31);
      boolean boolean0 = FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      assertArrayEquals(new byte[] {(byte)59, (byte)0, (byte)0, (byte) (-87), (byte) (-31), (byte) (-31)}, byteArray0);
      assertFalse(boolean0);
      
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      assertFalse(nominalToBinary0.getTransformAllValues());
      assertEquals("Whether resulting binary attributes will be nominal.", nominalToBinary0.binaryAttributesNominalTipText());
      assertTrue(nominalToBinary0.isNewBatch());
      assertFalse(nominalToBinary0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(nominalToBinary0.isFirstBatchDone());
      assertFalse(nominalToBinary0.isOutputFormatDefined());
      assertEquals("Whether all nominal values are turned into new attributes, not only if there are more than 2.", nominalToBinary0.transformAllValuesTipText());
      assertFalse(nominalToBinary0.getBinaryAttributesNominal());
      assertNotNull(nominalToBinary0);
      
      nominalToBinary0.setTransformAllValues(true);
      assertEquals("Whether resulting binary attributes will be nominal.", nominalToBinary0.binaryAttributesNominalTipText());
      assertTrue(nominalToBinary0.isNewBatch());
      assertFalse(nominalToBinary0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(nominalToBinary0.isFirstBatchDone());
      assertFalse(nominalToBinary0.isOutputFormatDefined());
      assertEquals("Whether all nominal values are turned into new attributes, not only if there are more than 2.", nominalToBinary0.transformAllValuesTipText());
      assertTrue(nominalToBinary0.getTransformAllValues());
      assertFalse(nominalToBinary0.getBinaryAttributesNominal());
      
      filter0.setFilter(nominalToBinary0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Converts all nominal attributes into binary numeric attributes</font><br><br> An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach).<br>Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al.<br>(i.e.<br>taking the average class value associated with each attribute value into account)<br><br>For more information, see:<br><br>L.<br>Breiman, J.H.<br>Friedman, R.A.<br>Olshen, C.J.<br>Stone (1984).<br>Classification and Regression Trees.<br>Wadsworth Inc.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("NominalToBinary", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("Whether resulting binary attributes will be nominal.", nominalToBinary0.binaryAttributesNominalTipText());
      assertTrue(nominalToBinary0.isNewBatch());
      assertFalse(nominalToBinary0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(nominalToBinary0.isFirstBatchDone());
      assertFalse(nominalToBinary0.isOutputFormatDefined());
      assertEquals("Whether all nominal values are turned into new attributes, not only if there are more than 2.", nominalToBinary0.transformAllValuesTipText());
      assertTrue(nominalToBinary0.getTransformAllValues());
      assertFalse(nominalToBinary0.getBinaryAttributesNominal());
      
      Associator associator0 = new Associator();
      assertTrue(associator0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      assertFalse(associator0.getIgnoreRepaint());
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertFalse(associator0.isFocusCycleRoot());
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      assertFalse(associator0.isBusy());
      assertEquals("Apriori", associator0.getCustomName());
      assertNotNull(associator0);
      
      BeanVisual beanVisual0 = filter0.getVisual();
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Converts all nominal attributes into binary numeric attributes</font><br><br> An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach).<br>Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al.<br>(i.e.<br>taking the average class value associated with each attribute value into account)<br><br>For more information, see:<br><br>L.<br>Breiman, J.H.<br>Friedman, R.A.<br>Olshen, C.J.<br>Stone (1984).<br>Classification and Regression Trees.<br>Wadsworth Inc.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("NominalToBinary", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(beanVisual0.isFocusTraversalPolicyProvider());
      assertFalse(beanVisual0.isFocusCycleRoot());
      assertFalse(beanVisual0.getIgnoreRepaint());
      assertEquals("weka/gui/beans/icons/filters.supervised.attribute.NominalToBinary.gif", beanVisual0.getIconPath());
      assertFalse(beanVisual0.isFocusTraversalPolicySet());
      assertEquals("NominalToBinary", beanVisual0.getText());
      assertTrue(beanVisual0.getFocusTraversalKeysEnabled());
      assertEquals("weka/gui/beans/icons/filters.supervised.attribute.NominalToBinary_animated.gif", beanVisual0.getAnimatedIconPath());
      assertEquals(1, BeanVisual.SOUTH_CONNECTOR);
      assertEquals(0, BeanVisual.NORTH_CONNECTOR);
      assertEquals(3, BeanVisual.WEST_CONNECTOR);
      assertEquals(2, BeanVisual.EAST_CONNECTOR);
      assertNotNull(beanVisual0);
      
      boolean boolean1 = filter0.isBusy();
      assertTrue(boolean1 == boolean0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Converts all nominal attributes into binary numeric attributes</font><br><br> An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach).<br>Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al.<br>(i.e.<br>taking the average class value associated with each attribute value into account)<br><br>For more information, see:<br><br>L.<br>Breiman, J.H.<br>Friedman, R.A.<br>Olshen, C.J.<br>Stone (1984).<br>Classification and Regression Trees.<br>Wadsworth Inc.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("NominalToBinary", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(boolean1);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertNotNull(substringLabeler0);
      
      substringLabeler0.list();
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      
      InstanceEvent instanceEvent0 = substringLabeler0.m_ie;
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertNotNull(instanceEvent0);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Converts all nominal attributes into binary numeric attributes</font><br><br> An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach).<br>Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al.<br>(i.e.<br>taking the average class value associated with each attribute value into account)<br><br>For more information, see:<br><br>L.<br>Breiman, J.H.<br>Friedman, R.A.<br>Olshen, C.J.<br>Stone (1984).<br>Classification and Regression Trees.<br>Wadsworth Inc.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("NominalToBinary", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      filter0.setFilter(nominalToBinary0);
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Converts all nominal attributes into binary numeric attributes</font><br><br> An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach).<br>Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al.<br>(i.e.<br>taking the average class value associated with each attribute value into account)<br><br>For more information, see:<br><br>L.<br>Breiman, J.H.<br>Friedman, R.A.<br>Olshen, C.J.<br>Stone (1984).<br>Classification and Regression Trees.<br>Wadsworth Inc.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("NominalToBinary", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("Whether resulting binary attributes will be nominal.", nominalToBinary0.binaryAttributesNominalTipText());
      assertTrue(nominalToBinary0.isNewBatch());
      assertFalse(nominalToBinary0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(nominalToBinary0.isFirstBatchDone());
      assertFalse(nominalToBinary0.isOutputFormatDefined());
      assertEquals("Whether all nominal values are turned into new attributes, not only if there are more than 2.", nominalToBinary0.transformAllValuesTipText());
      assertTrue(nominalToBinary0.getTransformAllValues());
      assertFalse(nominalToBinary0.getBinaryAttributesNominal());
      
      // Undeclared exception!
      try { 
        filter0.setWrappedAlgorithm((Object) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertNotNull(filter0);
      
      weka.gui.LogPanel logPanel0 = new weka.gui.LogPanel();
      assertFalse(logPanel0.isFocusCycleRoot());
      assertFalse(logPanel0.isFocusTraversalPolicyProvider());
      assertFalse(logPanel0.getIgnoreRepaint());
      assertFalse(logPanel0.isFocusTraversalPolicySet());
      assertTrue(logPanel0.getFocusTraversalKeysEnabled());
      assertNotNull(logPanel0);
      
      filter0.setLog(logPanel0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(logPanel0.isFocusCycleRoot());
      assertFalse(logPanel0.isFocusTraversalPolicyProvider());
      assertFalse(logPanel0.getIgnoreRepaint());
      assertFalse(logPanel0.isFocusTraversalPolicySet());
      assertTrue(logPanel0.getFocusTraversalKeysEnabled());
      
      byte[] byteArray0 = new byte[6];
      byteArray0[0] = (byte)59;
      byteArray0[2] = (byte) (-31);
      HierarchyListener[] hierarchyListenerArray0 = filter0.getHierarchyListeners();
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertNotNull(hierarchyListenerArray0);
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer0.isBusy());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertNotNull(substringReplacer0);
      
      InstanceEvent instanceEvent0 = substringReplacer0.m_ie;
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertNotNull(instanceEvent0);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer0.isBusy());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      filter0.setDebugGraphicsOptions((byte)59);
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      
      Filter filter1 = new Filter();
      assertFalse(filter1.equals((Object)filter0));
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isBusy());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.getIgnoreRepaint());
      assertEquals("AllFilter", filter1.getCustomName());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertNotNull(filter1);
      
      filter1.addMouseListener((MouseListener) null);
      assertFalse(filter1.equals((Object)filter0));
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isBusy());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.getIgnoreRepaint());
      assertEquals("AllFilter", filter1.getCustomName());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertNotSame(filter1, filter0);
      
      Canvas canvas0 = new Canvas();
      assertEquals(0, canvas0.getX());
      assertEquals(0, canvas0.getHeight());
      assertEquals(0, canvas0.getY());
      assertFalse(canvas0.isDoubleBuffered());
      assertEquals(0.5F, canvas0.getAlignmentX(), 0.01F);
      assertTrue(canvas0.getFocusTraversalKeysEnabled());
      assertEquals(Component.BaselineResizeBehavior.OTHER, canvas0.getBaselineResizeBehavior());
      assertFalse(canvas0.isOpaque());
      assertEquals(0, canvas0.getWidth());
      assertFalse(canvas0.getIgnoreRepaint());
      assertEquals(0.5F, canvas0.getAlignmentY(), 0.01F);
      assertNotNull(canvas0);
      
      // Undeclared exception!
      try { 
        filter0.performRequest("~%,+&GO,?jwC;?P*%");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ~%,+&GO,?jwC;?P*% not supported (Filter)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/mnt/gaiagpfs/users/homedirs/apanichella/Evosuite_performance/Dataset/gordon_script_sum/projects/9_weka");
      boolean boolean0 = FileSystemHandling.appendStringToFile(evoSuiteFile0, "0BxqEIf");
      assertFalse(boolean0);
      
      Filter filter0 = new Filter();
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertNotNull(filter0);
      
      TestInstances testInstances0 = new TestInstances();
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertFalse(testInstances0.getNoClass());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertNotNull(testInstances0);
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      filter0.addConfigurationListener(configurationListener0);
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      
      Enumeration enumeration0 = filter0.enumerateRequests();
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertNotNull(enumeration0);
      
      MultiFilter multiFilter0 = new MultiFilter();
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      assertNotNull(multiFilter0);
      
      filter0.setFilter(multiFilter0);
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("MultiFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(multiFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter0.debugTipText());
      assertFalse(multiFilter0.isFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter0.filtersTipText());
      assertTrue(multiFilter0.isNewBatch());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter0.globalInfo());
      assertFalse(multiFilter0.isOutputFormatDefined());
      assertFalse(multiFilter0.getDebug());
      
      CostBenefitAnalysis costBenefitAnalysis0 = new CostBenefitAnalysis();
      assertFalse(costBenefitAnalysis0.isFocusCycleRoot());
      assertEquals("Visualize performance charts (such as ROC).", costBenefitAnalysis0.globalInfo());
      assertFalse(costBenefitAnalysis0.isFocusTraversalPolicySet());
      assertFalse(costBenefitAnalysis0.isFocusTraversalPolicyProvider());
      assertFalse(costBenefitAnalysis0.getIgnoreRepaint());
      assertFalse(costBenefitAnalysis0.isBusy());
      assertTrue(costBenefitAnalysis0.getFocusTraversalKeysEnabled());
      assertEquals("CostBenefitAnalysis", costBenefitAnalysis0.getCustomName());
      assertNotNull(costBenefitAnalysis0);
      
      KeyStroke[] keyStrokeArray0 = costBenefitAnalysis0.getRegisteredKeyStrokes();
      assertFalse(costBenefitAnalysis0.isFocusCycleRoot());
      assertEquals("Visualize performance charts (such as ROC).", costBenefitAnalysis0.globalInfo());
      assertFalse(costBenefitAnalysis0.isFocusTraversalPolicySet());
      assertFalse(costBenefitAnalysis0.isFocusTraversalPolicyProvider());
      assertFalse(costBenefitAnalysis0.getIgnoreRepaint());
      assertFalse(costBenefitAnalysis0.isBusy());
      assertTrue(costBenefitAnalysis0.getFocusTraversalKeysEnabled());
      assertEquals("CostBenefitAnalysis", costBenefitAnalysis0.getCustomName());
      assertNotNull(keyStrokeArray0);
      
      CostBenefitAnalysis costBenefitAnalysis1 = new CostBenefitAnalysis();
      assertFalse(costBenefitAnalysis1.equals((Object)costBenefitAnalysis0));
      assertFalse(costBenefitAnalysis1.getIgnoreRepaint());
      assertFalse(costBenefitAnalysis1.isFocusTraversalPolicySet());
      assertTrue(costBenefitAnalysis1.getFocusTraversalKeysEnabled());
      assertFalse(costBenefitAnalysis1.isBusy());
      assertEquals("CostBenefitAnalysis", costBenefitAnalysis1.getCustomName());
      assertFalse(costBenefitAnalysis1.isFocusCycleRoot());
      assertFalse(costBenefitAnalysis1.isFocusTraversalPolicyProvider());
      assertEquals("Visualize performance charts (such as ROC).", costBenefitAnalysis1.globalInfo());
      assertNotNull(costBenefitAnalysis1);
      
      BeanVisual beanVisual0 = costBenefitAnalysis1.m_visual;
      assertEquals("weka/gui/beans/icons/ModelPerformanceChart_animated.gif", beanVisual0.getAnimatedIconPath());
      assertEquals("CostBenefitAnalysis", beanVisual0.getText());
      assertFalse(beanVisual0.isFocusTraversalPolicySet());
      assertTrue(beanVisual0.getFocusTraversalKeysEnabled());
      assertFalse(beanVisual0.getIgnoreRepaint());
      assertFalse(beanVisual0.isFocusCycleRoot());
      assertEquals("weka/gui/beans/icons/ModelPerformanceChart.gif", beanVisual0.getIconPath());
      assertFalse(beanVisual0.isFocusTraversalPolicyProvider());
      assertEquals(3, BeanVisual.WEST_CONNECTOR);
      assertEquals(2, BeanVisual.EAST_CONNECTOR);
      assertEquals(0, BeanVisual.NORTH_CONNECTOR);
      assertEquals(1, BeanVisual.SOUTH_CONNECTOR);
      assertNotNull(beanVisual0);
      
      BeanVisual beanVisual1 = new BeanVisual("0BxqEIf", " ", "weka/gui/beans/icons/");
      assertFalse(beanVisual1.equals((Object)beanVisual0));
      assertFalse(beanVisual1.isFocusTraversalPolicyProvider());
      assertEquals("weka/gui/beans/icons/", beanVisual1.getAnimatedIconPath());
      assertEquals(" ", beanVisual1.getIconPath());
      assertFalse(beanVisual1.getIgnoreRepaint());
      assertEquals("0BxqEIf", beanVisual1.getText());
      assertFalse(beanVisual1.isFocusTraversalPolicySet());
      assertTrue(beanVisual1.getFocusTraversalKeysEnabled());
      assertFalse(beanVisual1.isFocusCycleRoot());
      assertEquals(0, BeanVisual.NORTH_CONNECTOR);
      assertEquals(1, BeanVisual.SOUTH_CONNECTOR);
      assertEquals(3, BeanVisual.WEST_CONNECTOR);
      assertEquals(2, BeanVisual.EAST_CONNECTOR);
      assertNotNull(beanVisual1);
      
      filter0.setVisual(beanVisual0);
      assertFalse(costBenefitAnalysis1.equals((Object)costBenefitAnalysis0));
      assertFalse(beanVisual0.equals((Object)beanVisual1));
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertEquals("CostBenefitAnalysis", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(costBenefitAnalysis1.getIgnoreRepaint());
      assertFalse(costBenefitAnalysis1.isFocusTraversalPolicySet());
      assertTrue(costBenefitAnalysis1.getFocusTraversalKeysEnabled());
      assertFalse(costBenefitAnalysis1.isBusy());
      assertEquals("CostBenefitAnalysis", costBenefitAnalysis1.getCustomName());
      assertFalse(costBenefitAnalysis1.isFocusCycleRoot());
      assertFalse(costBenefitAnalysis1.isFocusTraversalPolicyProvider());
      assertEquals("Visualize performance charts (such as ROC).", costBenefitAnalysis1.globalInfo());
      assertEquals("weka/gui/beans/icons/ModelPerformanceChart_animated.gif", beanVisual0.getAnimatedIconPath());
      assertEquals("CostBenefitAnalysis", beanVisual0.getText());
      assertFalse(beanVisual0.isFocusTraversalPolicySet());
      assertTrue(beanVisual0.getFocusTraversalKeysEnabled());
      assertFalse(beanVisual0.getIgnoreRepaint());
      assertFalse(beanVisual0.isFocusCycleRoot());
      assertEquals("weka/gui/beans/icons/ModelPerformanceChart.gif", beanVisual0.getIconPath());
      assertFalse(beanVisual0.isFocusTraversalPolicyProvider());
      assertNotSame(costBenefitAnalysis1, costBenefitAnalysis0);
      assertNotSame(beanVisual0, beanVisual1);
      assertEquals(3, BeanVisual.WEST_CONNECTOR);
      assertEquals(2, BeanVisual.EAST_CONNECTOR);
      assertEquals(0, BeanVisual.NORTH_CONNECTOR);
      assertEquals(1, BeanVisual.SOUTH_CONNECTOR);
      
      MultiFilter multiFilter1 = (MultiFilter)filter0.getWrappedAlgorithm();
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertEquals("CostBenefitAnalysis", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(multiFilter1.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("Turns on output of debugging information.", multiFilter1.debugTipText());
      assertEquals("Applies several filters successively. In case all supplied filters are StreamableFilters, it will act as a streamable one, too.", multiFilter1.globalInfo());
      assertTrue(multiFilter1.isNewBatch());
      assertFalse(multiFilter1.getDebug());
      assertFalse(multiFilter1.isOutputFormatDefined());
      assertFalse(multiFilter1.isFirstBatchDone());
      assertEquals("The base filters to be used.", multiFilter1.filtersTipText());
      assertSame(multiFilter1, multiFilter0);
      assertNotNull(multiFilter1);
      
      String string0 = filter0.globalInfo();
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", filter0.globalInfo());
      assertEquals("CostBenefitAnalysis", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>Applies several filters successively</font><br><br> In case all supplied filters are StreamableFilters, it will act as a streamable one, too.<br></html>", string0);
      assertNotNull(string0);
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertNotNull(filter0);
      
      filter0.acceptInstance((InstanceEvent) null);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      
      Filter filter1 = new Filter();
      assertFalse(filter1.equals((Object)filter0));
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertNotNull(filter1);
      
      FlowByExpression flowByExpression0 = new FlowByExpression();
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertFalse(flowByExpression0.isBusy());
      assertEquals("", flowByExpression0.getExpressionString());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      assertNotNull(flowByExpression0);
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      weka.gui.LogPanel logPanel0 = new weka.gui.LogPanel();
      assertFalse(logPanel0.getIgnoreRepaint());
      assertTrue(logPanel0.getFocusTraversalKeysEnabled());
      assertFalse(logPanel0.isFocusTraversalPolicySet());
      assertFalse(logPanel0.isFocusTraversalPolicyProvider());
      assertFalse(logPanel0.isFocusCycleRoot());
      assertNotNull(logPanel0);
      
      filter0.setLog(logPanel0);
      assertFalse(filter0.equals((Object)filter1));
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(logPanel0.getIgnoreRepaint());
      assertTrue(logPanel0.getFocusTraversalKeysEnabled());
      assertFalse(logPanel0.isFocusTraversalPolicySet());
      assertFalse(logPanel0.isFocusTraversalPolicyProvider());
      assertFalse(logPanel0.isFocusCycleRoot());
      assertNotSame(filter0, filter1);
      
      String string0 = filter1.globalInfo();
      assertFalse(filter1.equals((Object)filter0));
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertNotSame(filter1, filter0);
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", string0);
      assertNotNull(string0);
      
      byte[] byteArray0 = new byte[6];
      boolean boolean1 = FileSystemHandling.appendDataToFile((EvoSuiteFile) null, byteArray0);
      assertFalse(boolean1 == boolean0);
      assertArrayEquals(new byte[] {(byte)0, (byte)0, (byte)0, (byte)0, (byte)0, (byte)0}, byteArray0);
      assertFalse(boolean1);
      
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      assertTrue(nominalToBinary0.isNewBatch());
      assertFalse(nominalToBinary0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(nominalToBinary0.isFirstBatchDone());
      assertFalse(nominalToBinary0.getTransformAllValues());
      assertEquals("Whether all nominal values are turned into new attributes, not only if there are more than 2.", nominalToBinary0.transformAllValuesTipText());
      assertEquals("Whether resulting binary attributes will be nominal.", nominalToBinary0.binaryAttributesNominalTipText());
      assertFalse(nominalToBinary0.getBinaryAttributesNominal());
      assertFalse(nominalToBinary0.isOutputFormatDefined());
      assertNotNull(nominalToBinary0);
      
      nominalToBinary0.setTransformAllValues(false);
      assertTrue(nominalToBinary0.isNewBatch());
      assertFalse(nominalToBinary0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(nominalToBinary0.isFirstBatchDone());
      assertFalse(nominalToBinary0.getTransformAllValues());
      assertEquals("Whether all nominal values are turned into new attributes, not only if there are more than 2.", nominalToBinary0.transformAllValuesTipText());
      assertEquals("Whether resulting binary attributes will be nominal.", nominalToBinary0.binaryAttributesNominalTipText());
      assertFalse(nominalToBinary0.getBinaryAttributesNominal());
      assertFalse(nominalToBinary0.isOutputFormatDefined());
      
      filter0.setFilter(nominalToBinary0);
      assertFalse(filter0.equals((Object)filter1));
      assertEquals("<html><font color=blue>Converts all nominal attributes into binary numeric attributes</font><br><br> An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach).<br>Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al.<br>(i.e.<br>taking the average class value associated with each attribute value into account)<br><br>For more information, see:<br><br>L.<br>Breiman, J.H.<br>Friedman, R.A.<br>Olshen, C.J.<br>Stone (1984).<br>Classification and Regression Trees.<br>Wadsworth Inc.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("NominalToBinary", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(nominalToBinary0.isNewBatch());
      assertFalse(nominalToBinary0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(nominalToBinary0.isFirstBatchDone());
      assertFalse(nominalToBinary0.getTransformAllValues());
      assertEquals("Whether all nominal values are turned into new attributes, not only if there are more than 2.", nominalToBinary0.transformAllValuesTipText());
      assertEquals("Whether resulting binary attributes will be nominal.", nominalToBinary0.binaryAttributesNominalTipText());
      assertFalse(nominalToBinary0.getBinaryAttributesNominal());
      assertFalse(nominalToBinary0.isOutputFormatDefined());
      assertNotSame(filter0, filter1);
      
      Associator associator0 = new Associator();
      assertFalse(associator0.isFocusTraversalPolicyProvider());
      assertFalse(associator0.isBusy());
      assertFalse(associator0.isFocusCycleRoot());
      assertFalse(associator0.getIgnoreRepaint());
      assertFalse(associator0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>Class implementing an Apriori-type algorithm</font><br><br> Iteratively reduces the minimum support until it finds the required number of rules with the given minimum confidence.<br>The algorithm has an option to mine class association rules.<br>It is adapted as explained in the second reference.<br><br>For more information see:<br><br>R.<br>Agrawal, R.<br>Srikant: Fast Algorithms for Mining Association Rules in Large Databases.<br>In: 20th International Conference on Very Large Data Bases, 478-499, 1994.<br><br>Bing Liu, Wynne Hsu, Yiming Ma: Integrating Classification and Association Rule Mining.<br>In: Fourth International Conference on Knowledge Discovery and Data Mining, 80-86, 1998.<br></html>", associator0.globalInfo());
      assertTrue(associator0.getFocusTraversalKeysEnabled());
      assertEquals("Apriori", associator0.getCustomName());
      assertNotNull(associator0);
      
      filter1.addDataSourceListener(filter0);
      assertFalse(filter0.equals((Object)filter1));
      assertFalse(filter1.equals((Object)filter0));
      assertEquals("<html><font color=blue>Converts all nominal attributes into binary numeric attributes</font><br><br> An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach).<br>Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al.<br>(i.e.<br>taking the average class value associated with each attribute value into account)<br><br>For more information, see:<br><br>L.<br>Breiman, J.H.<br>Friedman, R.A.<br>Olshen, C.J.<br>Stone (1984).<br>Classification and Regression Trees.<br>Wadsworth Inc.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("NominalToBinary", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertNotSame(filter0, filter1);
      assertNotSame(filter1, filter0);
      
      BeanVisual beanVisual0 = filter1.getVisual();
      assertFalse(filter1.equals((Object)filter0));
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusCycleRoot());
      assertFalse(filter1.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(beanVisual0.getIgnoreRepaint());
      assertFalse(beanVisual0.isFocusCycleRoot());
      assertFalse(beanVisual0.isFocusTraversalPolicyProvider());
      assertEquals("AllFilter", beanVisual0.getText());
      assertEquals("weka/gui/beans/icons/DefaultFilter_animated.gif", beanVisual0.getAnimatedIconPath());
      assertFalse(beanVisual0.isFocusTraversalPolicySet());
      assertTrue(beanVisual0.getFocusTraversalKeysEnabled());
      assertEquals("weka/gui/beans/icons/DefaultFilter.gif", beanVisual0.getIconPath());
      assertNotSame(filter1, filter0);
      assertEquals(0, BeanVisual.NORTH_CONNECTOR);
      assertEquals(1, BeanVisual.SOUTH_CONNECTOR);
      assertEquals(2, BeanVisual.EAST_CONNECTOR);
      assertEquals(3, BeanVisual.WEST_CONNECTOR);
      assertNotNull(beanVisual0);
      
      boolean boolean2 = filter0.isBusy();
      assertTrue(boolean2 == boolean1);
      assertFalse(boolean2 == boolean0);
      assertFalse(filter0.equals((Object)filter1));
      assertEquals("<html><font color=blue>Converts all nominal attributes into binary numeric attributes</font><br><br> An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach).<br>Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al.<br>(i.e.<br>taking the average class value associated with each attribute value into account)<br><br>For more information, see:<br><br>L.<br>Breiman, J.H.<br>Friedman, R.A.<br>Olshen, C.J.<br>Stone (1984).<br>Classification and Regression Trees.<br>Wadsworth Inc.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("NominalToBinary", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertNotSame(filter0, filter1);
      assertFalse(boolean2);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertNotNull(substringLabeler0);
      
      substringLabeler0.list();
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      
      InstanceEvent instanceEvent0 = substringLabeler0.m_ie;
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertNotNull(instanceEvent0);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.equals((Object)filter1));
      assertEquals("<html><font color=blue>Converts all nominal attributes into binary numeric attributes</font><br><br> An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach).<br>Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al.<br>(i.e.<br>taking the average class value associated with each attribute value into account)<br><br>For more information, see:<br><br>L.<br>Breiman, J.H.<br>Friedman, R.A.<br>Olshen, C.J.<br>Stone (1984).<br>Classification and Regression Trees.<br>Wadsworth Inc.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("NominalToBinary", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isBusy());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertEquals(0, instanceEvent0.getStatus());
      assertNotSame(filter0, filter1);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      Filter filter2 = new Filter();
      assertFalse(filter2.equals((Object)filter1));
      assertFalse(filter2.equals((Object)filter0));
      assertFalse(filter2.isFocusCycleRoot());
      assertFalse(filter2.isFocusTraversalPolicySet());
      assertFalse(filter2.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter2.globalInfo());
      assertFalse(filter2.getIgnoreRepaint());
      assertEquals("AllFilter", filter2.getCustomName());
      assertTrue(filter2.getFocusTraversalKeysEnabled());
      assertFalse(filter2.isBusy());
      assertNotNull(filter2);
      
      FilteredClassifier filteredClassifier0 = new FilteredClassifier();
      assertEquals(1, filteredClassifier0.graphType());
      assertEquals("Class for running an arbitrary classifier on data that has been passed through an arbitrary filter. Like the classifier, the structure of the filter is based exclusively on the training data and test instances will be processed by the filter without changing their structure.", filteredClassifier0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", filteredClassifier0.debugTipText());
      assertFalse(filteredClassifier0.getDebug());
      assertEquals("The base classifier to be used.", filteredClassifier0.classifierTipText());
      assertEquals("The filter to be used.", filteredClassifier0.filterTipText());
      assertNotNull(filteredClassifier0);
      
      Discretize discretize0 = (Discretize)filteredClassifier0.getFilter();
      assertEquals(1, filteredClassifier0.graphType());
      assertEquals("Class for running an arbitrary classifier on data that has been passed through an arbitrary filter. Like the classifier, the structure of the filter is based exclusively on the training data and test instances will be processed by the filter without changing their structure.", filteredClassifier0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", filteredClassifier0.debugTipText());
      assertFalse(filteredClassifier0.getDebug());
      assertEquals("The base classifier to be used.", filteredClassifier0.classifierTipText());
      assertEquals("The filter to be used.", filteredClassifier0.filterTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getUseBetterEncoding());
      assertEquals("Use Kononenko's MDL criterion. If set to false uses the Fayyad & Irani criterion.", discretize0.useKononenkoTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.getUseKononenko());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Uses a more efficient split point encoding.", discretize0.useBetterEncodingTipText());
      assertNotNull(discretize0);
      
      filter1.setFilter(discretize0);
      assertFalse(filter1.equals((Object)filter0));
      assertFalse(filter1.equals((Object)filter2));
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes</font><br><br> Discretization is by Fayyad & Irani's MDL method (the default).<br><br>For more information, see:<br><br>Usama M.<br>Fayyad, Keki B.<br>Irani: Multi-interval discretization of continuousvalued attributes for classification learning.<br>In: Thirteenth International Joint Conference on Articial Intelligence, 1022-1027, 1993.<br><br>Igor Kononenko: On Biases in Estimating Multi-Valued Attributes.<br>In: 14th International Joint Conference on Articial Intelligence, 1034-1040, 1995.<br></html>", filter1.globalInfo());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertFalse(filter1.isFocusCycleRoot());
      assertEquals("Discretize", filter1.getCustomName());
      assertFalse(filter1.isBusy());
      assertEquals(1, filteredClassifier0.graphType());
      assertEquals("Class for running an arbitrary classifier on data that has been passed through an arbitrary filter. Like the classifier, the structure of the filter is based exclusively on the training data and test instances will be processed by the filter without changing their structure.", filteredClassifier0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", filteredClassifier0.debugTipText());
      assertFalse(filteredClassifier0.getDebug());
      assertEquals("The base classifier to be used.", filteredClassifier0.classifierTipText());
      assertEquals("The filter to be used.", filteredClassifier0.filterTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getUseBetterEncoding());
      assertEquals("Use Kononenko's MDL criterion. If set to false uses the Fayyad & Irani criterion.", discretize0.useKononenkoTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.getUseKononenko());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Uses a more efficient split point encoding.", discretize0.useBetterEncodingTipText());
      assertNotSame(filter1, filter0);
      assertNotSame(filter1, filter2);
      
      TestSetEvent testSetEvent0 = new TestSetEvent(discretize0, (Instances) null, (-1745), 10000);
      assertEquals(1, filteredClassifier0.graphType());
      assertEquals("Class for running an arbitrary classifier on data that has been passed through an arbitrary filter. Like the classifier, the structure of the filter is based exclusively on the training data and test instances will be processed by the filter without changing their structure.", filteredClassifier0.globalInfo());
      assertEquals("If set to true, classifier may output additional info to the console.", filteredClassifier0.debugTipText());
      assertFalse(filteredClassifier0.getDebug());
      assertEquals("The base classifier to be used.", filteredClassifier0.classifierTipText());
      assertEquals("The filter to be used.", filteredClassifier0.filterTipText());
      assertEquals("Set attribute selection mode. If false, only selected (numeric) attributes in the range will be discretized; if true, only non-selected attributes will be discretized.", discretize0.invertSelectionTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", discretize0.attributeIndicesTipText());
      assertFalse(discretize0.getUseBetterEncoding());
      assertEquals("Use Kononenko's MDL criterion. If set to false uses the Fayyad & Irani criterion.", discretize0.useKononenkoTipText());
      assertEquals("Use bin numbers (eg BXofY) rather than ranges for for discretized attributes", discretize0.useBinNumbersTipText());
      assertEquals("Make resulting attributes binary.", discretize0.makeBinaryTipText());
      assertTrue(discretize0.isNewBatch());
      assertFalse(discretize0.mayRemoveInstanceAfterFirstBatchDone());
      assertFalse(discretize0.getMakeBinary());
      assertFalse(discretize0.getUseKononenko());
      assertFalse(discretize0.isOutputFormatDefined());
      assertFalse(discretize0.getUseBinNumbers());
      assertFalse(discretize0.isFirstBatchDone());
      assertEquals("Uses a more efficient split point encoding.", discretize0.useBetterEncodingTipText());
      assertEquals(1, testSetEvent0.getRunNumber());
      assertEquals(10000, testSetEvent0.getMaxSetNumber());
      assertEquals((-1745), testSetEvent0.getSetNumber());
      assertFalse(testSetEvent0.isStructureOnly());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertNotNull(testSetEvent0);
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertNotNull(filter0);
      
      boolean boolean0 = filter0.eventGeneratable("configuration");
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertTrue(boolean0);
      
      boolean boolean1 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean1 == boolean0);
      assertTrue(boolean1);
      
      GraphicsConfiguration graphicsConfiguration0 = filter0.getGraphicsConfiguration();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertNull(graphicsConfiguration0);
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      Filter filter0 = new Filter();
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertNotNull(filter0);
      
      MetaBean metaBean0 = new MetaBean();
      assertFalse(metaBean0.isFocusTraversalPolicySet());
      assertFalse(metaBean0.isFocusCycleRoot());
      assertEquals("Group", metaBean0.getCustomName());
      assertTrue(metaBean0.getFocusTraversalKeysEnabled());
      assertFalse(metaBean0.getIgnoreRepaint());
      assertFalse(metaBean0.isFocusTraversalPolicyProvider());
      assertNotNull(metaBean0);
      
      KeyListener keyListener0 = AWTEventMulticaster.add((KeyListener) null, (KeyListener) null);
      assertNull(keyListener0);
      
      KeyListener keyListener1 = AWTEventMulticaster.add((KeyListener) null, (KeyListener) null);
      assertNull(keyListener1);
      
      ManhattanDistance manhattanDistance0 = new ManhattanDistance();
      assertEquals("", manhattanDistance0.toString());
      assertFalse(manhattanDistance0.getDontNormalize());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", manhattanDistance0.attributeIndicesTipText());
      assertEquals("Set attribute selection mode. If false, only selected attributes in the range will be used in the distance calculation; if true, only non-selected attributes will be used for the calculation.", manhattanDistance0.invertSelectionTipText());
      assertFalse(manhattanDistance0.rangesSet());
      assertEquals("Whether if the normalization of attributes should be turned off for distance calculation (Default: false i.e. attribute values are normalized). ", manhattanDistance0.dontNormalizeTipText());
      assertEquals(2, NormalizableDistance.R_WIDTH);
      assertEquals(0, NormalizableDistance.R_MIN);
      assertEquals(1, NormalizableDistance.R_MAX);
      assertNotNull(manhattanDistance0);
      
      filter0.connectionNotification("FUVO@]DVrt[*JJ", "FUVO@]DVrt[*JJ");
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      assertFalse(nominalToBinary0.getBinaryAttributesNominal());
      assertEquals("Whether resulting binary attributes will be nominal.", nominalToBinary0.binaryAttributesNominalTipText());
      assertEquals("Whether all nominal values are turned into new attributes, not only if there are more than 2.", nominalToBinary0.transformAllValuesTipText());
      assertFalse(nominalToBinary0.isOutputFormatDefined());
      assertFalse(nominalToBinary0.getTransformAllValues());
      assertFalse(nominalToBinary0.isFirstBatchDone());
      assertTrue(nominalToBinary0.isNewBatch());
      assertFalse(nominalToBinary0.mayRemoveInstanceAfterFirstBatchDone());
      assertNotNull(nominalToBinary0);
      
      boolean boolean0 = filter0.eventGeneratable("FUVO@]DVrt[*JJ");
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertTrue(boolean0);
      
      filter0.useDefaultVisual();
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertNotNull(filter0);
      
      boolean boolean0 = FileSystemHandling.setPermissions((EvoSuiteFile) null, true, true, true);
      assertFalse(boolean0);
      
      // Undeclared exception!
      try { 
        filter0.connectionAllowed((EventSetDescriptor) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertNotNull(filter0);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertNotNull(textDirectoryLoader0);
      
      Instances instances0 = textDirectoryLoader0.getStructure();
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertNotNull(instances0);
      
      String[] stringArray0 = new String[8];
      stringArray0[0] = "@relation";
      stringArray0[1] = "@data";
      stringArray0[2] = ".bsi";
      stringArray0[3] = "@data";
      stringArray0[4] = "@data";
      stringArray0[5] = "@data";
      stringArray0[6] = "@relation";
      stringArray0[7] = "@relation";
      TestSetEvent testSetEvent0 = new TestSetEvent(filter0, instances0, (-2468), (-2468));
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, testSetEvent0.getRunNumber());
      assertTrue(testSetEvent0.isStructureOnly());
      assertEquals((-2468), testSetEvent0.getMaxSetNumber());
      assertEquals((-2468), testSetEvent0.getSetNumber());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertNotNull(testSetEvent0);
      
      filter0.acceptTestSet(testSetEvent0);
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numInstances());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertEquals(0, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, testSetEvent0.getRunNumber());
      assertTrue(testSetEvent0.isStructureOnly());
      assertEquals((-2468), testSetEvent0.getMaxSetNumber());
      assertEquals((-2468), testSetEvent0.getSetNumber());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      
      AllFilter allFilter0 = (AllFilter)filter0.getFilter();
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(allFilter0.isOutputFormatDefined());
      assertFalse(allFilter0.isFirstBatchDone());
      assertEquals("An instance filter that passes all instances through unmodified. Primarily for testing purposes.", allFilter0.globalInfo());
      assertTrue(allFilter0.isNewBatch());
      assertFalse(allFilter0.mayRemoveInstanceAfterFirstBatchDone());
      assertNotNull(allFilter0);
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertNotNull(filter0);
      
      TestInstances testInstances0 = new TestInstances();
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertFalse(testInstances0.getNoClass());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getClassType());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertNotNull(testInstances0);
      
      TextDirectoryLoader textDirectoryLoader0 = new TextDirectoryLoader();
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertNotNull(textDirectoryLoader0);
      
      Instances instances0 = textDirectoryLoader0.getStructure();
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertNotNull(instances0);
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(testInstances0, instances0);
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertFalse(testInstances0.getNoClass());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getClassType());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumAttributes());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertNotNull(trainingSetEvent0);
      
      trainingSetEvent0.m_maxRunNumber = (-2);
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertFalse(testInstances0.getNoClass());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getClassType());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumAttributes());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals((-2), trainingSetEvent0.getMaxRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertFalse(testInstances0.getNoClass());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getClassType());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumAttributes());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertEquals((-2), trainingSetEvent0.getMaxRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertTrue(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      filter0.addConfigurationListener(configurationListener0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      
      MetaBean metaBean0 = new MetaBean();
      assertFalse(metaBean0.getIgnoreRepaint());
      assertTrue(metaBean0.getFocusTraversalKeysEnabled());
      assertEquals("Group", metaBean0.getCustomName());
      assertFalse(metaBean0.isFocusTraversalPolicySet());
      assertFalse(metaBean0.isFocusCycleRoot());
      assertFalse(metaBean0.isFocusTraversalPolicyProvider());
      assertNotNull(metaBean0);
      
      boolean boolean0 = metaBean0.isFocusOwner();
      assertFalse(metaBean0.getIgnoreRepaint());
      assertTrue(metaBean0.getFocusTraversalKeysEnabled());
      assertEquals("Group", metaBean0.getCustomName());
      assertFalse(metaBean0.isFocusTraversalPolicySet());
      assertFalse(metaBean0.isFocusCycleRoot());
      assertFalse(metaBean0.isFocusTraversalPolicyProvider());
      assertFalse(boolean0);
      
      Vector vector0 = metaBean0.getBeansInOutputs();
      assertFalse(metaBean0.getIgnoreRepaint());
      assertTrue(metaBean0.getFocusTraversalKeysEnabled());
      assertEquals("Group", metaBean0.getCustomName());
      assertFalse(metaBean0.isFocusTraversalPolicySet());
      assertFalse(metaBean0.isFocusCycleRoot());
      assertFalse(metaBean0.isFocusTraversalPolicyProvider());
      assertEquals(0, vector0.size());
      assertEquals(10, vector0.capacity());
      assertEquals("[]", vector0.toString());
      assertTrue(vector0.isEmpty());
      assertNotNull(vector0);
      
      filter0.disconnectionNotification(".arff", vector0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(metaBean0.getIgnoreRepaint());
      assertTrue(metaBean0.getFocusTraversalKeysEnabled());
      assertEquals("Group", metaBean0.getCustomName());
      assertFalse(metaBean0.isFocusTraversalPolicySet());
      assertFalse(metaBean0.isFocusCycleRoot());
      assertFalse(metaBean0.isFocusTraversalPolicyProvider());
      assertEquals(0, vector0.size());
      assertEquals(10, vector0.capacity());
      assertEquals("[]", vector0.toString());
      assertTrue(vector0.isEmpty());
      
      Cursor cursor0 = filter0.getCursor();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("Default Cursor", cursor0.getName());
      assertEquals(0, cursor0.getType());
      assertNotNull(cursor0);
      
      Resample resample0 = new Resample();
      assertTrue(resample0.isNewBatch());
      assertFalse(resample0.isFirstBatchDone());
      assertEquals("Sets the random number seed for subsampling.", resample0.randomSeedTipText());
      assertFalse(resample0.getInvertSelection());
      assertEquals(1, resample0.getRandomSeed());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample0.globalInfo());
      assertFalse(resample0.isOutputFormatDefined());
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample0.invertSelectionTipText());
      assertFalse(resample0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals(0.0, resample0.getBiasToUniformClass(), 0.01);
      assertEquals(100.0, resample0.getSampleSizePercent(), 0.01);
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample0.biasToUniformClassTipText());
      assertFalse(resample0.getNoReplacement());
      assertEquals("Disables the replacement of instances.", resample0.noReplacementTipText());
      assertEquals("The subsample size as a percentage of the original set.", resample0.sampleSizePercentTipText());
      assertNotNull(resample0);
      
      filter0.setFilter(resample0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory</font><br><br> The number of instances in the generated dataset may be specified.<br>The dataset must have a nominal class attribute.<br>If not, use the unsupervised version.<br>The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution.<br>When used in batch mode (i.e.<br>in the FilteredClassifier), subsequent batches are NOT resampled.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Resample", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertTrue(resample0.isNewBatch());
      assertFalse(resample0.isFirstBatchDone());
      assertEquals("Sets the random number seed for subsampling.", resample0.randomSeedTipText());
      assertFalse(resample0.getInvertSelection());
      assertEquals(1, resample0.getRandomSeed());
      assertEquals("Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled.", resample0.globalInfo());
      assertFalse(resample0.isOutputFormatDefined());
      assertEquals("Inverts the selection (only if instances are drawn WITHOUT replacement).", resample0.invertSelectionTipText());
      assertFalse(resample0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals(0.0, resample0.getBiasToUniformClass(), 0.01);
      assertEquals(100.0, resample0.getSampleSizePercent(), 0.01);
      assertEquals("Whether to use bias towards a uniform class. A value of 0 leaves the class distribution as-is, a value of 1 ensures the class distribution is uniform in the output data.", resample0.biasToUniformClassTipText());
      assertFalse(resample0.getNoReplacement());
      assertEquals("Disables the replacement of instances.", resample0.noReplacementTipText());
      assertEquals("The subsample size as a percentage of the original set.", resample0.sampleSizePercentTipText());
      
      CheckGOE checkGOE0 = new CheckGOE();
      assertFalse(checkGOE0.getSilent());
      assertFalse(checkGOE0.getDebug());
      assertFalse(checkGOE0.getSuccess());
      assertNotNull(checkGOE0);
      
      filter0.setDoubleBuffered(false);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory</font><br><br> The number of instances in the generated dataset may be specified.<br>The dataset must have a nominal class attribute.<br>If not, use the unsupervised version.<br>The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution.<br>When used in batch mode (i.e.<br>in the FilteredClassifier), subsequent batches are NOT resampled.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Resample", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      
      DirectColorModel directColorModel0 = (DirectColorModel)filter0.getColorModel();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory</font><br><br> The number of instances in the generated dataset may be specified.<br>The dataset must have a nominal class attribute.<br>If not, use the unsupervised version.<br>The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution.<br>When used in batch mode (i.e.<br>in the FilteredClassifier), subsequent batches are NOT resampled.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Resample", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals(3, directColorModel0.getTransparency());
      assertTrue(directColorModel0.hasAlpha());
      assertEquals(3, directColorModel0.getTransferType());
      assertEquals(3, directColorModel0.getNumColorComponents());
      assertEquals(65280, directColorModel0.getGreenMask());
      assertEquals(32, directColorModel0.getPixelSize());
      assertEquals((-16777216), directColorModel0.getAlphaMask());
      assertEquals(255, directColorModel0.getBlueMask());
      assertEquals(16711680, directColorModel0.getRedMask());
      assertFalse(directColorModel0.isAlphaPremultiplied());
      assertEquals(4, directColorModel0.getNumComponents());
      assertNotNull(directColorModel0);
      
      TrainingSetEvent trainingSetEvent1 = new TrainingSetEvent(filter0, instances0);
      assertFalse(trainingSetEvent1.equals((Object)trainingSetEvent0));
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory</font><br><br> The number of instances in the generated dataset may be specified.<br>The dataset must have a nominal class attribute.<br>If not, use the unsupervised version.<br>The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution.<br>When used in batch mode (i.e.<br>in the FilteredClassifier), subsequent batches are NOT resampled.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Resample", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertTrue(trainingSetEvent1.isStructureOnly());
      assertEquals(1, trainingSetEvent1.getMaxRunNumber());
      assertEquals(0, trainingSetEvent1.getSetNumber());
      assertEquals(1, trainingSetEvent1.getRunNumber());
      assertEquals(0, trainingSetEvent1.getMaxSetNumber());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertNotNull(trainingSetEvent1);
      
      FlowByExpression.ExpressionClause.ExpressionType flowByExpression_ExpressionClause_ExpressionType0 = FlowByExpression.ExpressionClause.ExpressionType.LESSTHAN;
      Random.setNextRandom((-497));
      TestSetEvent testSetEvent0 = new TestSetEvent(trainingSetEvent1, instances0);
      assertFalse(trainingSetEvent1.equals((Object)trainingSetEvent0));
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory</font><br><br> The number of instances in the generated dataset may be specified.<br>The dataset must have a nominal class attribute.<br>If not, use the unsupervised version.<br>The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution.<br>When used in batch mode (i.e.<br>in the FilteredClassifier), subsequent batches are NOT resampled.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Resample", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertTrue(trainingSetEvent1.isStructureOnly());
      assertEquals(1, trainingSetEvent1.getMaxRunNumber());
      assertEquals(0, trainingSetEvent1.getSetNumber());
      assertEquals(1, trainingSetEvent1.getRunNumber());
      assertEquals(0, trainingSetEvent1.getMaxSetNumber());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertEquals(1, testSetEvent0.getRunNumber());
      assertTrue(testSetEvent0.isStructureOnly());
      assertEquals(0, testSetEvent0.getSetNumber());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertEquals(0, testSetEvent0.getMaxSetNumber());
      assertNotNull(testSetEvent0);
      
      Integer integer0 = JLayeredPane.PALETTE_LAYER;
      assertEquals(100, (int)integer0);
      assertNotNull(integer0);
      
      DataSetEvent dataSetEvent0 = new DataSetEvent(integer0, instances0);
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(dataSetEvent0.isStructureOnly());
      assertNotNull(dataSetEvent0);
      
      filter0.acceptDataSet(dataSetEvent0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("<html><font color=blue>Produces a random subsample of a dataset using either sampling with replacement or without replacement.\nThe original dataset must fit entirely in memory</font><br><br> The number of instances in the generated dataset may be specified.<br>The dataset must have a nominal class attribute.<br>If not, use the unsupervised version.<br>The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution.<br>When used in batch mode (i.e.<br>in the FilteredClassifier), subsequent batches are NOT resampled.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("Resample", filter0.getCustomName());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(textDirectoryLoader0.getOutputFilename());
      assertEquals("Whether to store the filename in an additional attribute.", textDirectoryLoader0.outputFilenameTipText());
      assertFalse(textDirectoryLoader0.getDebug());
      assertEquals("Whether to print additional debug information to the console.", textDirectoryLoader0.debugTipText());
      assertEquals("Directories", textDirectoryLoader0.getFileDescription());
      assertEquals("The character set to use when reading text files (eg UTF-8) - leave blank to use the default character set.", textDirectoryLoader0.charSetTipText());
      assertEquals("Loads all text files in a directory and uses the subdirectory names as class labels. The content of the text files will be stored in a String attribute, the filename can be stored as well.", textDirectoryLoader0.globalInfo());
      assertEquals("", textDirectoryLoader0.getCharSet());
      assertEquals(0, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, instances0.numClasses());
      assertEquals("_mnt_gaiagpfs_users_homedirs_apanichella_Evosuite_performance_Dataset_gordon_script_sum_projects_9_weka", instances0.relationName());
      assertTrue(instances0.checkForStringAttributes());
      assertEquals(0, instances0.size());
      assertEquals(0.0, instances0.sumOfWeights(), 0.01);
      assertTrue(dataSetEvent0.isStructureOnly());
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      Filter filter0 = new Filter();
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertNotNull(filter0);
      
      TestInstances testInstances0 = new TestInstances();
      assertEquals(0, testInstances0.getNumString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(20, testInstances0.getNumInstances());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getNoClass());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getClassType());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertNotNull(testInstances0);
      
      Instances instances0 = testInstances0.generate();
      assertEquals(0, testInstances0.getNumString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(20, testInstances0.getNumInstances());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getNoClass());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getClassType());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(20, instances0.size());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numClasses());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numAttributes());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertNotNull(instances0);
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(testInstances0, instances0);
      assertEquals(0, testInstances0.getNumString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(20, testInstances0.getNumInstances());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getNoClass());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getClassType());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(20, instances0.size());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numClasses());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertFalse(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertNotNull(trainingSetEvent0);
      
      filter0.acceptTrainingSet(trainingSetEvent0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(20, testInstances0.getNumInstances());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getNoClass());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getClassType());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(20, instances0.size());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numClasses());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertFalse(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      
      MetaBean metaBean0 = new MetaBean();
      assertFalse(metaBean0.getIgnoreRepaint());
      assertTrue(metaBean0.getFocusTraversalKeysEnabled());
      assertFalse(metaBean0.isFocusTraversalPolicySet());
      assertEquals("Group", metaBean0.getCustomName());
      assertFalse(metaBean0.isFocusCycleRoot());
      assertFalse(metaBean0.isFocusTraversalPolicyProvider());
      assertNotNull(metaBean0);
      
      boolean boolean0 = FileSystemHandling.shouldAllThrowIOExceptions();
      assertTrue(boolean0);
      
      InstanceStreamToBatchMaker instanceStreamToBatchMaker0 = new InstanceStreamToBatchMaker();
      assertEquals("InstanceStreamToBatchMaker", instanceStreamToBatchMaker0.getCustomName());
      assertFalse(instanceStreamToBatchMaker0.getIgnoreRepaint());
      assertTrue(instanceStreamToBatchMaker0.getFocusTraversalKeysEnabled());
      assertFalse(instanceStreamToBatchMaker0.isBusy());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicySet());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicyProvider());
      assertFalse(instanceStreamToBatchMaker0.isFocusCycleRoot());
      assertNotNull(instanceStreamToBatchMaker0);
      
      TestSetEvent testSetEvent0 = new TestSetEvent(instanceStreamToBatchMaker0, instances0);
      assertEquals(0, testInstances0.getNumString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(20, testInstances0.getNumInstances());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getNoClass());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getClassType());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(20, instances0.size());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numClasses());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numAttributes());
      assertEquals("InstanceStreamToBatchMaker", instanceStreamToBatchMaker0.getCustomName());
      assertFalse(instanceStreamToBatchMaker0.getIgnoreRepaint());
      assertTrue(instanceStreamToBatchMaker0.getFocusTraversalKeysEnabled());
      assertFalse(instanceStreamToBatchMaker0.isBusy());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicySet());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicyProvider());
      assertFalse(instanceStreamToBatchMaker0.isFocusCycleRoot());
      assertFalse(testSetEvent0.isStructureOnly());
      assertEquals(1, testSetEvent0.getRunNumber());
      assertEquals(0, testSetEvent0.getSetNumber());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertEquals(0, testSetEvent0.getMaxSetNumber());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertNotNull(testSetEvent0);
      
      filter0.acceptTestSet(testSetEvent0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(20, testInstances0.getNumInstances());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getNoClass());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getClassType());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(20, instances0.size());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numClasses());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numAttributes());
      assertEquals("InstanceStreamToBatchMaker", instanceStreamToBatchMaker0.getCustomName());
      assertFalse(instanceStreamToBatchMaker0.getIgnoreRepaint());
      assertTrue(instanceStreamToBatchMaker0.getFocusTraversalKeysEnabled());
      assertFalse(instanceStreamToBatchMaker0.isBusy());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicySet());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicyProvider());
      assertFalse(instanceStreamToBatchMaker0.isFocusCycleRoot());
      assertFalse(testSetEvent0.isStructureOnly());
      assertEquals(1, testSetEvent0.getRunNumber());
      assertEquals(0, testSetEvent0.getSetNumber());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertEquals(0, testSetEvent0.getMaxSetNumber());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      assertNotNull(fileSystemHandling0);
      
      CSVLoader cSVLoader0 = new CSVLoader();
      assertEquals("The format to use for parsing date values.", cSVLoader0.dateFormatTipText());
      assertEquals("First row of data does not contain attribute names", cSVLoader0.noHeaderRowPresentTipText());
      assertEquals("?", cSVLoader0.getMissingValue());
      assertEquals("\",'", cSVLoader0.getEnclosureCharacters());
      assertEquals("The characters to use as enclosures for strings. E.g. \",'", cSVLoader0.enclosureCharactersTipText());
      assertFalse(cSVLoader0.getUseRelativePath());
      assertEquals("CSV data files", cSVLoader0.getFileDescription());
      assertFalse(cSVLoader0.getNoHeaderRowPresent());
      assertEquals("The placeholder for missing values, default is '?'.", cSVLoader0.missingValueTipText());
      assertEquals("The range of attributes to force to be of type STRING, example ranges: 'first-last', '1,4,7-14,50-last'.", cSVLoader0.stringAttributesTipText());
      assertEquals("", cSVLoader0.getDateFormat());
      assertEquals("Reads a source that is in comma separated format (the default). One can also change the column separator from comma to tab or another character. Assumes that the first row in the file determines the number of and names of the attributes.", cSVLoader0.globalInfo());
      assertEquals("Use relative rather than absolute paths", cSVLoader0.useRelativePathTipText());
      assertEquals("The range of attributes to force to be of type NOMINAL, example ranges: 'first-last', '1,4,7-14,50-last'.", cSVLoader0.nominalAttributesTipText());
      assertEquals(".csv", cSVLoader0.getFileExtension());
      assertEquals("The character to use as separator for the columns/fields (use '\\t' for TAB).", cSVLoader0.fieldSeparatorTipText());
      assertEquals("The range of attributes to force to type STRING, example ranges: 'first-last', '1,4,7-14, 50-last'.", cSVLoader0.dateAttributesTipText());
      assertNotNull(cSVLoader0);
      
      ClassAssigner classAssigner0 = new ClassAssigner();
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertFalse(classAssigner0.isBusy());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertEquals("last", classAssigner0.getClassColumn());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertNotNull(classAssigner0);
      
      FlowByExpression flowByExpression0 = new FlowByExpression();
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertFalse(flowByExpression0.isBusy());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertEquals("", flowByExpression0.getExpressionString());
      assertNotNull(flowByExpression0);
      
      Appender appender0 = new Appender();
      assertFalse(appender0.isFocusTraversalPolicyProvider());
      assertFalse(appender0.isFocusCycleRoot());
      assertFalse(appender0.isBusy());
      assertFalse(appender0.getIgnoreRepaint());
      assertFalse(appender0.isFocusTraversalPolicySet());
      assertTrue(appender0.getFocusTraversalKeysEnabled());
      assertEquals("Appender", appender0.getCustomName());
      assertNotNull(appender0);
      
      CheckGOE checkGOE0 = new CheckGOE();
      assertFalse(checkGOE0.getSilent());
      assertFalse(checkGOE0.getDebug());
      assertFalse(checkGOE0.getSuccess());
      assertNotNull(checkGOE0);
      
      FlowByExpression flowByExpression1 = new FlowByExpression();
      assertFalse(flowByExpression1.equals((Object)flowByExpression0));
      assertEquals("", flowByExpression1.getTrueStepName());
      assertFalse(flowByExpression1.getIgnoreRepaint());
      assertEquals("FlowByExpression", flowByExpression1.getCustomName());
      assertEquals("", flowByExpression1.getFalseStepName());
      assertTrue(flowByExpression1.getFocusTraversalKeysEnabled());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression1.globalInfo());
      assertEquals("", flowByExpression1.getExpressionString());
      assertFalse(flowByExpression1.isFocusTraversalPolicySet());
      assertFalse(flowByExpression1.isBusy());
      assertFalse(flowByExpression1.isFocusCycleRoot());
      assertFalse(flowByExpression1.isFocusTraversalPolicyProvider());
      assertNotNull(flowByExpression1);
      
      Instances instances1 = flowByExpression0.getConnectedFormat();
      assertFalse(flowByExpression0.equals((Object)flowByExpression1));
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertFalse(flowByExpression0.isBusy());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertEquals("", flowByExpression0.getExpressionString());
      assertNotSame(flowByExpression0, flowByExpression1);
      assertNull(instances1);
      
      Instances instances2 = classAssigner0.getConnectedFormat();
      assertFalse(classAssigner0.isFocusCycleRoot());
      assertEquals("Specify the number of the column that contains the class attribute", classAssigner0.classColumnTipText());
      assertFalse(classAssigner0.isBusy());
      assertEquals("Designate which column is to be considered the class column in incoming data.", classAssigner0.globalInfo());
      assertFalse(classAssigner0.isFocusTraversalPolicySet());
      assertEquals("ClassAssigner", classAssigner0.getCustomName());
      assertTrue(classAssigner0.getFocusTraversalKeysEnabled());
      assertFalse(classAssigner0.getIgnoreRepaint());
      assertEquals("last", classAssigner0.getClassColumn());
      assertFalse(classAssigner0.isFocusTraversalPolicyProvider());
      assertNull(instances2);
      
      cSVLoader0.setOptions(testInstances0.DEFAULT_WORDS);
      assertEquals(0, testInstances0.getNumString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(20, testInstances0.getNumInstances());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertFalse(testInstances0.getNoClass());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getClassType());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals("The format to use for parsing date values.", cSVLoader0.dateFormatTipText());
      assertEquals("First row of data does not contain attribute names", cSVLoader0.noHeaderRowPresentTipText());
      assertEquals("?", cSVLoader0.getMissingValue());
      assertEquals("\",'", cSVLoader0.getEnclosureCharacters());
      assertEquals("The characters to use as enclosures for strings. E.g. \",'", cSVLoader0.enclosureCharactersTipText());
      assertFalse(cSVLoader0.getUseRelativePath());
      assertEquals("CSV data files", cSVLoader0.getFileDescription());
      assertFalse(cSVLoader0.getNoHeaderRowPresent());
      assertEquals("The placeholder for missing values, default is '?'.", cSVLoader0.missingValueTipText());
      assertEquals("The range of attributes to force to be of type STRING, example ranges: 'first-last', '1,4,7-14,50-last'.", cSVLoader0.stringAttributesTipText());
      assertEquals("", cSVLoader0.getDateFormat());
      assertEquals("Reads a source that is in comma separated format (the default). One can also change the column separator from comma to tab or another character. Assumes that the first row in the file determines the number of and names of the attributes.", cSVLoader0.globalInfo());
      assertEquals("Use relative rather than absolute paths", cSVLoader0.useRelativePathTipText());
      assertEquals("The range of attributes to force to be of type NOMINAL, example ranges: 'first-last', '1,4,7-14,50-last'.", cSVLoader0.nominalAttributesTipText());
      assertEquals(".csv", cSVLoader0.getFileExtension());
      assertEquals("The character to use as separator for the columns/fields (use '\\t' for TAB).", cSVLoader0.fieldSeparatorTipText());
      assertEquals("The range of attributes to force to type STRING, example ranges: 'first-last', '1,4,7-14, 50-last'.", cSVLoader0.dateAttributesTipText());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      
      ClassValuePicker classValuePicker0 = new ClassValuePicker();
      assertEquals("Designate which class value is to be considered the \"positive\" class value (useful for ROC style curves).", classValuePicker0.globalInfo());
      assertTrue(classValuePicker0.getFocusTraversalKeysEnabled());
      assertFalse(classValuePicker0.isFocusCycleRoot());
      assertFalse(classValuePicker0.isBusy());
      assertFalse(classValuePicker0.isFocusTraversalPolicyProvider());
      assertNull(classValuePicker0.getClassValue());
      assertFalse(classValuePicker0.getIgnoreRepaint());
      assertFalse(classValuePicker0.isFocusTraversalPolicySet());
      assertEquals("ClassValuePicker", classValuePicker0.getCustomName());
      assertNotNull(classValuePicker0);
      
      ClassValuePicker classValuePicker1 = new ClassValuePicker();
      assertFalse(classValuePicker1.equals((Object)classValuePicker0));
      assertFalse(classValuePicker1.isBusy());
      assertFalse(classValuePicker1.isFocusTraversalPolicyProvider());
      assertFalse(classValuePicker1.getIgnoreRepaint());
      assertNull(classValuePicker1.getClassValue());
      assertFalse(classValuePicker1.isFocusTraversalPolicySet());
      assertEquals("ClassValuePicker", classValuePicker1.getCustomName());
      assertEquals("Designate which class value is to be considered the \"positive\" class value (useful for ROC style curves).", classValuePicker1.globalInfo());
      assertTrue(classValuePicker1.getFocusTraversalKeysEnabled());
      assertFalse(classValuePicker1.isFocusCycleRoot());
      assertNotNull(classValuePicker1);
      
      Logger logger0 = classValuePicker1.m_logger;
      assertNull(logger0);
      
      filter0.setLog((Logger) null);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("AllFilter", filter0.getCustomName());
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertNotNull(filter0);
      
      TestInstances testInstances0 = new TestInstances();
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumString());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertNotNull(testInstances0);
      
      TextViewer textViewer0 = new TextViewer();
      assertFalse(textViewer0.getIgnoreRepaint());
      assertEquals("General purpose text display.", textViewer0.globalInfo());
      assertTrue(textViewer0.getFocusTraversalKeysEnabled());
      assertFalse(textViewer0.isFocusTraversalPolicySet());
      assertFalse(textViewer0.isFocusTraversalPolicyProvider());
      assertFalse(textViewer0.isFocusCycleRoot());
      assertFalse(textViewer0.isBusy());
      assertNotNull(textViewer0);
      
      filter0.removeTrainingSetListener(textViewer0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(textViewer0.getIgnoreRepaint());
      assertEquals("General purpose text display.", textViewer0.globalInfo());
      assertTrue(textViewer0.getFocusTraversalKeysEnabled());
      assertFalse(textViewer0.isFocusTraversalPolicySet());
      assertFalse(textViewer0.isFocusTraversalPolicyProvider());
      assertFalse(textViewer0.isFocusCycleRoot());
      assertFalse(textViewer0.isBusy());
      
      Add add0 = new Add();
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertNotNull(add0);
      
      filter0.setFilter(add0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      
      FlowByExpression flowByExpression0 = new FlowByExpression();
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertEquals("", flowByExpression0.getExpressionString());
      assertFalse(flowByExpression0.isBusy());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertNotNull(flowByExpression0);
      
      TestInstances testInstances1 = new TestInstances();
      assertFalse(testInstances1.equals((Object)testInstances0));
      assertEquals(0, testInstances1.getNumNumeric());
      assertEquals(0, testInstances1.getNumRelational());
      assertEquals(2, testInstances1.getNumClasses());
      assertEquals(2, testInstances1.getNumAttributes());
      assertEquals(20, testInstances1.getNumInstances());
      assertEquals(10, testInstances1.getNumInstancesRelational());
      assertEquals(1, testInstances1.getClassType());
      assertEquals(0, testInstances1.getNumDate());
      assertEquals(1, testInstances1.getNumNominal());
      assertEquals(0, testInstances1.getNumRelationalDate());
      assertEquals(2, testInstances1.getNumNominalValues());
      assertEquals(" ", testInstances1.getWordSeparators());
      assertEquals("Testdata", testInstances1.getRelation());
      assertEquals(0, testInstances1.getNumRelationalNumeric());
      assertEquals(0, testInstances1.getNumRelationalString());
      assertEquals(1, testInstances1.getSeed());
      assertEquals(1, testInstances1.getNumRelationalNominal());
      assertEquals((-1), testInstances1.getClassIndex());
      assertFalse(testInstances1.getMultiInstance());
      assertFalse(testInstances1.getNoClass());
      assertEquals(2, testInstances1.getNumRelationalNominalValues());
      assertEquals(0, testInstances1.getNumString());
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertNotNull(testInstances1);
      
      Instances instances0 = testInstances0.generate(",8OWK=TOr/");
      assertFalse(testInstances0.equals((Object)testInstances1));
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumString());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals(20, instances0.numInstances());
      assertEquals(20, instances0.size());
      assertEquals(1, instances0.classIndex());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(2, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertNotSame(testInstances0, testInstances1);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertNotNull(instances0);
      
      DataVisualizer dataVisualizer0 = new DataVisualizer();
      assertFalse(dataVisualizer0.isFocusCycleRoot());
      assertFalse(dataVisualizer0.isFocusTraversalPolicySet());
      assertEquals("500", dataVisualizer0.getOffscreenWidth());
      assertFalse(dataVisualizer0.isBusy());
      assertFalse(dataVisualizer0.getIgnoreRepaint());
      assertEquals("", dataVisualizer0.getOffscreenXAxis());
      assertEquals("", dataVisualizer0.getOffscreenAdditionalOpts());
      assertFalse(dataVisualizer0.isFocusTraversalPolicyProvider());
      assertEquals("400", dataVisualizer0.getOffscreenHeight());
      assertTrue(dataVisualizer0.getFocusTraversalKeysEnabled());
      assertEquals("Visualize incoming data/training/test sets in a 2D scatter plot.", dataVisualizer0.globalInfo());
      assertEquals("", dataVisualizer0.getOffscreenYAxis());
      assertEquals("Weka Chart Renderer", dataVisualizer0.getOffscreenRendererName());
      assertEquals("DataVisualizer", dataVisualizer0.getCustomName());
      assertNotNull(dataVisualizer0);
      
      filter0.addTestSetListener(dataVisualizer0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(dataVisualizer0.isFocusCycleRoot());
      assertFalse(dataVisualizer0.isFocusTraversalPolicySet());
      assertEquals("500", dataVisualizer0.getOffscreenWidth());
      assertFalse(dataVisualizer0.isBusy());
      assertFalse(dataVisualizer0.getIgnoreRepaint());
      assertEquals("", dataVisualizer0.getOffscreenXAxis());
      assertEquals("", dataVisualizer0.getOffscreenAdditionalOpts());
      assertFalse(dataVisualizer0.isFocusTraversalPolicyProvider());
      assertEquals("400", dataVisualizer0.getOffscreenHeight());
      assertTrue(dataVisualizer0.getFocusTraversalKeysEnabled());
      assertEquals("Visualize incoming data/training/test sets in a 2D scatter plot.", dataVisualizer0.globalInfo());
      assertEquals("", dataVisualizer0.getOffscreenYAxis());
      assertEquals("Weka Chart Renderer", dataVisualizer0.getOffscreenRendererName());
      assertEquals("DataVisualizer", dataVisualizer0.getCustomName());
      
      boolean boolean0 = filter0.eventGeneratable(",8OWK=TOr/");
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(boolean0);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertNotNull(substringLabeler0);
      
      SubstringLabeler substringLabeler1 = new SubstringLabeler();
      assertFalse(substringLabeler1.equals((Object)substringLabeler0));
      assertFalse(substringLabeler1.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler1.getIgnoreRepaint());
      assertEquals("Match", substringLabeler1.getMatchAttributeName());
      assertFalse(substringLabeler1.isFocusTraversalPolicySet());
      assertFalse(substringLabeler1.isFocusCycleRoot());
      assertFalse(substringLabeler1.isBusy());
      assertTrue(substringLabeler1.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler1.getConsumeNonMatching());
      assertEquals("", substringLabeler1.getMatchDetails());
      assertFalse(substringLabeler1.getNominalBinary());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler1.globalInfo());
      assertEquals("SubstringLabeler", substringLabeler1.getCustomName());
      assertNotNull(substringLabeler1);
      
      InstanceEvent instanceEvent0 = substringLabeler0.m_ie;
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertNotNull(instanceEvent0);
      
      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(".bsi");
      assertNotNull(mockPrintWriter0);
      
      substringLabeler0.list((PrintWriter) mockPrintWriter0);
      assertFalse(substringLabeler0.equals((Object)substringLabeler1));
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertNotSame(substringLabeler0, substringLabeler1);
      
      instanceEvent0.setStructure(instances0);
      assertFalse(testInstances0.equals((Object)testInstances1));
      assertFalse(substringLabeler0.equals((Object)substringLabeler1));
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumString());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals(20, instances0.numInstances());
      assertEquals(20, instances0.size());
      assertEquals(1, instances0.classIndex());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(2, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertEquals(0, instanceEvent0.getStatus());
      assertNotSame(testInstances0, testInstances1);
      assertNotSame(substringLabeler0, substringLabeler1);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      SubstringLabeler substringLabeler2 = new SubstringLabeler();
      assertFalse(substringLabeler2.equals((Object)substringLabeler1));
      assertFalse(substringLabeler2.equals((Object)substringLabeler0));
      assertEquals("", substringLabeler2.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler2.getCustomName());
      assertFalse(substringLabeler2.getNominalBinary());
      assertFalse(substringLabeler2.getIgnoreRepaint());
      assertFalse(substringLabeler2.getConsumeNonMatching());
      assertFalse(substringLabeler2.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler2.isBusy());
      assertFalse(substringLabeler2.isFocusTraversalPolicySet());
      assertFalse(substringLabeler2.isFocusCycleRoot());
      assertEquals("Match", substringLabeler2.getMatchAttributeName());
      assertTrue(substringLabeler2.getFocusTraversalKeysEnabled());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler2.globalInfo());
      assertNotNull(substringLabeler2);
      
      Clusterer clusterer0 = new Clusterer();
      assertFalse(clusterer0.isBusy());
      assertFalse(clusterer0.getIgnoreRepaint());
      assertFalse(clusterer0.isFocusTraversalPolicyProvider());
      assertFalse(clusterer0.isFocusCycleRoot());
      assertFalse(clusterer0.hasIncomingBatchInstances());
      assertFalse(clusterer0.isFocusTraversalPolicySet());
      assertEquals("EM", clusterer0.getCustomName());
      assertTrue(clusterer0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>Simple EM (expectation maximisation) class.\n\nEM assigns a probability distribution to each instance which indicates the probability of it belonging to each of the clusters</font><br><br> EM can decide how many clusters to create by cross validation, or you may specify apriori how many clusters to generate.<br><br>The cross validation performed to determine the number of clusters is done in the following steps:<br>1. the number of clusters is set to 1<br>2. the training set is split randomly into 10 folds.<br>3. EM is performed 10 times using the 10 folds the usual CV way.<br>4. the loglikelihood is averaged over all 10 results.<br>5.<br>if loglikelihood has increased the number of clusters is increased by 1 and the program continues at step 2.<br><br><br>The number of folds is fixed to 10, as long as the number of instances in the training set is not smaller 10.<br>If this is the case the number of folds is set equal to the number of instances.<br></html>", clusterer0.globalInfo());
      assertNotNull(clusterer0);
      
      OptionHandlerJavadoc optionHandlerJavadoc0 = new OptionHandlerJavadoc();
      assertEquals("weka.core.Javadoc", optionHandlerJavadoc0.getClassname());
      assertTrue(optionHandlerJavadoc0.getUseStars());
      assertTrue(optionHandlerJavadoc0.getProlog());
      assertFalse(optionHandlerJavadoc0.getSilent());
      assertEquals("", optionHandlerJavadoc0.getDir());
      assertNotNull(optionHandlerJavadoc0);
      
      Object object0 = BeanContext.globalHierarchyLock;
      assertNotNull(object0);
      
      InstanceEvent instanceEvent1 = substringLabeler1.m_ie;
      assertFalse(instanceEvent1.equals((Object)instanceEvent0));
      assertEquals(0, instanceEvent1.getStatus());
      assertNotSame(instanceEvent1, instanceEvent0);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertNotNull(instanceEvent1);
      
      instanceEvent1.setStructure(instances0);
      assertFalse(testInstances0.equals((Object)testInstances1));
      assertFalse(instanceEvent1.equals((Object)instanceEvent0));
      assertFalse(substringLabeler1.equals((Object)substringLabeler2));
      assertFalse(substringLabeler1.equals((Object)substringLabeler0));
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumString());
      assertEquals((-1), testInstances0.getClassIndex());
      assertFalse(testInstances0.getNoClass());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(0, instanceEvent1.getStatus());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals(20, instances0.numInstances());
      assertEquals(20, instances0.size());
      assertEquals(1, instances0.classIndex());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(2, instances0.numClasses());
      assertEquals(2, instances0.numAttributes());
      assertFalse(substringLabeler1.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler1.getIgnoreRepaint());
      assertEquals("Match", substringLabeler1.getMatchAttributeName());
      assertFalse(substringLabeler1.isFocusTraversalPolicySet());
      assertFalse(substringLabeler1.isFocusCycleRoot());
      assertFalse(substringLabeler1.isBusy());
      assertTrue(substringLabeler1.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler1.getConsumeNonMatching());
      assertEquals("", substringLabeler1.getMatchDetails());
      assertFalse(substringLabeler1.getNominalBinary());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler1.globalInfo());
      assertEquals("SubstringLabeler", substringLabeler1.getCustomName());
      assertNotSame(testInstances0, testInstances1);
      assertNotSame(instanceEvent1, instanceEvent0);
      assertNotSame(substringLabeler1, substringLabeler2);
      assertNotSame(substringLabeler1, substringLabeler0);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      filter0.acceptInstance(instanceEvent1);
      assertFalse(instanceEvent1.equals((Object)instanceEvent0));
      assertFalse(substringLabeler1.equals((Object)substringLabeler2));
      assertFalse(substringLabeler1.equals((Object)substringLabeler0));
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals(0, instanceEvent1.getStatus());
      assertFalse(substringLabeler1.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler1.getIgnoreRepaint());
      assertEquals("Match", substringLabeler1.getMatchAttributeName());
      assertFalse(substringLabeler1.isFocusTraversalPolicySet());
      assertFalse(substringLabeler1.isFocusCycleRoot());
      assertFalse(substringLabeler1.isBusy());
      assertTrue(substringLabeler1.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler1.getConsumeNonMatching());
      assertEquals("", substringLabeler1.getMatchDetails());
      assertFalse(substringLabeler1.getNominalBinary());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler1.globalInfo());
      assertEquals("SubstringLabeler", substringLabeler1.getCustomName());
      assertNotSame(instanceEvent1, instanceEvent0);
      assertNotSame(substringLabeler1, substringLabeler2);
      assertNotSame(substringLabeler1, substringLabeler0);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      
      ConfigurationListener configurationListener0 = mock(ConfigurationListener.class, new ViolatedAssumptionAnswer());
      // Undeclared exception!
      try { 
        filter0.performRequest("v0mc>");
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // v0mc> not supported (Filter)
         //
         verifyException("weka.gui.beans.Filter", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      Filter filter0 = new Filter();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertNotNull(filter0);
      
      TestInstances testInstances0 = new TestInstances();
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertFalse(testInstances0.getNoClass());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getSeed());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertNotNull(testInstances0);
      
      Instances instances0 = testInstances0.generate(" ");
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertFalse(testInstances0.getNoClass());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getSeed());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(2, instances0.numClasses());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(20, instances0.size());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals("Testdata", instances0.relationName());
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertNotNull(instances0);
      
      TrainingSetEvent trainingSetEvent0 = new TrainingSetEvent(testInstances0, instances0);
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertFalse(testInstances0.getNoClass());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getSeed());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(2, instances0.numClasses());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(20, instances0.size());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals("Testdata", instances0.relationName());
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(1, trainingSetEvent0.getMaxRunNumber());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertFalse(trainingSetEvent0.isStructureOnly());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertNotNull(trainingSetEvent0);
      
      trainingSetEvent0.m_maxRunNumber = (-2);
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertFalse(testInstances0.getNoClass());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getSeed());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(2, instances0.numClasses());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(20, instances0.size());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals("Testdata", instances0.relationName());
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, instances0.classIndex());
      assertEquals(0, trainingSetEvent0.getMaxSetNumber());
      assertFalse(trainingSetEvent0.isStructureOnly());
      assertEquals((-2), trainingSetEvent0.getMaxRunNumber());
      assertEquals(1, trainingSetEvent0.getRunNumber());
      assertEquals(0, trainingSetEvent0.getSetNumber());
      
      MetaBean metaBean0 = new MetaBean();
      assertTrue(metaBean0.getFocusTraversalKeysEnabled());
      assertFalse(metaBean0.isFocusCycleRoot());
      assertFalse(metaBean0.isFocusTraversalPolicyProvider());
      assertEquals("Group", metaBean0.getCustomName());
      assertFalse(metaBean0.getIgnoreRepaint());
      assertFalse(metaBean0.isFocusTraversalPolicySet());
      assertNotNull(metaBean0);
      
      CheckGOE checkGOE0 = new CheckGOE();
      assertFalse(checkGOE0.getSuccess());
      assertFalse(checkGOE0.getSilent());
      assertFalse(checkGOE0.getDebug());
      assertNotNull(checkGOE0);
      
      InstanceStreamToBatchMaker instanceStreamToBatchMaker0 = new InstanceStreamToBatchMaker();
      assertFalse(instanceStreamToBatchMaker0.isBusy());
      assertEquals("InstanceStreamToBatchMaker", instanceStreamToBatchMaker0.getCustomName());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicySet());
      assertFalse(instanceStreamToBatchMaker0.isFocusCycleRoot());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicyProvider());
      assertFalse(instanceStreamToBatchMaker0.getIgnoreRepaint());
      assertTrue(instanceStreamToBatchMaker0.getFocusTraversalKeysEnabled());
      assertNotNull(instanceStreamToBatchMaker0);
      
      TestSetEvent testSetEvent0 = new TestSetEvent(instanceStreamToBatchMaker0, instances0);
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertFalse(testInstances0.getNoClass());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getSeed());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(2, instances0.numClasses());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(20, instances0.size());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals("Testdata", instances0.relationName());
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, instances0.classIndex());
      assertFalse(instanceStreamToBatchMaker0.isBusy());
      assertEquals("InstanceStreamToBatchMaker", instanceStreamToBatchMaker0.getCustomName());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicySet());
      assertFalse(instanceStreamToBatchMaker0.isFocusCycleRoot());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicyProvider());
      assertFalse(instanceStreamToBatchMaker0.getIgnoreRepaint());
      assertTrue(instanceStreamToBatchMaker0.getFocusTraversalKeysEnabled());
      assertEquals(1, testSetEvent0.getRunNumber());
      assertEquals(0, testSetEvent0.getMaxSetNumber());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertFalse(testSetEvent0.isStructureOnly());
      assertEquals(0, testSetEvent0.getSetNumber());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertNotNull(testSetEvent0);
      
      Sorter sorter0 = new Sorter();
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("", sorter0.getTempDirectory());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      assertNotNull(sorter0);
      
      filter0.removeTrainingSetListener(sorter0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(sorter0.isFocusTraversalPolicySet());
      assertEquals("10000", sorter0.getBufferSize());
      assertTrue(sorter0.getFocusTraversalKeysEnabled());
      assertFalse(sorter0.getIgnoreRepaint());
      assertEquals("", sorter0.getTempDirectory());
      assertEquals("Sorter", sorter0.getCustomName());
      assertFalse(sorter0.isBusy());
      assertFalse(sorter0.isFocusCycleRoot());
      assertNull(sorter0.getSortDetails());
      assertFalse(sorter0.isFocusTraversalPolicyProvider());
      assertEquals("Sorts incoming instances in ascending or descending order according to the values of user specified attributes. Instances can be sorted according to multiple attributes (defined in order). Handles data sets larger than can be fit into main memory via instance connections and specifying the in-memory buffer size. Implements a merge-sort by writing the sorted in-memory buffer to a file when full and then interleaving instances from the disk based file(s) when the incoming stream has finished.", sorter0.globalInfo());
      
      Add add0 = new Add();
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertNotNull(add0);
      
      String[] stringArray0 = add0.getOptions();
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertNotNull(stringArray0);
      
      filter0.setFilter(add0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("unnamed", add0.getAttributeName());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      
      SystemInUtil.addInputLine("@data");
      FlowByExpression flowByExpression0 = new FlowByExpression();
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertFalse(flowByExpression0.isBusy());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertEquals("", flowByExpression0.getExpressionString());
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      assertNotNull(flowByExpression0);
      
      Instances instances1 = testInstances0.generate();
      assertFalse(instances1.equals((Object)instances0));
      assertEquals(20, instances1.size());
      assertEquals("Testdata", instances1.relationName());
      assertEquals(1, instances1.classIndex());
      assertEquals(2, instances1.numClasses());
      assertEquals(20.0, instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      assertEquals(20, instances1.numInstances());
      assertFalse(instances1.checkForStringAttributes());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertFalse(testInstances0.getNoClass());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getSeed());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertNotSame(instances1, instances0);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertNotNull(instances1);
      
      boolean boolean0 = filter0.eventGeneratable("pT3+_S{.J$e[oy;C)");
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(boolean0);
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertFalse(substringReplacer0.isBusy());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertNotNull(substringReplacer0);
      
      InstanceEvent instanceEvent0 = substringReplacer0.m_ie;
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertNotNull(instanceEvent0);
      
      instanceEvent0.setStatus((-1));
      assertFalse(substringReplacer0.isBusy());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals((-1), instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(substringReplacer0.isBusy());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertEquals((-1), instanceEvent0.getStatus());
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      
      SystemInUtil.addInputLine("@data");
      DefaultCaret defaultCaret0 = new DefaultCaret();
      assertEquals(0.0, defaultCaret0.getX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMinY(), 0.01);
      assertEquals(0.0, defaultCaret0.getY(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterX(), 0.01);
      assertEquals(0.0, defaultCaret0.getMaxY(), 0.01);
      assertTrue(defaultCaret0.isEmpty());
      assertEquals(0.0, defaultCaret0.getMinX(), 0.01);
      assertEquals(0.0, defaultCaret0.getCenterY(), 0.01);
      assertEquals(0.0, defaultCaret0.getWidth(), 0.01);
      assertEquals(0.0, defaultCaret0.getHeight(), 0.01);
      assertEquals(0, defaultCaret0.height);
      assertEquals(0, defaultCaret0.width);
      assertEquals(0, defaultCaret0.x);
      assertEquals(0, defaultCaret0.y);
      assertNotNull(defaultCaret0);
      
      String string0 = filter0.getCustomName();
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals("Add", string0);
      assertNotNull(string0);
      
      MinkowskiDistance minkowskiDistance0 = new MinkowskiDistance(instances1);
      assertFalse(instances1.equals((Object)instances0));
      assertEquals(20, instances1.size());
      assertEquals("Testdata", instances1.relationName());
      assertEquals(1, instances1.classIndex());
      assertEquals(2, instances1.numClasses());
      assertEquals(20.0, instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      assertEquals(20, instances1.numInstances());
      assertFalse(instances1.checkForStringAttributes());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertFalse(testInstances0.getNoClass());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getSeed());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertFalse(minkowskiDistance0.rangesSet());
      assertEquals("Set attribute selection mode. If false, only selected attributes in the range will be used in the distance calculation; if true, only non-selected attributes will be used for the calculation.", minkowskiDistance0.invertSelectionTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", minkowskiDistance0.attributeIndicesTipText());
      assertEquals("", minkowskiDistance0.toString());
      assertFalse(minkowskiDistance0.getDontNormalize());
      assertEquals("Whether if the normalization of attributes should be turned off for distance calculation (Default: false i.e. attribute values are normalized). ", minkowskiDistance0.dontNormalizeTipText());
      assertEquals(2.0, minkowskiDistance0.getOrder(), 0.01);
      assertEquals("The order of the Minkowski distance ('1' is Manhattan distance and '2' the Euclidean distance).", minkowskiDistance0.orderTipText());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals(2, NormalizableDistance.R_WIDTH);
      assertEquals(0, NormalizableDistance.R_MIN);
      assertEquals(1, NormalizableDistance.R_MAX);
      assertNotNull(minkowskiDistance0);
      
      TestSetEvent testSetEvent1 = new TestSetEvent(minkowskiDistance0, instances1, 0, (-2), (-1), 0);
      assertFalse(instances1.equals((Object)instances0));
      assertFalse(testSetEvent1.equals((Object)testSetEvent0));
      assertEquals(20, instances1.size());
      assertEquals("Testdata", instances1.relationName());
      assertEquals(1, instances1.classIndex());
      assertEquals(2, instances1.numClasses());
      assertEquals(20.0, instances1.sumOfWeights(), 0.01);
      assertEquals(2, instances1.numAttributes());
      assertEquals(20, instances1.numInstances());
      assertFalse(instances1.checkForStringAttributes());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertFalse(testInstances0.getNoClass());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getSeed());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertFalse(minkowskiDistance0.rangesSet());
      assertEquals("Set attribute selection mode. If false, only selected attributes in the range will be used in the distance calculation; if true, only non-selected attributes will be used for the calculation.", minkowskiDistance0.invertSelectionTipText());
      assertEquals("Specify range of attributes to act on. This is a comma separated list of attribute indices, with \"first\" and \"last\" valid values. Specify an inclusive range with \"-\". E.g: \"first-3,5,6-10,last\".", minkowskiDistance0.attributeIndicesTipText());
      assertEquals("", minkowskiDistance0.toString());
      assertFalse(minkowskiDistance0.getDontNormalize());
      assertEquals("Whether if the normalization of attributes should be turned off for distance calculation (Default: false i.e. attribute values are normalized). ", minkowskiDistance0.dontNormalizeTipText());
      assertEquals(2.0, minkowskiDistance0.getOrder(), 0.01);
      assertEquals("The order of the Minkowski distance ('1' is Manhattan distance and '2' the Euclidean distance).", minkowskiDistance0.orderTipText());
      assertFalse(testSetEvent1.isStructureOnly());
      assertEquals((-1), testSetEvent1.getSetNumber());
      assertEquals(0, testSetEvent1.getMaxSetNumber());
      assertEquals((-2), testSetEvent1.getMaxRunNumber());
      assertEquals(0, testSetEvent1.getRunNumber());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals(2, NormalizableDistance.R_WIDTH);
      assertEquals(0, NormalizableDistance.R_MIN);
      assertEquals(1, NormalizableDistance.R_MAX);
      assertNotNull(testSetEvent1);
      
      filter0.acceptTestSet(testSetEvent0);
      assertFalse(instances0.equals((Object)instances1));
      assertFalse(testSetEvent0.equals((Object)testSetEvent1));
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(filter0.isBusy());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isFocusCycleRoot());
      assertEquals(1, testInstances0.getClassType());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(2, testInstances0.getNumAttributes());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertFalse(testInstances0.getNoClass());
      assertEquals(20, testInstances0.getNumInstances());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(1, testInstances0.getSeed());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals(2, instances0.numClasses());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(20, instances0.size());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals("Testdata", instances0.relationName());
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numAttributes());
      assertEquals(1, instances0.classIndex());
      assertFalse(instanceStreamToBatchMaker0.isBusy());
      assertEquals("InstanceStreamToBatchMaker", instanceStreamToBatchMaker0.getCustomName());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicySet());
      assertFalse(instanceStreamToBatchMaker0.isFocusCycleRoot());
      assertFalse(instanceStreamToBatchMaker0.isFocusTraversalPolicyProvider());
      assertFalse(instanceStreamToBatchMaker0.getIgnoreRepaint());
      assertTrue(instanceStreamToBatchMaker0.getFocusTraversalKeysEnabled());
      assertEquals(1, testSetEvent0.getRunNumber());
      assertEquals(0, testSetEvent0.getMaxSetNumber());
      assertEquals(1, testSetEvent0.getMaxRunNumber());
      assertFalse(testSetEvent0.isStructureOnly());
      assertEquals(0, testSetEvent0.getSetNumber());
      assertNotSame(instances0, instances1);
      assertNotSame(testSetEvent0, testSetEvent1);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      
      AllJavadoc allJavadoc0 = null;
      try {
        allJavadoc0 = new AllJavadoc();
        fail("Expecting exception: NoClassDefFoundError");
      
      } catch(NoClassDefFoundError e) {
      }
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      Filter filter0 = new Filter();
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertNotNull(filter0);
      
      TestInstances testInstances0 = new TestInstances();
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getClassType());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumAttributes());
      assertFalse(testInstances0.getNoClass());
      assertEquals(20, testInstances0.getNumInstances());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertNotNull(testInstances0);
      
      TextViewer textViewer0 = new TextViewer();
      assertFalse(textViewer0.isFocusTraversalPolicyProvider());
      assertFalse(textViewer0.isBusy());
      assertEquals("General purpose text display.", textViewer0.globalInfo());
      assertTrue(textViewer0.getFocusTraversalKeysEnabled());
      assertFalse(textViewer0.isFocusCycleRoot());
      assertFalse(textViewer0.isFocusTraversalPolicySet());
      assertFalse(textViewer0.getIgnoreRepaint());
      assertNotNull(textViewer0);
      
      filter0.removeTrainingSetListener(textViewer0);
      assertEquals("AllFilter", filter0.getCustomName());
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter0.globalInfo());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(textViewer0.isFocusTraversalPolicyProvider());
      assertFalse(textViewer0.isBusy());
      assertEquals("General purpose text display.", textViewer0.globalInfo());
      assertTrue(textViewer0.getFocusTraversalKeysEnabled());
      assertFalse(textViewer0.isFocusCycleRoot());
      assertFalse(textViewer0.isFocusTraversalPolicySet());
      assertFalse(textViewer0.getIgnoreRepaint());
      
      Add add0 = new Add();
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("unnamed", add0.getAttributeName());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      assertNotNull(add0);
      
      filter0.setFilter(add0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertEquals("The format of the date values (see ISO-8601).", add0.dateFormatTipText());
      assertEquals("The position (starting from 1) where the attribute will be inserted (first and last are valid indices).", add0.attributeIndexTipText());
      assertEquals("Set the new attribute's name.", add0.attributeNameTipText());
      assertEquals("yyyy-MM-dd'T'HH:mm:ss", add0.getDateFormat());
      assertEquals("The list of value labels (nominal attribute creation only).  The list must be comma-separated, eg: \"red,green,blue\". If this is empty, the created attribute will be numeric.", add0.nominalLabelsTipText());
      assertEquals("Defines the type of the attribute to generate.", add0.attributeTypeTipText());
      assertFalse(add0.mayRemoveInstanceAfterFirstBatchDone());
      assertTrue(add0.isNewBatch());
      assertEquals("last", add0.getAttributeIndex());
      assertFalse(add0.isFirstBatchDone());
      assertEquals("unnamed", add0.getAttributeName());
      assertFalse(add0.isOutputFormatDefined());
      assertEquals("An instance filter that adds a new attribute to the dataset. The new attribute will contain all missing values.", add0.globalInfo());
      
      String string0 = ",8OWK=TOr\\/";
      FlowByExpression flowByExpression0 = new FlowByExpression();
      assertFalse(flowByExpression0.isFocusTraversalPolicySet());
      assertFalse(flowByExpression0.isFocusCycleRoot());
      assertEquals("", flowByExpression0.getExpressionString());
      assertFalse(flowByExpression0.isBusy());
      assertFalse(flowByExpression0.isFocusTraversalPolicyProvider());
      assertEquals("Splits incoming instances (or instance stream) according to the evaluation of a logical expression. The expression can test the values of one or more incoming attributes. The test can involve constants or comparing one attribute's values to another. Inequalities along with string operations such as contains, starts-with, ends-with and regular expressions may be used as operators. \"True\" instances can be sent to one downstream step and \"False\" instances sent to another.", flowByExpression0.globalInfo());
      assertEquals("", flowByExpression0.getTrueStepName());
      assertFalse(flowByExpression0.getIgnoreRepaint());
      assertEquals("FlowByExpression", flowByExpression0.getCustomName());
      assertEquals("", flowByExpression0.getFalseStepName());
      assertTrue(flowByExpression0.getFocusTraversalKeysEnabled());
      assertNotNull(flowByExpression0);
      
      TestInstances testInstances1 = new TestInstances();
      assertFalse(testInstances1.equals((Object)testInstances0));
      assertEquals(2, testInstances1.getNumNominalValues());
      assertEquals(10, testInstances1.getNumInstancesRelational());
      assertFalse(testInstances1.getMultiInstance());
      assertFalse(testInstances1.getNoClass());
      assertEquals(1, testInstances1.getNumRelationalNominal());
      assertEquals(0, testInstances1.getNumNumeric());
      assertEquals(2, testInstances1.getNumRelationalNominalValues());
      assertEquals(0, testInstances1.getNumRelationalString());
      assertEquals(0, testInstances1.getNumRelationalNumeric());
      assertEquals(0, testInstances1.getNumString());
      assertEquals(2, testInstances1.getNumAttributes());
      assertEquals((-1), testInstances1.getClassIndex());
      assertEquals(1, testInstances1.getSeed());
      assertEquals(1, testInstances1.getClassType());
      assertEquals(0, testInstances1.getNumRelational());
      assertEquals(2, testInstances1.getNumClasses());
      assertEquals(0, testInstances1.getNumDate());
      assertEquals("Testdata", testInstances1.getRelation());
      assertEquals(" ", testInstances1.getWordSeparators());
      assertEquals(20, testInstances1.getNumInstances());
      assertEquals(1, testInstances1.getNumNominal());
      assertEquals(0, testInstances1.getNumRelationalDate());
      assertEquals((-2), TestInstances.NO_CLASS);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertNotNull(testInstances1);
      
      Instances instances0 = testInstances0.generate(",8OWK=TOr/");
      assertFalse(testInstances0.equals((Object)testInstances1));
      assertEquals(0, testInstances0.getNumString());
      assertEquals(0, testInstances0.getNumNumeric());
      assertEquals(" ", testInstances0.getWordSeparators());
      assertEquals(2, testInstances0.getNumClasses());
      assertEquals(1, testInstances0.getNumNominal());
      assertEquals(0, testInstances0.getNumRelationalDate());
      assertEquals("Testdata", testInstances0.getRelation());
      assertEquals(0, testInstances0.getNumRelational());
      assertEquals(1, testInstances0.getClassType());
      assertEquals((-1), testInstances0.getClassIndex());
      assertEquals(2, testInstances0.getNumAttributes());
      assertFalse(testInstances0.getNoClass());
      assertEquals(20, testInstances0.getNumInstances());
      assertFalse(testInstances0.getMultiInstance());
      assertEquals(10, testInstances0.getNumInstancesRelational());
      assertEquals(2, testInstances0.getNumNominalValues());
      assertEquals(0, testInstances0.getNumDate());
      assertEquals(2, testInstances0.getNumRelationalNominalValues());
      assertEquals(0, testInstances0.getNumRelationalNumeric());
      assertEquals(0, testInstances0.getNumRelationalString());
      assertEquals(1, testInstances0.getSeed());
      assertEquals(1, testInstances0.getNumRelationalNominal());
      assertEquals("Testdata", instances0.relationName());
      assertEquals(1, instances0.classIndex());
      assertEquals(20, instances0.size());
      assertEquals(20.0, instances0.sumOfWeights(), 0.01);
      assertEquals(20, instances0.numInstances());
      assertEquals(2, instances0.numClasses());
      assertFalse(instances0.checkForStringAttributes());
      assertEquals(2, instances0.numAttributes());
      assertNotSame(testInstances0, testInstances1);
      assertEquals((-1), TestInstances.CLASS_IS_LAST);
      assertEquals((-2), TestInstances.NO_CLASS);
      assertNotNull(instances0);
      
      DataVisualizer dataVisualizer0 = new DataVisualizer();
      assertFalse(dataVisualizer0.isBusy());
      assertEquals("Weka Chart Renderer", dataVisualizer0.getOffscreenRendererName());
      assertFalse(dataVisualizer0.isFocusTraversalPolicySet());
      assertFalse(dataVisualizer0.getIgnoreRepaint());
      assertEquals("", dataVisualizer0.getOffscreenXAxis());
      assertFalse(dataVisualizer0.isFocusCycleRoot());
      assertEquals("", dataVisualizer0.getOffscreenAdditionalOpts());
      assertFalse(dataVisualizer0.isFocusTraversalPolicyProvider());
      assertEquals("DataVisualizer", dataVisualizer0.getCustomName());
      assertTrue(dataVisualizer0.getFocusTraversalKeysEnabled());
      assertEquals("500", dataVisualizer0.getOffscreenWidth());
      assertEquals("Visualize incoming data/training/test sets in a 2D scatter plot.", dataVisualizer0.globalInfo());
      assertEquals("", dataVisualizer0.getOffscreenYAxis());
      assertEquals("400", dataVisualizer0.getOffscreenHeight());
      assertNotNull(dataVisualizer0);
      
      filter0.addTestSetListener(dataVisualizer0);
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(dataVisualizer0.isBusy());
      assertEquals("Weka Chart Renderer", dataVisualizer0.getOffscreenRendererName());
      assertFalse(dataVisualizer0.isFocusTraversalPolicySet());
      assertFalse(dataVisualizer0.getIgnoreRepaint());
      assertEquals("", dataVisualizer0.getOffscreenXAxis());
      assertFalse(dataVisualizer0.isFocusCycleRoot());
      assertEquals("", dataVisualizer0.getOffscreenAdditionalOpts());
      assertFalse(dataVisualizer0.isFocusTraversalPolicyProvider());
      assertEquals("DataVisualizer", dataVisualizer0.getCustomName());
      assertTrue(dataVisualizer0.getFocusTraversalKeysEnabled());
      assertEquals("500", dataVisualizer0.getOffscreenWidth());
      assertEquals("Visualize incoming data/training/test sets in a 2D scatter plot.", dataVisualizer0.globalInfo());
      assertEquals("", dataVisualizer0.getOffscreenYAxis());
      assertEquals("400", dataVisualizer0.getOffscreenHeight());
      
      boolean boolean0 = filter0.eventGeneratable(",8OWK=TOr/");
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(boolean0);
      
      SubstringLabeler substringLabeler0 = new SubstringLabeler();
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertNotNull(substringLabeler0);
      
      SubstringLabeler substringLabeler1 = new SubstringLabeler();
      assertFalse(substringLabeler1.equals((Object)substringLabeler0));
      assertTrue(substringLabeler1.getFocusTraversalKeysEnabled());
      assertFalse(substringLabeler1.getNominalBinary());
      assertFalse(substringLabeler1.getConsumeNonMatching());
      assertFalse(substringLabeler1.isFocusTraversalPolicySet());
      assertFalse(substringLabeler1.getIgnoreRepaint());
      assertFalse(substringLabeler1.isFocusCycleRoot());
      assertFalse(substringLabeler1.isBusy());
      assertFalse(substringLabeler1.isFocusTraversalPolicyProvider());
      assertEquals("Match", substringLabeler1.getMatchAttributeName());
      assertEquals("", substringLabeler1.getMatchDetails());
      assertEquals("SubstringLabeler", substringLabeler1.getCustomName());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler1.globalInfo());
      assertNotNull(substringLabeler1);
      
      InstanceEvent instanceEvent0 = substringLabeler0.m_ie;
      assertEquals(0, instanceEvent0.getStatus());
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertNotNull(instanceEvent0);
      
      SubstringReplacer substringReplacer0 = new SubstringReplacer();
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertNotNull(substringReplacer0);
      
      Container container0 = substringReplacer0.getTopLevelAncestor();
      assertFalse(substringReplacer0.isFocusCycleRoot());
      assertEquals("SubstringReplacer", substringReplacer0.getCustomName());
      assertFalse(substringReplacer0.isBusy());
      assertEquals("Replaces substrings in String attribute values using either literal match and replace or regular expression matching. The attributesto apply the match and replace rules to can be selected via a range string (e.g 1-5,6,last) or by a comma separated list of attribute names (/first and /last can be used to indicate the first and last attribute respectively)", substringReplacer0.globalInfo());
      assertFalse(substringReplacer0.isFocusTraversalPolicyProvider());
      assertFalse(substringReplacer0.getIgnoreRepaint());
      assertEquals("", substringReplacer0.getMatchReplaceDetails());
      assertFalse(substringReplacer0.isFocusTraversalPolicySet());
      assertTrue(substringReplacer0.getFocusTraversalKeysEnabled());
      assertNull(container0);
      
      InstanceEvent instanceEvent1 = substringReplacer0.m_ie;
      assertFalse(instanceEvent1.equals((Object)instanceEvent0));
      assertEquals(0, instanceEvent1.getStatus());
      assertNotSame(instanceEvent1, instanceEvent0);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      assertNotNull(instanceEvent1);
      
      instanceEvent0.setStatus(2);
      assertFalse(substringLabeler0.equals((Object)substringLabeler1));
      assertFalse(instanceEvent0.equals((Object)instanceEvent1));
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals(2, instanceEvent0.getStatus());
      assertNotSame(substringLabeler0, substringLabeler1);
      assertNotSame(instanceEvent0, instanceEvent1);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      filter0.acceptInstance(instanceEvent0);
      assertFalse(substringLabeler0.equals((Object)substringLabeler1));
      assertFalse(instanceEvent0.equals((Object)instanceEvent1));
      assertTrue(filter0.getFocusTraversalKeysEnabled());
      assertEquals("<html><font color=blue>An instance filter that adds a new attribute to the dataset</font><br><br> The new attribute will contain all missing values.<br></html>", filter0.globalInfo());
      assertEquals("Add", filter0.getCustomName());
      assertFalse(filter0.isBusy());
      assertFalse(filter0.isFocusCycleRoot());
      assertFalse(filter0.isFocusTraversalPolicyProvider());
      assertFalse(filter0.getIgnoreRepaint());
      assertFalse(filter0.isFocusTraversalPolicySet());
      assertFalse(substringLabeler0.isFocusTraversalPolicyProvider());
      assertFalse(substringLabeler0.isBusy());
      assertEquals("SubstringLabeler", substringLabeler0.getCustomName());
      assertEquals("", substringLabeler0.getMatchDetails());
      assertFalse(substringLabeler0.getNominalBinary());
      assertFalse(substringLabeler0.getIgnoreRepaint());
      assertFalse(substringLabeler0.isFocusTraversalPolicySet());
      assertTrue(substringLabeler0.getFocusTraversalKeysEnabled());
      assertEquals("Matches substrings in String attributes using either literal or regular expression matches. The value of a new attribute is set to reflect the status of the match. The new attribute can be either binary (in which case values indicate match or no match) or multi-valued nominal, in which case a label must be associated with each distinct matching rule. In the case of labeled matches, the user can opt to have non matching instances output with missing value set for the new attribute or not output at all (i.e. consumed by the step).", substringLabeler0.globalInfo());
      assertFalse(substringLabeler0.isFocusCycleRoot());
      assertEquals("Match", substringLabeler0.getMatchAttributeName());
      assertFalse(substringLabeler0.getConsumeNonMatching());
      assertEquals(2, instanceEvent0.getStatus());
      assertNotSame(substringLabeler0, substringLabeler1);
      assertNotSame(instanceEvent0, instanceEvent1);
      assertEquals(1, InstanceEvent.INSTANCE_AVAILABLE);
      assertEquals(0, InstanceEvent.FORMAT_AVAILABLE);
      assertEquals(2, InstanceEvent.BATCH_FINISHED);
      
      Filter filter1 = new Filter();
      assertFalse(filter1.equals((Object)filter0));
      assertEquals("<html><font color=blue>An instance filter that passes all instances through unmodified</font><br><br> Primarily for testing purposes.<br></html>", filter1.globalInfo());
      assertFalse(filter1.isFocusCycleRoot());
      assertTrue(filter1.getFocusTraversalKeysEnabled());
      assertFalse(filter1.getIgnoreRepaint());
      assertFalse(filter1.isFocusTraversalPolicySet());
      assertEquals("AllFilter", filter1.getCustomName());
      assertFalse(filter1.isFocusTraversalPolicyProvider());
      assertFalse(filter1.isBusy());
      assertNotNull(filter1);
      
      PopupMenu popupMenu0 = null;
      try {
        popupMenu0 = new PopupMenu();
        fail("Expecting exception: HeadlessException");
      
      } catch(HeadlessException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.awt.GraphicsEnvironment", e);
      }
  }
}
